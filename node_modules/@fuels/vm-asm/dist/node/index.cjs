'use strict';

let wasm$1;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }
let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {GMArgs} args
* @returns {Instruction}
*/
function gm_args(ra, args) {
    const ret = wasm$1.gm_args(ra, args);
    return Instruction.__wrap(ret);
}

/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {GTFArgs} args
* @returns {Instruction}
*/
function gtf_args(ra, rb, args) {
    const ret = wasm$1.gtf_args(ra, rb, args);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
function wdcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
function wqcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
function wdop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
function wqop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
function wdml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
function wqml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
function wddv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wddv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
function wqdv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqdv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
*Adds two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function add(dst, lhs, rhs) {
    const ret = wasm$1.add(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ANDs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function and(dst, lhs, rhs) {
    const ret = wasm$1.and(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Divides two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function div(dst, lhs, rhs) {
    const ret = wasm$1.div(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for equality.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function eq(dst, lhs, rhs) {
    const ret = wasm$1.eq(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Raises one register to the power of another.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function exp(dst, lhs, rhs) {
    const ret = wasm$1.exp(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for greater-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function gt(dst, lhs, rhs) {
    const ret = wasm$1.gt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for less-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function lt(dst, lhs, rhs) {
    const ret = wasm$1.lt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*The integer logarithm of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mlog(dst, lhs, rhs) {
    const ret = wasm$1.mlog(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*The integer root of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mroo(dst, lhs, rhs) {
    const ret = wasm$1.mroo(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Modulo remainder of two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mod_(dst, lhs, rhs) {
    const ret = wasm$1.mod_(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Copy from one register to another.
* @param {number} dst
* @param {number} src
* @returns {Instruction}
*/
function move_(dst, src) {
    const ret = wasm$1.move_(dst, src);
    return Instruction.__wrap(ret);
}

/**
*Multiplies two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mul(dst, lhs, rhs) {
    const ret = wasm$1.mul(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise NOT a register.
* @param {number} dst
* @param {number} arg
* @returns {Instruction}
*/
function not(dst, arg) {
    const ret = wasm$1.not(dst, arg);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function or(dst, lhs, rhs) {
    const ret = wasm$1.or(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Left shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function sll(dst, lhs, rhs) {
    const ret = wasm$1.sll(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Right shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function srl(dst, lhs, rhs) {
    const ret = wasm$1.srl(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Subtracts two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function sub(dst, lhs, rhs) {
    const ret = wasm$1.sub(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise XORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function xor(dst, lhs, rhs) {
    const ret = wasm$1.xor(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide with arbitrary precision intermediate step.
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function mldv(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*Return from context.
* @param {number} value
* @returns {Instruction}
*/
function ret(value) {
    const ret = wasm$1.ret(value);
    return Instruction.__wrap(ret);
}

/**
*Return from context with data.
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
function retd(addr, len) {
    const ret = wasm$1.retd(addr, len);
    return Instruction.__wrap(ret);
}

/**
*Allocate a number of bytes from the heap.
* @param {number} bytes
* @returns {Instruction}
*/
function aloc(bytes) {
    const ret = wasm$1.aloc(bytes);
    return Instruction.__wrap(ret);
}

/**
*Clear a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} len
* @returns {Instruction}
*/
function mcl(dst_addr, len) {
    const ret = wasm$1.mcl(dst_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Copy a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function mcp(dst_addr, src_addr, len) {
    const ret = wasm$1.mcp(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Compare bytes in memory.
* @param {number} result
* @param {number} lhs_addr
* @param {number} rhs_addr
* @param {number} len
* @returns {Instruction}
*/
function meq(result, lhs_addr, rhs_addr, len) {
    const ret = wasm$1.meq(result, lhs_addr, rhs_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get block header hash for height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
function bhsh(dst, heigth) {
    const ret = wasm$1.bhsh(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
*Get current block height.
* @param {number} dst
* @returns {Instruction}
*/
function bhei(dst) {
    const ret = wasm$1.bhei(dst);
    return Instruction.__wrap(ret);
}

/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
function burn(amount, sub_id_addr) {
    const ret = wasm$1.burn(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Call a contract.
* @param {number} target_struct
* @param {number} fwd_coins
* @param {number} asset_id_addr
* @param {number} fwd_gas
* @returns {Instruction}
*/
function call(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
    const ret = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
    return Instruction.__wrap(ret);
}

/**
*Copy contract code for a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
function ccp(dst_addr, contract_id_addr, offset, len) {
    const ret = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
*Get code root of a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function croo(dst_addr, contract_id_addr) {
    const ret = wasm$1.croo(dst_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Get code size of a contract.
* @param {number} dst
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function csiz(dst, contract_id_addr) {
    const ret = wasm$1.csiz(dst, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Get current block proposer's address.
* @param {number} dst
* @returns {Instruction}
*/
function cb(dst) {
    const ret = wasm$1.cb(dst);
    return Instruction.__wrap(ret);
}

/**
*Load code as executable either from contract, blob, or memory.
* @param {number} src_addr
* @param {number} offset
* @param {number} len
* @param {number} mode
* @returns {Instruction}
*/
function ldc(src_addr, offset, len, mode) {
    const ret = wasm$1.ldc(src_addr, offset, len, mode);
    return Instruction.__wrap(ret);
}

/**
*Log an event.
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
function log(a, b, c, d) {
    const ret = wasm$1.log(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
*Log data.
* @param {number} a
* @param {number} b
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
function logd(a, b, addr, len) {
    const ret = wasm$1.logd(a, b, addr, len);
    return Instruction.__wrap(ret);
}

/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
function mint(amount, sub_id_addr) {
    const ret = wasm$1.mint(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Halt execution, reverting state changes and returning a value.
* @param {number} value
* @returns {Instruction}
*/
function rvrt(value) {
    const ret = wasm$1.rvrt(value);
    return Instruction.__wrap(ret);
}

/**
*Clear a series of slots from contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} lenq
* @returns {Instruction}
*/
function scwq(key_addr, status, lenq) {
    const ret = wasm$1.scwq(key_addr, status, lenq);
    return Instruction.__wrap(ret);
}

/**
*Load a word from contract storage.
* @param {number} dst
* @param {number} status
* @param {number} key_addr
* @returns {Instruction}
*/
function srw(dst, status, key_addr) {
    const ret = wasm$1.srw(dst, status, key_addr);
    return Instruction.__wrap(ret);
}

/**
*Load a series of 32 byte slots from contract storage.
* @param {number} dst_addr
* @param {number} status
* @param {number} key_addr
* @param {number} lenq
* @returns {Instruction}
*/
function srwq(dst_addr, status, key_addr, lenq) {
    const ret = wasm$1.srwq(dst_addr, status, key_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
*Store a word in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} value
* @returns {Instruction}
*/
function sww(key_addr, status, value) {
    const ret = wasm$1.sww(key_addr, status, value);
    return Instruction.__wrap(ret);
}

/**
*Store a series of 32 byte slots in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} src_addr
* @param {number} lenq
* @returns {Instruction}
*/
function swwq(key_addr, status, src_addr, lenq) {
    const ret = wasm$1.swwq(key_addr, status, src_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
*Transfer coins to a contract unconditionally.
* @param {number} contract_id_addr
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
function tr(contract_id_addr, amount, asset_id_addr) {
    const ret = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Transfer coins to a variable output.
* @param {number} contract_id_addr
* @param {number} output_index
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
function tro(contract_id_addr, output_index, amount, asset_id_addr) {
    const ret = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message hash.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function eck1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message hash.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function ecr1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*Verify ED25519 public key and signature match a message.
* @param {number} pub_key_addr
* @param {number} sig_addr
* @param {number} msg_addr
* @param {number} msg_len
* @returns {Instruction}
*/
function ed19(pub_key_addr, sig_addr, msg_addr, msg_len) {
    const ret = wasm$1.ed19(pub_key_addr, sig_addr, msg_addr, msg_len);
    return Instruction.__wrap(ret);
}

/**
*The keccak-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function k256(dst_addr, src_addr, len) {
    const ret = wasm$1.k256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*The SHA-2-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function s256(dst_addr, src_addr, len) {
    const ret = wasm$1.s256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get timestamp of block at given height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
function time(dst, heigth) {
    const ret = wasm$1.time(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
*Performs no operation.
* @returns {Instruction}
*/
function noop() {
    const ret = wasm$1.noop();
    return Instruction.__wrap(ret);
}

/**
*Set flag register to a register.
* @param {number} value
* @returns {Instruction}
*/
function flag(value) {
    const ret = wasm$1.flag(value);
    return Instruction.__wrap(ret);
}

/**
*Get the balance of contract of an asset ID.
* @param {number} dst
* @param {number} asset_id_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function bal(dst, asset_id_addr, contract_id_addr) {
    const ret = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Dynamic jump.
* @param {number} abs_target
* @returns {Instruction}
*/
function jmp(abs_target) {
    const ret = wasm$1.jmp(abs_target);
    return Instruction.__wrap(ret);
}

/**
*Conditional dynamic jump.
* @param {number} abs_target
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function jne(abs_target, lhs, rhs) {
    const ret = wasm$1.jne(abs_target, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Send a message to recipient address with call abi, coins, and output.
* @param {number} recipient_addr
* @param {number} data_addr
* @param {number} data_len
* @param {number} coins
* @returns {Instruction}
*/
function smo(recipient_addr, data_addr, data_len, coins) {
    const ret = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
    return Instruction.__wrap(ret);
}

/**
*Adds a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function addi(dst, lhs, rhs) {
    const ret = wasm$1.addi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ANDs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function andi(dst, lhs, rhs) {
    const ret = wasm$1.andi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Divides a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function divi(dst, lhs, rhs) {
    const ret = wasm$1.divi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Raises one register to the power of an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function expi(dst, lhs, rhs) {
    const ret = wasm$1.expi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Modulo remainder of a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function modi(dst, lhs, rhs) {
    const ret = wasm$1.modi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Multiplies a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function muli(dst, lhs, rhs) {
    const ret = wasm$1.muli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function ori(dst, lhs, rhs) {
    const ret = wasm$1.ori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Left shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function slli(dst, lhs, rhs) {
    const ret = wasm$1.slli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Right shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function srli(dst, lhs, rhs) {
    const ret = wasm$1.srli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Subtracts a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function subi(dst, lhs, rhs) {
    const ret = wasm$1.subi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise XORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function xori(dst, lhs, rhs) {
    const ret = wasm$1.xori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Conditional jump.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} abs_target
* @returns {Instruction}
*/
function jnei(cond_lhs, cond_rhs, abs_target) {
    const ret = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
    return Instruction.__wrap(ret);
}

/**
*A byte is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
function lb(dst, addr, offset) {
    const ret = wasm$1.lb(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
*A word is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
function lw(dst, addr, offset) {
    const ret = wasm$1.lw(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
*Write the least significant byte of a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
function sb(addr, value, offset) {
    const ret = wasm$1.sb(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
*Write a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
function sw(addr, value, offset) {
    const ret = wasm$1.sw(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
*Copy an immediate number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function mcpi(dst_addr, src_addr, len) {
    const ret = wasm$1.mcpi(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get transaction fields.
* @param {number} dst
* @param {number} arg
* @param {number} selector
* @returns {Instruction}
*/
function gtf(dst, arg, selector) {
    const ret = wasm$1.gtf(dst, arg, selector);
    return Instruction.__wrap(ret);
}

/**
*Clear an immediate number of bytes in memory.
* @param {number} addr
* @param {number} count
* @returns {Instruction}
*/
function mcli(addr, count) {
    const ret = wasm$1.mcli(addr, count);
    return Instruction.__wrap(ret);
}

/**
*Get metadata from memory.
* @param {number} dst
* @param {number} selector
* @returns {Instruction}
*/
function gm(dst, selector) {
    const ret = wasm$1.gm(dst, selector);
    return Instruction.__wrap(ret);
}

/**
*Copy immediate value into a register
* @param {number} dst
* @param {number} val
* @returns {Instruction}
*/
function movi(dst, val) {
    const ret = wasm$1.movi(dst, val);
    return Instruction.__wrap(ret);
}

/**
*Conditional jump against zero.
* @param {number} cond_nz
* @param {number} abs_target
* @returns {Instruction}
*/
function jnzi(cond_nz, abs_target) {
    const ret = wasm$1.jnzi(cond_nz, abs_target);
    return Instruction.__wrap(ret);
}

/**
*Unconditional dynamic relative jump forwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jmpf(dynamic, fixed) {
    const ret = wasm$1.jmpf(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Unconditional dynamic relative jump backwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jmpb(dynamic, fixed) {
    const ret = wasm$1.jmpb(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnzf(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzf(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnzb(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzb(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Jump.
* @param {number} abs_target
* @returns {Instruction}
*/
function ji(abs_target) {
    const ret = wasm$1.ji(abs_target);
    return Instruction.__wrap(ret);
}

/**
*Extend the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
function cfei(amount) {
    const ret = wasm$1.cfei(amount);
    return Instruction.__wrap(ret);
}

/**
*Shrink the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
function cfsi(amount) {
    const ret = wasm$1.cfsi(amount);
    return Instruction.__wrap(ret);
}

/**
*Extend the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
function cfe(amount) {
    const ret = wasm$1.cfe(amount);
    return Instruction.__wrap(ret);
}

/**
*Shrink the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
function cfs(amount) {
    const ret = wasm$1.cfs(amount);
    return Instruction.__wrap(ret);
}

/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function pshl(bitmask) {
    const ret = wasm$1.pshl(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function pshh(bitmask) {
    const ret = wasm$1.pshh(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function popl(bitmask) {
    const ret = wasm$1.popl(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function poph(bitmask) {
    const ret = wasm$1.poph(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Compare 128bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Compare 256bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Simple 128bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Simple 256bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Multiply 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Multiply 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Divide 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wddv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wddv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Divide 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqdv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqdv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function wdmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function wqmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*AddMod 128bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wdam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*AddMod 256bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wqam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*MulMod 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wdmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*MulMod 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wqmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*Call external function
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
function ecal(a, b, c, d) {
    const ret = wasm$1.ecal(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
*Get blob size
* @param {number} dst
* @param {number} blob_id_ptr
* @returns {Instruction}
*/
function bsiz(dst, blob_id_ptr) {
    const ret = wasm$1.bsiz(dst, blob_id_ptr);
    return Instruction.__wrap(ret);
}

/**
*Load blob as data
* @param {number} dst_ptr
* @param {number} blob_id_ptr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
function bldd(dst_ptr, blob_id_ptr, offset, len) {
    const ret = wasm$1.bldd(dst_ptr, blob_id_ptr, offset, len);
    return Instruction.__wrap(ret);
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm$1.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm$1.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
*r" Argument list for GTF (get tx fields) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
const GTFArgs = Object.freeze({
/**
*r" Set `$rA` to `tx.type`
*/
Type:1,"1":"Type",
/**
*r" Set `$rA` to `tx.scriptGasLimit`
*/
ScriptGasLimit:2,"2":"ScriptGasLimit",
/**
*r" Set `$rA` to `tx.scriptLength`
*/
ScriptLength:3,"3":"ScriptLength",
/**
*r" Set `$rA` to `tx.scriptDataLength`
*/
ScriptDataLength:4,"4":"ScriptDataLength",
/**
*r" Set `$rA` to `tx.inputsCount`
*/
ScriptInputsCount:5,"5":"ScriptInputsCount",
/**
*r" Set `$rA` to `tx.outputsCount`
*/
ScriptOutputsCount:6,"6":"ScriptOutputsCount",
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
ScriptWitnessesCount:7,"7":"ScriptWitnessesCount",
/**
*r" Set `$rA` to `Memory address of tx.script`
*/
Script:9,"9":"Script",
/**
*r" Set `$rA` to `Memory address of tx.scriptData`
*/
ScriptData:10,"10":"ScriptData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
ScriptInputAtIndex:11,"11":"ScriptInputAtIndex",
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
ScriptOutputAtIndex:12,"12":"ScriptOutputAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
ScriptWitnessAtIndex:13,"13":"ScriptWitnessAtIndex",
/**
*r" Set `$rA` to size of the transaction in memory, in bytes
*/
TxLength:14,"14":"TxLength",
/**
*r" Set `$rA` to `tx.bytecodeWitnessIndex`
*/
CreateBytecodeWitnessIndex:257,"257":"CreateBytecodeWitnessIndex",
/**
*r" Set `$rA` to `tx.storageSlotsCount`
*/
CreateStorageSlotsCount:258,"258":"CreateStorageSlotsCount",
/**
*r" Set `$rA` to `tx.inputsCount`
*/
CreateInputsCount:259,"259":"CreateInputsCount",
/**
*r" Set `$rA` to `tx.outputsCount`
*/
CreateOutputsCount:260,"260":"CreateOutputsCount",
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
CreateWitnessesCount:261,"261":"CreateWitnessesCount",
/**
*r" Set `$rA` to `Memory address of tx.salt`
*/
CreateSalt:262,"262":"CreateSalt",
/**
*r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
*/
CreateStorageSlotAtIndex:263,"263":"CreateStorageSlotAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
CreateInputAtIndex:264,"264":"CreateInputAtIndex",
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
CreateOutputAtIndex:265,"265":"CreateOutputAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
CreateWitnessAtIndex:266,"266":"CreateWitnessAtIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].type`
*/
InputType:512,"512":"InputType",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
InputCoinTxId:513,"513":"InputCoinTxId",
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
InputCoinOutputIndex:514,"514":"InputCoinOutputIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
*/
InputCoinOwner:515,"515":"InputCoinOwner",
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
InputCoinAmount:516,"516":"InputCoinAmount",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
*/
InputCoinAssetId:517,"517":"InputCoinAssetId",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
*/
InputCoinTxPointer:518,"518":"InputCoinTxPointer",
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
InputCoinWitnessIndex:519,"519":"InputCoinWitnessIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
InputCoinPredicateLength:521,"521":"InputCoinPredicateLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
InputCoinPredicateDataLength:522,"522":"InputCoinPredicateDataLength",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
InputCoinPredicate:523,"523":"InputCoinPredicate",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
InputCoinPredicateData:524,"524":"InputCoinPredicateData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
InputCoinPredicateGasUsed:525,"525":"InputCoinPredicateGasUsed",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
InputContractTxId:544,"544":"InputContractTxId",
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
InputContractOutputIndex:545,"545":"InputContractOutputIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
*/
InputContractId:549,"549":"InputContractId",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
*/
InputMessageSender:576,"576":"InputMessageSender",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
*/
InputMessageRecipient:577,"577":"InputMessageRecipient",
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
InputMessageAmount:578,"578":"InputMessageAmount",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
*/
InputMessageNonce:579,"579":"InputMessageNonce",
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
InputMessageWitnessIndex:580,"580":"InputMessageWitnessIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].dataLength`
*/
InputMessageDataLength:581,"581":"InputMessageDataLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
InputMessagePredicateLength:582,"582":"InputMessagePredicateLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
InputMessagePredicateDataLength:583,"583":"InputMessagePredicateDataLength",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
*/
InputMessageData:584,"584":"InputMessageData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
InputMessagePredicate:585,"585":"InputMessagePredicate",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
InputMessagePredicateData:586,"586":"InputMessagePredicateData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
InputMessagePredicateGasUsed:587,"587":"InputMessagePredicateGasUsed",
/**
*r" Set `$rA` to `tx.outputs[$rB].type`
*/
OutputType:768,"768":"OutputType",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
*/
OutputCoinTo:769,"769":"OutputCoinTo",
/**
*r" Set `$rA` to `tx.outputs[$rB].amount`
*/
OutputCoinAmount:770,"770":"OutputCoinAmount",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
*/
OutputCoinAssetId:771,"771":"OutputCoinAssetId",
/**
*r" Set `$rA` to `tx.outputs[$rB].inputIndex`
*/
OutputContractInputIndex:772,"772":"OutputContractInputIndex",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
*/
OutputContractCreatedContractId:775,"775":"OutputContractCreatedContractId",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
*/
OutputContractCreatedStateRoot:776,"776":"OutputContractCreatedStateRoot",
/**
*r" Set `$rA` to `tx.witnesses[$rB].dataLength`
*/
WitnessDataLength:1024,"1024":"WitnessDataLength",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
*/
WitnessData:1025,"1025":"WitnessData",
/**
*r" Set `$rA` to `tx.policyTypes`
*/
PolicyTypes:1280,"1280":"PolicyTypes",
/**
*r" Set `$rA` to `tx.policies[0x00].gasPrice`
*/
PolicyTip:1281,"1281":"PolicyTip",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
*/
PolicyWitnessLimit:1282,"1282":"PolicyWitnessLimit",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
*/
PolicyMaturity:1283,"1283":"PolicyMaturity",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
*/
PolicyMaxFee:1284,"1284":"PolicyMaxFee", });
/**
* Comparison mode used by WDCM and WQCM instructions.
*/
const CompareMode = Object.freeze({
/**
* Equality (`==`)
*/
EQ:0,"0":"EQ",
/**
* Inequality (`!=`)
*/
NE:1,"1":"NE",
/**
* Less than (`<`)
*/
LT:2,"2":"LT",
/**
* Greater than (`>`)
*/
GT:3,"3":"GT",
/**
* Less than or equals (`>=`)
*/
LTE:4,"4":"LTE",
/**
* Greater than or equals (`>=`)
*/
GTE:5,"5":"GTE",
/**
* Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
*/
LZC:6,"6":"LZC", });
/**
*r" Panic reason representation for the interpreter.
*/
const PanicReason = Object.freeze({
/**
*r" The byte can't be mapped to any known `PanicReason`.
*/
UnknownPanicReason:0,"0":"UnknownPanicReason",
/**
*r" Found `RVRT` instruction.
*/
Revert:1,"1":"Revert",
/**
*r" Execution ran out of gas.
*/
OutOfGas:2,"2":"OutOfGas",
/**
*r" The transaction validity is violated.
*/
TransactionValidity:3,"3":"TransactionValidity",
/**
*r" Attempt to write outside interpreter memory boundaries.
*/
MemoryOverflow:4,"4":"MemoryOverflow",
/**
*r" Overflow while executing arithmetic operation.
*r" These errors are ignored using the WRAPPING flag.
*/
ArithmeticOverflow:5,"5":"ArithmeticOverflow",
/**
*r" Designed contract was not found in the storage.
*/
ContractNotFound:6,"6":"ContractNotFound",
/**
*r" Memory ownership rules are violated.
*/
MemoryOwnership:7,"7":"MemoryOwnership",
/**
*r" The asset ID balance isn't enough for the instruction.
*/
NotEnoughBalance:8,"8":"NotEnoughBalance",
/**
*r" The interpreter is expected to be in internal context.
*/
ExpectedInternalContext:9,"9":"ExpectedInternalContext",
/**
*r" The queried asset ID was not found in the state.
*/
AssetIdNotFound:10,"10":"AssetIdNotFound",
/**
*r" The provided input is not found in the transaction.
*/
InputNotFound:11,"11":"InputNotFound",
/**
*r" The provided output is not found in the transaction.
*/
OutputNotFound:12,"12":"OutputNotFound",
/**
*r" The provided witness is not found in the transaction.
*/
WitnessNotFound:13,"13":"WitnessNotFound",
/**
*r" The transaction maturity is not valid for this request.
*/
TransactionMaturity:14,"14":"TransactionMaturity",
/**
*r" The metadata identifier is invalid.
*/
InvalidMetadataIdentifier:15,"15":"InvalidMetadataIdentifier",
/**
*r" The call structure is not valid.
*/
MalformedCallStructure:16,"16":"MalformedCallStructure",
/**
*r" The provided register does not allow write operations.
*/
ReservedRegisterNotWritable:17,"17":"ReservedRegisterNotWritable",
/**
*r" The execution resulted in an erroneous state of the interpreter.
*/
InvalidFlags:18,"18":"InvalidFlags",
/**
*r" The provided immediate value is not valid for this instruction.
*/
InvalidImmediateValue:19,"19":"InvalidImmediateValue",
/**
*r" The provided transaction input is not of type `Coin`.
*/
ExpectedCoinInput:20,"20":"ExpectedCoinInput",
/**
*r" `ECAL` instruction failed.
*/
EcalError:21,"21":"EcalError",
/**
*r" Two segments of the interpreter memory should not intersect for write operations.
*/
MemoryWriteOverlap:22,"22":"MemoryWriteOverlap",
/**
*r" The requested contract is not listed in the transaction inputs.
*/
ContractNotInInputs:23,"23":"ContractNotInInputs",
/**
*r" The internal asset ID balance overflowed with the provided instruction.
*/
InternalBalanceOverflow:24,"24":"InternalBalanceOverflow",
/**
*r" The maximum allowed contract size is violated.
*/
ContractMaxSize:25,"25":"ContractMaxSize",
/**
*r" This instruction expects the stack area to be unallocated for this call.
*/
ExpectedUnallocatedStack:26,"26":"ExpectedUnallocatedStack",
/**
*r" The maximum allowed number of static contracts was reached for this transaction.
*/
MaxStaticContractsReached:27,"27":"MaxStaticContractsReached",
/**
*r" The requested transfer amount cannot be zero.
*/
TransferAmountCannotBeZero:28,"28":"TransferAmountCannotBeZero",
/**
*r" The provided transaction output should be of type `Variable`.
*/
ExpectedOutputVariable:29,"29":"ExpectedOutputVariable",
/**
*r" The expected context of the stack parent is internal.
*/
ExpectedParentInternalContext:30,"30":"ExpectedParentInternalContext",
/**
*r" The predicate returned non `1`. The `1` means successful verification
*r" of the predicate, all other values means unsuccessful.
*/
PredicateReturnedNonOne:31,"31":"PredicateReturnedNonOne",
/**
*r" The contract ID is already deployed and can't be overwritten.
*/
ContractIdAlreadyDeployed:32,"32":"ContractIdAlreadyDeployed",
/**
*r" The loaded contract mismatch expectations.
*/
ContractMismatch:33,"33":"ContractMismatch",
/**
*r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
*/
MessageDataTooLong:34,"34":"MessageDataTooLong",
/**
*r" Mathematically invalid arguments where given to an arithmetic instruction.
*r" For instance, division by zero produces this.
*r" These errors are ignored using the UNSAFEMATH flag.
*/
ArithmeticError:35,"35":"ArithmeticError",
/**
*r" The contract instruction is not allowed in predicates.
*/
ContractInstructionNotAllowed:36,"36":"ContractInstructionNotAllowed",
/**
*r" Transfer of zero coins is not allowed.
*/
TransferZeroCoins:37,"37":"TransferZeroCoins",
/**
*r" Attempted to execute an invalid instruction
*/
InvalidInstruction:38,"38":"InvalidInstruction",
/**
*r" Memory outside $is..$ssp range is not executable
*/
MemoryNotExecutable:39,"39":"MemoryNotExecutable",
/**
*r" The policy is not set.
*/
PolicyIsNotSet:40,"40":"PolicyIsNotSet",
/**
*r" The policy is not found across policies.
*/
PolicyNotFound:41,"41":"PolicyNotFound",
/**
*r" Receipt context is full
*/
TooManyReceipts:42,"42":"TooManyReceipts",
/**
*r" Balance of a contract overflowed
*/
BalanceOverflow:43,"43":"BalanceOverflow",
/**
*r" Block height value is invalid, typically because it is too large
*/
InvalidBlockHeight:44,"44":"InvalidBlockHeight",
/**
*r" Attempt to use sequential memory instructions with too large slot count,
*r" typically because it cannot fit into usize
*/
TooManySlots:45,"45":"TooManySlots",
/**
*r" Caller of this internal context is also expected to be internal,
*r" i.e. $fp->$fp must be non-zero.
*/
ExpectedNestedCaller:46,"46":"ExpectedNestedCaller",
/**
*r" During memory growth, the stack overlapped with the heap
*/
MemoryGrowthOverlap:47,"47":"MemoryGrowthOverlap",
/**
*r" Attempting to read or write uninitialized memory.
*r" Also occurs when boundary crosses from stack to heap.
*/
UninitalizedMemoryAccess:48,"48":"UninitalizedMemoryAccess",
/**
*r" Overriding consensus parameters is not allowed.
*/
OverridingConsensusParameters:49,"49":"OverridingConsensusParameters",
/**
*r" The storage doesn't know about the hash of the state transition bytecode.
*/
UnknownStateTransactionBytecodeRoot:50,"50":"UnknownStateTransactionBytecodeRoot",
/**
*r" Overriding the state transition bytecode is not allowed.
*/
OverridingStateTransactionBytecode:51,"51":"OverridingStateTransactionBytecode",
/**
*r" The bytecode is already uploaded and cannot be uploaded again.
*/
BytecodeAlreadyUploaded:52,"52":"BytecodeAlreadyUploaded",
/**
*r" The part of the bytecode is not sequentially connected to the previous parts.
*/
ThePartIsNotSequentiallyConnected:53,"53":"ThePartIsNotSequentiallyConnected",
/**
*r" The requested blob is not found.
*/
BlobNotFound:54,"54":"BlobNotFound",
/**
*r" The blob was already
*/
BlobIdAlreadyUploaded:55,"55":"BlobIdAlreadyUploaded",
/**
*r" Active gas costs do not define the cost for this instruction.
*/
GasCostNotDefined:56,"56":"GasCostNotDefined", });
/**
* The operation performed by WDOP and WQOP instructions, determined as
*/
const MathOp = Object.freeze({
/**
* Add
*/
ADD:0,"0":"ADD",
/**
* Subtract
*/
SUB:1,"1":"SUB",
/**
* Invert bits (discards rhs)
*/
NOT:2,"2":"NOT",
/**
* Bitwise or
*/
OR:3,"3":"OR",
/**
* Bitwise exclusive or
*/
XOR:4,"4":"XOR",
/**
* Bitwise and
*/
AND:5,"5":"AND",
/**
* Shift left
*/
SHL:6,"6":"SHL",
/**
* Shift right
*/
SHR:7,"7":"SHR", });
/**
*r" Argument list for GM (get metadata) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
const GMArgs = Object.freeze({
/**
*r" Get if caller is external.
*/
IsCallerExternal:1,"1":"IsCallerExternal",
/**
*r" Get caller's contract ID.
*/
GetCaller:2,"2":"GetCaller",
/**
*r" Get index of current predicate.
*/
GetVerifyingPredicate:3,"3":"GetVerifyingPredicate",
/**
*r" Get the Chain ID this VM is operating within
*/
GetChainId:4,"4":"GetChainId",
/**
*r" Get memory address where the transaction is located
*/
TxStart:5,"5":"TxStart",
/**
*r" Get memory address of base asset ID
*/
BaseAssetId:6,"6":"BaseAssetId", });

const ADDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_add_free(ptr >>> 0, 1));
/**
*Adds two registers.
*/
class ADD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ADDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_add_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ADDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ADDIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_addi_free(ptr >>> 0, 1));
/**
*Adds a register and an immediate value.
*/
class ADDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ADDIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_addi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ADDIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const ALOCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_aloc_free(ptr >>> 0, 1));
/**
*Allocate a number of bytes from the heap.
*/
class ALOC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ALOCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_aloc_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} bytes
    */
    constructor(bytes) {
        _assertClass(bytes, RegId);
        var ptr0 = bytes.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        ALOCFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ANDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_and_free(ptr >>> 0, 1));
/**
*Bitwise ANDs two registers.
*/
class AND {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ANDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_and_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ANDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ANDIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_andi_free(ptr >>> 0, 1));
/**
*Bitwise ANDs a register and an immediate value.
*/
class ANDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ANDIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_andi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ANDIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const BALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bal_free(ptr >>> 0, 1));
/**
*Get the balance of contract of an asset ID.
*/
class BAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bal_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} asset_id_addr
    * @param {RegId} contract_id_addr
    */
    constructor(dst, asset_id_addr, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr1 = asset_id_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr2 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        BALFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BHEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bhei_free(ptr >>> 0, 1));
/**
*Get current block height.
*/
class BHEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BHEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhei_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        BHEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BHSHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bhsh_free(ptr >>> 0, 1));
/**
*Get block header hash for height.
*/
class BHSH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BHSHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhsh_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} heigth
    */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BHSHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BLDDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bldd_free(ptr >>> 0, 1));
/**
*Load blob as data
*/
class BLDD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BLDDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bldd_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_ptr
    * @param {RegId} blob_id_ptr
    * @param {RegId} offset
    * @param {RegId} len
    */
    constructor(dst_ptr, blob_id_ptr, offset, len) {
        _assertClass(dst_ptr, RegId);
        var ptr0 = dst_ptr.__destroy_into_raw();
        _assertClass(blob_id_ptr, RegId);
        var ptr1 = blob_id_ptr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        BLDDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BSIZFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bsiz_free(ptr >>> 0, 1));
/**
*Get blob size
*/
class BSIZ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BSIZFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bsiz_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} blob_id_ptr
    */
    constructor(dst, blob_id_ptr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(blob_id_ptr, RegId);
        var ptr1 = blob_id_ptr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BSIZFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BURNFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_burn_free(ptr >>> 0, 1));
/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
class BURN {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BURNFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_burn_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    * @param {RegId} sub_id_addr
    */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        BURNFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CALLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_call_free(ptr >>> 0, 1));
/**
*Call a contract.
*/
class CALL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CALLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_call_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} target_struct
    * @param {RegId} fwd_coins
    * @param {RegId} asset_id_addr
    * @param {RegId} fwd_gas
    */
    constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        _assertClass(target_struct, RegId);
        var ptr0 = target_struct.__destroy_into_raw();
        _assertClass(fwd_coins, RegId);
        var ptr1 = fwd_coins.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        _assertClass(fwd_gas, RegId);
        var ptr3 = fwd_gas.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        CALLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cb_free(ptr >>> 0, 1));
/**
*Get current block proposer's address.
*/
class CB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cb_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CCPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ccp_free(ptr >>> 0, 1));
/**
*Copy contract code for a contract.
*/
class CCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CCPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ccp_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} contract_id_addr
    * @param {RegId} offset
    * @param {RegId} len
    */
    constructor(dst_addr, contract_id_addr, offset, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        CCPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfe_free(ptr >>> 0, 1));
/**
*Extend the current call frame's stack
*/
class CFE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfe_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfei_free(ptr >>> 0, 1));
/**
*Extend the current call frame's stack by an immediate value.
*/
class CFEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfei_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} amount
    */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const CFSFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfs_free(ptr >>> 0, 1));
/**
*Shrink the current call frame's stack
*/
class CFS {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFSFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfs_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFSFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFSIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfsi_free(ptr >>> 0, 1));
/**
*Shrink the current call frame's stack by an immediate value.
*/
class CFSI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFSIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfsi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} amount
    */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        CFSIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const CROOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_croo_free(ptr >>> 0, 1));
/**
*Get code root of a contract.
*/
class CROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CROOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_croo_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} contract_id_addr
    */
    constructor(dst_addr, contract_id_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        CROOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CSIZFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_csiz_free(ptr >>> 0, 1));
/**
*Get code size of a contract.
*/
class CSIZ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CSIZFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_csiz_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} contract_id_addr
    */
    constructor(dst, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        CSIZFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CompareArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compareargs_free(ptr >>> 0, 1));
/**
* Arguments for WDCM and WQCM instructions.
*/
class CompareArgs {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompareArgs.prototype);
        obj.__wbg_ptr = ptr;
        CompareArgsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompareArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compareargs_free(ptr, 0);
    }
    /**
    * Comparison mode
    * @returns {CompareMode}
    */
    get mode() {
        const ret = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
        return ret;
    }
    /**
    * Comparison mode
    * @param {CompareMode} arg0
    */
    set mode(arg0) {
        wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
    * Convert to immediate value.
    * @returns {Imm06}
    */
    to_imm() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.compareargs_to_imm(ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
    * @param {Imm06} bits
    * @returns {CompareArgs | undefined}
    */
    static from_imm(bits) {
        _assertClass(bits, Imm06);
        var ptr0 = bits.__destroy_into_raw();
        const ret = wasm$1.compareargs_from_imm(ptr0);
        return ret === 0 ? undefined : CompareArgs.__wrap(ret);
    }
}

const DIVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_div_free(ptr >>> 0, 1));
/**
*Divides two registers.
*/
class DIV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DIVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_div_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        DIVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const DIVIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_divi_free(ptr >>> 0, 1));
/**
*Divides a register and an immediate value.
*/
class DIVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DIVIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        DIVIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const DivArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_divargs_free(ptr >>> 0, 1));
/**
* Additional arguments for WMDV and WDDV instructions.
*/
class DivArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DivArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divargs_free(ptr, 0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const ECALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecal_free(ptr >>> 0, 1));
/**
*Call external function
*/
class ECAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecal_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} c
    * @param {RegId} d
    */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        ECALFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECK1Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_eck1_free(ptr >>> 0, 1));
/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message hash.
*/
class ECK1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECK1Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eck1_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ECK1Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECR1Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecr1_free(ptr >>> 0, 1));
/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message hash.
*/
class ECR1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECR1Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecr1_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ECR1Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ED19Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ed19_free(ptr >>> 0, 1));
/**
*Verify ED25519 public key and signature match a message.
*/
class ED19 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ED19Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ed19_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} pub_key_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_addr
    * @param {RegId} msg_len
    */
    constructor(pub_key_addr, sig_addr, msg_addr, msg_len) {
        _assertClass(pub_key_addr, RegId);
        var ptr0 = pub_key_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_addr, RegId);
        var ptr2 = msg_addr.__destroy_into_raw();
        _assertClass(msg_len, RegId);
        var ptr3 = msg_len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        ED19Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_eq_free(ptr >>> 0, 1));
/**
*Compares two registers for equality.
*/
class EQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eq_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EXPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_exp_free(ptr >>> 0, 1));
/**
*Raises one register to the power of another.
*/
class EXP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EXPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_exp_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EXPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EXPIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_expi_free(ptr >>> 0, 1));
/**
*Raises one register to the power of an immediate value.
*/
class EXPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EXPIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_expi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        EXPIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const FLAGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_flag_free(ptr >>> 0, 1));
/**
*Set flag register to a register.
*/
class FLAG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FLAGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_flag_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        FLAGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const GMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gm_free(ptr >>> 0, 1));
/**
*Get metadata from memory.
*/
class GM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GM.prototype);
        obj.__wbg_ptr = ptr;
        GMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gm_free(ptr, 0);
    }
    /**
    * Construct a `GM` instruction from its arguments.
    * @param {RegId} ra
    * @param {GMArgs} args
    * @returns {GM}
    */
    static from_args(ra, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        const ret = wasm$1.gm_from_args(ptr0, args);
        return GM.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {Imm18} selector
    */
    constructor(dst, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(selector, Imm18);
        var ptr1 = selector.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        GMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const GTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gt_free(ptr >>> 0, 1));
/**
*Compares two registers for greater-than.
*/
class GT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gt_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        GTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const GTFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gtf_free(ptr >>> 0, 1));
/**
*Get transaction fields.
*/
class GTF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GTF.prototype);
        obj.__wbg_ptr = ptr;
        GTFFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GTFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gtf_free(ptr, 0);
    }
    /**
    * Construct a `GTF` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {GTFArgs} args
    * @returns {GTF}
    */
    static from_args(ra, rb, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        const ret = wasm$1.gtf_from_args(ptr0, ptr1, args);
        return GTF.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} arg
    * @param {Imm12} selector
    */
    constructor(dst, arg, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(selector, Imm12);
        var ptr2 = selector.__destroy_into_raw();
        const ret = wasm$1.gtf_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        GTFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const Imm06Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm06_free(ptr >>> 0, 1));
/**
* Represents a 6-bit immediate value, guaranteed to be masked by construction.
*/
class Imm06 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm06.prototype);
        obj.__wbg_ptr = ptr;
        Imm06Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm06Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm06_free(ptr, 0);
    }
}

const Imm12Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm12_free(ptr >>> 0, 1));
/**
* Represents a 12-bit immediate value, guaranteed to be masked by construction.
*/
class Imm12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm12.prototype);
        obj.__wbg_ptr = ptr;
        Imm12Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm12Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm12_free(ptr, 0);
    }
}

const Imm18Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm18_free(ptr >>> 0, 1));
/**
* Represents a 18-bit immediate value, guaranteed to be masked by construction.
*/
class Imm18 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm18.prototype);
        obj.__wbg_ptr = ptr;
        Imm18Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm18Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm18_free(ptr, 0);
    }
}

const Imm24Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm24_free(ptr >>> 0, 1));
/**
* Represents a 24-bit immediate value, guaranteed to be masked by construction.
*/
class Imm24 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm24.prototype);
        obj.__wbg_ptr = ptr;
        Imm24Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm24Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm24_free(ptr, 0);
    }
}

const InstructionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_instruction_free(ptr >>> 0, 1));
/**
* Representation of a single instruction for the interpreter.
*
* The opcode is represented in the tag (variant), or may be retrieved in the
* form of an `Opcode` byte using the `opcode` method.
*
* The register and immediate data associated with the instruction is represented
* within an inner unit type wrapper around the 3 remaining bytes.
*/
class Instruction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Instruction.prototype);
        obj.__wbg_ptr = ptr;
        InstructionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InstructionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_instruction_free(ptr, 0);
    }
    /**
    * Convenience method for converting to bytes
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_export_0(r0, r1 * 1, 1);
            return v1;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Size of an instruction in bytes
    * @returns {number}
    */
    static size() {
        const ret = wasm$1.instruction_size();
        return ret >>> 0;
    }
}

const JIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ji_free(ptr >>> 0, 1));
/**
*Jump.
*/
class JI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ji_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} abs_target
    */
    constructor(abs_target) {
        _assertClass(abs_target, Imm24);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        JIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const JMPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmp_free(ptr >>> 0, 1));
/**
*Dynamic jump.
*/
class JMP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmp_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} abs_target
    */
    constructor(abs_target) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        JMPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const JMPBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmpb_free(ptr >>> 0, 1));
/**
*Unconditional dynamic relative jump backwards, with a constant offset.
*/
class JMPB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpb_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dynamic
    * @param {Imm18} fixed
    */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JMPBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const JMPFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmpf_free(ptr >>> 0, 1));
/**
*Unconditional dynamic relative jump forwards, with a constant offset.
*/
class JMPF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpf_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dynamic
    * @param {Imm18} fixed
    */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JMPFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const JNEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jne_free(ptr >>> 0, 1));
/**
*Conditional dynamic jump.
*/
class JNE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jne_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} abs_target
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(abs_target, lhs, rhs) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const JNEBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jneb_free(ptr >>> 0, 1));
/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
*/
class JNEB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jneb_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {RegId} dynamic
    * @param {Imm06} fixed
    */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        JNEBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const JNEFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnef_free(ptr >>> 0, 1));
/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
*/
class JNEF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnef_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {RegId} dynamic
    * @param {Imm06} fixed
    */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        JNEFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const JNEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnei_free(ptr >>> 0, 1));
/**
*Conditional jump.
*/
class JNEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnei_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {Imm12} abs_target
    */
    constructor(cond_lhs, cond_rhs, abs_target) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(abs_target, Imm12);
        var ptr2 = abs_target.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNEIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzb_free(ptr >>> 0, 1));
/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
*/
class JNZB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzb_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {RegId} dynamic
    * @param {Imm12} fixed
    */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNZBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzf_free(ptr >>> 0, 1));
/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
*/
class JNZF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzf_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {RegId} dynamic
    * @param {Imm12} fixed
    */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        JNZFFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzi_free(ptr >>> 0, 1));
/**
*Conditional jump against zero.
*/
class JNZI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {Imm18} abs_target
    */
    constructor(cond_nz, abs_target) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(abs_target, Imm18);
        var ptr1 = abs_target.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        JNZIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const K256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_k256_free(ptr >>> 0, 1));
/**
*The keccak-256 hash of a slice.
*/
class K256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        K256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_k256_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        K256Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lb_free(ptr >>> 0, 1));
/**
*A byte is loaded from the specified address offset by an immediate value.
*/
class LB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lb_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} addr
    * @param {Imm12} offset
    */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const LDCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ldc_free(ptr >>> 0, 1));
/**
*Load code as executable either from contract, blob, or memory.
*/
class LDC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LDCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ldc_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} src_addr
    * @param {RegId} offset
    * @param {RegId} len
    * @param {Imm06} mode
    */
    constructor(src_addr, offset, len, mode) {
        _assertClass(src_addr, RegId);
        var ptr0 = src_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr1 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        _assertClass(mode, Imm06);
        var ptr3 = mode.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LDCFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const LOGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_log_free(ptr >>> 0, 1));
/**
*Log an event.
*/
class LOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LOGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_log_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} c
    * @param {RegId} d
    */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LOGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LOGDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_logd_free(ptr >>> 0, 1));
/**
*Log data.
*/
class LOGD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LOGDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_logd_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} addr
    * @param {RegId} len
    */
    constructor(a, b, addr, len) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr2 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        LOGDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lt_free(ptr >>> 0, 1));
/**
*Compares two registers for less-than.
*/
class LT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lt_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lw_free(ptr >>> 0, 1));
/**
*A word is loaded from the specified address offset by an immediate value.
*/
class LW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lw_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} addr
    * @param {Imm12} offset
    */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        LWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MCLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcl_free(ptr >>> 0, 1));
/**
*Clear a variable number of bytes in memory.
*/
class MCL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcl_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} len
    */
    constructor(dst_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MCLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MCLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcli_free(ptr >>> 0, 1));
/**
*Clear an immediate number of bytes in memory.
*/
class MCLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcli_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {Imm18} count
    */
    constructor(addr, count) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(count, Imm18);
        var ptr1 = count.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MCLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const MCPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcp_free(ptr >>> 0, 1));
/**
*Copy a variable number of bytes in memory.
*/
class MCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcp_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MCPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MCPIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcpi_free(ptr >>> 0, 1));
/**
*Copy an immediate number of bytes in memory.
*/
class MCPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCPIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcpi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {Imm12} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, Imm12);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MCPIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MEQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_meq_free(ptr >>> 0, 1));
/**
*Compare bytes in memory.
*/
class MEQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MEQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_meq_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} result
    * @param {RegId} lhs_addr
    * @param {RegId} rhs_addr
    * @param {RegId} len
    */
    constructor(result, lhs_addr, rhs_addr, len) {
        _assertClass(result, RegId);
        var ptr0 = result.__destroy_into_raw();
        _assertClass(lhs_addr, RegId);
        var ptr1 = lhs_addr.__destroy_into_raw();
        _assertClass(rhs_addr, RegId);
        var ptr2 = rhs_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        MEQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MINTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mint_free(ptr >>> 0, 1));
/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
class MINT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MINTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mint_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    * @param {RegId} sub_id_addr
    */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MINTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MLDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mldv_free(ptr >>> 0, 1));
/**
*Fused multiply-divide with arbitrary precision intermediate step.
*/
class MLDV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MLDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mldv_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        MLDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MLOGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mlog_free(ptr >>> 0, 1));
/**
*The integer logarithm of a register.
*/
class MLOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MLOGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mlog_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MLOGFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MODFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mod_free(ptr >>> 0, 1));
/**
*Modulo remainder of two registers.
*/
class MOD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MODFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mod_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MODFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MODIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_modi_free(ptr >>> 0, 1));
/**
*Modulo remainder of a register and an immediate value.
*/
class MODI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MODIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_modi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MODIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MOVEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_move_free(ptr >>> 0, 1));
/**
*Copy from one register to another.
*/
class MOVE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MOVEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_move_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} src
    */
    constructor(dst, src) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(src, RegId);
        var ptr1 = src.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MOVEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MOVIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_movi_free(ptr >>> 0, 1));
/**
*Copy immediate value into a register
*/
class MOVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MOVIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_movi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {Imm18} val
    */
    constructor(dst, val) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(val, Imm18);
        var ptr1 = val.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        MOVIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const MROOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mroo_free(ptr >>> 0, 1));
/**
*The integer root of a register.
*/
class MROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MROOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mroo_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MROOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MULFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mul_free(ptr >>> 0, 1));
/**
*Multiplies two registers.
*/
class MUL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MULFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mul_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MULFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MULIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_muli_free(ptr >>> 0, 1));
/**
*Multiplies a register and an immediate value.
*/
class MULI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MULIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_muli_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        MULIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MathArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mathargs_free(ptr >>> 0, 1));
/**
* Additional arguments for WDOP and WQOP instructions.
*/
class MathArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MathArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mathargs_free(ptr, 0);
    }
    /**
    * The operation to perform
    * @returns {MathOp}
    */
    get op() {
        const ret = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
        return ret;
    }
    /**
    * The operation to perform
    * @param {MathOp} arg0
    */
    set op(arg0) {
        wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const MulArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mulargs_free(ptr >>> 0, 1));
/**
* Additional arguments for WDML and WQML instructions.
*/
class MulArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MulArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mulargs_free(ptr, 0);
    }
    /**
    * Load LHSS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_lhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load LHSS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_lhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_mulargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_mulargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const NOOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_noop_free(ptr >>> 0, 1));
/**
*Performs no operation.
*/
class NOOP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NOOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_noop_free(ptr, 0);
    }
    /**
    * Construct the instruction.
    */
    constructor() {
        const ret = wasm$1.noop_new_typescript();
        this.__wbg_ptr = ret >>> 0;
        NOOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
}

const NOTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_not_free(ptr >>> 0, 1));
/**
*Bitwise NOT a register.
*/
class NOT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NOTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_not_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} arg
    */
    constructor(dst, arg) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        NOTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ORFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_or_free(ptr >>> 0, 1));
/**
*Bitwise ORs two registers.
*/
class OR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ORFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_or_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ORFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ORIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ori_free(ptr >>> 0, 1));
/**
*Bitwise ORs a register and an immediate value.
*/
class ORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ORIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ori_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        ORIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const POPHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_poph_free(ptr >>> 0, 1));
/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
*/
class POPH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        POPHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_poph_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        POPHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const POPLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_popl_free(ptr >>> 0, 1));
/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
*/
class POPL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        POPLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_popl_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        POPLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PSHHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_pshh_free(ptr >>> 0, 1));
/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
*/
class PSHH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSHHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshh_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        PSHHFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PSHLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_pshl_free(ptr >>> 0, 1));
/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
*/
class PSHL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSHLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshl_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        PSHLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PanicInstructionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_panicinstruction_free(ptr >>> 0, 1));
/**
* Describe a panic reason with the instruction that generated it
*/
class PanicInstruction {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PanicInstructionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_panicinstruction_free(ptr, 0);
    }
    /**
    * Represents an error described by a reason and an instruction.
    * @param {PanicReason} reason
    * @param {number} instruction
    */
    constructor(reason, instruction) {
        const ret = wasm$1.panicinstruction_error_typescript(reason, instruction);
        this.__wbg_ptr = ret >>> 0;
        PanicInstructionFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Underlying panic reason
    * @returns {PanicReason}
    */
    reason() {
        const ret = wasm$1.panicinstruction_reason(this.__wbg_ptr);
        return ret;
    }
    /**
    * Underlying instruction
    * @returns {number}
    */
    instruction() {
        const ret = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
        return ret >>> 0;
    }
}

const RETFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ret_free(ptr >>> 0, 1));
/**
*Return from context.
*/
class RET {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RETFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ret_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        RETFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RETDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_retd_free(ptr >>> 0, 1));
/**
*Return from context with data.
*/
class RETD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RETDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_retd_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} len
    */
    constructor(addr, len) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        RETDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RVRTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_rvrt_free(ptr >>> 0, 1));
/**
*Halt execution, reverting state changes and returning a value.
*/
class RVRT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RVRTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_rvrt_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        RVRTFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RegIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_regid_free(ptr >>> 0, 1));
/**
* Represents a 6-bit register ID, guaranteed to be masked by construction.
*/
class RegId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegId.prototype);
        obj.__wbg_ptr = ptr;
        RegIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RegIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_regid_free(ptr, 0);
    }
    /**
    * Construct a register ID from the given value.
    *
    * Returns `None` if the value is outside the 6-bit value range.
    * @param {number} u
    * @returns {RegId | undefined}
    */
    static new_checked(u) {
        const ret = wasm$1.regid_new_checked(u);
        return ret === 0 ? undefined : RegId.__wrap(ret);
    }
    /**
    * Received balance for this context.
    * @returns {RegId}
    */
    static bal() {
        const ret = wasm$1.regid_bal();
        return RegId.__wrap(ret);
    }
    /**
    * Remaining gas in the context.
    * @returns {RegId}
    */
    static cgas() {
        const ret = wasm$1.regid_cgas();
        return RegId.__wrap(ret);
    }
    /**
    * Error codes for particular operations.
    * @returns {RegId}
    */
    static err() {
        const ret = wasm$1.regid_err();
        return RegId.__wrap(ret);
    }
    /**
    * Flags register.
    * @returns {RegId}
    */
    static flag() {
        const ret = wasm$1.regid_flag();
        return RegId.__wrap(ret);
    }
    /**
    * Frame pointer. Memory address of beginning of current call frame.
    * @returns {RegId}
    */
    static fp() {
        const ret = wasm$1.regid_fp();
        return RegId.__wrap(ret);
    }
    /**
    * Remaining gas globally.
    * @returns {RegId}
    */
    static ggas() {
        const ret = wasm$1.regid_ggas();
        return RegId.__wrap(ret);
    }
    /**
    * Heap pointer. Memory address below the current bottom of the heap (points to free
    * memory).
    * @returns {RegId}
    */
    static hp() {
        const ret = wasm$1.regid_hp();
        return RegId.__wrap(ret);
    }
    /**
    * Instructions start. Pointer to the start of the currently-executing code.
    * @returns {RegId}
    */
    static is() {
        const ret = wasm$1.regid_is();
        return RegId.__wrap(ret);
    }
    /**
    * Contains overflow/underflow of addition, subtraction, and multiplication.
    * @returns {RegId}
    */
    static of() {
        const ret = wasm$1.regid_of();
        return RegId.__wrap(ret);
    }
    /**
    * Contains one (1), for convenience.
    * @returns {RegId}
    */
    static one() {
        const ret = wasm$1.regid_one();
        return RegId.__wrap(ret);
    }
    /**
    * The program counter. Memory address of the current instruction.
    * @returns {RegId}
    */
    static pc() {
        const ret = wasm$1.regid_pc();
        return RegId.__wrap(ret);
    }
    /**
    * Return value or pointer.
    * @returns {RegId}
    */
    static ret() {
        const ret = wasm$1.regid_ret();
        return RegId.__wrap(ret);
    }
    /**
    * Return value length in bytes.
    * @returns {RegId}
    */
    static retl() {
        const ret = wasm$1.regid_retl();
        return RegId.__wrap(ret);
    }
    /**
    * Stack pointer. Memory address on top of current writable stack area (points to
    * free memory).
    * @returns {RegId}
    */
    static sp() {
        const ret = wasm$1.regid_sp();
        return RegId.__wrap(ret);
    }
    /**
    * Stack start pointer. Memory address of bottom of current writable stack area.
    * @returns {RegId}
    */
    static spp() {
        const ret = wasm$1.regid_spp();
        return RegId.__wrap(ret);
    }
    /**
    * Smallest writable register.
    * @returns {RegId}
    */
    static writable() {
        const ret = wasm$1.regid_writable();
        return RegId.__wrap(ret);
    }
    /**
    * Contains zero (0), for convenience.
    * @returns {RegId}
    */
    static zero() {
        const ret = wasm$1.regid_zero();
        return RegId.__wrap(ret);
    }
    /**
    * Construct a register ID from the given value.
    *
    * The given value will be masked to 6 bits.
    * @param {number} u
    */
    constructor(u) {
        const ret = wasm$1.regid_new_typescript(u);
        this.__wbg_ptr = ret >>> 0;
        RegIdFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * A const alternative to the `Into<u8>` implementation.
    * @returns {number}
    */
    to_u8() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.regid_to_u8(ptr);
        return ret;
    }
}

const S256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_s256_free(ptr >>> 0, 1));
/**
*The SHA-2-256 hash of a slice.
*/
class S256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        S256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_s256_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        S256Finalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sb_free(ptr >>> 0, 1));
/**
*Write the least significant byte of a register to memory.
*/
class SB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sb_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} value
    * @param {Imm12} offset
    */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SCWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_scwq_free(ptr >>> 0, 1));
/**
*Clear a series of slots from contract storage.
*/
class SCWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SCWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_scwq_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} lenq
    */
    constructor(key_addr, status, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr2 = lenq.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SCWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SLLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sll_free(ptr >>> 0, 1));
/**
*Left shifts a register by a register.
*/
class SLL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SLLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sll_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SLLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SLLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_slli_free(ptr >>> 0, 1));
/**
*Left shifts a register by an immediate value.
*/
class SLLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SLLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_slli_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SLLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SMOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_smo_free(ptr >>> 0, 1));
/**
*Send a message to recipient address with call abi, coins, and output.
*/
class SMO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SMOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_smo_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} recipient_addr
    * @param {RegId} data_addr
    * @param {RegId} data_len
    * @param {RegId} coins
    */
    constructor(recipient_addr, data_addr, data_len, coins) {
        _assertClass(recipient_addr, RegId);
        var ptr0 = recipient_addr.__destroy_into_raw();
        _assertClass(data_addr, RegId);
        var ptr1 = data_addr.__destroy_into_raw();
        _assertClass(data_len, RegId);
        var ptr2 = data_len.__destroy_into_raw();
        _assertClass(coins, RegId);
        var ptr3 = coins.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SMOFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srl_free(ptr >>> 0, 1));
/**
*Right shifts a register by a register.
*/
class SRL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srl_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srli_free(ptr >>> 0, 1));
/**
*Right shifts a register by an immediate value.
*/
class SRLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srli_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRLIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SRWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srw_free(ptr >>> 0, 1));
/**
*Load a word from contract storage.
*/
class SRW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srw_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} status
    * @param {RegId} key_addr
    */
    constructor(dst, status, key_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SRWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srwq_free(ptr >>> 0, 1));
/**
*Load a series of 32 byte slots from contract storage.
*/
class SRWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srwq_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} status
    * @param {RegId} key_addr
    * @param {RegId} lenq
    */
    constructor(dst_addr, status, key_addr, lenq) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SRWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SUBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sub_free(ptr >>> 0, 1));
/**
*Subtracts two registers.
*/
class SUB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SUBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sub_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SUBFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SUBIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_subi_free(ptr >>> 0, 1));
/**
*Subtracts a register and an immediate value.
*/
class SUBI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SUBIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_subi_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SUBIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sw_free(ptr >>> 0, 1));
/**
*Write a register to memory.
*/
class SW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sw_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} value
    * @param {Imm12} offset
    */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SWWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sww_free(ptr >>> 0, 1));
/**
*Store a word in contract storage.
*/
class SWW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sww_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} value
    */
    constructor(key_addr, status, value) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr2 = value.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        SWWFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SWWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_swwq_free(ptr >>> 0, 1));
/**
*Store a series of 32 byte slots in contract storage.
*/
class SWWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_swwq_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} src_addr
    * @param {RegId} lenq
    */
    constructor(key_addr, status, src_addr, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr2 = src_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        SWWQFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TIMEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_time_free(ptr >>> 0, 1));
/**
*Get timestamp of block at given height.
*/
class TIME {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TIMEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_time_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} heigth
    */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        TIMEFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TRFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tr_free(ptr >>> 0, 1));
/**
*Transfer coins to a contract unconditionally.
*/
class TR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TRFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tr_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} amount
    * @param {RegId} asset_id_addr
    */
    constructor(contract_id_addr, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr1 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        TRFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TROFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tro_free(ptr >>> 0, 1));
/**
*Transfer coins to a variable output.
*/
class TRO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TROFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tro_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} output_index
    * @param {RegId} amount
    * @param {RegId} asset_id_addr
    */
    constructor(contract_id_addr, output_index, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(output_index, RegId);
        var ptr1 = output_index.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr2 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr3 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        TROFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDAMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdam_free(ptr >>> 0, 1));
/**
*AddMod 128bit
*/
class WDAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDAMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdam_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} add_lhs
    * @param {RegId} add_rhs
    * @param {RegId} modulo
    */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDAMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDCMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdcm_free(ptr >>> 0, 1));
/**
*Compare 128bit integers
*/
class WDCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDCM.prototype);
        obj.__wbg_ptr = ptr;
        WDCMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDCMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdcm_free(ptr, 0);
    }
    /**
    * Construct a `WDCM` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {CompareArgs} args
    * @returns {WDCM}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDCM.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDCMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wddv_free(ptr >>> 0, 1));
/**
*Divide 128bit
*/
class WDDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDDV.prototype);
        obj.__wbg_ptr = ptr;
        WDDVFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wddv_free(ptr, 0);
    }
    /**
    * Construct a `WDDV` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {DivArgs} args
    * @returns {WDDV}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDDV.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDMDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdmd_free(ptr >>> 0, 1));
/**
*Fused multiply-divide 128bit
*/
class WDMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmd_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDMLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdml_free(ptr >>> 0, 1));
/**
*Multiply 128bit
*/
class WDML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDML.prototype);
        obj.__wbg_ptr = ptr;
        WDMLFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdml_free(ptr, 0);
    }
    /**
    * Construct a `WDML` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MulArgs} args
    * @returns {WDML}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDML.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDMMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdmm_free(ptr >>> 0, 1));
/**
*MulMod 128bit
*/
class WDMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmm_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} modulo
    */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDMMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdop_free(ptr >>> 0, 1));
/**
*Simple 128bit operations
*/
class WDOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDOP.prototype);
        obj.__wbg_ptr = ptr;
        WDOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdop_free(ptr, 0);
    }
    /**
    * Construct a `WDOP` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MathArgs} args
    * @returns {WDOP}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDOP.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WDOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQAMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqam_free(ptr >>> 0, 1));
/**
*AddMod 256bit
*/
class WQAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQAMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqam_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} add_lhs
    * @param {RegId} add_rhs
    * @param {RegId} modulo
    */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQAMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQCMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqcm_free(ptr >>> 0, 1));
/**
*Compare 256bit integers
*/
class WQCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQCM.prototype);
        obj.__wbg_ptr = ptr;
        WQCMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQCMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqcm_free(ptr, 0);
    }
    /**
    * Construct a `WQCM` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {CompareArgs} args
    * @returns {WQCM}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQCM.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQCMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqdv_free(ptr >>> 0, 1));
/**
*Divide 256bit
*/
class WQDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQDV.prototype);
        obj.__wbg_ptr = ptr;
        WQDVFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqdv_free(ptr, 0);
    }
    /**
    * Construct a `WQDV` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {DivArgs} args
    * @returns {WQDV}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQDV.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQDVFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQMDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqmd_free(ptr >>> 0, 1));
/**
*Fused multiply-divide 256bit
*/
class WQMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmd_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMDFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQMLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqml_free(ptr >>> 0, 1));
/**
*Multiply 256bit
*/
class WQML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQML.prototype);
        obj.__wbg_ptr = ptr;
        WQMLFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqml_free(ptr, 0);
    }
    /**
    * Construct a `WQML` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MulArgs} args
    * @returns {WQML}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQML.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMLFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQMMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqmm_free(ptr >>> 0, 1));
/**
*MulMod 256bit
*/
class WQMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmm_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} modulo
    */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQMMFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.bldd_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqop_free(ptr >>> 0, 1));
/**
*Simple 256bit operations
*/
class WQOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQOP.prototype);
        obj.__wbg_ptr = ptr;
        WQOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqop_free(ptr, 0);
    }
    /**
    * Construct a `WQOP` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MathArgs} args
    * @returns {WQOP}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQOP.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        WQOPFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const XORFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_xor_free(ptr >>> 0, 1));
/**
*Bitwise XORs two registers.
*/
class XOR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XORFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xor_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        XORFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const XORIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_xori_free(ptr >>> 0, 1));
/**
*Bitwise XORs a register and an immediate value.
*/
class XORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XORIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xori_free(ptr, 0);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        XORIFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_finalize_init(instance, module) {
    wasm$1 = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedUint8ArrayMemory0 = null;



    return wasm$1;
}

function initSync(module) {
    if (wasm$1 !== undefined) return wasm$1;


    if (typeof module !== 'undefined' && Object.getPrototypeOf(module) === Object.prototype)
    ({module} = module);
    else
    console.warn('using deprecated parameters for `initSync()`; pass a single object instead');

    const imports = __wbg_get_imports();

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(module_or_path) {
    if (wasm$1 !== undefined) return wasm$1;


    if (typeof module_or_path !== 'undefined' && Object.getPrototypeOf(module_or_path) === Object.prototype)
    ({module_or_path} = module_or_path);
    else
    console.warn('using deprecated parameters for the initialization function; pass a single object instead');
    const imports = __wbg_get_imports();

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function wasm(imports){return _loadWasmModule(1, null, 'AGFzbQEAAAABOgpgA39/fwF/YAF/AX9gBH9/f38Bf2ACf38AYAJ/fwF/YAABf2AFf39/f38Bf2ABfwBgA39/fwBgAAACGAEDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAwP/Af0BAQEDAwMDAwMBAQMDAQEBAwMBAQEEAQMDAwEBAwEBAQQCAQMCAgICAgIDAwMEBAQEBAQEBAEBAQMDAAICBAQEBAQEBAQEBAABAQgDAwQBAQEBAQEBAgcDAQAAAQEDBwcBAwEDAgIBAQEAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQUBAQEBBAAEAQYCAgMDAAIABwEIBAEEAQkDAQEHAQUFBQUFBQUFBQUFBQUFBQUFBQUDBgYCAgQCBgYAAAgABAUDAQARBgkBfwFBgIDAAAsHjUzPBQZtZW1vcnkCABZfX3diZ19jb21wYXJlYXJnc19mcmVlABAaX193YmdfZ2V0X2NvbXBhcmVhcmdzX21vZGUASBpfX3diZ19zZXRfY29tcGFyZWFyZ3NfbW9kZQA4Il9fd2JnX2dldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMASSJfX3diZ19zZXRfY29tcGFyZWFyZ3NfaW5kaXJlY3RfcmhzAEsSY29tcGFyZWFyZ3NfdG9faW1tAFgUY29tcGFyZWFyZ3NfZnJvbV9pbW0AHxVfX3diZ19nZXRfbWF0aGFyZ3Nfb3AASBVfX3diZ19zZXRfbWF0aGFyZ3Nfb3AAORJfX3diZ19tdWxhcmdzX2ZyZWUAER5fX3diZ19nZXRfbXVsYXJnc19pbmRpcmVjdF9yaHMASB5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9yaHMATBJfX3diZ19kaXZhcmdzX2ZyZWUAIx5fX3diZ19nZXRfZGl2YXJnc19pbmRpcmVjdF9yaHMAuQEeX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAGMbX193YmdfcGFuaWNpbnN0cnVjdGlvbl9mcmVlABchcGFuaWNpbnN0cnVjdGlvbl9lcnJvcl90eXBlc2NyaXB0AE0XcGFuaWNpbnN0cnVjdGlvbl9yZWFzb24AWxxwYW5pY2luc3RydWN0aW9uX2luc3RydWN0aW9uAFwMZ21fZnJvbV9hcmdzANUBDWd0Zl9mcm9tX2FyZ3MAzQEHZ21fYXJncwCIAQhndGZfYXJncwBpDndkY21fZnJvbV9hcmdzADsOd2RvcF9mcm9tX2FyZ3MAOw53ZG1sX2Zyb21fYXJncwA8DndkZHZfZnJvbV9hcmdzAMkBCXdkY21fYXJncwAkCXdxY21fYXJncwAlCXdkb3BfYXJncwAmCXdxb3BfYXJncwAnCXdkbWxfYXJncwAoCXdxbWxfYXJncwApCXdkZHZfYXJncwBkCXdxZHZfYXJncwBlEF9fd2JnX2ltbTA2X2ZyZWUAKhBfX3diZ19pbW0xMl9mcmVlACsQX193YmdfaW1tMThfZnJlZQAsDl9fd2JnX2FkZF9mcmVlABgPX193Ymdfbm9vcF9mcmVlAAcSYWRkX25ld190eXBlc2NyaXB0AFkGYWRkX3JhADUGYWRkX3JiABIGYWRkX3JjABoDYWRkAMUBA2FuZACKAQNkaXYAiwECZXEAjAEDZXhwAI0BAmd0AI4BAmx0AI8BBG1sb2cAkAEEbXJvbwCRAQRtb2RfAJIBBW1vdmVfAD0DbXVsAJMBA25vdAA+Am9yAJQBA3NsbACVAQNzcmwAlgEDc3ViAJcBA3hvcgCYAQRtbGR2AGoDcmV0ALoBBHJldGQAPxNhbG9jX25ld190eXBlc2NyaXB0AGAHYWxvY19yYQAiBGFsb2MAuwEDbWNsAEADbWNwAJkBA21lcQBrE2Joc2hfbmV3X3R5cGVzY3JpcHQAIARiaHNoAC0EYmhlaQC8AQRidXJuAEEEY2FsbABsA2NjcABtBGNyb28AQgRjc2l6AEMCY2IAvQEDbGRjAG4DbG9nAG8EbG9nZABwBG1pbnQARARydnJ0AL4BBHNjd3EAmgEDc3J3AJsBBHNyd3EAcQNzd3cAnAEEc3d3cQByAnRyAJ0BA3RybwBzBGVjazEAngEEZWNyMQCfAQRlZDE5AHQEazI1NgCgAQRzMjU2AKEBBHRpbWUARRNub29wX25ld190eXBlc2NyaXB0AL8BBG5vb3AA3QEEZmxhZwDAAQNiYWwAogEDam1wAMEBA2puZQCjAQNzbW8AdRNhZGRpX25ld190eXBlc2NyaXB0AFoKYWRkaV9pbW0xMgAJBGFkZGkApAEEYW5kaQClAQRkaXZpAKYBBGV4cGkApwEEbW9kaQCoAQRtdWxpAKkBA29yaQCqAQRzbGxpAKsBBHNybGkArAEEc3ViaQCtAQR4b3JpAK4BBGpuZWkArwECbGIAsAECbHcAsQECc2IAsgECc3cAswEEbWNwaQC0ARJndGZfbmV3X3R5cGVzY3JpcHQAzwEDZ3RmALUBBG1jbGkALhFnbV9uZXdfdHlwZXNjcmlwdABGCGdtX2ltbTE4AA0CZ20ALwRtb3ZpADAEam56aQAxBGptcGYAMhNqbXBiX25ld190eXBlc2NyaXB0ABUEam1wYgAzBGpuemYAtgEEam56YgC3AQRqbmVmAHYKam5lYl9pbW0wNgA2BGpuZWIAdwJqaQBOE2NmZWlfbmV3X3R5cGVzY3JpcHQANwpjZmVpX2ltbTI0AAoEY2ZlaQBPBGNmc2kAUANjZmUAwgEDY2ZzAMMBBHBzaGwAUQRwc2hoAFIEcG9wbABTBHBvcGgAVBN3ZGNtX25ld190eXBlc2NyaXB0AMoBBHdkY20AeAR3cWNtAHkEd2RvcAB6BHdxb3AAewR3ZG1sAHwEd3FtbAB9BHdkZHYAfgR3cWR2AH8Ed2RtZACAAQR3cW1kAIEBBHdkYW0AggEEd3FhbQCDAQR3ZG1tAIQBBHdxbW0AhQEEZWNhbACGAQRic2l6ADQTYmxkZF9uZXdfdHlwZXNjcmlwdABVB2JsZGRfcmQANgRibGRkAIcBFl9fd2JnX2luc3RydWN0aW9uX2ZyZWUADBRpbnN0cnVjdGlvbl90b19ieXRlcwAGEGluc3RydWN0aW9uX3NpemUA7wERcmVnaWRfbmV3X2NoZWNrZWQAuAEJcmVnaWRfYmFsAN4BCnJlZ2lkX2NnYXMA3wEJcmVnaWRfZXJyAOABCnJlZ2lkX2ZsYWcA4QEIcmVnaWRfZnAA4gEKcmVnaWRfZ2dhcwDjAQhyZWdpZF9ocADkAQhyZWdpZF9pcwDlAQhyZWdpZF9vZgDmAQlyZWdpZF9vbmUA5wEIcmVnaWRfcGMA6AEJcmVnaWRfcmV0AOkBCnJlZ2lkX3JldGwA6gEIcmVnaWRfc3AA6wEJcmVnaWRfc3BwAOwBDnJlZ2lkX3dyaXRhYmxlAO0BCnJlZ2lkX3plcm8A7gEUcmVnaWRfbmV3X3R5cGVzY3JpcHQA2QELcmVnaWRfdG9fdTgA2gESYW5kX25ld190eXBlc2NyaXB0AFkSZGl2X25ld190eXBlc2NyaXB0AFkRZXFfbmV3X3R5cGVzY3JpcHQAWRJleHBfbmV3X3R5cGVzY3JpcHQAWRFndF9uZXdfdHlwZXNjcmlwdABZEWx0X25ld190eXBlc2NyaXB0AFkTbWxvZ19uZXdfdHlwZXNjcmlwdABZE21yb29fbmV3X3R5cGVzY3JpcHQAWRJtb2RfbmV3X3R5cGVzY3JpcHQAWRJtdWxfbmV3X3R5cGVzY3JpcHQAWRFvcl9uZXdfdHlwZXNjcmlwdABZEnNsbF9uZXdfdHlwZXNjcmlwdABZEnNybF9uZXdfdHlwZXNjcmlwdABZEnN1Yl9uZXdfdHlwZXNjcmlwdABZEnhvcl9uZXdfdHlwZXNjcmlwdABZEm1jcF9uZXdfdHlwZXNjcmlwdABZE3Njd3FfbmV3X3R5cGVzY3JpcHQAWRJzcndfbmV3X3R5cGVzY3JpcHQAWRJzd3dfbmV3X3R5cGVzY3JpcHQAWRF0cl9uZXdfdHlwZXNjcmlwdABZE2VjazFfbmV3X3R5cGVzY3JpcHQAWRNlY3IxX25ld190eXBlc2NyaXB0AFkTazI1Nl9uZXdfdHlwZXNjcmlwdABZE3MyNTZfbmV3X3R5cGVzY3JpcHQAWRJiYWxfbmV3X3R5cGVzY3JpcHQAWRJqbmVfbmV3X3R5cGVzY3JpcHQAWRNhbmRpX25ld190eXBlc2NyaXB0AFoTZGl2aV9uZXdfdHlwZXNjcmlwdABaE2V4cGlfbmV3X3R5cGVzY3JpcHQAWhNtb2RpX25ld190eXBlc2NyaXB0AFoTbXVsaV9uZXdfdHlwZXNjcmlwdABaEm9yaV9uZXdfdHlwZXNjcmlwdABaE3NsbGlfbmV3X3R5cGVzY3JpcHQAWhNzcmxpX25ld190eXBlc2NyaXB0AFoTc3ViaV9uZXdfdHlwZXNjcmlwdABaE3hvcmlfbmV3X3R5cGVzY3JpcHQAWhNqbmVpX25ld190eXBlc2NyaXB0AFoRbGJfbmV3X3R5cGVzY3JpcHQAWhFsd19uZXdfdHlwZXNjcmlwdABaEXNiX25ld190eXBlc2NyaXB0AFoRc3dfbmV3X3R5cGVzY3JpcHQAWhNtY3BpX25ld190eXBlc2NyaXB0AFoTam56Zl9uZXdfdHlwZXNjcmlwdABaE2puemJfbmV3X3R5cGVzY3JpcHQAWhFqaV9uZXdfdHlwZXNjcmlwdAA3E2Nmc2lfbmV3X3R5cGVzY3JpcHQANxNwc2hsX25ld190eXBlc2NyaXB0ADcTcHNoaF9uZXdfdHlwZXNjcmlwdAA3E3BvcGxfbmV3X3R5cGVzY3JpcHQANxNwb3BoX25ld190eXBlc2NyaXB0ADcTbW92aV9uZXdfdHlwZXNjcmlwdAAVE21jbGlfbmV3X3R5cGVzY3JpcHQAFRNqbnppX25ld190eXBlc2NyaXB0ABUTam1wZl9uZXdfdHlwZXNjcmlwdAAVEm5vdF9uZXdfdHlwZXNjcmlwdAAgE3JldGRfbmV3X3R5cGVzY3JpcHQAIBNtb3ZlX25ld190eXBlc2NyaXB0ACASbWNsX25ld190eXBlc2NyaXB0ACATYnVybl9uZXdfdHlwZXNjcmlwdAAgE2Nyb29fbmV3X3R5cGVzY3JpcHQAIBNjc2l6X25ld190eXBlc2NyaXB0ACATbWludF9uZXdfdHlwZXNjcmlwdAAgE3RpbWVfbmV3X3R5cGVzY3JpcHQAIBNic2l6X25ld190eXBlc2NyaXB0ACAGcmV0X3JhACIHYmhlaV9yYQAiBWNiX3JhACIHcnZydF9yYQAiB2ZsYWdfcmEAIgZqbXBfcmEAIghqaV9pbW0yNAAKCmNmc2lfaW1tMjQACgZjZmVfcmEAIgZjZnNfcmEAIgpwc2hsX2ltbTI0AAoKcHNoaF9pbW0yNAAKCnBvcGxfaW1tMjQACgpwb3BoX2ltbTI0AAoTbWxkdl9uZXdfdHlwZXNjcmlwdABVEm1lcV9uZXdfdHlwZXNjcmlwdABVEmNjcF9uZXdfdHlwZXNjcmlwdABVEmxvZ19uZXdfdHlwZXNjcmlwdABVE2xvZ2RfbmV3X3R5cGVzY3JpcHQAVRNzcndxX25ld190eXBlc2NyaXB0AFUTc3d3cV9uZXdfdHlwZXNjcmlwdABVEnRyb19uZXdfdHlwZXNjcmlwdABVE2VkMTlfbmV3X3R5cGVzY3JpcHQAVRJzbW9fbmV3X3R5cGVzY3JpcHQAVRJsZGNfbmV3X3R5cGVzY3JpcHQAVRNqbmVmX25ld190eXBlc2NyaXB0AFUTd2RtZF9uZXdfdHlwZXNjcmlwdABVE3dxbWRfbmV3X3R5cGVzY3JpcHQAVRN3ZGFtX25ld190eXBlc2NyaXB0AFUTd3FhbV9uZXdfdHlwZXNjcmlwdABVE3dkbW1fbmV3X3R5cGVzY3JpcHQAVRN3cW1tX25ld190eXBlc2NyaXB0AFUTZWNhbF9uZXdfdHlwZXNjcmlwdABVE2NhbGxfbmV3X3R5cGVzY3JpcHQAVRNfX3diZ19tYXRoYXJnc19mcmVlABAfX193Ymdfc2V0X21hdGhhcmdzX2luZGlyZWN0X3JocwBLHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X2xocwBLH19fd2JnX2dldF9tYXRoYXJnc19pbmRpcmVjdF9yaHMASR5fX3diZ19nZXRfbXVsYXJnc19pbmRpcmVjdF9saHMASRJyZXRfbmV3X3R5cGVzY3JpcHQAYBNiaGVpX25ld190eXBlc2NyaXB0AGARY2JfbmV3X3R5cGVzY3JpcHQAYBNydnJ0X25ld190eXBlc2NyaXB0AGATZmxhZ19uZXdfdHlwZXNjcmlwdABgEmptcF9uZXdfdHlwZXNjcmlwdABgEmNmZV9uZXdfdHlwZXNjcmlwdABgEmNmc19uZXdfdHlwZXNjcmlwdABgD19fd2JnX3dkb3BfZnJlZQAYDl9fd2JnX21vZF9mcmVlABgPX193Ymdfd3Fkdl9mcmVlABgNX193Ymdfc2JfZnJlZQAYDl9fd2JnX3Ntb19mcmVlABgPX193YmdfcHNobF9mcmVlABgOX193YmdfbG9nX2ZyZWUAGA9fX3diZ193cWFtX2ZyZWUAGA9fX3diZ193cW1sX2ZyZWUAGA5fX3diZ19ub3RfZnJlZQAYD19fd2JnX2puemlfZnJlZQAYD19fd2JnX2puZWlfZnJlZQAYD19fd2JnX3N1YmlfZnJlZQAYD19fd2JnX2ZsYWdfZnJlZQAYD19fd2JnX2NzaXpfZnJlZQAYD19fd2JnX3Nyd3FfZnJlZQAYD19fd2JnX3NsbGlfZnJlZQAYD19fd2JnX2ptcGJfZnJlZQAYD19fd2JnX3dkbWxfZnJlZQAYD19fd2JnX3MyNTZfZnJlZQAYDl9fd2JnX3hvcl9mcmVlABgOX193YmdfY2ZlX2ZyZWUAGA1fX3diZ19ndF9mcmVlABgPX193YmdfcHNoaF9mcmVlABgPX193YmdfbWNsaV9mcmVlABgNX193YmdfbHRfZnJlZQAYD19fd2JnX2puZWZfZnJlZQAYDV9fd2JnX3N3X2ZyZWUAGA9fX3diZ19zcmxpX2ZyZWUAGA9fX3diZ19idXJuX2ZyZWUAGA9fX3diZ19ic2l6X2ZyZWUAGA9fX3diZ19ydnJ0X2ZyZWUAGA9fX3diZ194b3JpX2ZyZWUAGA9fX3diZ19tdWxpX2ZyZWUAGA1fX3diZ19sYl9mcmVlABgNX193YmdfZ21fZnJlZQAYD19fd2JnX2Joc2hfZnJlZQAYDV9fd2JnX2VxX2ZyZWUAGA5fX3diZ19zbGxfZnJlZQAYDl9fd2JnX29yaV9mcmVlABgPX193YmdfZWQxOV9mcmVlABgPX193YmdfY2ZlaV9mcmVlABgPX193YmdfY2ZzaV9mcmVlABgPX193Ymdfam56Yl9mcmVlABgPX193YmdfYWxvY19mcmVlABgOX193Ymdfc3JsX2ZyZWUAGA9fX3diZ19tcm9vX2ZyZWUAGA5fX3diZ19jZnNfZnJlZQAYDl9fd2JnX2ptcF9mcmVlABgPX193YmdfYmhlaV9mcmVlABgPX193YmdfbG9nZF9mcmVlABgPX193Ymdfam5lYl9mcmVlABgPX193Ymdfd3FtbV9mcmVlABgPX193YmdfcG9waF9mcmVlABgPX193Ymdfd2RjbV9mcmVlABgPX193YmdfZXhwaV9mcmVlABgPX193YmdfYWRkaV9mcmVlABgPX193YmdfYmxkZF9mcmVlABgOX193YmdfbGRjX2ZyZWUAGA5fX3diZ19kaXZfZnJlZQAYD19fd2JnX3dkZHZfZnJlZQAYD19fd2JnX21sZHZfZnJlZQAYDl9fd2JnX21jbF9mcmVlABgOX193YmdfbXVsX2ZyZWUAGA9fX3diZ193ZGFtX2ZyZWUAGA9fX3diZ19jYWxsX2ZyZWUAGA1fX3diZ19sd19mcmVlABgPX193YmdfZWNhbF9mcmVlABgPX193YmdfbWxvZ19mcmVlABgPX193YmdfcmV0ZF9mcmVlABgPX193YmdfdGltZV9mcmVlABgOX193YmdfZ3RmX2ZyZWUAGA5fX3diZ19qbmVfZnJlZQAYDV9fd2JnX29yX2ZyZWUAGA9fX3diZ19kaXZpX2ZyZWUAGA9fX3diZ19qbnpmX2ZyZWUAGA5fX3diZ190cm9fZnJlZQAYDl9fd2JnX21jcF9mcmVlABgPX193YmdfbWludF9mcmVlABgOX193Ymdfc3ViX2ZyZWUAGA1fX3diZ19jYl9mcmVlABgPX193Ymdfd3FvcF9mcmVlABgOX193Ymdfc3J3X2ZyZWUAGA9fX3diZ19lY3IxX2ZyZWUAGA9fX3diZ19qbXBmX2ZyZWUAGA9fX3diZ19rMjU2X2ZyZWUAGA5fX3diZ19yZXRfZnJlZQAYD19fd2JnX3Njd3FfZnJlZQAYDl9fd2JnX21lcV9mcmVlABgPX193Ymdfc3d3cV9mcmVlABgOX193YmdfYmFsX2ZyZWUAGA9fX3diZ19tb3ZpX2ZyZWUAGA9fX3diZ193ZG1kX2ZyZWUAGA9fX3diZ19wb3BsX2ZyZWUAGA9fX3diZ193ZG1tX2ZyZWUAGA5fX3diZ19leHBfZnJlZQAYDV9fd2JnX2ppX2ZyZWUAGA9fX3diZ193cWNtX2ZyZWUAGA9fX3diZ19tY3BpX2ZyZWUAGA9fX3diZ19tb2RpX2ZyZWUAGA1fX3diZ190cl9mcmVlABgPX193YmdfYW5kaV9mcmVlABgOX193YmdfY2NwX2ZyZWUAGA5fX3diZ19zd3dfZnJlZQAYD19fd2JnX2Nyb29fZnJlZQAYD19fd2JnX3dxbWRfZnJlZQAYD19fd2JnX21vdmVfZnJlZQAYD19fd2JnX2VjazFfZnJlZQAYDl9fd2JnX2FuZF9mcmVlABgTd3Fkdl9uZXdfdHlwZXNjcmlwdADKARN3cW1sX25ld190eXBlc2NyaXB0AMoBE3dkbWxfbmV3X3R5cGVzY3JpcHQAygETd3FvcF9uZXdfdHlwZXNjcmlwdADKARN3ZG9wX25ld190eXBlc2NyaXB0AMoBE3dxY21fbmV3X3R5cGVzY3JpcHQAygETd2Rkdl9uZXdfdHlwZXNjcmlwdADKAQ53cWNtX2Zyb21fYXJncwA7CndxZHZfaW1tMDYANgp3cW1sX2ltbTA2ADYKd2RtbF9pbW0wNgA2Cndxb3BfaW1tMDYANgp3ZG9wX2ltbTA2ADYKd3FjbV9pbW0wNgA2CndkZHZfaW1tMDYANgp3ZGNtX2ltbTA2ADYKam5lZl9pbW0wNgA2CWxkY19pbW0wNgA2DndxbWxfZnJvbV9hcmdzADwOd3FvcF9mcm9tX2FyZ3MAOwVnbV9yYQA1BWd0X3JjABoFZ3RfcmIAEgVndF9yYQA1BWxiX3JiABIFbGJfcmEANQVsdF9yYwAaBWx0X3JiABIFbHRfcmEANQhsd19pbW0xMgAJBWx3X3JiABIFbHdfcmEANQVvcl9yYwAaBW9yX3JiABIFb3JfcmEANQhzYl9pbW0xMgAJBXNiX3JiABIFc2JfcmEANQhzd19pbW0xMgAJBXN3X3JiABIFc3dfcmEANQV0cl9yYwAaBXRyX3JiABIFdHJfcmEANQVlcV9yYwAaBWVxX3JiABIFZXFfcmEANQZhbmRfcmMAGgZhbmRfcmIAEgZhbmRfcmEANQZiYWxfcmMAGgZiYWxfcmIAEgZiYWxfcmEANQZjY3BfcmMAGgZjY3BfcmIAEgZjY3BfcmEANQZkaXZfcmMAGgZkaXZfcmIAEgZkaXZfcmEANQZleHBfcmMAGgZleHBfcmIAEgZleHBfcmEANQhsYl9pbW0xMgAJBmd0Zl9yYgASBmd0Zl9yYQA1BmpuZV9yYwAaBmpuZV9yYgASBmpuZV9yYQA1BmxkY19yYwAaBmxkY19yYgASBmxkY19yYQA1BmxvZ19yZAA2BmxvZ19yYwAaBmxvZ19yYgASBmxvZ19yYQA1Bm1jbF9yYgASBm1jbF9yYQA1Bm1jcF9yYwAaBm1jcF9yYgASBm1jcF9yYQA1Bm1lcV9yZAA2Bm1lcV9yYwAaBm1lcV9yYgASBm1lcV9yYQA1Bm1vZF9yYwAaBm1vZF9yYgASBm1vZF9yYQA1Bm11bF9yYwAaBm11bF9yYgASBm11bF9yYQA1Bm5vdF9yYgASBm5vdF9yYQA1CW9yaV9pbW0xMgAJBm9yaV9yYgASBm9yaV9yYQA1BnNsbF9yYwAaBnNsbF9yYgASBnNsbF9yYQA1BnNtb19yZAA2BnNtb19yYwAaBnNtb19yYgASBnNtb19yYQA1BnNybF9yYwAaBnNybF9yYgASBnNybF9yYQA1BnNyd19yYwAaBnNyd19yYgASBnNyd19yYQA1BnN1Yl9yYwAaBnN1Yl9yYgASBnN1Yl9yYQA1BnN3d19yYwAaBnN3d19yYgASBnN3d19yYQA1BnRyb19yZAA2BnRyb19yYwAaBnRyb19yYgASBnRyb19yYQA1Bnhvcl9yYwAaBnhvcl9yYgASBnhvcl9yYQA1CWd0Zl9pbW0xMgAJB2FkZGlfcmIAEgdhZGRpX3JhADUKYW5kaV9pbW0xMgAJB2FuZGlfcmIAEgdhbmRpX3JhADUHYmhzaF9yYgASB2Joc2hfcmEANQZjY3BfcmQANgdibGRkX3JjABoHYmxkZF9yYgASB2JsZGRfcmEANQdic2l6X3JiABIHYnNpel9yYQA1B2J1cm5fcmIAEgdidXJuX3JhADUHY2FsbF9yZAA2B2NhbGxfcmMAGgdjYWxsX3JiABIHY2FsbF9yYQA1B2Nyb29fcmIAEgdjcm9vX3JhADUHY3Npel9yYgASB2NzaXpfcmEANQpkaXZpX2ltbTEyAAkHZGl2aV9yYgASB2RpdmlfcmEANQdlY2FsX3JkADYHZWNhbF9yYwAaB2VjYWxfcmIAEgdlY2FsX3JhADUHZWNrMV9yYwAaB2VjazFfcmIAEgdlY2sxX3JhADUHZWNyMV9yYwAaB2VjcjFfcmIAEgdlY3IxX3JhADUHZWQxOV9yZAA2B2VkMTlfcmMAGgdlZDE5X3JiABIHZWQxOV9yYQA1CmV4cGlfaW1tMTIACQdleHBpX3JiABIHZXhwaV9yYQA1CmptcGJfaW1tMTgADQdqbXBiX3JhADUKam1wZl9pbW0xOAANB2ptcGZfcmEANQdqbmViX3JjABoHam5lYl9yYgASB2puZWJfcmEANQdqbmVmX3JjABoHam5lZl9yYgASB2puZWZfcmEANQpqbmVpX2ltbTEyAAkHam5laV9yYgASB2puZWlfcmEANQpqbnpiX2ltbTEyAAkHam56Yl9yYgASB2puemJfcmEANQpqbnpmX2ltbTEyAAkHam56Zl9yYgASB2puemZfcmEANQpqbnppX2ltbTE4AA0Ham56aV9yYQA1B2syNTZfcmMAGgdrMjU2X3JiABIHazI1Nl9yYQA1B2xvZ2RfcmQANgdsb2dkX3JjABoHbG9nZF9yYgASB2xvZ2RfcmEANQptY2xpX2ltbTE4AA0HbWNsaV9yYQA1Cm1jcGlfaW1tMTIACQdtY3BpX3JiABIHbWNwaV9yYQA1B21pbnRfcmIAEgdtaW50X3JhADUHbWxkdl9yZAA2B21sZHZfcmMAGgdtbGR2X3JiABIHbWxkdl9yYQA1B21sb2dfcmMAGgdtbG9nX3JiABIHbWxvZ19yYQA1Cm1vZGlfaW1tMTIACQdtb2RpX3JiABIHbW9kaV9yYQA1B21vdmVfcmIAEgdtb3ZlX3JhADUKbW92aV9pbW0xOAANB21vdmlfcmEANQdtcm9vX3JjABoHbXJvb19yYgASB21yb29fcmEANQptdWxpX2ltbTEyAAkHbXVsaV9yYgASB211bGlfcmEANQdyZXRkX3JiABIHcmV0ZF9yYQA1B3MyNTZfcmMAGgdzMjU2X3JiABIHczI1Nl9yYQA1B3Njd3FfcmMAGgdzY3dxX3JiABIHc2N3cV9yYQA1CnNsbGlfaW1tMTIACQdzbGxpX3JiABIHc2xsaV9yYQA1CnNybGlfaW1tMTIACQdzcmxpX3JiABIHc3JsaV9yYQA1B3Nyd3FfcmQANgdzcndxX3JjABoHc3J3cV9yYgASB3Nyd3FfcmEANQpzdWJpX2ltbTEyAAkHc3ViaV9yYgASB3N1YmlfcmEANQdzd3dxX3JkADYHc3d3cV9yYwAaB3N3d3FfcmIAEgdzd3dxX3JhADUHdGltZV9yYgASB3RpbWVfcmEANQd3ZGFtX3JkADYHd2RhbV9yYwAaB3dkYW1fcmIAEgd3ZGFtX3JhADUHd2RjbV9yYwAaB3dkY21fcmIAEgd3ZGNtX3JhADUHd2Rkdl9yYwAaB3dkZHZfcmIAEgd3ZGR2X3JhADUHd2RtZF9yZAA2B3dkbWRfcmMAGgd3ZG1kX3JiABIHd2RtZF9yYQA1B3dkbWxfcmMAGgd3ZG1sX3JiABIHd2RtbF9yYQA1B3dkbW1fcmQANgd3ZG1tX3JjABoHd2RtbV9yYgASB3dkbW1fcmEANQd3ZG9wX3JjABoHd2RvcF9yYgASB3dkb3BfcmEANQd3cWFtX3JkADYHd3FhbV9yYwAaB3dxYW1fcmIAEgd3cWFtX3JhADUHd3FjbV9yYwAaB3dxY21fcmIAEgd3cWNtX3JhADUHd3Fkdl9yYwAaB3dxZHZfcmIAEgd3cWR2X3JhADUHd3FtZF9yZAA2B3dxbWRfcmMAGgd3cW1kX3JiABIHd3FtZF9yYQA1B3dxbWxfcmMAGgd3cW1sX3JiABIHd3FtbF9yYQA1B3dxbW1fcmQANgd3cW1tX3JjABoHd3FtbV9y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C0HggsAAQRkQ2AEACykBAX9BEEEEEMYBIgEgADoADCABQQA2AgggAUKBgICAEDcCACABQQhqCykBAX9BEEEEEMYBIgEgADYCDCABQQA2AgggAUKBgICAEDcCACABQQhqCyIAIAIQAiECIAAQxwEgARDHASACEEdBCHRBygByENEBEGgLDwAgACABIAIgA0ESEPEBCw8AIAAgASACIANBGBDxAQsPACAAIAEgAiADQRwQ8QELDwAgACABIAIgA0EdEPEBCw8AIAAgASACIANBIRDyAQsPACAAIAEgAiADQSIQ8QELDwAgACABIAIgA0EjEPEBCw8AIAAgASACIANBKBDxAQsPACAAIAEgAiADQSoQ8QELDwAgACABIAIgA0EsEPEBCw8AIAAgASACIANBLxDxAQsPACAAIAEgAiADQTgQ8QELEAAgACABIAIgA0HTABDyAQsQACAAIAEgAiADQdQAEPIBCxAAIAAgASACIANB3gAQ8gELEAAgACABIAIgA0HfABDyAQsQACAAIAEgAiADQeAAEPIBCxAAIAAgASACIANB4QAQ8gELEAAgACABIAIgA0HiABDyAQsQACAAIAEgAiADQeMAEPIBCxAAIAAgASACIANB5AAQ8gELEAAgACABIAIgA0HlABDyAQsQACAAIAEgAiADQeYAEPEBCxAAIAAgASACIANB5wAQ8QELEAAgACABIAIgA0HoABDxAQsQACAAIAEgAiADQekAEPEBCxAAIAAgASACIANB6gAQ8QELEAAgACABIAIgA0HrABDxAQsQACAAIAEgAiADQewAEPEBCxAAIAAgASACIANB7gAQ8QELHgAgARBmIQEgABDHASABEMQBQQh0QcwAchDRARBoCxkAIAAgASACQSBBACAEG0EQQQAgAxtyECELDQAgACABIAJBARDzAQsNACAAIAEgAkECEPMBCw0AIAAgASACQQMQ8wELDQAgACABIAJBBBDzAQsNACAAIAEgAkEFEPMBCw0AIAAgASACQQYQ8wELDQAgACABIAJBBxDzAQsNACAAIAEgAkEIEPMBCw0AIAAgASACQQkQ8wELDQAgACABIAJBCxDzAQsNACAAIAEgAkENEPMBCw0AIAAgASACQQ4Q8wELDQAgACABIAJBDxDzAQsNACAAIAEgAkEQEPMBCw0AIAAgASACQREQ8wELDQAgACABIAJBFxDzAQsNACAAIAEgAkEmEPMBCw0AIAAgASACQScQ8wELDQAgACABIAJBKRDzAQsNACAAIAEgAkErEPMBCw0AIAAgASACQS0Q8wELDQAgACABIAJBLhDzAQsNACAAIAEgAkEwEPMBCw0AIAAgASACQTEQ8wELDQAgACABIAJBNRDzAQsNACAAIAEgAkE3EPMBCw0AIAAgASACQTkQ9AELDQAgACABIAJBOhD0AQsNACAAIAEgAkE7EPQBCw0AIAAgASACQTwQ9AELDQAgACABIAJBPRD0AQsNACAAIAEgAkE+EPQBCw0AIAAgASACQT8Q9AELDgAgACABIAJBwAAQ9AELDgAgACABIAJBwQAQ9AELDgAgACABIAJBwgAQ9AELDgAgACABIAJBwwAQ9AELDgAgACABIAJBxAAQ9AELDgAgACABIAJBxQAQ9AELDgAgACABIAJBxgAQ9AELDgAgACABIAJBxwAQ9AELDgAgACABIAJByAAQ9AELDgAgACABIAJByQAQ9AELDgAgACABIAJBygAQ9AELDgAgACABIAJB0QAQ9AELDgAgACABIAJB0gAQ9AELFwEBfyAAQf8BcUE/TQR/IAAQZwVBAAsLGwAgABDQASAAKAIAQX9GBEAQ1wEACyAALQAECwkAIABBExD1AQsJACAAQRUQ9QELCQAgAEEaEPUBCwkAIABBIBD1AQsJACAAQSUQ9QELIgEBf0EQQQQQxgEiAEIANwIIIABCgYCAgBA3AgAgAEEIagsJACAAQTQQ9QELCQAgAEE2EPUBCwoAIABB2AAQ9QELCgAgAEHZABD1AQsXACABQRB0QYCA/ANxIABBAnRB/AFxcgsbACAAEMcBIAEQxwEgAhDHARA6QQh0ENEBEGgLEgAgASAAENMBIgAEQCAADwsAC3UBAX8gAEH/AXFBwABPBEAjAEEQayIBJAAgAUEiNgIMIAFBgIDAADYCCCMAQSBrIgAkACAAQQE2AgQgAEH0hsAANgIAIABCATcCDCAAIAFBCGqtQoCAgIDAAIQ3AxggACAAQRhqNgIIIABBuIDAABBXAAsgAAsUACAAIAEgAkEgQQAgAxsgBHIQIQsXACAAEBsgARAbIAIQGyADEBYQzgEQYgsWACAAEBsgARAbIAIQGyADEBsQIRBiCxMAIAAgACgCAEEBazYCACABEF4LEwAgACAAKAIAQQFrNgIAIAEQXwsSACAAEBsgARAbIAIQAhBHEGILEQAgACABIAJBIEEAIAMbECELEgAgABAbIAEQGyACEB0QRxBiCxMAIAAEQA8LQdSKwABBGxDYAQALFAEBf0EEQQEQxgEiASAANgAAIAELDQAgAQRAIAAgARAZCwuBAwEFf0GRj8AALQAAGgJ/IABBCU8EQAJAQc3/e0EQIAAgAEEQTRsiAGsgAU0NACAAQRAgAUELakF4cSABQQtJGyIEakEMahABIgJFDQAgAkEIayEBAkAgAEEBayIDIAJxRQRAIAEhAAwBCyACQQRrIgUoAgAiBkF4cSACIANqQQAgAGtxQQhrIgIgAEEAIAIgAWtBEE0baiIAIAFrIgJrIQMgBkEDcQRAIAAgAyAAKAIEQQFxckECcjYCBCAAIANqIgMgAygCBEEBcjYCBCAFIAIgBSgCAEEBcXJBAnI2AgAgASACaiIDIAMoAgRBAXI2AgQgASACEAMMAQsgASgCACEBIAAgAzYCBCAAIAEgAmo2AgALAkAgACgCBCIBQQNxRQ0AIAFBeHEiAiAEQRBqTQ0AIAAgBCABQQFxckECcjYCBCAAIARqIgEgAiAEayIEQQNyNgIEIAAgAmoiAiACKAIEQQFyNgIEIAEgBBADCyAAQQhqIQMLIAMMAQsgARABCwsNACAAENwBQQp2QT9xCw8AIAAQGyABEGYQxAEQYgsLACAAIwBqJAAjAAsOAEHvisAAQc8AENgBAAsJACAAIAEQAAALCQAgAEE/cRBnCwoAIAAQG0H/AXELCAAgAEEEEBkLBwAgAEEIdAsJAEEzENEBEGgLBgBBCxBnCwYAQQoQZwsGAEEIEGcLBgBBDxBnCwYAQQYQZwsGAEEJEGcLBgBBBxBnCwYAQQwQZwsGAEECEGcLBgBBARBnCwYAQQMQZwsGAEENEGcLBgBBDhBnCwYAQQUQZwsGAEEEEGcLBgBBEBBnCwYAQQAQZwsEAEEECzMBAX8gACAAKAIAQQFrIgI2AgACQCACDQAgACAAKAIEQQFrIgI2AgQgAg0AIAAgARAZCwsjACAAEMcBIAEQxwEgAhDHASADEMcBECFBCHQgBHIQ0QEQaAsiACAAEMcBIAEQxwEgAhDHASADEA4QIUEIdCAEchDRARBoCx4AIAAQxwEgARDHASACEMcBEDpBCHQgA3IQ0QEQaAsdACAAEMcBIAEQxwEgAhAPEEdBCHQgA3IQ0QEQaAsaACAAEMcBGiAAQQp0QYD4A3EgAXIQ0QEQaAtfAQF/IwBBMGsiBCQAIAQgADYCDCAAIANPBEAgBEECNgIUIAQgAjYCECAEQgE3AhwgBEEDNgIsIAQgBEEoajYCGCAEIARBDGo2AiggBEEQaiABEFcACyAEQTBqJAAgAAtMAQJ/IwBBEGsiBSQAIAVBCGogAxALIAUtAAkhAyAFLQAIIQYgABDHASABEMcBIAIQxwEgBiADEMgBQQh0IARyENEBEGggBUEQaiQAC0wBAn8jAEEQayIFJAAgBUEIaiADEAggBS0ACSEDIAUtAAghBiAAEMcBIAEQxwEgAhDHASAGIAMQiQFBCHQgBHIQ0QEQaCAFQRBqJAALSQAgABDHARogARDHARogAEESdEGAgPAXcSIAIAFBDHRBgOA/cXIiAUGA4ANxQQh0IAFBCHZBgP4DcSAAIAJyQRh2cnIQ0QEQaAtJACAAEMcBGiABEBMiAUEQdEGAgPwHcSAAQRJ0QYCA8B9xIAFyIgBBgP4DcUEIdCAAQQh2QYD+A3FyQQh2ckEIdCACchDRARBoC0kBAX8jAEEQayIDJAAgABDQASABIAJPBEBB4ILAAEEZENgBAAsgA0EIaiAAEGEgAygCDCADKAIIIAE6AAFBADYCACADQRBqJAALQQAgABDHARogARDHARogAEESdEGAgPAHcSABQQx0QYDgP3FyIgBBCHZBgP4DcSAAQYDgA3FBCHRyIAJyENEBEGgLNQAgABAUIgBBEHRBgID8B3EgAEEIdkGA/gNxIABBgP4DcUEIdHJBCHZyQQh0IAFyENEBEGgLC8gLAQBBgIDAAAu+C0NoZWNrUmVnSWQgd2FzIGdpdmVuIGludmFsaWQgUmVnSWRmdWVsLWFzbS9zcmMvbGliLnJzAAAAIgAQABMAAABuAAAAIgAAAFZhbHVlIGBgIG91dCBvZiByYW5nZSBmb3IgNi1iaXQgaW1tZWRpYXRlAAAASAAQAAcAAABPABAAIgAAACIAEAATAAAAsAMAABwAAABgIG91dCBvZiByYW5nZSBmb3IgMTItYml0IGltbWVkaWF0ZQBIABAABwAAAJQAEAAjAAAAIgAQABMAAAC1AwAAHAAAAGAgb3V0IG9mIHJhbmdlIGZvciAxOC1iaXQgaW1tZWRpYXRlAEgAEAAHAAAA2AAQACMAAAAiABAAEwAAALoDAAAcAAAAYCBvdXQgb2YgcmFuZ2UgZm9yIDI0LWJpdCBpbW1lZGlhdGUASAAQAAcAAAAcARAAIwAAACIAEAATAAAAvwMAABwAAABpbnZhbGlkIGVudW0gdmFsdWUgcGFzc2VkYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAQQAAAEIAAABDAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAAUAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAFoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAABhAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAJAAAACRAAAAkgAAAJMAAACUAAAAlQAAAJYAAACXAAAAmAAAAKAAAAChAAAAogAAAKMAAACkAAAApQAAAKYAAACnAAAAqAAAAKkAAACqAAAAqwAAAKwAAACtAAAAsAAAALoAAAC7AAAAAQAAAAAAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAAUAAAAAAAAAAQAAAAYAAAAwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OS9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZACABBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAgAQQACkAAACuBAAADQAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnMoBRAAHAAAAIsCAAAeAAAAbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAA7CXByb2R1Y2VycwEMcHJvY2Vzc2VkLWJ5AgZ3YWxydXMGMC4yMS4zDHdhc20tYmluZGdlbgYwLjIuOTM=', imports)}

async function initWasm () {
  return await __wbg_init(wasm());
}

/**
 * calling it right away for pre-caching
 * the wasm async initialization at startup
 */
initWasm();

exports.ADD = ADD;
exports.ADDI = ADDI;
exports.ALOC = ALOC;
exports.AND = AND;
exports.ANDI = ANDI;
exports.BAL = BAL;
exports.BHEI = BHEI;
exports.BHSH = BHSH;
exports.BLDD = BLDD;
exports.BSIZ = BSIZ;
exports.BURN = BURN;
exports.CALL = CALL;
exports.CB = CB;
exports.CCP = CCP;
exports.CFE = CFE;
exports.CFEI = CFEI;
exports.CFS = CFS;
exports.CFSI = CFSI;
exports.CROO = CROO;
exports.CSIZ = CSIZ;
exports.CompareArgs = CompareArgs;
exports.CompareMode = CompareMode;
exports.DIV = DIV;
exports.DIVI = DIVI;
exports.DivArgs = DivArgs;
exports.ECAL = ECAL;
exports.ECK1 = ECK1;
exports.ECR1 = ECR1;
exports.ED19 = ED19;
exports.EQ = EQ;
exports.EXP = EXP;
exports.EXPI = EXPI;
exports.FLAG = FLAG;
exports.GM = GM;
exports.GMArgs = GMArgs;
exports.GT = GT;
exports.GTF = GTF;
exports.GTFArgs = GTFArgs;
exports.Imm06 = Imm06;
exports.Imm12 = Imm12;
exports.Imm18 = Imm18;
exports.Imm24 = Imm24;
exports.Instruction = Instruction;
exports.JI = JI;
exports.JMP = JMP;
exports.JMPB = JMPB;
exports.JMPF = JMPF;
exports.JNE = JNE;
exports.JNEB = JNEB;
exports.JNEF = JNEF;
exports.JNEI = JNEI;
exports.JNZB = JNZB;
exports.JNZF = JNZF;
exports.JNZI = JNZI;
exports.K256 = K256;
exports.LB = LB;
exports.LDC = LDC;
exports.LOG = LOG;
exports.LOGD = LOGD;
exports.LT = LT;
exports.LW = LW;
exports.MCL = MCL;
exports.MCLI = MCLI;
exports.MCP = MCP;
exports.MCPI = MCPI;
exports.MEQ = MEQ;
exports.MINT = MINT;
exports.MLDV = MLDV;
exports.MLOG = MLOG;
exports.MOD = MOD;
exports.MODI = MODI;
exports.MOVE = MOVE;
exports.MOVI = MOVI;
exports.MROO = MROO;
exports.MUL = MUL;
exports.MULI = MULI;
exports.MathArgs = MathArgs;
exports.MathOp = MathOp;
exports.MulArgs = MulArgs;
exports.NOOP = NOOP;
exports.NOT = NOT;
exports.OR = OR;
exports.ORI = ORI;
exports.POPH = POPH;
exports.POPL = POPL;
exports.PSHH = PSHH;
exports.PSHL = PSHL;
exports.PanicInstruction = PanicInstruction;
exports.PanicReason = PanicReason;
exports.RET = RET;
exports.RETD = RETD;
exports.RVRT = RVRT;
exports.RegId = RegId;
exports.S256 = S256;
exports.SB = SB;
exports.SCWQ = SCWQ;
exports.SLL = SLL;
exports.SLLI = SLLI;
exports.SMO = SMO;
exports.SRL = SRL;
exports.SRLI = SRLI;
exports.SRW = SRW;
exports.SRWQ = SRWQ;
exports.SUB = SUB;
exports.SUBI = SUBI;
exports.SW = SW;
exports.SWW = SWW;
exports.SWWQ = SWWQ;
exports.TIME = TIME;
exports.TR = TR;
exports.TRO = TRO;
exports.WDAM = WDAM;
exports.WDCM = WDCM;
exports.WDDV = WDDV;
exports.WDMD = WDMD;
exports.WDML = WDML;
exports.WDMM = WDMM;
exports.WDOP = WDOP;
exports.WQAM = WQAM;
exports.WQCM = WQCM;
exports.WQDV = WQDV;
exports.WQMD = WQMD;
exports.WQML = WQML;
exports.WQMM = WQMM;
exports.WQOP = WQOP;
exports.XOR = XOR;
exports.XORI = XORI;
exports.add = add;
exports.addi = addi;
exports.aloc = aloc;
exports.and = and;
exports.andi = andi;
exports.bal = bal;
exports.bhei = bhei;
exports.bhsh = bhsh;
exports.bldd = bldd;
exports.bsiz = bsiz;
exports.burn = burn;
exports.call = call;
exports.cb = cb;
exports.ccp = ccp;
exports.cfe = cfe;
exports.cfei = cfei;
exports.cfs = cfs;
exports.cfsi = cfsi;
exports.croo = croo;
exports.csiz = csiz;
exports.div = div;
exports.divi = divi;
exports.ecal = ecal;
exports.eck1 = eck1;
exports.ecr1 = ecr1;
exports.ed19 = ed19;
exports.eq = eq;
exports.exp = exp;
exports.expi = expi;
exports.flag = flag;
exports.gm = gm;
exports.gm_args = gm_args;
exports.gt = gt;
exports.gtf = gtf;
exports.gtf_args = gtf_args;
exports.initSync = initSync;
exports.initWasm = initWasm;
exports.ji = ji;
exports.jmp = jmp;
exports.jmpb = jmpb;
exports.jmpf = jmpf;
exports.jne = jne;
exports.jneb = jneb;
exports.jnef = jnef;
exports.jnei = jnei;
exports.jnzb = jnzb;
exports.jnzf = jnzf;
exports.jnzi = jnzi;
exports.k256 = k256;
exports.lb = lb;
exports.ldc = ldc;
exports.log = log;
exports.logd = logd;
exports.lt = lt;
exports.lw = lw;
exports.mcl = mcl;
exports.mcli = mcli;
exports.mcp = mcp;
exports.mcpi = mcpi;
exports.meq = meq;
exports.mint = mint;
exports.mldv = mldv;
exports.mlog = mlog;
exports.mod_ = mod_;
exports.modi = modi;
exports.move_ = move_;
exports.movi = movi;
exports.mroo = mroo;
exports.mul = mul;
exports.muli = muli;
exports.noop = noop;
exports.not = not;
exports.or = or;
exports.ori = ori;
exports.poph = poph;
exports.popl = popl;
exports.pshh = pshh;
exports.pshl = pshl;
exports.ret = ret;
exports.retd = retd;
exports.rvrt = rvrt;
exports.s256 = s256;
exports.sb = sb;
exports.scwq = scwq;
exports.sll = sll;
exports.slli = slli;
exports.smo = smo;
exports.srl = srl;
exports.srli = srli;
exports.srw = srw;
exports.srwq = srwq;
exports.sub = sub;
exports.subi = subi;
exports.sw = sw;
exports.sww = sww;
exports.swwq = swwq;
exports.time = time;
exports.tr = tr;
exports.tro = tro;
exports.wdam = wdam;
exports.wdcm = wdcm;
exports.wdcm_args = wdcm_args;
exports.wddv = wddv;
exports.wddv_args = wddv_args;
exports.wdmd = wdmd;
exports.wdml = wdml;
exports.wdml_args = wdml_args;
exports.wdmm = wdmm;
exports.wdop = wdop;
exports.wdop_args = wdop_args;
exports.wqam = wqam;
exports.wqcm = wqcm;
exports.wqcm_args = wqcm_args;
exports.wqdv = wqdv;
exports.wqdv_args = wqdv_args;
exports.wqmd = wqmd;
exports.wqml = wqml;
exports.wqml_args = wqml_args;
exports.wqmm = wqmm;
exports.wqop = wqop;
exports.wqop_args = wqop_args;
exports.xor = xor;
exports.xori = xori;
