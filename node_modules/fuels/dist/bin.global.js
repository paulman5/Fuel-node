"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require2 = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require3() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter2) => {
    __accessCheck(obj, member, "read from private field");
    return getter2 ? getter2.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };

  // ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports, module) {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert2 = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      module.exports = convert2;
      for (const model of Object.keys(convert2)) {
        if (!("channels" in convert2[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert2[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert2[model].labels.length !== convert2[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const { channels, labels } = convert2[model];
        delete convert2[model].channels;
        delete convert2[model].labels;
        Object.defineProperty(convert2[model], "channels", { value: channels });
        Object.defineProperty(convert2[model], "labels", { value: labels });
      }
      convert2.rgb.hsl = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const min = Math.min(r, g, b);
        const max2 = Math.max(r, g, b);
        const delta = max2 - min;
        let h;
        let s;
        if (max2 === min) {
          h = 0;
        } else if (r === max2) {
          h = (g - b) / delta;
        } else if (g === max2) {
          h = 2 + (b - r) / delta;
        } else if (b === max2) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        const l = (min + max2) / 2;
        if (max2 === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max2 + min);
        } else {
          s = delta / (2 - max2 - min);
        }
        return [h, s * 100, l * 100];
      };
      convert2.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h;
        let s;
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const v = Math.max(r, g, b);
        const diff = v - Math.min(r, g, b);
        const diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = 0;
          s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert2.rgb.hwb = function(rgb) {
        const r = rgb[0];
        const g = rgb[1];
        let b = rgb[2];
        const h = convert2.rgb.hsl(rgb)[0];
        const w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert2.rgb.cmyk = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const k = Math.min(1 - r, 1 - g, 1 - b);
        const c = (1 - r - k) / (1 - k) || 0;
        const m = (1 - g - k) / (1 - k) || 0;
        const y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
      }
      convert2.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert2.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert2.rgb.xyz = function(rgb) {
        let r = rgb[0] / 255;
        let g = rgb[1] / 255;
        let b = rgb[2] / 255;
        r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
        g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
        b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert2.rgb.lab = function(rgb) {
        const xyz = convert2.rgb.xyz(rgb);
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.hsl.rgb = function(hsl) {
        const h = hsl[0] / 360;
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        const t1 = 2 * l - t2;
        const rgb = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert2.hsl.hsv = function(hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100;
        let l = hsl[2] / 100;
        let smin = s;
        const lmin = Math.max(l, 0.01);
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v = (l + s) / 2;
        const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert2.hsv.rgb = function(hsv) {
        const h = hsv[0] / 60;
        const s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6;
        const f2 = h - Math.floor(h);
        const p = 255 * v * (1 - s);
        const q = 255 * v * (1 - s * f2);
        const t = 255 * v * (1 - s * (1 - f2));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t];
          case 3:
            return [p, q, v];
          case 4:
            return [t, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert2.hsv.hsl = function(hsv) {
        const h = hsv[0];
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const vmin = Math.max(v, 0.01);
        let sl;
        let l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert2.hwb.rgb = function(hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f2;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i = Math.floor(6 * h);
        const v = 1 - bl;
        f2 = 6 * h - i;
        if ((i & 1) !== 0) {
          f2 = 1 - f2;
        }
        const n = wh + f2 * (v - wh);
        let r;
        let g;
        let b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert2.cmyk.rgb = function(cmyk) {
        const c = cmyk[0] / 100;
        const m = cmyk[1] / 100;
        const y = cmyk[2] / 100;
        const k = cmyk[3] / 100;
        const r = 1 - Math.min(1, c * (1 - k) + k);
        const g = 1 - Math.min(1, m * (1 - k) + k);
        const b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.rgb = function(xyz) {
        const x = xyz[0] / 100;
        const y = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r;
        let g;
        let b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.lab = function(xyz) {
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.lab.xyz = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let x;
        let y;
        let z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        const y2 = y ** 3;
        const x2 = x ** 3;
        const z2 = z ** 3;
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert2.lab.lch = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let h;
        const hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        const c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert2.lch.lab = function(lch) {
        const l = lch[0];
        const c = lch[1];
        const h = lch[2];
        const hr = h / 360 * 2 * Math.PI;
        const a = c * Math.cos(hr);
        const b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert2.rgb.ansi16 = function(args, saturation = null) {
        const [r, g, b] = args;
        let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert2.hsv.ansi16 = function(args) {
        return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
      };
      convert2.rgb.ansi256 = function(args) {
        const r = args[0];
        const g = args[1];
        const b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert2.ansi16.rgb = function(args) {
        let color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r = (color & 1) * mult * 255;
        const g = (color >> 1 & 1) * mult * 255;
        const b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert2.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        let rem;
        const r = Math.floor(args / 36) / 5 * 255;
        const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        const b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert2.rgb.hex = function(args) {
        const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string2 = integer.toString(16).toUpperCase();
        return "000000".substring(string2.length) + string2;
      };
      convert2.hex.rgb = function(args) {
        const match3 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match3) {
          return [0, 0, 0];
        }
        let colorString = match3[0];
        if (match3[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r = integer >> 16 & 255;
        const g = integer >> 8 & 255;
        const b = integer & 255;
        return [r, g, b];
      };
      convert2.rgb.hcg = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const max2 = Math.max(Math.max(r, g), b);
        const min = Math.min(Math.min(r, g), b);
        const chroma = max2 - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max2 === r) {
          hue = (g - b) / chroma % 6;
        } else if (max2 === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert2.hsl.hcg = function(hsl) {
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
        let f2 = 0;
        if (c < 1) {
          f2 = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f2 * 100];
      };
      convert2.hsv.hcg = function(hsv) {
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const c = s * v;
        let f2 = 0;
        if (c < 1) {
          f2 = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f2 * 100];
      };
      convert2.hcg.rgb = function(hcg) {
        const h = hcg[0] / 360;
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        const pure = [0, 0, 0];
        const hi = h % 1 * 6;
        const v = hi % 1;
        const w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert2.hcg.hsv = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        let f2 = 0;
        if (v > 0) {
          f2 = c / v;
        }
        return [hcg[0], f2 * 100, v * 100];
      };
      convert2.hcg.hsl = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const l = g * (1 - c) + 0.5 * c;
        let s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert2.hcg.hwb = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert2.hwb.hcg = function(hwb) {
        const w = hwb[1] / 100;
        const b = hwb[2] / 100;
        const v = 1 - b;
        const c = v - w;
        let g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert2.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert2.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert2.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert2.gray.hsl = function(args) {
        return [0, 0, args[0]];
      };
      convert2.gray.hsv = convert2.gray.hsl;
      convert2.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert2.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert2.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert2.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string2 = integer.toString(16).toUpperCase();
        return "000000".substring(string2.length) + string2;
      };
      convert2.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
  var require_route = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports, module) {
      var conversions = require_conversions();
      function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i = 0; i < len; i++) {
            const adjacent = adjacents[i];
            const node2 = graph[adjacent];
            if (node2.distance === -1) {
              node2.distance = graph[current].distance + 1;
              node2.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph) {
        const path6 = [graph[toModel].parent, toModel];
        let fn = conversions[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path6.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path6;
        return fn;
      }
      module.exports = function(fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i = 0; i < len; i++) {
          const toModel = models[i];
          const node2 = graph[toModel];
          if (node2.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports, module) {
      var conversions = require_conversions();
      var route = require_route();
      var convert2 = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          const result = fn(args);
          if (typeof result === "object") {
            for (let len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach((fromModel) => {
        convert2[fromModel] = {};
        Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert2[fromModel][toModel] = wrapRounded(fn);
          convert2[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert2;
    }
  });

  // ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
  var require_ansi_styles = __commonJS({
    "../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports, module) {
      "use strict";
      var wrapAnsi16 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `\x1B[${code + offset}m`;
      };
      var wrapAnsi256 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `\x1B[${38 + offset};5;${code}m`;
      };
      var wrapAnsi16m = (fn, offset) => (...args) => {
        const rgb = fn(...args);
        return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      var ansi2ansi = (n) => n;
      var rgb2rgb = (r, g, b) => [r, g, b];
      var setLazyProperty = (object2, property, get) => {
        Object.defineProperty(object2, property, {
          get: () => {
            const value = get();
            Object.defineProperty(object2, property, {
              value,
              enumerable: true,
              configurable: true
            });
            return value;
          },
          enumerable: true,
          configurable: true
        });
      };
      var colorConvert;
      var makeDynamicStyles = (wrap3, targetSpace, identity2, isBackground) => {
        if (colorConvert === void 0) {
          colorConvert = require_color_convert();
        }
        const offset = isBackground ? 10 : 0;
        const styles = {};
        for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
          const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
          if (sourceSpace === targetSpace) {
            styles[name] = wrap3(identity2, offset);
          } else if (typeof suite === "object") {
            styles[name] = wrap3(suite[targetSpace], offset);
          }
        }
        return styles;
      };
      function assembleStyles() {
        const codes3 = /* @__PURE__ */ new Map();
        const styles = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            // Bright color
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.gray = styles.color.blackBright;
        styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
        styles.color.grey = styles.color.blackBright;
        styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles)) {
          for (const [styleName, style] of Object.entries(group)) {
            styles[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes3.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
          });
        }
        Object.defineProperty(styles, "codes", {
          value: codes3,
          enumerable: false
        });
        styles.color.close = "\x1B[39m";
        styles.bgColor.close = "\x1B[49m";
        setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
        setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
        return styles;
      }
      Object.defineProperty(module, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    }
  });

  // ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
  var require_has_flag = __commonJS({
    "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module) {
      "use strict";
      module.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    }
  });

  // ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
  var require_supports_color = __commonJS({
    "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
      "use strict";
      var os2 = __require2("os");
      var tty = __require2("tty");
      var hasFlag = require_has_flag();
      var { env } = process;
      var forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        forceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = 1;
      }
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min = forceColor || 0;
        if (env.TERM === "dumb") {
          return min;
        }
        if (process.platform === "win32") {
          const osRelease = os2.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version3 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        return min;
      }
      function getSupportLevel(stream2) {
        const level = supportsColor(stream2, stream2 && stream2.isTTY);
        return translateLevel(level);
      }
      module.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel(supportsColor(true, tty.isatty(1))),
        stderr: translateLevel(supportsColor(true, tty.isatty(2)))
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/util.js
  var require_util = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/util.js"(exports, module) {
      "use strict";
      var stringReplaceAll = (string2, substring, replacer) => {
        let index = string2.indexOf(substring);
        if (index === -1) {
          return string2;
        }
        const substringLength = substring.length;
        let endIndex = 0;
        let returnValue = "";
        do {
          returnValue += string2.substr(endIndex, index - endIndex) + substring + replacer;
          endIndex = index + substringLength;
          index = string2.indexOf(substring, endIndex);
        } while (index !== -1);
        returnValue += string2.substr(endIndex);
        return returnValue;
      };
      var stringEncaseCRLFWithFirstIndex = (string2, prefix, postfix, index) => {
        let endIndex = 0;
        let returnValue = "";
        do {
          const gotCR = string2[index - 1] === "\r";
          returnValue += string2.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
          endIndex = index + 1;
          index = string2.indexOf("\n", endIndex);
        } while (index !== -1);
        returnValue += string2.substr(endIndex);
        return returnValue;
      };
      module.exports = {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/templates.js
  var require_templates = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/templates.js"(exports, module) {
      "use strict";
      var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = /* @__PURE__ */ new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", "\x1B"],
        ["a", "\x07"]
      ]);
      function unescape2(c) {
        const u = c[0] === "u";
        const bracket = c[1] === "{";
        if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        if (u && bracket) {
          return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      function parseArguments(name, arguments_) {
        const results = [];
        const chunks = arguments_.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          const number3 = Number(chunk);
          if (!Number.isNaN(number3)) {
            results.push(number3);
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
          }
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1];
          if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([name].concat(args));
          } else {
            results.push([name]);
          }
        }
        return results;
      }
      function buildStyle(chalk4, styles) {
        const enabled = {};
        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk4;
        for (const [styleName, styles2] of Object.entries(enabled)) {
          if (!Array.isArray(styles2)) {
            continue;
          }
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
        }
        return current;
      }
      module.exports = (chalk4, temporary) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
          if (escapeCharacter) {
            chunk.push(unescape2(escapeCharacter));
          } else if (style) {
            const string2 = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? string2 : buildStyle(chalk4, styles)(string2));
            styles.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk4, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
          } else {
            chunk.push(character);
          }
        });
        chunks.push(chunk.join(""));
        if (styles.length > 0) {
          const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMessage);
        }
        return chunks.join("");
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/index.js
  var require_source = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/index.js"(exports, module) {
      "use strict";
      var ansiStyles = require_ansi_styles();
      var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
      var {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      } = require_util();
      var levelMapping = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
      ];
      var styles = /* @__PURE__ */ Object.create(null);
      var applyOptions = (object2, options = {}) => {
        if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
          throw new Error("The `level` option should be an integer from 0 to 3");
        }
        const colorLevel = stdoutColor ? stdoutColor.level : 0;
        object2.level = options.level === void 0 ? colorLevel : options.level;
      };
      var ChalkClass = class {
        constructor(options) {
          return chalkFactory(options);
        }
      };
      var chalkFactory = (options) => {
        const chalk5 = {};
        applyOptions(chalk5, options);
        chalk5.template = (...arguments_) => chalkTag(chalk5.template, ...arguments_);
        Object.setPrototypeOf(chalk5, Chalk.prototype);
        Object.setPrototypeOf(chalk5.template, chalk5);
        chalk5.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        };
        chalk5.template.Instance = ChalkClass;
        return chalk5.template;
      };
      function Chalk(options) {
        return chalkFactory(options);
      }
      for (const [styleName, style] of Object.entries(ansiStyles)) {
        styles[styleName] = {
          get() {
            const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
            Object.defineProperty(this, styleName, { value: builder });
            return builder;
          }
        };
      }
      styles.visible = {
        get() {
          const builder = createBuilder(this, this._styler, true);
          Object.defineProperty(this, "visible", { value: builder });
          return builder;
        }
      };
      var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const model of usedModels) {
        styles[model] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      for (const model of usedModels) {
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      var proto = Object.defineProperties(() => {
      }, {
        ...styles,
        level: {
          enumerable: true,
          get() {
            return this._generator.level;
          },
          set(level) {
            this._generator.level = level;
          }
        }
      });
      var createStyler = (open, close, parent) => {
        let openAll;
        let closeAll;
        if (parent === void 0) {
          openAll = open;
          closeAll = close;
        } else {
          openAll = parent.openAll + open;
          closeAll = close + parent.closeAll;
        }
        return {
          open,
          close,
          openAll,
          closeAll,
          parent
        };
      };
      var createBuilder = (self2, _styler, _isEmpty) => {
        const builder = (...arguments_) => {
          return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
        };
        Object.setPrototypeOf(builder, proto);
        builder._generator = self2;
        builder._styler = _styler;
        builder._isEmpty = _isEmpty;
        return builder;
      };
      var applyStyle = (self2, string2) => {
        if (self2.level <= 0 || !string2) {
          return self2._isEmpty ? "" : string2;
        }
        let styler = self2._styler;
        if (styler === void 0) {
          return string2;
        }
        const { openAll, closeAll } = styler;
        if (string2.indexOf("\x1B") !== -1) {
          while (styler !== void 0) {
            string2 = stringReplaceAll(string2, styler.close, styler.open);
            styler = styler.parent;
          }
        }
        const lfIndex = string2.indexOf("\n");
        if (lfIndex !== -1) {
          string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
        }
        return openAll + string2 + closeAll;
      };
      var template;
      var chalkTag = (chalk5, ...strings) => {
        const [firstString] = strings;
        if (!Array.isArray(firstString)) {
          return strings.join(" ");
        }
        const arguments_ = strings.slice(1);
        const parts = [firstString.raw[0]];
        for (let i = 1; i < firstString.length; i++) {
          parts.push(
            String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
            String(firstString.raw[i])
          );
        }
        if (template === void 0) {
          template = require_templates();
        }
        return template(chalk5, parts.join(""));
      };
      Object.defineProperties(Chalk.prototype, styles);
      var chalk4 = Chalk();
      chalk4.supportsColor = stdoutColor;
      chalk4.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
      chalk4.stderr.supportsColor = stderrColor;
      module.exports = chalk4;
    }
  });

  // ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js
  var require_error = __commonJS({
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/error.js"(exports) {
      var CommanderError2 = class extends Error {
        /**
         * Constructs the CommanderError class
         * @param {number} exitCode suggested exit code which could be used with process.exit
         * @param {string} code an id string representing the error
         * @param {string} message human-readable description of the error
         */
        constructor(exitCode, code, message) {
          super(message);
          Error.captureStackTrace(this, this.constructor);
          this.name = this.constructor.name;
          this.code = code;
          this.exitCode = exitCode;
          this.nestedError = void 0;
        }
      };
      var InvalidArgumentError2 = class extends CommanderError2 {
        /**
         * Constructs the InvalidArgumentError class
         * @param {string} [message] explanation of why argument is invalid
         */
        constructor(message) {
          super(1, "commander.invalidArgument", message);
          Error.captureStackTrace(this, this.constructor);
          this.name = this.constructor.name;
        }
      };
      exports.CommanderError = CommanderError2;
      exports.InvalidArgumentError = InvalidArgumentError2;
    }
  });

  // ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/argument.js
  var require_argument = __commonJS({
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/argument.js"(exports) {
      var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var Argument2 = class {
        /**
         * Initialize a new command argument with the given name and description.
         * The default is that the argument is required, and you can explicitly
         * indicate this with <> around the name. Put [] around the name for an optional argument.
         *
         * @param {string} name
         * @param {string} [description]
         */
        constructor(name, description) {
          this.description = description || "";
          this.variadic = false;
          this.parseArg = void 0;
          this.defaultValue = void 0;
          this.defaultValueDescription = void 0;
          this.argChoices = void 0;
          switch (name[0]) {
            case "<":
              this.required = true;
              this._name = name.slice(1, -1);
              break;
            case "[":
              this.required = false;
              this._name = name.slice(1, -1);
              break;
            default:
              this.required = true;
              this._name = name;
              break;
          }
          if (this._name.length > 3 && this._name.slice(-3) === "...") {
            this.variadic = true;
            this._name = this._name.slice(0, -3);
          }
        }
        /**
         * Return argument name.
         *
         * @return {string}
         */
        name() {
          return this._name;
        }
        /**
         * @package
         */
        _concatValue(value, previous) {
          if (previous === this.defaultValue || !Array.isArray(previous)) {
            return [value];
          }
          return previous.concat(value);
        }
        /**
         * Set the default value, and optionally supply the description to be displayed in the help.
         *
         * @param {*} value
         * @param {string} [description]
         * @return {Argument}
         */
        default(value, description) {
          this.defaultValue = value;
          this.defaultValueDescription = description;
          return this;
        }
        /**
         * Set the custom handler for processing CLI command arguments into argument values.
         *
         * @param {Function} [fn]
         * @return {Argument}
         */
        argParser(fn) {
          this.parseArg = fn;
          return this;
        }
        /**
         * Only allow argument value to be one of choices.
         *
         * @param {string[]} values
         * @return {Argument}
         */
        choices(values) {
          this.argChoices = values.slice();
          this.parseArg = (arg, previous) => {
            if (!this.argChoices.includes(arg)) {
              throw new InvalidArgumentError2(
                `Allowed choices are ${this.argChoices.join(", ")}.`
              );
            }
            if (this.variadic) {
              return this._concatValue(arg, previous);
            }
            return arg;
          };
          return this;
        }
        /**
         * Make argument required.
         *
         * @returns {Argument}
         */
        argRequired() {
          this.required = true;
          return this;
        }
        /**
         * Make argument optional.
         *
         * @returns {Argument}
         */
        argOptional() {
          this.required = false;
          return this;
        }
      };
      function humanReadableArgName(arg) {
        const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
        return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
      }
      exports.Argument = Argument2;
      exports.humanReadableArgName = humanReadableArgName;
    }
  });

  // ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/help.js
  var require_help = __commonJS({
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/help.js"(exports) {
      var { humanReadableArgName } = require_argument();
      var Help2 = class {
        constructor() {
          this.helpWidth = void 0;
          this.sortSubcommands = false;
          this.sortOptions = false;
          this.showGlobalOptions = false;
        }
        /**
         * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
         *
         * @param {Command} cmd
         * @returns {Command[]}
         */
        visibleCommands(cmd) {
          const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
          const helpCommand = cmd._getHelpCommand();
          if (helpCommand && !helpCommand._hidden) {
            visibleCommands.push(helpCommand);
          }
          if (this.sortSubcommands) {
            visibleCommands.sort((a, b) => {
              return a.name().localeCompare(b.name());
            });
          }
          return visibleCommands;
        }
        /**
         * Compare options for sort.
         *
         * @param {Option} a
         * @param {Option} b
         * @returns {number}
         */
        compareOptions(a, b) {
          const getSortKey = (option) => {
            return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
          };
          return getSortKey(a).localeCompare(getSortKey(b));
        }
        /**
         * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
         *
         * @param {Command} cmd
         * @returns {Option[]}
         */
        visibleOptions(cmd) {
          const visibleOptions = cmd.options.filter((option) => !option.hidden);
          const helpOption = cmd._getHelpOption();
          if (helpOption && !helpOption.hidden) {
            const removeShort = helpOption.short && cmd._findOption(helpOption.short);
            const removeLong = helpOption.long && cmd._findOption(helpOption.long);
            if (!removeShort && !removeLong) {
              visibleOptions.push(helpOption);
            } else if (helpOption.long && !removeLong) {
              visibleOptions.push(
                cmd.createOption(helpOption.long, helpOption.description)
              );
            } else if (helpOption.short && !removeShort) {
              visibleOptions.push(
                cmd.createOption(helpOption.short, helpOption.description)
              );
            }
          }
          if (this.sortOptions) {
            visibleOptions.sort(this.compareOptions);
          }
          return visibleOptions;
        }
        /**
         * Get an array of the visible global options. (Not including help.)
         *
         * @param {Command} cmd
         * @returns {Option[]}
         */
        visibleGlobalOptions(cmd) {
          if (!this.showGlobalOptions)
            return [];
          const globalOptions = [];
          for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
            const visibleOptions = ancestorCmd.options.filter(
              (option) => !option.hidden
            );
            globalOptions.push(...visibleOptions);
          }
          if (this.sortOptions) {
            globalOptions.sort(this.compareOptions);
          }
          return globalOptions;
        }
        /**
         * Get an array of the arguments if any have a description.
         *
         * @param {Command} cmd
         * @returns {Argument[]}
         */
        visibleArguments(cmd) {
          if (cmd._argsDescription) {
            cmd.registeredArguments.forEach((argument) => {
              argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
            });
          }
          if (cmd.registeredArguments.find((argument) => argument.description)) {
            return cmd.registeredArguments;
          }
          return [];
        }
        /**
         * Get the command term to show in the list of subcommands.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        subcommandTerm(cmd) {
          const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
          return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
          (args ? " " + args : "");
        }
        /**
         * Get the option term to show in the list of options.
         *
         * @param {Option} option
         * @returns {string}
         */
        optionTerm(option) {
          return option.flags;
        }
        /**
         * Get the argument term to show in the list of arguments.
         *
         * @param {Argument} argument
         * @returns {string}
         */
        argumentTerm(argument) {
          return argument.name();
        }
        /**
         * Get the longest command term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestSubcommandTermLength(cmd, helper2) {
          return helper2.visibleCommands(cmd).reduce((max2, command) => {
            return Math.max(max2, helper2.subcommandTerm(command).length);
          }, 0);
        }
        /**
         * Get the longest option term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestOptionTermLength(cmd, helper2) {
          return helper2.visibleOptions(cmd).reduce((max2, option) => {
            return Math.max(max2, helper2.optionTerm(option).length);
          }, 0);
        }
        /**
         * Get the longest global option term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestGlobalOptionTermLength(cmd, helper2) {
          return helper2.visibleGlobalOptions(cmd).reduce((max2, option) => {
            return Math.max(max2, helper2.optionTerm(option).length);
          }, 0);
        }
        /**
         * Get the longest argument term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestArgumentTermLength(cmd, helper2) {
          return helper2.visibleArguments(cmd).reduce((max2, argument) => {
            return Math.max(max2, helper2.argumentTerm(argument).length);
          }, 0);
        }
        /**
         * Get the command usage to be displayed at the top of the built-in help.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        commandUsage(cmd) {
          let cmdName = cmd._name;
          if (cmd._aliases[0]) {
            cmdName = cmdName + "|" + cmd._aliases[0];
          }
          let ancestorCmdNames = "";
          for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
            ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
          }
          return ancestorCmdNames + cmdName + " " + cmd.usage();
        }
        /**
         * Get the description for the command.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        commandDescription(cmd) {
          return cmd.description();
        }
        /**
         * Get the subcommand summary to show in the list of subcommands.
         * (Fallback to description for backwards compatibility.)
         *
         * @param {Command} cmd
         * @returns {string}
         */
        subcommandDescription(cmd) {
          return cmd.summary() || cmd.description();
        }
        /**
         * Get the option description to show in the list of options.
         *
         * @param {Option} option
         * @return {string}
         */
        optionDescription(option) {
          const extraInfo = [];
          if (option.argChoices) {
            extraInfo.push(
              // use stringify to match the display of the default value
              `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
            );
          }
          if (option.defaultValue !== void 0) {
            const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
            if (showDefault) {
              extraInfo.push(
                `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`
              );
            }
          }
          if (option.presetArg !== void 0 && option.optional) {
            extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
          }
          if (option.envVar !== void 0) {
            extraInfo.push(`env: ${option.envVar}`);
          }
          if (extraInfo.length > 0) {
            return `${option.description} (${extraInfo.join(", ")})`;
          }
          return option.description;
        }
        /**
         * Get the argument description to show in the list of arguments.
         *
         * @param {Argument} argument
         * @return {string}
         */
        argumentDescription(argument) {
          const extraInfo = [];
          if (argument.argChoices) {
            extraInfo.push(
              // use stringify to match the display of the default value
              `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
            );
          }
          if (argument.defaultValue !== void 0) {
            extraInfo.push(
              `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`
            );
          }
          if (extraInfo.length > 0) {
            const extraDescripton = `(${extraInfo.join(", ")})`;
            if (argument.description) {
              return `${argument.description} ${extraDescripton}`;
            }
            return extraDescripton;
          }
          return argument.description;
        }
        /**
         * Generate the built-in help text.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {string}
         */
        formatHelp(cmd, helper2) {
          const termWidth = helper2.padWidth(cmd, helper2);
          const helpWidth = helper2.helpWidth || 80;
          const itemIndentWidth = 2;
          const itemSeparatorWidth = 2;
          function formatItem(term, description) {
            if (description) {
              const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
              return helper2.wrap(
                fullText,
                helpWidth - itemIndentWidth,
                termWidth + itemSeparatorWidth
              );
            }
            return term;
          }
          function formatList(textArray) {
            return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
          }
          let output2 = [`Usage: ${helper2.commandUsage(cmd)}`, ""];
          const commandDescription = helper2.commandDescription(cmd);
          if (commandDescription.length > 0) {
            output2 = output2.concat([
              helper2.wrap(commandDescription, helpWidth, 0),
              ""
            ]);
          }
          const argumentList = helper2.visibleArguments(cmd).map((argument) => {
            return formatItem(
              helper2.argumentTerm(argument),
              helper2.argumentDescription(argument)
            );
          });
          if (argumentList.length > 0) {
            output2 = output2.concat(["Arguments:", formatList(argumentList), ""]);
          }
          const optionList = helper2.visibleOptions(cmd).map((option) => {
            return formatItem(
              helper2.optionTerm(option),
              helper2.optionDescription(option)
            );
          });
          if (optionList.length > 0) {
            output2 = output2.concat(["Options:", formatList(optionList), ""]);
          }
          if (this.showGlobalOptions) {
            const globalOptionList = helper2.visibleGlobalOptions(cmd).map((option) => {
              return formatItem(
                helper2.optionTerm(option),
                helper2.optionDescription(option)
              );
            });
            if (globalOptionList.length > 0) {
              output2 = output2.concat([
                "Global Options:",
                formatList(globalOptionList),
                ""
              ]);
            }
          }
          const commandList = helper2.visibleCommands(cmd).map((cmd2) => {
            return formatItem(
              helper2.subcommandTerm(cmd2),
              helper2.subcommandDescription(cmd2)
            );
          });
          if (commandList.length > 0) {
            output2 = output2.concat(["Commands:", formatList(commandList), ""]);
          }
          return output2.join("\n");
        }
        /**
         * Calculate the pad width from the maximum term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        padWidth(cmd, helper2) {
          return Math.max(
            helper2.longestOptionTermLength(cmd, helper2),
            helper2.longestGlobalOptionTermLength(cmd, helper2),
            helper2.longestSubcommandTermLength(cmd, helper2),
            helper2.longestArgumentTermLength(cmd, helper2)
          );
        }
        /**
         * Wrap the given string to width characters per line, with lines after the first indented.
         * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
         *
         * @param {string} str
         * @param {number} width
         * @param {number} indent
         * @param {number} [minColumnWidth=40]
         * @return {string}
         *
         */
        wrap(str, width, indent2, minColumnWidth = 40) {
          const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
          const manualIndent = new RegExp(`[\\n][${indents}]+`);
          if (str.match(manualIndent))
            return str;
          const columnWidth = width - indent2;
          if (columnWidth < minColumnWidth)
            return str;
          const leadingStr = str.slice(0, indent2);
          const columnText = str.slice(indent2).replace("\r\n", "\n");
          const indentString = " ".repeat(indent2);
          const zeroWidthSpace = "\u200B";
          const breaks = `\\s${zeroWidthSpace}`;
          const regex = new RegExp(
            `
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
            "g"
          );
          const lines = columnText.match(regex) || [];
          return leadingStr + lines.map((line, i) => {
            if (line === "\n")
              return "";
            return (i > 0 ? indentString : "") + line.trimEnd();
          }).join("\n");
        }
      };
      exports.Help = Help2;
    }
  });

  // ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/option.js
  var require_option = __commonJS({
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/option.js"(exports) {
      var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var Option2 = class {
        /**
         * Initialize a new `Option` with the given `flags` and `description`.
         *
         * @param {string} flags
         * @param {string} [description]
         */
        constructor(flags, description) {
          this.flags = flags;
          this.description = description || "";
          this.required = flags.includes("<");
          this.optional = flags.includes("[");
          this.variadic = /\w\.\.\.[>\]]$/.test(flags);
          this.mandatory = false;
          const optionFlags = splitOptionFlags(flags);
          this.short = optionFlags.shortFlag;
          this.long = optionFlags.longFlag;
          this.negate = false;
          if (this.long) {
            this.negate = this.long.startsWith("--no-");
          }
          this.defaultValue = void 0;
          this.defaultValueDescription = void 0;
          this.presetArg = void 0;
          this.envVar = void 0;
          this.parseArg = void 0;
          this.hidden = false;
          this.argChoices = void 0;
          this.conflictsWith = [];
          this.implied = void 0;
        }
        /**
         * Set the default value, and optionally supply the description to be displayed in the help.
         *
         * @param {*} value
         * @param {string} [description]
         * @return {Option}
         */
        default(value, description) {
          this.defaultValue = value;
          this.defaultValueDescription = description;
          return this;
        }
        /**
         * Preset to use when option used without option-argument, especially optional but also boolean and negated.
         * The custom processing (parseArg) is called.
         *
         * @example
         * new Option('--color').default('GREYSCALE').preset('RGB');
         * new Option('--donate [amount]').preset('20').argParser(parseFloat);
         *
         * @param {*} arg
         * @return {Option}
         */
        preset(arg) {
          this.presetArg = arg;
          return this;
        }
        /**
         * Add option name(s) that conflict with this option.
         * An error will be displayed if conflicting options are found during parsing.
         *
         * @example
         * new Option('--rgb').conflicts('cmyk');
         * new Option('--js').conflicts(['ts', 'jsx']);
         *
         * @param {(string | string[])} names
         * @return {Option}
         */
        conflicts(names) {
          this.conflictsWith = this.conflictsWith.concat(names);
          return this;
        }
        /**
         * Specify implied option values for when this option is set and the implied options are not.
         *
         * The custom processing (parseArg) is not called on the implied values.
         *
         * @example
         * program
         *   .addOption(new Option('--log', 'write logging information to file'))
         *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
         *
         * @param {object} impliedOptionValues
         * @return {Option}
         */
        implies(impliedOptionValues) {
          let newImplied = impliedOptionValues;
          if (typeof impliedOptionValues === "string") {
            newImplied = { [impliedOptionValues]: true };
          }
          this.implied = Object.assign(this.implied || {}, newImplied);
          return this;
        }
        /**
         * Set environment variable to check for option value.
         *
         * An environment variable is only used if when processed the current option value is
         * undefined, or the source of the current value is 'default' or 'config' or 'env'.
         *
         * @param {string} name
         * @return {Option}
         */
        env(name) {
          this.envVar = name;
          return this;
        }
        /**
         * Set the custom handler for processing CLI option arguments into option values.
         *
         * @param {Function} [fn]
         * @return {Option}
         */
        argParser(fn) {
          this.parseArg = fn;
          return this;
        }
        /**
         * Whether the option is mandatory and must have a value after parsing.
         *
         * @param {boolean} [mandatory=true]
         * @return {Option}
         */
        makeOptionMandatory(mandatory = true) {
          this.mandatory = !!mandatory;
          return this;
        }
        /**
         * Hide option in help.
         *
         * @param {boolean} [hide=true]
         * @return {Option}
         */
        hideHelp(hide = true) {
          this.hidden = !!hide;
          return this;
        }
        /**
         * @package
         */
        _concatValue(value, previous) {
          if (previous === this.defaultValue || !Array.isArray(previous)) {
            return [value];
          }
          return previous.concat(value);
        }
        /**
         * Only allow option value to be one of choices.
         *
         * @param {string[]} values
         * @return {Option}
         */
        choices(values) {
          this.argChoices = values.slice();
          this.parseArg = (arg, previous) => {
            if (!this.argChoices.includes(arg)) {
              throw new InvalidArgumentError2(
                `Allowed choices are ${this.argChoices.join(", ")}.`
              );
            }
            if (this.variadic) {
              return this._concatValue(arg, previous);
            }
            return arg;
          };
          return this;
        }
        /**
         * Return option name.
         *
         * @return {string}
         */
        name() {
          if (this.long) {
            return this.long.replace(/^--/, "");
          }
          return this.short.replace(/^-/, "");
        }
        /**
         * Return option name, in a camelcase format that can be used
         * as a object attribute key.
         *
         * @return {string}
         */
        attributeName() {
          return camelcase(this.name().replace(/^no-/, ""));
        }
        /**
         * Check if `arg` matches the short or long flag.
         *
         * @param {string} arg
         * @return {boolean}
         * @package
         */
        is(arg) {
          return this.short === arg || this.long === arg;
        }
        /**
         * Return whether a boolean option.
         *
         * Options are one of boolean, negated, required argument, or optional argument.
         *
         * @return {boolean}
         * @package
         */
        isBoolean() {
          return !this.required && !this.optional && !this.negate;
        }
      };
      var DualOptions = class {
        /**
         * @param {Option[]} options
         */
        constructor(options) {
          this.positiveOptions = /* @__PURE__ */ new Map();
          this.negativeOptions = /* @__PURE__ */ new Map();
          this.dualOptions = /* @__PURE__ */ new Set();
          options.forEach((option) => {
            if (option.negate) {
              this.negativeOptions.set(option.attributeName(), option);
            } else {
              this.positiveOptions.set(option.attributeName(), option);
            }
          });
          this.negativeOptions.forEach((value, key) => {
            if (this.positiveOptions.has(key)) {
              this.dualOptions.add(key);
            }
          });
        }
        /**
         * Did the value come from the option, and not from possible matching dual option?
         *
         * @param {*} value
         * @param {Option} option
         * @returns {boolean}
         */
        valueFromOption(value, option) {
          const optionKey = option.attributeName();
          if (!this.dualOptions.has(optionKey))
            return true;
          const preset = this.negativeOptions.get(optionKey).presetArg;
          const negativeValue = preset !== void 0 ? preset : false;
          return option.negate === (negativeValue === value);
        }
      };
      function camelcase(str) {
        return str.split("-").reduce((str2, word) => {
          return str2 + word[0].toUpperCase() + word.slice(1);
        });
      }
      function splitOptionFlags(flags) {
        let shortFlag;
        let longFlag;
        const flagParts = flags.split(/[ |,]+/);
        if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
          shortFlag = flagParts.shift();
        longFlag = flagParts.shift();
        if (!shortFlag && /^-[^-]$/.test(longFlag)) {
          shortFlag = longFlag;
          longFlag = void 0;
        }
        return { shortFlag, longFlag };
      }
      exports.Option = Option2;
      exports.DualOptions = DualOptions;
    }
  });

  // ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/suggestSimilar.js
  var require_suggestSimilar = __commonJS({
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/suggestSimilar.js"(exports) {
      var maxDistance = 3;
      function editDistance(a, b) {
        if (Math.abs(a.length - b.length) > maxDistance)
          return Math.max(a.length, b.length);
        const d = [];
        for (let i = 0; i <= a.length; i++) {
          d[i] = [i];
        }
        for (let j = 0; j <= b.length; j++) {
          d[0][j] = j;
        }
        for (let j = 1; j <= b.length; j++) {
          for (let i = 1; i <= a.length; i++) {
            let cost = 1;
            if (a[i - 1] === b[j - 1]) {
              cost = 0;
            } else {
              cost = 1;
            }
            d[i][j] = Math.min(
              d[i - 1][j] + 1,
              // deletion
              d[i][j - 1] + 1,
              // insertion
              d[i - 1][j - 1] + cost
              // substitution
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
            }
          }
        }
        return d[a.length][b.length];
      }
      function suggestSimilar(word, candidates) {
        if (!candidates || candidates.length === 0)
          return "";
        candidates = Array.from(new Set(candidates));
        const searchingOptions = word.startsWith("--");
        if (searchingOptions) {
          word = word.slice(2);
          candidates = candidates.map((candidate) => candidate.slice(2));
        }
        let similar = [];
        let bestDistance = maxDistance;
        const minSimilarity = 0.4;
        candidates.forEach((candidate) => {
          if (candidate.length <= 1)
            return;
          const distance = editDistance(word, candidate);
          const length = Math.max(word.length, candidate.length);
          const similarity = (length - distance) / length;
          if (similarity > minSimilarity) {
            if (distance < bestDistance) {
              bestDistance = distance;
              similar = [candidate];
            } else if (distance === bestDistance) {
              similar.push(candidate);
            }
          }
        });
        similar.sort((a, b) => a.localeCompare(b));
        if (searchingOptions) {
          similar = similar.map((candidate) => `--${candidate}`);
        }
        if (similar.length > 1) {
          return `
(Did you mean one of ${similar.join(", ")}?)`;
        }
        if (similar.length === 1) {
          return `
(Did you mean ${similar[0]}?)`;
        }
        return "";
      }
      exports.suggestSimilar = suggestSimilar;
    }
  });

  // ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/command.js
  var require_command = __commonJS({
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/lib/command.js"(exports) {
      var EventEmitter3 = __require2("events").EventEmitter;
      var childProcess = __require2("child_process");
      var path6 = __require2("path");
      var fs5 = __require2("fs");
      var process2 = __require2("process");
      var { Argument: Argument2, humanReadableArgName } = require_argument();
      var { CommanderError: CommanderError2 } = require_error();
      var { Help: Help2 } = require_help();
      var { Option: Option2, DualOptions } = require_option();
      var { suggestSimilar } = require_suggestSimilar();
      var Command2 = class extends EventEmitter3 {
        /**
         * Initialize a new `Command`.
         *
         * @param {string} [name]
         */
        constructor(name) {
          super();
          this.commands = [];
          this.options = [];
          this.parent = null;
          this._allowUnknownOption = false;
          this._allowExcessArguments = true;
          this.registeredArguments = [];
          this._args = this.registeredArguments;
          this.args = [];
          this.rawArgs = [];
          this.processedArgs = [];
          this._scriptPath = null;
          this._name = name || "";
          this._optionValues = {};
          this._optionValueSources = {};
          this._storeOptionsAsProperties = false;
          this._actionHandler = null;
          this._executableHandler = false;
          this._executableFile = null;
          this._executableDir = null;
          this._defaultCommandName = null;
          this._exitCallback = null;
          this._aliases = [];
          this._combineFlagAndOptionalValue = true;
          this._description = "";
          this._summary = "";
          this._argsDescription = void 0;
          this._enablePositionalOptions = false;
          this._passThroughOptions = false;
          this._lifeCycleHooks = {};
          this._showHelpAfterError = false;
          this._showSuggestionAfterError = true;
          this._outputConfiguration = {
            writeOut: (str) => process2.stdout.write(str),
            writeErr: (str) => process2.stderr.write(str),
            getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
            getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
            outputError: (str, write) => write(str)
          };
          this._hidden = false;
          this._helpOption = void 0;
          this._addImplicitHelpCommand = void 0;
          this._helpCommand = void 0;
          this._helpConfiguration = {};
        }
        /**
         * Copy settings that are useful to have in common across root command and subcommands.
         *
         * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
         *
         * @param {Command} sourceCommand
         * @return {Command} `this` command for chaining
         */
        copyInheritedSettings(sourceCommand) {
          this._outputConfiguration = sourceCommand._outputConfiguration;
          this._helpOption = sourceCommand._helpOption;
          this._helpCommand = sourceCommand._helpCommand;
          this._helpConfiguration = sourceCommand._helpConfiguration;
          this._exitCallback = sourceCommand._exitCallback;
          this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
          this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
          this._allowExcessArguments = sourceCommand._allowExcessArguments;
          this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
          this._showHelpAfterError = sourceCommand._showHelpAfterError;
          this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
          return this;
        }
        /**
         * @returns {Command[]}
         * @private
         */
        _getCommandAndAncestors() {
          const result = [];
          for (let command = this; command; command = command.parent) {
            result.push(command);
          }
          return result;
        }
        /**
         * Define a command.
         *
         * There are two styles of command: pay attention to where to put the description.
         *
         * @example
         * // Command implemented using action handler (description is supplied separately to `.command`)
         * program
         *   .command('clone <source> [destination]')
         *   .description('clone a repository into a newly created directory')
         *   .action((source, destination) => {
         *     console.log('clone command called');
         *   });
         *
         * // Command implemented using separate executable file (description is second parameter to `.command`)
         * program
         *   .command('start <service>', 'start named service')
         *   .command('stop [service]', 'stop named service, or all if no name supplied');
         *
         * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
         * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
         * @param {object} [execOpts] - configuration options (for executable)
         * @return {Command} returns new command for action handler, or `this` for executable command
         */
        command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
          let desc = actionOptsOrExecDesc;
          let opts = execOpts;
          if (typeof desc === "object" && desc !== null) {
            opts = desc;
            desc = null;
          }
          opts = opts || {};
          const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
          const cmd = this.createCommand(name);
          if (desc) {
            cmd.description(desc);
            cmd._executableHandler = true;
          }
          if (opts.isDefault)
            this._defaultCommandName = cmd._name;
          cmd._hidden = !!(opts.noHelp || opts.hidden);
          cmd._executableFile = opts.executableFile || null;
          if (args)
            cmd.arguments(args);
          this._registerCommand(cmd);
          cmd.parent = this;
          cmd.copyInheritedSettings(this);
          if (desc)
            return this;
          return cmd;
        }
        /**
         * Factory routine to create a new unattached command.
         *
         * See .command() for creating an attached subcommand, which uses this routine to
         * create the command. You can override createCommand to customise subcommands.
         *
         * @param {string} [name]
         * @return {Command} new command
         */
        createCommand(name) {
          return new Command2(name);
        }
        /**
         * You can customise the help with a subclass of Help by overriding createHelp,
         * or by overriding Help properties using configureHelp().
         *
         * @return {Help}
         */
        createHelp() {
          return Object.assign(new Help2(), this.configureHelp());
        }
        /**
         * You can customise the help by overriding Help properties using configureHelp(),
         * or with a subclass of Help by overriding createHelp().
         *
         * @param {object} [configuration] - configuration options
         * @return {(Command | object)} `this` command for chaining, or stored configuration
         */
        configureHelp(configuration) {
          if (configuration === void 0)
            return this._helpConfiguration;
          this._helpConfiguration = configuration;
          return this;
        }
        /**
         * The default output goes to stdout and stderr. You can customise this for special
         * applications. You can also customise the display of errors by overriding outputError.
         *
         * The configuration properties are all functions:
         *
         *     // functions to change where being written, stdout and stderr
         *     writeOut(str)
         *     writeErr(str)
         *     // matching functions to specify width for wrapping help
         *     getOutHelpWidth()
         *     getErrHelpWidth()
         *     // functions based on what is being written out
         *     outputError(str, write) // used for displaying errors, and not used for displaying help
         *
         * @param {object} [configuration] - configuration options
         * @return {(Command | object)} `this` command for chaining, or stored configuration
         */
        configureOutput(configuration) {
          if (configuration === void 0)
            return this._outputConfiguration;
          Object.assign(this._outputConfiguration, configuration);
          return this;
        }
        /**
         * Display the help or a custom message after an error occurs.
         *
         * @param {(boolean|string)} [displayHelp]
         * @return {Command} `this` command for chaining
         */
        showHelpAfterError(displayHelp = true) {
          if (typeof displayHelp !== "string")
            displayHelp = !!displayHelp;
          this._showHelpAfterError = displayHelp;
          return this;
        }
        /**
         * Display suggestion of similar commands for unknown commands, or options for unknown options.
         *
         * @param {boolean} [displaySuggestion]
         * @return {Command} `this` command for chaining
         */
        showSuggestionAfterError(displaySuggestion = true) {
          this._showSuggestionAfterError = !!displaySuggestion;
          return this;
        }
        /**
         * Add a prepared subcommand.
         *
         * See .command() for creating an attached subcommand which inherits settings from its parent.
         *
         * @param {Command} cmd - new subcommand
         * @param {object} [opts] - configuration options
         * @return {Command} `this` command for chaining
         */
        addCommand(cmd, opts) {
          if (!cmd._name) {
            throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
          }
          opts = opts || {};
          if (opts.isDefault)
            this._defaultCommandName = cmd._name;
          if (opts.noHelp || opts.hidden)
            cmd._hidden = true;
          this._registerCommand(cmd);
          cmd.parent = this;
          cmd._checkForBrokenPassThrough();
          return this;
        }
        /**
         * Factory routine to create a new unattached argument.
         *
         * See .argument() for creating an attached argument, which uses this routine to
         * create the argument. You can override createArgument to return a custom argument.
         *
         * @param {string} name
         * @param {string} [description]
         * @return {Argument} new argument
         */
        createArgument(name, description) {
          return new Argument2(name, description);
        }
        /**
         * Define argument syntax for command.
         *
         * The default is that the argument is required, and you can explicitly
         * indicate this with <> around the name. Put [] around the name for an optional argument.
         *
         * @example
         * program.argument('<input-file>');
         * program.argument('[output-file]');
         *
         * @param {string} name
         * @param {string} [description]
         * @param {(Function|*)} [fn] - custom argument processing function
         * @param {*} [defaultValue]
         * @return {Command} `this` command for chaining
         */
        argument(name, description, fn, defaultValue) {
          const argument = this.createArgument(name, description);
          if (typeof fn === "function") {
            argument.default(defaultValue).argParser(fn);
          } else {
            argument.default(fn);
          }
          this.addArgument(argument);
          return this;
        }
        /**
         * Define argument syntax for command, adding multiple at once (without descriptions).
         *
         * See also .argument().
         *
         * @example
         * program.arguments('<cmd> [env]');
         *
         * @param {string} names
         * @return {Command} `this` command for chaining
         */
        arguments(names) {
          names.trim().split(/ +/).forEach((detail) => {
            this.argument(detail);
          });
          return this;
        }
        /**
         * Define argument syntax for command, adding a prepared argument.
         *
         * @param {Argument} argument
         * @return {Command} `this` command for chaining
         */
        addArgument(argument) {
          const previousArgument = this.registeredArguments.slice(-1)[0];
          if (previousArgument && previousArgument.variadic) {
            throw new Error(
              `only the last argument can be variadic '${previousArgument.name()}'`
            );
          }
          if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
            throw new Error(
              `a default value for a required argument is never used: '${argument.name()}'`
            );
          }
          this.registeredArguments.push(argument);
          return this;
        }
        /**
         * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
         *
         * @example
         *    program.helpCommand('help [cmd]');
         *    program.helpCommand('help [cmd]', 'show help');
         *    program.helpCommand(false); // suppress default help command
         *    program.helpCommand(true); // add help command even if no subcommands
         *
         * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
         * @param {string} [description] - custom description
         * @return {Command} `this` command for chaining
         */
        helpCommand(enableOrNameAndArgs, description) {
          if (typeof enableOrNameAndArgs === "boolean") {
            this._addImplicitHelpCommand = enableOrNameAndArgs;
            return this;
          }
          enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
          const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
          const helpDescription = description ?? "display help for command";
          const helpCommand = this.createCommand(helpName);
          helpCommand.helpOption(false);
          if (helpArgs)
            helpCommand.arguments(helpArgs);
          if (helpDescription)
            helpCommand.description(helpDescription);
          this._addImplicitHelpCommand = true;
          this._helpCommand = helpCommand;
          return this;
        }
        /**
         * Add prepared custom help command.
         *
         * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
         * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
         * @return {Command} `this` command for chaining
         */
        addHelpCommand(helpCommand, deprecatedDescription) {
          if (typeof helpCommand !== "object") {
            this.helpCommand(helpCommand, deprecatedDescription);
            return this;
          }
          this._addImplicitHelpCommand = true;
          this._helpCommand = helpCommand;
          return this;
        }
        /**
         * Lazy create help command.
         *
         * @return {(Command|null)}
         * @package
         */
        _getHelpCommand() {
          const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
          if (hasImplicitHelpCommand) {
            if (this._helpCommand === void 0) {
              this.helpCommand(void 0, void 0);
            }
            return this._helpCommand;
          }
          return null;
        }
        /**
         * Add hook for life cycle event.
         *
         * @param {string} event
         * @param {Function} listener
         * @return {Command} `this` command for chaining
         */
        hook(event, listener) {
          const allowedValues = ["preSubcommand", "preAction", "postAction"];
          if (!allowedValues.includes(event)) {
            throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
          }
          if (this._lifeCycleHooks[event]) {
            this._lifeCycleHooks[event].push(listener);
          } else {
            this._lifeCycleHooks[event] = [listener];
          }
          return this;
        }
        /**
         * Register callback to use as replacement for calling process.exit.
         *
         * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
         * @return {Command} `this` command for chaining
         */
        exitOverride(fn) {
          if (fn) {
            this._exitCallback = fn;
          } else {
            this._exitCallback = (err2) => {
              if (err2.code !== "commander.executeSubCommandAsync") {
                throw err2;
              } else {
              }
            };
          }
          return this;
        }
        /**
         * Call process.exit, and _exitCallback if defined.
         *
         * @param {number} exitCode exit code for using with process.exit
         * @param {string} code an id string representing the error
         * @param {string} message human-readable description of the error
         * @return never
         * @private
         */
        _exit(exitCode, code, message) {
          if (this._exitCallback) {
            this._exitCallback(new CommanderError2(exitCode, code, message));
          }
          process2.exit(exitCode);
        }
        /**
         * Register callback `fn` for the command.
         *
         * @example
         * program
         *   .command('serve')
         *   .description('start service')
         *   .action(function() {
         *      // do work here
         *   });
         *
         * @param {Function} fn
         * @return {Command} `this` command for chaining
         */
        action(fn) {
          const listener = (args) => {
            const expectedArgsCount = this.registeredArguments.length;
            const actionArgs = args.slice(0, expectedArgsCount);
            if (this._storeOptionsAsProperties) {
              actionArgs[expectedArgsCount] = this;
            } else {
              actionArgs[expectedArgsCount] = this.opts();
            }
            actionArgs.push(this);
            return fn.apply(this, actionArgs);
          };
          this._actionHandler = listener;
          return this;
        }
        /**
         * Factory routine to create a new unattached option.
         *
         * See .option() for creating an attached option, which uses this routine to
         * create the option. You can override createOption to return a custom option.
         *
         * @param {string} flags
         * @param {string} [description]
         * @return {Option} new option
         */
        createOption(flags, description) {
          return new Option2(flags, description);
        }
        /**
         * Wrap parseArgs to catch 'commander.invalidArgument'.
         *
         * @param {(Option | Argument)} target
         * @param {string} value
         * @param {*} previous
         * @param {string} invalidArgumentMessage
         * @private
         */
        _callParseArg(target, value, previous, invalidArgumentMessage) {
          try {
            return target.parseArg(value, previous);
          } catch (err2) {
            if (err2.code === "commander.invalidArgument") {
              const message = `${invalidArgumentMessage} ${err2.message}`;
              this.error(message, { exitCode: err2.exitCode, code: err2.code });
            }
            throw err2;
          }
        }
        /**
         * Check for option flag conflicts.
         * Register option if no conflicts found, or throw on conflict.
         *
         * @param {Option} option
         * @private
         */
        _registerOption(option) {
          const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
          if (matchingOption) {
            const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
            throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
          }
          this.options.push(option);
        }
        /**
         * Check for command name and alias conflicts with existing commands.
         * Register command if no conflicts found, or throw on conflict.
         *
         * @param {Command} command
         * @private
         */
        _registerCommand(command) {
          const knownBy = (cmd) => {
            return [cmd.name()].concat(cmd.aliases());
          };
          const alreadyUsed = knownBy(command).find(
            (name) => this._findCommand(name)
          );
          if (alreadyUsed) {
            const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
            const newCmd = knownBy(command).join("|");
            throw new Error(
              `cannot add command '${newCmd}' as already have command '${existingCmd}'`
            );
          }
          this.commands.push(command);
        }
        /**
         * Add an option.
         *
         * @param {Option} option
         * @return {Command} `this` command for chaining
         */
        addOption(option) {
          this._registerOption(option);
          const oname = option.name();
          const name = option.attributeName();
          if (option.negate) {
            const positiveLongFlag = option.long.replace(/^--no-/, "--");
            if (!this._findOption(positiveLongFlag)) {
              this.setOptionValueWithSource(
                name,
                option.defaultValue === void 0 ? true : option.defaultValue,
                "default"
              );
            }
          } else if (option.defaultValue !== void 0) {
            this.setOptionValueWithSource(name, option.defaultValue, "default");
          }
          const handleOptionValue = (val, invalidValueMessage, valueSource) => {
            if (val == null && option.presetArg !== void 0) {
              val = option.presetArg;
            }
            const oldValue = this.getOptionValue(name);
            if (val !== null && option.parseArg) {
              val = this._callParseArg(option, val, oldValue, invalidValueMessage);
            } else if (val !== null && option.variadic) {
              val = option._concatValue(val, oldValue);
            }
            if (val == null) {
              if (option.negate) {
                val = false;
              } else if (option.isBoolean() || option.optional) {
                val = true;
              } else {
                val = "";
              }
            }
            this.setOptionValueWithSource(name, val, valueSource);
          };
          this.on("option:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "cli");
          });
          if (option.envVar) {
            this.on("optionEnv:" + oname, (val) => {
              const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
              handleOptionValue(val, invalidValueMessage, "env");
            });
          }
          return this;
        }
        /**
         * Internal implementation shared by .option() and .requiredOption()
         *
         * @return {Command} `this` command for chaining
         * @private
         */
        _optionEx(config, flags, description, fn, defaultValue) {
          if (typeof flags === "object" && flags instanceof Option2) {
            throw new Error(
              "To add an Option object use addOption() instead of option() or requiredOption()"
            );
          }
          const option = this.createOption(flags, description);
          option.makeOptionMandatory(!!config.mandatory);
          if (typeof fn === "function") {
            option.default(defaultValue).argParser(fn);
          } else if (fn instanceof RegExp) {
            const regex = fn;
            fn = (val, def) => {
              const m = regex.exec(val);
              return m ? m[0] : def;
            };
            option.default(defaultValue).argParser(fn);
          } else {
            option.default(fn);
          }
          return this.addOption(option);
        }
        /**
         * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
         *
         * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
         * option-argument is indicated by `<>` and an optional option-argument by `[]`.
         *
         * See the README for more details, and see also addOption() and requiredOption().
         *
         * @example
         * program
         *     .option('-p, --pepper', 'add pepper')
         *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
         *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
         *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
         *
         * @param {string} flags
         * @param {string} [description]
         * @param {(Function|*)} [parseArg] - custom option processing function or default value
         * @param {*} [defaultValue]
         * @return {Command} `this` command for chaining
         */
        option(flags, description, parseArg, defaultValue) {
          return this._optionEx({}, flags, description, parseArg, defaultValue);
        }
        /**
         * Add a required option which must have a value after parsing. This usually means
         * the option must be specified on the command line. (Otherwise the same as .option().)
         *
         * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
         *
         * @param {string} flags
         * @param {string} [description]
         * @param {(Function|*)} [parseArg] - custom option processing function or default value
         * @param {*} [defaultValue]
         * @return {Command} `this` command for chaining
         */
        requiredOption(flags, description, parseArg, defaultValue) {
          return this._optionEx(
            { mandatory: true },
            flags,
            description,
            parseArg,
            defaultValue
          );
        }
        /**
         * Alter parsing of short flags with optional values.
         *
         * @example
         * // for `.option('-f,--flag [value]'):
         * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
         * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
         *
         * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
         * @return {Command} `this` command for chaining
         */
        combineFlagAndOptionalValue(combine = true) {
          this._combineFlagAndOptionalValue = !!combine;
          return this;
        }
        /**
         * Allow unknown options on the command line.
         *
         * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
         * @return {Command} `this` command for chaining
         */
        allowUnknownOption(allowUnknown = true) {
          this._allowUnknownOption = !!allowUnknown;
          return this;
        }
        /**
         * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
         *
         * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
         * @return {Command} `this` command for chaining
         */
        allowExcessArguments(allowExcess = true) {
          this._allowExcessArguments = !!allowExcess;
          return this;
        }
        /**
         * Enable positional options. Positional means global options are specified before subcommands which lets
         * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
         * The default behaviour is non-positional and global options may appear anywhere on the command line.
         *
         * @param {boolean} [positional]
         * @return {Command} `this` command for chaining
         */
        enablePositionalOptions(positional = true) {
          this._enablePositionalOptions = !!positional;
          return this;
        }
        /**
         * Pass through options that come after command-arguments rather than treat them as command-options,
         * so actual command-options come before command-arguments. Turning this on for a subcommand requires
         * positional options to have been enabled on the program (parent commands).
         * The default behaviour is non-positional and options may appear before or after command-arguments.
         *
         * @param {boolean} [passThrough] for unknown options.
         * @return {Command} `this` command for chaining
         */
        passThroughOptions(passThrough = true) {
          this._passThroughOptions = !!passThrough;
          this._checkForBrokenPassThrough();
          return this;
        }
        /**
         * @private
         */
        _checkForBrokenPassThrough() {
          if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
            throw new Error(
              `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`
            );
          }
        }
        /**
         * Whether to store option values as properties on command object,
         * or store separately (specify false). In both cases the option values can be accessed using .opts().
         *
         * @param {boolean} [storeAsProperties=true]
         * @return {Command} `this` command for chaining
         */
        storeOptionsAsProperties(storeAsProperties = true) {
          if (this.options.length) {
            throw new Error("call .storeOptionsAsProperties() before adding options");
          }
          if (Object.keys(this._optionValues).length) {
            throw new Error(
              "call .storeOptionsAsProperties() before setting option values"
            );
          }
          this._storeOptionsAsProperties = !!storeAsProperties;
          return this;
        }
        /**
         * Retrieve option value.
         *
         * @param {string} key
         * @return {object} value
         */
        getOptionValue(key) {
          if (this._storeOptionsAsProperties) {
            return this[key];
          }
          return this._optionValues[key];
        }
        /**
         * Store option value.
         *
         * @param {string} key
         * @param {object} value
         * @return {Command} `this` command for chaining
         */
        setOptionValue(key, value) {
          return this.setOptionValueWithSource(key, value, void 0);
        }
        /**
         * Store option value and where the value came from.
         *
         * @param {string} key
         * @param {object} value
         * @param {string} source - expected values are default/config/env/cli/implied
         * @return {Command} `this` command for chaining
         */
        setOptionValueWithSource(key, value, source) {
          if (this._storeOptionsAsProperties) {
            this[key] = value;
          } else {
            this._optionValues[key] = value;
          }
          this._optionValueSources[key] = source;
          return this;
        }
        /**
         * Get source of option value.
         * Expected values are default | config | env | cli | implied
         *
         * @param {string} key
         * @return {string}
         */
        getOptionValueSource(key) {
          return this._optionValueSources[key];
        }
        /**
         * Get source of option value. See also .optsWithGlobals().
         * Expected values are default | config | env | cli | implied
         *
         * @param {string} key
         * @return {string}
         */
        getOptionValueSourceWithGlobals(key) {
          let source;
          this._getCommandAndAncestors().forEach((cmd) => {
            if (cmd.getOptionValueSource(key) !== void 0) {
              source = cmd.getOptionValueSource(key);
            }
          });
          return source;
        }
        /**
         * Get user arguments from implied or explicit arguments.
         * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
         *
         * @private
         */
        _prepareUserArgs(argv, parseOptions) {
          if (argv !== void 0 && !Array.isArray(argv)) {
            throw new Error("first parameter to parse must be array or undefined");
          }
          parseOptions = parseOptions || {};
          if (argv === void 0 && parseOptions.from === void 0) {
            if (process2.versions?.electron) {
              parseOptions.from = "electron";
            }
            const execArgv = process2.execArgv ?? [];
            if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
              parseOptions.from = "eval";
            }
          }
          if (argv === void 0) {
            argv = process2.argv;
          }
          this.rawArgs = argv.slice();
          let userArgs;
          switch (parseOptions.from) {
            case void 0:
            case "node":
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
              break;
            case "electron":
              if (process2.defaultApp) {
                this._scriptPath = argv[1];
                userArgs = argv.slice(2);
              } else {
                userArgs = argv.slice(1);
              }
              break;
            case "user":
              userArgs = argv.slice(0);
              break;
            case "eval":
              userArgs = argv.slice(1);
              break;
            default:
              throw new Error(
                `unexpected parse option { from: '${parseOptions.from}' }`
              );
          }
          if (!this._name && this._scriptPath)
            this.nameFromFilename(this._scriptPath);
          this._name = this._name || "program";
          return userArgs;
        }
        /**
         * Parse `argv`, setting options and invoking commands when defined.
         *
         * Use parseAsync instead of parse if any of your action handlers are async.
         *
         * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
         *
         * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
         * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
         * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
         * - `'user'`: just user arguments
         *
         * @example
         * program.parse(); // parse process.argv and auto-detect electron and special node flags
         * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
         * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
         *
         * @param {string[]} [argv] - optional, defaults to process.argv
         * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
         * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
         * @return {Command} `this` command for chaining
         */
        parse(argv, parseOptions) {
          const userArgs = this._prepareUserArgs(argv, parseOptions);
          this._parseCommand([], userArgs);
          return this;
        }
        /**
         * Parse `argv`, setting options and invoking commands when defined.
         *
         * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
         *
         * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
         * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
         * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
         * - `'user'`: just user arguments
         *
         * @example
         * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
         * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
         * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
         *
         * @param {string[]} [argv]
         * @param {object} [parseOptions]
         * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
         * @return {Promise}
         */
        async parseAsync(argv, parseOptions) {
          const userArgs = this._prepareUserArgs(argv, parseOptions);
          await this._parseCommand([], userArgs);
          return this;
        }
        /**
         * Execute a sub-command executable.
         *
         * @private
         */
        _executeSubCommand(subcommand, args) {
          args = args.slice();
          let launchWithNode = false;
          const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
          function findFile(baseDir, baseName) {
            const localBin = path6.resolve(baseDir, baseName);
            if (fs5.existsSync(localBin))
              return localBin;
            if (sourceExt.includes(path6.extname(baseName)))
              return void 0;
            const foundExt = sourceExt.find(
              (ext2) => fs5.existsSync(`${localBin}${ext2}`)
            );
            if (foundExt)
              return `${localBin}${foundExt}`;
            return void 0;
          }
          this._checkForMissingMandatoryOptions();
          this._checkForConflictingOptions();
          let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
          let executableDir = this._executableDir || "";
          if (this._scriptPath) {
            let resolvedScriptPath;
            try {
              resolvedScriptPath = fs5.realpathSync(this._scriptPath);
            } catch (err2) {
              resolvedScriptPath = this._scriptPath;
            }
            executableDir = path6.resolve(
              path6.dirname(resolvedScriptPath),
              executableDir
            );
          }
          if (executableDir) {
            let localFile = findFile(executableDir, executableFile);
            if (!localFile && !subcommand._executableFile && this._scriptPath) {
              const legacyName = path6.basename(
                this._scriptPath,
                path6.extname(this._scriptPath)
              );
              if (legacyName !== this._name) {
                localFile = findFile(
                  executableDir,
                  `${legacyName}-${subcommand._name}`
                );
              }
            }
            executableFile = localFile || executableFile;
          }
          launchWithNode = sourceExt.includes(path6.extname(executableFile));
          let proc2;
          if (process2.platform !== "win32") {
            if (launchWithNode) {
              args.unshift(executableFile);
              args = incrementNodeInspectorPort(process2.execArgv).concat(args);
              proc2 = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
            } else {
              proc2 = childProcess.spawn(executableFile, args, { stdio: "inherit" });
            }
          } else {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc2 = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
          }
          if (!proc2.killed) {
            const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
            signals.forEach((signal) => {
              process2.on(signal, () => {
                if (proc2.killed === false && proc2.exitCode === null) {
                  proc2.kill(signal);
                }
              });
            });
          }
          const exitCallback = this._exitCallback;
          proc2.on("close", (code) => {
            code = code ?? 1;
            if (!exitCallback) {
              process2.exit(code);
            } else {
              exitCallback(
                new CommanderError2(
                  code,
                  "commander.executeSubCommandAsync",
                  "(close)"
                )
              );
            }
          });
          proc2.on("error", (err2) => {
            if (err2.code === "ENOENT") {
              const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
              const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
              throw new Error(executableMissing);
            } else if (err2.code === "EACCES") {
              throw new Error(`'${executableFile}' not executable`);
            }
            if (!exitCallback) {
              process2.exit(1);
            } else {
              const wrappedError = new CommanderError2(
                1,
                "commander.executeSubCommandAsync",
                "(error)"
              );
              wrappedError.nestedError = err2;
              exitCallback(wrappedError);
            }
          });
          this.runningCommand = proc2;
        }
        /**
         * @private
         */
        _dispatchSubcommand(commandName, operands, unknown2) {
          const subCommand = this._findCommand(commandName);
          if (!subCommand)
            this.help({ error: true });
          let promiseChain;
          promiseChain = this._chainOrCallSubCommandHook(
            promiseChain,
            subCommand,
            "preSubcommand"
          );
          promiseChain = this._chainOrCall(promiseChain, () => {
            if (subCommand._executableHandler) {
              this._executeSubCommand(subCommand, operands.concat(unknown2));
            } else {
              return subCommand._parseCommand(operands, unknown2);
            }
          });
          return promiseChain;
        }
        /**
         * Invoke help directly if possible, or dispatch if necessary.
         * e.g. help foo
         *
         * @private
         */
        _dispatchHelpCommand(subcommandName) {
          if (!subcommandName) {
            this.help();
          }
          const subCommand = this._findCommand(subcommandName);
          if (subCommand && !subCommand._executableHandler) {
            subCommand.help();
          }
          return this._dispatchSubcommand(
            subcommandName,
            [],
            [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]
          );
        }
        /**
         * Check this.args against expected this.registeredArguments.
         *
         * @private
         */
        _checkNumberOfArguments() {
          this.registeredArguments.forEach((arg, i) => {
            if (arg.required && this.args[i] == null) {
              this.missingArgument(arg.name());
            }
          });
          if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
            return;
          }
          if (this.args.length > this.registeredArguments.length) {
            this._excessArguments(this.args);
          }
        }
        /**
         * Process this.args using this.registeredArguments and save as this.processedArgs!
         *
         * @private
         */
        _processArguments() {
          const myParseArg = (argument, value, previous) => {
            let parsedValue = value;
            if (value !== null && argument.parseArg) {
              const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
              parsedValue = this._callParseArg(
                argument,
                value,
                previous,
                invalidValueMessage
              );
            }
            return parsedValue;
          };
          this._checkNumberOfArguments();
          const processedArgs = [];
          this.registeredArguments.forEach((declaredArg, index) => {
            let value = declaredArg.defaultValue;
            if (declaredArg.variadic) {
              if (index < this.args.length) {
                value = this.args.slice(index);
                if (declaredArg.parseArg) {
                  value = value.reduce((processed, v) => {
                    return myParseArg(declaredArg, v, processed);
                  }, declaredArg.defaultValue);
                }
              } else if (value === void 0) {
                value = [];
              }
            } else if (index < this.args.length) {
              value = this.args[index];
              if (declaredArg.parseArg) {
                value = myParseArg(declaredArg, value, declaredArg.defaultValue);
              }
            }
            processedArgs[index] = value;
          });
          this.processedArgs = processedArgs;
        }
        /**
         * Once we have a promise we chain, but call synchronously until then.
         *
         * @param {(Promise|undefined)} promise
         * @param {Function} fn
         * @return {(Promise|undefined)}
         * @private
         */
        _chainOrCall(promise, fn) {
          if (promise && promise.then && typeof promise.then === "function") {
            return promise.then(() => fn());
          }
          return fn();
        }
        /**
         *
         * @param {(Promise|undefined)} promise
         * @param {string} event
         * @return {(Promise|undefined)}
         * @private
         */
        _chainOrCallHooks(promise, event) {
          let result = promise;
          const hooks = [];
          this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
            hookedCommand._lifeCycleHooks[event].forEach((callback) => {
              hooks.push({ hookedCommand, callback });
            });
          });
          if (event === "postAction") {
            hooks.reverse();
          }
          hooks.forEach((hookDetail) => {
            result = this._chainOrCall(result, () => {
              return hookDetail.callback(hookDetail.hookedCommand, this);
            });
          });
          return result;
        }
        /**
         *
         * @param {(Promise|undefined)} promise
         * @param {Command} subCommand
         * @param {string} event
         * @return {(Promise|undefined)}
         * @private
         */
        _chainOrCallSubCommandHook(promise, subCommand, event) {
          let result = promise;
          if (this._lifeCycleHooks[event] !== void 0) {
            this._lifeCycleHooks[event].forEach((hook) => {
              result = this._chainOrCall(result, () => {
                return hook(this, subCommand);
              });
            });
          }
          return result;
        }
        /**
         * Process arguments in context of this command.
         * Returns action result, in case it is a promise.
         *
         * @private
         */
        _parseCommand(operands, unknown2) {
          const parsed = this.parseOptions(unknown2);
          this._parseOptionsEnv();
          this._parseOptionsImplied();
          operands = operands.concat(parsed.operands);
          unknown2 = parsed.unknown;
          this.args = operands.concat(unknown2);
          if (operands && this._findCommand(operands[0])) {
            return this._dispatchSubcommand(operands[0], operands.slice(1), unknown2);
          }
          if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
            return this._dispatchHelpCommand(operands[1]);
          }
          if (this._defaultCommandName) {
            this._outputHelpIfRequested(unknown2);
            return this._dispatchSubcommand(
              this._defaultCommandName,
              operands,
              unknown2
            );
          }
          if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
            this.help({ error: true });
          }
          this._outputHelpIfRequested(parsed.unknown);
          this._checkForMissingMandatoryOptions();
          this._checkForConflictingOptions();
          const checkForUnknownOptions = () => {
            if (parsed.unknown.length > 0) {
              this.unknownOption(parsed.unknown[0]);
            }
          };
          const commandEvent = `command:${this.name()}`;
          if (this._actionHandler) {
            checkForUnknownOptions();
            this._processArguments();
            let promiseChain;
            promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
            promiseChain = this._chainOrCall(
              promiseChain,
              () => this._actionHandler(this.processedArgs)
            );
            if (this.parent) {
              promiseChain = this._chainOrCall(promiseChain, () => {
                this.parent.emit(commandEvent, operands, unknown2);
              });
            }
            promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
            return promiseChain;
          }
          if (this.parent && this.parent.listenerCount(commandEvent)) {
            checkForUnknownOptions();
            this._processArguments();
            this.parent.emit(commandEvent, operands, unknown2);
          } else if (operands.length) {
            if (this._findCommand("*")) {
              return this._dispatchSubcommand("*", operands, unknown2);
            }
            if (this.listenerCount("command:*")) {
              this.emit("command:*", operands, unknown2);
            } else if (this.commands.length) {
              this.unknownCommand();
            } else {
              checkForUnknownOptions();
              this._processArguments();
            }
          } else if (this.commands.length) {
            checkForUnknownOptions();
            this.help({ error: true });
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        }
        /**
         * Find matching command.
         *
         * @private
         * @return {Command | undefined}
         */
        _findCommand(name) {
          if (!name)
            return void 0;
          return this.commands.find(
            (cmd) => cmd._name === name || cmd._aliases.includes(name)
          );
        }
        /**
         * Return an option matching `arg` if any.
         *
         * @param {string} arg
         * @return {Option}
         * @package
         */
        _findOption(arg) {
          return this.options.find((option) => option.is(arg));
        }
        /**
         * Display an error message if a mandatory option does not have a value.
         * Called after checking for help flags in leaf subcommand.
         *
         * @private
         */
        _checkForMissingMandatoryOptions() {
          this._getCommandAndAncestors().forEach((cmd) => {
            cmd.options.forEach((anOption) => {
              if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
                cmd.missingMandatoryOptionValue(anOption);
              }
            });
          });
        }
        /**
         * Display an error message if conflicting options are used together in this.
         *
         * @private
         */
        _checkForConflictingLocalOptions() {
          const definedNonDefaultOptions = this.options.filter((option) => {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0) {
              return false;
            }
            return this.getOptionValueSource(optionKey) !== "default";
          });
          const optionsWithConflicting = definedNonDefaultOptions.filter(
            (option) => option.conflictsWith.length > 0
          );
          optionsWithConflicting.forEach((option) => {
            const conflictingAndDefined = definedNonDefaultOptions.find(
              (defined) => option.conflictsWith.includes(defined.attributeName())
            );
            if (conflictingAndDefined) {
              this._conflictingOption(option, conflictingAndDefined);
            }
          });
        }
        /**
         * Display an error message if conflicting options are used together.
         * Called after checking for help flags in leaf subcommand.
         *
         * @private
         */
        _checkForConflictingOptions() {
          this._getCommandAndAncestors().forEach((cmd) => {
            cmd._checkForConflictingLocalOptions();
          });
        }
        /**
         * Parse options from `argv` removing known options,
         * and return argv split into operands and unknown arguments.
         *
         * Examples:
         *
         *     argv => operands, unknown
         *     --known kkk op => [op], []
         *     op --known kkk => [op], []
         *     sub --unknown uuu op => [sub], [--unknown uuu op]
         *     sub -- --unknown uuu op => [sub --unknown uuu op], []
         *
         * @param {string[]} argv
         * @return {{operands: string[], unknown: string[]}}
         */
        parseOptions(argv) {
          const operands = [];
          const unknown2 = [];
          let dest = operands;
          const args = argv.slice();
          function maybeOption(arg) {
            return arg.length > 1 && arg[0] === "-";
          }
          let activeVariadicOption = null;
          while (args.length) {
            const arg = args.shift();
            if (arg === "--") {
              if (dest === unknown2)
                dest.push(arg);
              dest.push(...args);
              break;
            }
            if (activeVariadicOption && !maybeOption(arg)) {
              this.emit(`option:${activeVariadicOption.name()}`, arg);
              continue;
            }
            activeVariadicOption = null;
            if (maybeOption(arg)) {
              const option = this._findOption(arg);
              if (option) {
                if (option.required) {
                  const value = args.shift();
                  if (value === void 0)
                    this.optionMissingArgument(option);
                  this.emit(`option:${option.name()}`, value);
                } else if (option.optional) {
                  let value = null;
                  if (args.length > 0 && !maybeOption(args[0])) {
                    value = args.shift();
                  }
                  this.emit(`option:${option.name()}`, value);
                } else {
                  this.emit(`option:${option.name()}`);
                }
                activeVariadicOption = option.variadic ? option : null;
                continue;
              }
            }
            if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
              const option = this._findOption(`-${arg[1]}`);
              if (option) {
                if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                  this.emit(`option:${option.name()}`, arg.slice(2));
                } else {
                  this.emit(`option:${option.name()}`);
                  args.unshift(`-${arg.slice(2)}`);
                }
                continue;
              }
            }
            if (/^--[^=]+=/.test(arg)) {
              const index = arg.indexOf("=");
              const option = this._findOption(arg.slice(0, index));
              if (option && (option.required || option.optional)) {
                this.emit(`option:${option.name()}`, arg.slice(index + 1));
                continue;
              }
            }
            if (maybeOption(arg)) {
              dest = unknown2;
            }
            if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown2.length === 0) {
              if (this._findCommand(arg)) {
                operands.push(arg);
                if (args.length > 0)
                  unknown2.push(...args);
                break;
              } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
                operands.push(arg);
                if (args.length > 0)
                  operands.push(...args);
                break;
              } else if (this._defaultCommandName) {
                unknown2.push(arg);
                if (args.length > 0)
                  unknown2.push(...args);
                break;
              }
            }
            if (this._passThroughOptions) {
              dest.push(arg);
              if (args.length > 0)
                dest.push(...args);
              break;
            }
            dest.push(arg);
          }
          return { operands, unknown: unknown2 };
        }
        /**
         * Return an object containing local option values as key-value pairs.
         *
         * @return {object}
         */
        opts() {
          if (this._storeOptionsAsProperties) {
            const result = {};
            const len = this.options.length;
            for (let i = 0; i < len; i++) {
              const key = this.options[i].attributeName();
              result[key] = key === this._versionOptionName ? this._version : this[key];
            }
            return result;
          }
          return this._optionValues;
        }
        /**
         * Return an object containing merged local and global option values as key-value pairs.
         *
         * @return {object}
         */
        optsWithGlobals() {
          return this._getCommandAndAncestors().reduce(
            (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
            {}
          );
        }
        /**
         * Display error message and exit (or call exitOverride).
         *
         * @param {string} message
         * @param {object} [errorOptions]
         * @param {string} [errorOptions.code] - an id string representing the error
         * @param {number} [errorOptions.exitCode] - used with process.exit
         */
        error(message, errorOptions) {
          this._outputConfiguration.outputError(
            `${message}
`,
            this._outputConfiguration.writeErr
          );
          if (typeof this._showHelpAfterError === "string") {
            this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
          } else if (this._showHelpAfterError) {
            this._outputConfiguration.writeErr("\n");
            this.outputHelp({ error: true });
          }
          const config = errorOptions || {};
          const exitCode = config.exitCode || 1;
          const code = config.code || "commander.error";
          this._exit(exitCode, code, message);
        }
        /**
         * Apply any option related environment variables, if option does
         * not have a value from cli or client code.
         *
         * @private
         */
        _parseOptionsEnv() {
          this.options.forEach((option) => {
            if (option.envVar && option.envVar in process2.env) {
              const optionKey = option.attributeName();
              if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(
                this.getOptionValueSource(optionKey)
              )) {
                if (option.required || option.optional) {
                  this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
                } else {
                  this.emit(`optionEnv:${option.name()}`);
                }
              }
            }
          });
        }
        /**
         * Apply any implied option values, if option is undefined or default value.
         *
         * @private
         */
        _parseOptionsImplied() {
          const dualHelper = new DualOptions(this.options);
          const hasCustomOptionValue = (optionKey) => {
            return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
          };
          this.options.filter(
            (option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(
              this.getOptionValue(option.attributeName()),
              option
            )
          ).forEach((option) => {
            Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
              this.setOptionValueWithSource(
                impliedKey,
                option.implied[impliedKey],
                "implied"
              );
            });
          });
        }
        /**
         * Argument `name` is missing.
         *
         * @param {string} name
         * @private
         */
        missingArgument(name) {
          const message = `error: missing required argument '${name}'`;
          this.error(message, { code: "commander.missingArgument" });
        }
        /**
         * `Option` is missing an argument.
         *
         * @param {Option} option
         * @private
         */
        optionMissingArgument(option) {
          const message = `error: option '${option.flags}' argument missing`;
          this.error(message, { code: "commander.optionMissingArgument" });
        }
        /**
         * `Option` does not have a value, and is a mandatory option.
         *
         * @param {Option} option
         * @private
         */
        missingMandatoryOptionValue(option) {
          const message = `error: required option '${option.flags}' not specified`;
          this.error(message, { code: "commander.missingMandatoryOptionValue" });
        }
        /**
         * `Option` conflicts with another option.
         *
         * @param {Option} option
         * @param {Option} conflictingOption
         * @private
         */
        _conflictingOption(option, conflictingOption) {
          const findBestOptionFromValue = (option2) => {
            const optionKey = option2.attributeName();
            const optionValue = this.getOptionValue(optionKey);
            const negativeOption = this.options.find(
              (target) => target.negate && optionKey === target.attributeName()
            );
            const positiveOption = this.options.find(
              (target) => !target.negate && optionKey === target.attributeName()
            );
            if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
              return negativeOption;
            }
            return positiveOption || option2;
          };
          const getErrorMessage = (option2) => {
            const bestOption = findBestOptionFromValue(option2);
            const optionKey = bestOption.attributeName();
            const source = this.getOptionValueSource(optionKey);
            if (source === "env") {
              return `environment variable '${bestOption.envVar}'`;
            }
            return `option '${bestOption.flags}'`;
          };
          const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
          this.error(message, { code: "commander.conflictingOption" });
        }
        /**
         * Unknown option `flag`.
         *
         * @param {string} flag
         * @private
         */
        unknownOption(flag) {
          if (this._allowUnknownOption)
            return;
          let suggestion = "";
          if (flag.startsWith("--") && this._showSuggestionAfterError) {
            let candidateFlags = [];
            let command = this;
            do {
              const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
              candidateFlags = candidateFlags.concat(moreFlags);
              command = command.parent;
            } while (command && !command._enablePositionalOptions);
            suggestion = suggestSimilar(flag, candidateFlags);
          }
          const message = `error: unknown option '${flag}'${suggestion}`;
          this.error(message, { code: "commander.unknownOption" });
        }
        /**
         * Excess arguments, more than expected.
         *
         * @param {string[]} receivedArgs
         * @private
         */
        _excessArguments(receivedArgs) {
          if (this._allowExcessArguments)
            return;
          const expected = this.registeredArguments.length;
          const s = expected === 1 ? "" : "s";
          const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
          const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
          this.error(message, { code: "commander.excessArguments" });
        }
        /**
         * Unknown command.
         *
         * @private
         */
        unknownCommand() {
          const unknownName = this.args[0];
          let suggestion = "";
          if (this._showSuggestionAfterError) {
            const candidateNames = [];
            this.createHelp().visibleCommands(this).forEach((command) => {
              candidateNames.push(command.name());
              if (command.alias())
                candidateNames.push(command.alias());
            });
            suggestion = suggestSimilar(unknownName, candidateNames);
          }
          const message = `error: unknown command '${unknownName}'${suggestion}`;
          this.error(message, { code: "commander.unknownCommand" });
        }
        /**
         * Get or set the program version.
         *
         * This method auto-registers the "-V, --version" option which will print the version number.
         *
         * You can optionally supply the flags and description to override the defaults.
         *
         * @param {string} [str]
         * @param {string} [flags]
         * @param {string} [description]
         * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
         */
        version(str, flags, description) {
          if (str === void 0)
            return this._version;
          this._version = str;
          flags = flags || "-V, --version";
          description = description || "output the version number";
          const versionOption = this.createOption(flags, description);
          this._versionOptionName = versionOption.attributeName();
          this._registerOption(versionOption);
          this.on("option:" + versionOption.name(), () => {
            this._outputConfiguration.writeOut(`${str}
`);
            this._exit(0, "commander.version", str);
          });
          return this;
        }
        /**
         * Set the description.
         *
         * @param {string} [str]
         * @param {object} [argsDescription]
         * @return {(string|Command)}
         */
        description(str, argsDescription) {
          if (str === void 0 && argsDescription === void 0)
            return this._description;
          this._description = str;
          if (argsDescription) {
            this._argsDescription = argsDescription;
          }
          return this;
        }
        /**
         * Set the summary. Used when listed as subcommand of parent.
         *
         * @param {string} [str]
         * @return {(string|Command)}
         */
        summary(str) {
          if (str === void 0)
            return this._summary;
          this._summary = str;
          return this;
        }
        /**
         * Set an alias for the command.
         *
         * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
         *
         * @param {string} [alias]
         * @return {(string|Command)}
         */
        alias(alias) {
          if (alias === void 0)
            return this._aliases[0];
          let command = this;
          if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
            command = this.commands[this.commands.length - 1];
          }
          if (alias === command._name)
            throw new Error("Command alias can't be the same as its name");
          const matchingCommand = this.parent?._findCommand(alias);
          if (matchingCommand) {
            const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
            throw new Error(
              `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`
            );
          }
          command._aliases.push(alias);
          return this;
        }
        /**
         * Set aliases for the command.
         *
         * Only the first alias is shown in the auto-generated help.
         *
         * @param {string[]} [aliases]
         * @return {(string[]|Command)}
         */
        aliases(aliases) {
          if (aliases === void 0)
            return this._aliases;
          aliases.forEach((alias) => this.alias(alias));
          return this;
        }
        /**
         * Set / get the command usage `str`.
         *
         * @param {string} [str]
         * @return {(string|Command)}
         */
        usage(str) {
          if (str === void 0) {
            if (this._usage)
              return this._usage;
            const args = this.registeredArguments.map((arg) => {
              return humanReadableArgName(arg);
            });
            return [].concat(
              this.options.length || this._helpOption !== null ? "[options]" : [],
              this.commands.length ? "[command]" : [],
              this.registeredArguments.length ? args : []
            ).join(" ");
          }
          this._usage = str;
          return this;
        }
        /**
         * Get or set the name of the command.
         *
         * @param {string} [str]
         * @return {(string|Command)}
         */
        name(str) {
          if (str === void 0)
            return this._name;
          this._name = str;
          return this;
        }
        /**
         * Set the name of the command from script filename, such as process.argv[1],
         * or require.main.filename, or __filename.
         *
         * (Used internally and public although not documented in README.)
         *
         * @example
         * program.nameFromFilename(require.main.filename);
         *
         * @param {string} filename
         * @return {Command}
         */
        nameFromFilename(filename) {
          this._name = path6.basename(filename, path6.extname(filename));
          return this;
        }
        /**
         * Get or set the directory for searching for executable subcommands of this command.
         *
         * @example
         * program.executableDir(__dirname);
         * // or
         * program.executableDir('subcommands');
         *
         * @param {string} [path]
         * @return {(string|null|Command)}
         */
        executableDir(path7) {
          if (path7 === void 0)
            return this._executableDir;
          this._executableDir = path7;
          return this;
        }
        /**
         * Return program help documentation.
         *
         * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
         * @return {string}
         */
        helpInformation(contextOptions) {
          const helper2 = this.createHelp();
          if (helper2.helpWidth === void 0) {
            helper2.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
          }
          return helper2.formatHelp(this, helper2);
        }
        /**
         * @private
         */
        _getHelpContext(contextOptions) {
          contextOptions = contextOptions || {};
          const context2 = { error: !!contextOptions.error };
          let write;
          if (context2.error) {
            write = (arg) => this._outputConfiguration.writeErr(arg);
          } else {
            write = (arg) => this._outputConfiguration.writeOut(arg);
          }
          context2.write = contextOptions.write || write;
          context2.command = this;
          return context2;
        }
        /**
         * Output help information for this command.
         *
         * Outputs built-in help, and custom text added using `.addHelpText()`.
         *
         * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
         */
        outputHelp(contextOptions) {
          let deprecatedCallback;
          if (typeof contextOptions === "function") {
            deprecatedCallback = contextOptions;
            contextOptions = void 0;
          }
          const context2 = this._getHelpContext(contextOptions);
          this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context2));
          this.emit("beforeHelp", context2);
          let helpInformation = this.helpInformation(context2);
          if (deprecatedCallback) {
            helpInformation = deprecatedCallback(helpInformation);
            if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
              throw new Error("outputHelp callback must return a string or a Buffer");
            }
          }
          context2.write(helpInformation);
          if (this._getHelpOption()?.long) {
            this.emit(this._getHelpOption().long);
          }
          this.emit("afterHelp", context2);
          this._getCommandAndAncestors().forEach(
            (command) => command.emit("afterAllHelp", context2)
          );
        }
        /**
         * You can pass in flags and a description to customise the built-in help option.
         * Pass in false to disable the built-in help option.
         *
         * @example
         * program.helpOption('-?, --help' 'show help'); // customise
         * program.helpOption(false); // disable
         *
         * @param {(string | boolean)} flags
         * @param {string} [description]
         * @return {Command} `this` command for chaining
         */
        helpOption(flags, description) {
          if (typeof flags === "boolean") {
            if (flags) {
              this._helpOption = this._helpOption ?? void 0;
            } else {
              this._helpOption = null;
            }
            return this;
          }
          flags = flags ?? "-h, --help";
          description = description ?? "display help for command";
          this._helpOption = this.createOption(flags, description);
          return this;
        }
        /**
         * Lazy create help option.
         * Returns null if has been disabled with .helpOption(false).
         *
         * @returns {(Option | null)} the help option
         * @package
         */
        _getHelpOption() {
          if (this._helpOption === void 0) {
            this.helpOption(void 0, void 0);
          }
          return this._helpOption;
        }
        /**
         * Supply your own option to use for the built-in help option.
         * This is an alternative to using helpOption() to customise the flags and description etc.
         *
         * @param {Option} option
         * @return {Command} `this` command for chaining
         */
        addHelpOption(option) {
          this._helpOption = option;
          return this;
        }
        /**
         * Output help information and exit.
         *
         * Outputs built-in help, and custom text added using `.addHelpText()`.
         *
         * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
         */
        help(contextOptions) {
          this.outputHelp(contextOptions);
          let exitCode = process2.exitCode || 0;
          if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
            exitCode = 1;
          }
          this._exit(exitCode, "commander.help", "(outputHelp)");
        }
        /**
         * Add additional text to be displayed with the built-in help.
         *
         * Position is 'before' or 'after' to affect just this command,
         * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
         *
         * @param {string} position - before or after built-in help
         * @param {(string | Function)} text - string to add, or a function returning a string
         * @return {Command} `this` command for chaining
         */
        addHelpText(position, text) {
          const allowedValues = ["beforeAll", "before", "after", "afterAll"];
          if (!allowedValues.includes(position)) {
            throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
          }
          const helpEvent = `${position}Help`;
          this.on(helpEvent, (context2) => {
            let helpStr;
            if (typeof text === "function") {
              helpStr = text({ error: context2.error, command: context2.command });
            } else {
              helpStr = text;
            }
            if (helpStr) {
              context2.write(`${helpStr}
`);
            }
          });
          return this;
        }
        /**
         * Output help information if help flags specified
         *
         * @param {Array} args - array of options to search for help flags
         * @private
         */
        _outputHelpIfRequested(args) {
          const helpOption = this._getHelpOption();
          const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
          if (helpRequested) {
            this.outputHelp();
            this._exit(0, "commander.helpDisplayed", "(outputHelp)");
          }
        }
      };
      function incrementNodeInspectorPort(args) {
        return args.map((arg) => {
          if (!arg.startsWith("--inspect")) {
            return arg;
          }
          let debugOption;
          let debugHost = "127.0.0.1";
          let debugPort = "9229";
          let match3;
          if ((match3 = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
            debugOption = match3[1];
          } else if ((match3 = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
            debugOption = match3[1];
            if (/^\d+$/.test(match3[3])) {
              debugPort = match3[3];
            } else {
              debugHost = match3[3];
            }
          } else if ((match3 = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
            debugOption = match3[1];
            debugHost = match3[3];
            debugPort = match3[4];
          }
          if (debugOption && debugPort !== "0") {
            return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
          }
          return arg;
        });
      }
      exports.Command = Command2;
    }
  });

  // ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/index.js
  var require_commander = __commonJS({
    "../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/index.js"(exports) {
      var { Argument: Argument2 } = require_argument();
      var { Command: Command2 } = require_command();
      var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var { Help: Help2 } = require_help();
      var { Option: Option2 } = require_option();
      exports.program = new Command2();
      exports.createCommand = (name) => new Command2(name);
      exports.createOption = (flags, description) => new Option2(flags, description);
      exports.createArgument = (name, description) => new Argument2(name, description);
      exports.Command = Command2;
      exports.Option = Option2;
      exports.Argument = Argument2;
      exports.Help = Help2;
      exports.CommanderError = CommanderError2;
      exports.InvalidArgumentError = InvalidArgumentError2;
      exports.InvalidOptionArgumentError = InvalidArgumentError2;
    }
  });

  // ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
      "use strict";
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
  var require_brace_expansion = __commonJS({
    "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module) {
      var balanced = require_balanced_match();
      module.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand2(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand2(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m)
          return [str];
        var pre = m.pre;
        var post = m.post.length ? expand2(m.post, false) : [""];
        if (/\$$/.test(m.pre)) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
          }
        } else {
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
              str = m.pre + "{" + m.body + escClose + m.post;
              return expand2(str);
            }
            return [str];
          }
          var n;
          if (isSequence) {
            n = m.body.split(/\.\./);
          } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
              n = expand2(n[0], false).map(embrace);
              if (n.length === 1) {
                return post.map(function(p) {
                  return m.pre + n[0] + p;
                });
              }
            }
          }
          var N;
          if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
              incr *= -1;
              test = gte;
            }
            var pad = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
              var c;
              if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\")
                  c = "";
              } else {
                c = String(i);
                if (pad) {
                  var need = width - c.length;
                  if (need > 0) {
                    var z = new Array(need + 1).join("0");
                    if (i < 0)
                      c = "-" + z + c.slice(1);
                    else
                      c = z + c;
                  }
                }
              }
              N.push(c);
            }
          } else {
            N = [];
            for (var j = 0; j < n.length; j++) {
              N.push.apply(N, expand2(n[j], false));
            }
          }
          for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + N[j] + post[k];
              if (!isTop || isSequence || expansion)
                expansions.push(expansion);
            }
          }
        }
        return expansions;
      }
    }
  });

  // ../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert3(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number3, base2, endian) {
          if (BN2.isBN(number3)) {
            return number3;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number3 !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number3 || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = __require2("buffer").Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max2(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init2(number3, base2, endian) {
          if (typeof number3 === "number") {
            return this._initNumber(number3, base2, endian);
          }
          if (typeof number3 === "object") {
            return this._initArray(number3, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number3 = number3.toString().replace(/\s+/g, "");
          var start = 0;
          if (number3[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number3.length) {
            if (base2 === 16) {
              this._parseHex(number3, start, endian);
            } else {
              this._parseBase(number3, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number3, base2, endian) {
          if (number3 < 0) {
            this.negative = 1;
            number3 = -number3;
          }
          if (number3 < 67108864) {
            this.words = [number3 & 67108863];
            this.length = 1;
          } else if (number3 < 4503599627370496) {
            this.words = [
              number3 & 67108863,
              number3 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert3(number3 < 9007199254740992);
            this.words = [
              number3 & 67108863,
              number3 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN2.prototype._initArray = function _initArray(number3, base2, endian) {
          assert3(typeof number3.length === "number");
          if (number3.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number3.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number3.length - 1, j = 0; i >= 0; i -= 3) {
              w = number3[i] | number3[i - 1] << 8 | number3[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number3.length; i += 3) {
              w = number3[i] | number3[i + 1] << 8 | number3[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string2, index) {
          var c = string2.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert3(false, "Invalid character in " + string2);
          }
        }
        function parseHexByte(string2, lowerBound, index) {
          var r = parseHex4Bits(string2, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string2, index - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number3, start, endian) {
          this.length = Math.ceil((number3.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number3.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number3, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number3.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number3.length; i += 2) {
              w = parseHexByte(number3, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert3(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number3, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number3.length - start;
          var mod2 = total % limbLen;
          var end = Math.min(total, total - mod2) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number3, i, i + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod2 !== 0) {
            var pow3 = 1;
            word = parseBase(number3, i, number3.length, base2);
            for (i = 0; i < mod2; i++) {
              pow3 *= base2;
            }
            this.imuln(pow3);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone5() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect3;
          } catch (e) {
            BN2.prototype.inspect = inspect3;
          }
        } else {
          BN2.prototype.inspect = inspect3;
        }
        function inspect3() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString3(base2, padding) {
          base2 = base2 || 10;
          padding = padding | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert3(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber3() {
          var ret4 = this.words[0];
          if (this.length === 2) {
            ret4 += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret4 += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert3(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret4 : ret4;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN2.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray2(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType4, size) {
          if (ArrayType4.allocUnsafe) {
            return ArrayType4.allocUnsafe(size);
          }
          return new ArrayType4(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType4, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert3(byteLength <= reqLength, "byte array longer than desired length");
          assert3(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType4, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert3(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert3(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub3(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert3(carry === 0);
          assert3((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert3(typeof num === "number");
          assert3(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow3(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits2) {
          assert3(typeof bits2 === "number" && bits2 >= 0);
          var r = bits2 % 26;
          var s = (bits2 - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits2) {
          assert3(this.negative === 0);
          return this.iushln(bits2);
        };
        BN2.prototype.iushrn = function iushrn(bits2, hint, extended) {
          assert3(typeof bits2 === "number" && bits2 >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits2 % 26;
          var s = Math.min((bits2 - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits2, hint, extended) {
          assert3(this.negative === 0);
          return this.iushrn(bits2, hint, extended);
        };
        BN2.prototype.shln = function shln(bits2) {
          return this.clone().ishln(bits2);
        };
        BN2.prototype.ushln = function ushln(bits2) {
          return this.clone().iushln(bits2);
        };
        BN2.prototype.shrn = function shrn(bits2) {
          return this.clone().ishrn(bits2);
        };
        BN2.prototype.ushrn = function ushrn(bits2) {
          return this.clone().iushrn(bits2);
        };
        BN2.prototype.testn = function testn(bit) {
          assert3(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits2) {
          assert3(typeof bits2 === "number" && bits2 >= 0);
          var r = bits2 % 26;
          var s = (bits2 - r) / 26;
          assert3(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits2) {
          return this.clone().imaskn(bits2);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert3(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert3(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod2, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod2 = res.mod.neg();
              if (positive && mod2.negative !== 0) {
                mod2.iadd(num);
              }
            }
            return {
              div,
              mod: mod2
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod2 = res.mod.neg();
              if (positive && mod2.negative !== 0) {
                mod2.isub(num);
              }
            }
            return {
              div: res.div,
              mod: mod2
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod2(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod2.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert3(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert3(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert3(p.negative === 0);
          assert3(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert3(p.negative === 0);
          assert3(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert3(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert3(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt3(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq3(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          assert3(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert3(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert3(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert3(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert3(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert3(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert3(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert3(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert3(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert3(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert3(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert3(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert3(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split3(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split3(input, output2) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output2.words[i] = input.words[i];
          }
          output2.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output2.words[output2.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert3(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert3(a.negative === 0, "red works only with positives");
          assert3(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert3((a.negative | b.negative) === 0, "red works only with positives");
          assert3(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub3(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert3(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow3 = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow3);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert3(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert3(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow3(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/utils.js
  var require_utils = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/utils.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.extend = extend;
      exports.indexOf = indexOf;
      exports.escapeExpression = escapeExpression;
      exports.isEmpty = isEmpty;
      exports.createFrame = createFrame;
      exports.blockParams = blockParams;
      exports.appendContextPath = appendContextPath;
      var escape2 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      var badChars = /[&<>"'`=]/g;
      var possible = /[&<>"'`=]/;
      function escapeChar(chr) {
        return escape2[chr];
      }
      function extend(obj) {
        for (var i = 1; i < arguments.length; i++) {
          for (var key in arguments[i]) {
            if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
              obj[key] = arguments[i][key];
            }
          }
        }
        return obj;
      }
      var toString3 = Object.prototype.toString;
      exports.toString = toString3;
      var isFunction = function isFunction2(value) {
        return typeof value === "function";
      };
      if (isFunction(/x/)) {
        exports.isFunction = isFunction = function(value) {
          return typeof value === "function" && toString3.call(value) === "[object Function]";
        };
      }
      exports.isFunction = isFunction;
      var isArray = Array.isArray || function(value) {
        return value && typeof value === "object" ? toString3.call(value) === "[object Array]" : false;
      };
      exports.isArray = isArray;
      function indexOf(array2, value) {
        for (var i = 0, len = array2.length; i < len; i++) {
          if (array2[i] === value) {
            return i;
          }
        }
        return -1;
      }
      function escapeExpression(string2) {
        if (typeof string2 !== "string") {
          if (string2 && string2.toHTML) {
            return string2.toHTML();
          } else if (string2 == null) {
            return "";
          } else if (!string2) {
            return string2 + "";
          }
          string2 = "" + string2;
        }
        if (!possible.test(string2)) {
          return string2;
        }
        return string2.replace(badChars, escapeChar);
      }
      function isEmpty(value) {
        if (!value && value !== 0) {
          return true;
        } else if (isArray(value) && value.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      function createFrame(object2) {
        var frame = extend({}, object2);
        frame._parent = object2;
        return frame;
      }
      function blockParams(params, ids) {
        params.path = ids;
        return params;
      }
      function appendContextPath(contextPath, id) {
        return (contextPath ? contextPath + "." : "") + id;
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/exception.js
  var require_exception = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/exception.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
      function Exception(message, node2) {
        var loc = node2 && node2.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
        if (loc) {
          line = loc.start.line;
          endLineNumber = loc.end.line;
          column = loc.start.column;
          endColumn = loc.end.column;
          message += " - " + line + ":" + column;
        }
        var tmp = Error.prototype.constructor.call(this, message);
        for (var idx = 0; idx < errorProps.length; idx++) {
          this[errorProps[idx]] = tmp[errorProps[idx]];
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, Exception);
        }
        try {
          if (loc) {
            this.lineNumber = line;
            this.endLineNumber = endLineNumber;
            if (Object.defineProperty) {
              Object.defineProperty(this, "column", {
                value: column,
                enumerable: true
              });
              Object.defineProperty(this, "endColumn", {
                value: endColumn,
                enumerable: true
              });
            } else {
              this.column = column;
              this.endColumn = endColumn;
            }
          }
        } catch (nop) {
        }
      }
      Exception.prototype = new Error();
      exports["default"] = Exception;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
  var require_block_helper_missing = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      exports["default"] = function(instance) {
        instance.registerHelper("blockHelperMissing", function(context2, options) {
          var inverse = options.inverse, fn = options.fn;
          if (context2 === true) {
            return fn(this);
          } else if (context2 === false || context2 == null) {
            return inverse(this);
          } else if (_utils.isArray(context2)) {
            if (context2.length > 0) {
              if (options.ids) {
                options.ids = [options.name];
              }
              return instance.helpers.each(context2, options);
            } else {
              return inverse(this);
            }
          } else {
            if (options.data && options.ids) {
              var data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
              options = { data };
            }
            return fn(context2, options);
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
  var require_each = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/each.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("each", function(context2, options) {
          if (!options) {
            throw new _exception2["default"]("Must pass iterator to #each");
          }
          var fn = options.fn, inverse = options.inverse, i = 0, ret4 = "", data = void 0, contextPath = void 0;
          if (options.data && options.ids) {
            contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
          }
          if (_utils.isFunction(context2)) {
            context2 = context2.call(this);
          }
          if (options.data) {
            data = _utils.createFrame(options.data);
          }
          function execIteration(field, index, last) {
            if (data) {
              data.key = field;
              data.index = index;
              data.first = index === 0;
              data.last = !!last;
              if (contextPath) {
                data.contextPath = contextPath + field;
              }
            }
            ret4 = ret4 + fn(context2[field], {
              data,
              blockParams: _utils.blockParams([context2[field], field], [contextPath + field, null])
            });
          }
          if (context2 && typeof context2 === "object") {
            if (_utils.isArray(context2)) {
              for (var j = context2.length; i < j; i++) {
                if (i in context2) {
                  execIteration(i, i, i === context2.length - 1);
                }
              }
            } else if (typeof Symbol === "function" && context2[Symbol.iterator]) {
              var newContext = [];
              var iterator = context2[Symbol.iterator]();
              for (var it = iterator.next(); !it.done; it = iterator.next()) {
                newContext.push(it.value);
              }
              context2 = newContext;
              for (var j = context2.length; i < j; i++) {
                execIteration(i, i, i === context2.length - 1);
              }
            } else {
              (function() {
                var priorKey = void 0;
                Object.keys(context2).forEach(function(key) {
                  if (priorKey !== void 0) {
                    execIteration(priorKey, i - 1);
                  }
                  priorKey = key;
                  i++;
                });
                if (priorKey !== void 0) {
                  execIteration(priorKey, i - 1, true);
                }
              })();
            }
          }
          if (i === 0) {
            ret4 = inverse(this);
          }
          return ret4;
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
  var require_helper_missing = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("helperMissing", function() {
          if (arguments.length === 1) {
            return void 0;
          } else {
            throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
  var require_if = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/if.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("if", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#if requires exactly one argument");
          }
          if (_utils.isFunction(conditional)) {
            conditional = conditional.call(this);
          }
          if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
            return options.inverse(this);
          } else {
            return options.fn(this);
          }
        });
        instance.registerHelper("unless", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#unless requires exactly one argument");
          }
          return instance.helpers["if"].call(this, conditional, {
            fn: options.inverse,
            inverse: options.fn,
            hash: options.hash
          });
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
  var require_log = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/log.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("log", function() {
          var args = [void 0], options = arguments[arguments.length - 1];
          for (var i = 0; i < arguments.length - 1; i++) {
            args.push(arguments[i]);
          }
          var level = 1;
          if (options.hash.level != null) {
            level = options.hash.level;
          } else if (options.data && options.data.level != null) {
            level = options.data.level;
          }
          args[0] = level;
          instance.log.apply(instance, args);
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
  var require_lookup = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("lookup", function(obj, field, options) {
          if (!obj) {
            return obj;
          }
          return options.lookupProperty(obj, field);
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
  var require_with = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/with.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("with", function(context2, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#with requires exactly one argument");
          }
          if (_utils.isFunction(context2)) {
            context2 = context2.call(this);
          }
          var fn = options.fn;
          if (!_utils.isEmpty(context2)) {
            var data = options.data;
            if (options.data && options.ids) {
              data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
            }
            return fn(context2, {
              data,
              blockParams: _utils.blockParams([context2], [data && data.contextPath])
            });
          } else {
            return options.inverse(this);
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers.js
  var require_helpers = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.registerDefaultHelpers = registerDefaultHelpers;
      exports.moveHelperToHooks = moveHelperToHooks;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _helpersBlockHelperMissing = require_block_helper_missing();
      var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
      var _helpersEach = require_each();
      var _helpersEach2 = _interopRequireDefault(_helpersEach);
      var _helpersHelperMissing = require_helper_missing();
      var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
      var _helpersIf = require_if();
      var _helpersIf2 = _interopRequireDefault(_helpersIf);
      var _helpersLog = require_log();
      var _helpersLog2 = _interopRequireDefault(_helpersLog);
      var _helpersLookup = require_lookup();
      var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
      var _helpersWith = require_with();
      var _helpersWith2 = _interopRequireDefault(_helpersWith);
      function registerDefaultHelpers(instance) {
        _helpersBlockHelperMissing2["default"](instance);
        _helpersEach2["default"](instance);
        _helpersHelperMissing2["default"](instance);
        _helpersIf2["default"](instance);
        _helpersLog2["default"](instance);
        _helpersLookup2["default"](instance);
        _helpersWith2["default"](instance);
      }
      function moveHelperToHooks(instance, helperName, keepHelper) {
        if (instance.helpers[helperName]) {
          instance.hooks[helperName] = instance.helpers[helperName];
          if (!keepHelper) {
            delete instance.helpers[helperName];
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
  var require_inline = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      exports["default"] = function(instance) {
        instance.registerDecorator("inline", function(fn, props, container, options) {
          var ret4 = fn;
          if (!props.partials) {
            props.partials = {};
            ret4 = function(context2, options2) {
              var original = container.partials;
              container.partials = _utils.extend({}, original, props.partials);
              var ret5 = fn(context2, options2);
              container.partials = original;
              return ret5;
            };
          }
          props.partials[options.args[0]] = options.fn;
          return ret4;
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/decorators.js
  var require_decorators = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/decorators.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.registerDefaultDecorators = registerDefaultDecorators;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _decoratorsInline = require_inline();
      var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
      function registerDefaultDecorators(instance) {
        _decoratorsInline2["default"](instance);
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/logger.js
  var require_logger = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/logger.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      var logger = {
        methodMap: ["debug", "info", "warn", "error"],
        level: "info",
        // Maps a given level value to the `methodMap` indexes above.
        lookupLevel: function lookupLevel(level) {
          if (typeof level === "string") {
            var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
            if (levelMap >= 0) {
              level = levelMap;
            } else {
              level = parseInt(level, 10);
            }
          }
          return level;
        },
        // Can be overridden in the host environment
        log: function log4(level) {
          level = logger.lookupLevel(level);
          if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
            var method = logger.methodMap[level];
            if (!console[method]) {
              method = "log";
            }
            for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              message[_key - 1] = arguments[_key];
            }
            console[method].apply(console, message);
          }
        }
      };
      exports["default"] = logger;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
  var require_create_new_lookup_object = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.createNewLookupObject = createNewLookupObject;
      var _utils = require_utils();
      function createNewLookupObject() {
        for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
  var require_proto_access = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.createProtoAccessControl = createProtoAccessControl;
      exports.resultIsAllowed = resultIsAllowed;
      exports.resetLoggedProperties = resetLoggedProperties;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _createNewLookupObject = require_create_new_lookup_object();
      var _logger = require_logger();
      var _logger2 = _interopRequireDefault(_logger);
      var loggedProperties = /* @__PURE__ */ Object.create(null);
      function createProtoAccessControl(runtimeOptions) {
        var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
        defaultMethodWhiteList["constructor"] = false;
        defaultMethodWhiteList["__defineGetter__"] = false;
        defaultMethodWhiteList["__defineSetter__"] = false;
        defaultMethodWhiteList["__lookupGetter__"] = false;
        var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
        defaultPropertyWhiteList["__proto__"] = false;
        return {
          properties: {
            whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
            defaultValue: runtimeOptions.allowProtoPropertiesByDefault
          },
          methods: {
            whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
            defaultValue: runtimeOptions.allowProtoMethodsByDefault
          }
        };
      }
      function resultIsAllowed(result, protoAccessControl, propertyName) {
        if (typeof result === "function") {
          return checkWhiteList(protoAccessControl.methods, propertyName);
        } else {
          return checkWhiteList(protoAccessControl.properties, propertyName);
        }
      }
      function checkWhiteList(protoAccessControlForType, propertyName) {
        if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
          return protoAccessControlForType.whitelist[propertyName] === true;
        }
        if (protoAccessControlForType.defaultValue !== void 0) {
          return protoAccessControlForType.defaultValue;
        }
        logUnexpecedPropertyAccessOnce(propertyName);
        return false;
      }
      function logUnexpecedPropertyAccessOnce(propertyName) {
        if (loggedProperties[propertyName] !== true) {
          loggedProperties[propertyName] = true;
          _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
        }
      }
      function resetLoggedProperties() {
        Object.keys(loggedProperties).forEach(function(propertyName) {
          delete loggedProperties[propertyName];
        });
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/base.js
  var require_base = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.HandlebarsEnvironment = HandlebarsEnvironment;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _helpers = require_helpers();
      var _decorators = require_decorators();
      var _logger = require_logger();
      var _logger2 = _interopRequireDefault(_logger);
      var _internalProtoAccess = require_proto_access();
      var VERSION = "4.7.8";
      exports.VERSION = VERSION;
      var COMPILER_REVISION = 8;
      exports.COMPILER_REVISION = COMPILER_REVISION;
      var LAST_COMPATIBLE_COMPILER_REVISION = 7;
      exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
      var REVISION_CHANGES = {
        1: "<= 1.0.rc.2",
        // 1.0.rc.2 is actually rev2 but doesn't report it
        2: "== 1.0.0-rc.3",
        3: "== 1.0.0-rc.4",
        4: "== 1.x.x",
        5: "== 2.0.0-alpha.x",
        6: ">= 2.0.0-beta.1",
        7: ">= 4.0.0 <4.3.0",
        8: ">= 4.3.0"
      };
      exports.REVISION_CHANGES = REVISION_CHANGES;
      var objectType = "[object Object]";
      function HandlebarsEnvironment(helpers, partials, decorators) {
        this.helpers = helpers || {};
        this.partials = partials || {};
        this.decorators = decorators || {};
        _helpers.registerDefaultHelpers(this);
        _decorators.registerDefaultDecorators(this);
      }
      HandlebarsEnvironment.prototype = {
        constructor: HandlebarsEnvironment,
        logger: _logger2["default"],
        log: _logger2["default"].log,
        registerHelper: function registerHelper(name, fn) {
          if (_utils.toString.call(name) === objectType) {
            if (fn) {
              throw new _exception2["default"]("Arg not supported with multiple helpers");
            }
            _utils.extend(this.helpers, name);
          } else {
            this.helpers[name] = fn;
          }
        },
        unregisterHelper: function unregisterHelper(name) {
          delete this.helpers[name];
        },
        registerPartial: function registerPartial(name, partial) {
          if (_utils.toString.call(name) === objectType) {
            _utils.extend(this.partials, name);
          } else {
            if (typeof partial === "undefined") {
              throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
            }
            this.partials[name] = partial;
          }
        },
        unregisterPartial: function unregisterPartial(name) {
          delete this.partials[name];
        },
        registerDecorator: function registerDecorator(name, fn) {
          if (_utils.toString.call(name) === objectType) {
            if (fn) {
              throw new _exception2["default"]("Arg not supported with multiple decorators");
            }
            _utils.extend(this.decorators, name);
          } else {
            this.decorators[name] = fn;
          }
        },
        unregisterDecorator: function unregisterDecorator(name) {
          delete this.decorators[name];
        },
        /**
         * Reset the memory of illegal property accesses that have already been logged.
         * @deprecated should only be used in handlebars test-cases
         */
        resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
          _internalProtoAccess.resetLoggedProperties();
        }
      };
      var log4 = _logger2["default"].log;
      exports.log = log4;
      exports.createFrame = _utils.createFrame;
      exports.logger = _logger2["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/safe-string.js
  var require_safe_string = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/safe-string.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function SafeString(string2) {
        this.string = string2;
      }
      SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
        return "" + this.string;
      };
      exports["default"] = SafeString;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
  var require_wrapHelper = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.wrapHelper = wrapHelper;
      function wrapHelper(helper2, transformOptionsFn) {
        if (typeof helper2 !== "function") {
          return helper2;
        }
        var wrapper = function wrapper2() {
          var options = arguments[arguments.length - 1];
          arguments[arguments.length - 1] = transformOptionsFn(options);
          return helper2.apply(this, arguments);
        };
        return wrapper;
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/runtime.js
  var require_runtime = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/runtime.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.checkRevision = checkRevision;
      exports.template = template;
      exports.wrapProgram = wrapProgram;
      exports.resolvePartial = resolvePartial;
      exports.invokePartial = invokePartial;
      exports.noop = noop;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _utils = require_utils();
      var Utils = _interopRequireWildcard(_utils);
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _base = require_base();
      var _helpers = require_helpers();
      var _internalWrapHelper = require_wrapHelper();
      var _internalProtoAccess = require_proto_access();
      function checkRevision(compilerInfo) {
        var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
        if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
          return;
        }
        if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
          var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
          throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
        } else {
          throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
        }
      }
      function template(templateSpec, env) {
        if (!env) {
          throw new _exception2["default"]("No environment passed to template");
        }
        if (!templateSpec || !templateSpec.main) {
          throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
        }
        templateSpec.main.decorator = templateSpec.main_d;
        env.VM.checkRevision(templateSpec.compiler);
        var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
        function invokePartialWrapper(partial, context2, options) {
          if (options.hash) {
            context2 = Utils.extend({}, context2, options.hash);
            if (options.ids) {
              options.ids[0] = true;
            }
          }
          partial = env.VM.resolvePartial.call(this, partial, context2, options);
          var extendedOptions = Utils.extend({}, options, {
            hooks: this.hooks,
            protoAccessControl: this.protoAccessControl
          });
          var result = env.VM.invokePartial.call(this, partial, context2, extendedOptions);
          if (result == null && env.compile) {
            options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
            result = options.partials[options.name](context2, extendedOptions);
          }
          if (result != null) {
            if (options.indent) {
              var lines = result.split("\n");
              for (var i = 0, l = lines.length; i < l; i++) {
                if (!lines[i] && i + 1 === l) {
                  break;
                }
                lines[i] = options.indent + lines[i];
              }
              result = lines.join("\n");
            }
            return result;
          } else {
            throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
          }
        }
        var container = {
          strict: function strict(obj, name, loc) {
            if (!obj || !(name in obj)) {
              throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
                loc
              });
            }
            return container.lookupProperty(obj, name);
          },
          lookupProperty: function lookupProperty(parent, propertyName) {
            var result = parent[propertyName];
            if (result == null) {
              return result;
            }
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return result;
            }
            if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
              return result;
            }
            return void 0;
          },
          lookup: function lookup(depths, name) {
            var len = depths.length;
            for (var i = 0; i < len; i++) {
              var result = depths[i] && container.lookupProperty(depths[i], name);
              if (result != null) {
                return depths[i][name];
              }
            }
          },
          lambda: function lambda(current, context2) {
            return typeof current === "function" ? current.call(context2) : current;
          },
          escapeExpression: Utils.escapeExpression,
          invokePartial: invokePartialWrapper,
          fn: function fn(i) {
            var ret5 = templateSpec[i];
            ret5.decorator = templateSpec[i + "_d"];
            return ret5;
          },
          programs: [],
          program: function program2(i, data, declaredBlockParams, blockParams, depths) {
            var programWrapper = this.programs[i], fn = this.fn(i);
            if (data || depths || blockParams || declaredBlockParams) {
              programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
            } else if (!programWrapper) {
              programWrapper = this.programs[i] = wrapProgram(this, i, fn);
            }
            return programWrapper;
          },
          data: function data(value, depth) {
            while (value && depth--) {
              value = value._parent;
            }
            return value;
          },
          mergeIfNeeded: function mergeIfNeeded(param, common) {
            var obj = param || common;
            if (param && common && param !== common) {
              obj = Utils.extend({}, common, param);
            }
            return obj;
          },
          // An empty object to use as replacement for null-contexts
          nullContext: Object.seal({}),
          noop: env.VM.noop,
          compilerInfo: templateSpec.compiler
        };
        function ret4(context2) {
          var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          var data = options.data;
          ret4._setup(options);
          if (!options.partial && templateSpec.useData) {
            data = initData(context2, data);
          }
          var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
          if (templateSpec.useDepths) {
            if (options.depths) {
              depths = context2 != options.depths[0] ? [context2].concat(options.depths) : options.depths;
            } else {
              depths = [context2];
            }
          }
          function main(context3) {
            return "" + templateSpec.main(container, context3, container.helpers, container.partials, data, blockParams, depths);
          }
          main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
          return main(context2, options);
        }
        ret4.isTop = true;
        ret4._setup = function(options) {
          if (!options.partial) {
            var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
            wrapHelpersToPassLookupProperty(mergedHelpers, container);
            container.helpers = mergedHelpers;
            if (templateSpec.usePartial) {
              container.partials = container.mergeIfNeeded(options.partials, env.partials);
            }
            if (templateSpec.usePartial || templateSpec.useDecorators) {
              container.decorators = Utils.extend({}, env.decorators, options.decorators);
            }
            container.hooks = {};
            container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
            var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
            _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
            _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
          } else {
            container.protoAccessControl = options.protoAccessControl;
            container.helpers = options.helpers;
            container.partials = options.partials;
            container.decorators = options.decorators;
            container.hooks = options.hooks;
          }
        };
        ret4._child = function(i, data, blockParams, depths) {
          if (templateSpec.useBlockParams && !blockParams) {
            throw new _exception2["default"]("must pass block params");
          }
          if (templateSpec.useDepths && !depths) {
            throw new _exception2["default"]("must pass parent depths");
          }
          return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
        };
        return ret4;
      }
      function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
        function prog(context2) {
          var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          var currentDepths = depths;
          if (depths && context2 != depths[0] && !(context2 === container.nullContext && depths[0] === null)) {
            currentDepths = [context2].concat(depths);
          }
          return fn(container, context2, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
        }
        prog = executeDecorators(fn, prog, container, depths, data, blockParams);
        prog.program = i;
        prog.depth = depths ? depths.length : 0;
        prog.blockParams = declaredBlockParams || 0;
        return prog;
      }
      function resolvePartial(partial, context2, options) {
        if (!partial) {
          if (options.name === "@partial-block") {
            partial = options.data["partial-block"];
          } else {
            partial = options.partials[options.name];
          }
        } else if (!partial.call && !options.name) {
          options.name = partial;
          partial = options.partials[partial];
        }
        return partial;
      }
      function invokePartial(partial, context2, options) {
        var currentPartialBlock = options.data && options.data["partial-block"];
        options.partial = true;
        if (options.ids) {
          options.data.contextPath = options.ids[0] || options.data.contextPath;
        }
        var partialBlock = void 0;
        if (options.fn && options.fn !== noop) {
          (function() {
            options.data = _base.createFrame(options.data);
            var fn = options.fn;
            partialBlock = options.data["partial-block"] = function partialBlockWrapper(context3) {
              var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
              options2.data = _base.createFrame(options2.data);
              options2.data["partial-block"] = currentPartialBlock;
              return fn(context3, options2);
            };
            if (fn.partials) {
              options.partials = Utils.extend({}, options.partials, fn.partials);
            }
          })();
        }
        if (partial === void 0 && partialBlock) {
          partial = partialBlock;
        }
        if (partial === void 0) {
          throw new _exception2["default"]("The partial " + options.name + " could not be found");
        } else if (partial instanceof Function) {
          return partial(context2, options);
        }
      }
      function noop() {
        return "";
      }
      function initData(context2, data) {
        if (!data || !("root" in data)) {
          data = data ? _base.createFrame(data) : {};
          data.root = context2;
        }
        return data;
      }
      function executeDecorators(fn, prog, container, depths, data, blockParams) {
        if (fn.decorator) {
          var props = {};
          prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
          Utils.extend(prog, props);
        }
        return prog;
      }
      function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
        Object.keys(mergedHelpers).forEach(function(helperName) {
          var helper2 = mergedHelpers[helperName];
          mergedHelpers[helperName] = passLookupPropertyOption(helper2, container);
        });
      }
      function passLookupPropertyOption(helper2, container) {
        var lookupProperty = container.lookupProperty;
        return _internalWrapHelper.wrapHelper(helper2, function(options) {
          return Utils.extend({ lookupProperty }, options);
        });
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
  var require_no_conflict = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/no-conflict.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(Handlebars6) {
        (function() {
          if (typeof globalThis === "object")
            return;
          Object.prototype.__defineGetter__("__magic__", function() {
            return this;
          });
          __magic__.globalThis = __magic__;
          delete Object.prototype.__magic__;
        })();
        var $Handlebars = globalThis.Handlebars;
        Handlebars6.noConflict = function() {
          if (globalThis.Handlebars === Handlebars6) {
            globalThis.Handlebars = $Handlebars;
          }
          return Handlebars6;
        };
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars.runtime.js
  var require_handlebars_runtime = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars.runtime.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _handlebarsBase = require_base();
      var base2 = _interopRequireWildcard(_handlebarsBase);
      var _handlebarsSafeString = require_safe_string();
      var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
      var _handlebarsException = require_exception();
      var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
      var _handlebarsUtils = require_utils();
      var Utils = _interopRequireWildcard(_handlebarsUtils);
      var _handlebarsRuntime = require_runtime();
      var runtime = _interopRequireWildcard(_handlebarsRuntime);
      var _handlebarsNoConflict = require_no_conflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      function create() {
        var hb = new base2.HandlebarsEnvironment();
        Utils.extend(hb, base2);
        hb.SafeString = _handlebarsSafeString2["default"];
        hb.Exception = _handlebarsException2["default"];
        hb.Utils = Utils;
        hb.escapeExpression = Utils.escapeExpression;
        hb.VM = runtime;
        hb.template = function(spec) {
          return runtime.template(spec, hb);
        };
        return hb;
      }
      var inst = create();
      inst.create = create;
      _handlebarsNoConflict2["default"](inst);
      inst["default"] = inst;
      exports["default"] = inst;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
  var require_ast = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var AST2 = {
        // Public API used to evaluate derived attributes regarding AST nodes
        helpers: {
          // a mustache is definitely a helper if:
          // * it is an eligible helper, and
          // * it has at least one parameter or hash segment
          helperExpression: function helperExpression(node2) {
            return node2.type === "SubExpression" || (node2.type === "MustacheStatement" || node2.type === "BlockStatement") && !!(node2.params && node2.params.length || node2.hash);
          },
          scopedId: function scopedId(path6) {
            return /^\.|this\b/.test(path6.original);
          },
          // an ID is simple if it only has one part, and that part is not
          // `..` or `this`.
          simpleId: function simpleId(path6) {
            return path6.parts.length === 1 && !AST2.helpers.scopedId(path6) && !path6.depth;
          }
        }
      };
      exports["default"] = AST2;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
  var require_parser = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var handlebars = function() {
        var parser = {
          trace: function trace() {
          },
          yy: {},
          symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];
                break;
              case 2:
                this.$ = yy.prepareProgram($$[$0]);
                break;
              case 3:
                this.$ = $$[$0];
                break;
              case 4:
                this.$ = $$[$0];
                break;
              case 5:
                this.$ = $$[$0];
                break;
              case 6:
                this.$ = $$[$0];
                break;
              case 7:
                this.$ = $$[$0];
                break;
              case 8:
                this.$ = $$[$0];
                break;
              case 9:
                this.$ = {
                  type: "CommentStatement",
                  value: yy.stripComment($$[$0]),
                  strip: yy.stripFlags($$[$0], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 10:
                this.$ = {
                  type: "ContentStatement",
                  original: $$[$0],
                  value: $$[$0],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 11:
                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 12:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                break;
              case 13:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                break;
              case 14:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                break;
              case 15:
                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 16:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 17:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 18:
                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                break;
              case 19:
                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program2 = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                program2.chained = true;
                this.$ = { strip: $$[$0 - 2].strip, program: program2, chain: true };
                break;
              case 20:
                this.$ = $$[$0];
                break;
              case 21:
                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                break;
              case 22:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 23:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 24:
                this.$ = {
                  type: "PartialStatement",
                  name: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  indent: "",
                  strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 25:
                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 26:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                break;
              case 27:
                this.$ = $$[$0];
                break;
              case 28:
                this.$ = $$[$0];
                break;
              case 29:
                this.$ = {
                  type: "SubExpression",
                  path: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 30:
                this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 31:
                this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 32:
                this.$ = yy.id($$[$0 - 1]);
                break;
              case 33:
                this.$ = $$[$0];
                break;
              case 34:
                this.$ = $$[$0];
                break;
              case 35:
                this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 36:
                this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                break;
              case 37:
                this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
                break;
              case 38:
                this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
                break;
              case 39:
                this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
                break;
              case 40:
                this.$ = $$[$0];
                break;
              case 41:
                this.$ = $$[$0];
                break;
              case 42:
                this.$ = yy.preparePath(true, $$[$0], this._$);
                break;
              case 43:
                this.$ = yy.preparePath(false, $$[$0], this._$);
                break;
              case 44:
                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
                this.$ = $$[$0 - 2];
                break;
              case 45:
                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                break;
              case 46:
                this.$ = [];
                break;
              case 47:
                $$[$0 - 1].push($$[$0]);
                break;
              case 48:
                this.$ = [];
                break;
              case 49:
                $$[$0 - 1].push($$[$0]);
                break;
              case 50:
                this.$ = [];
                break;
              case 51:
                $$[$0 - 1].push($$[$0]);
                break;
              case 58:
                this.$ = [];
                break;
              case 59:
                $$[$0 - 1].push($$[$0]);
                break;
              case 64:
                this.$ = [];
                break;
              case 65:
                $$[$0 - 1].push($$[$0]);
                break;
              case 70:
                this.$ = [];
                break;
              case 71:
                $$[$0 - 1].push($$[$0]);
                break;
              case 78:
                this.$ = [];
                break;
              case 79:
                $$[$0 - 1].push($$[$0]);
                break;
              case 82:
                this.$ = [];
                break;
              case 83:
                $$[$0 - 1].push($$[$0]);
                break;
              case 86:
                this.$ = [];
                break;
              case 87:
                $$[$0 - 1].push($$[$0]);
                break;
              case 90:
                this.$ = [];
                break;
              case 91:
                $$[$0 - 1].push($$[$0]);
                break;
              case 94:
                this.$ = [];
                break;
              case 95:
                $$[$0 - 1].push($$[$0]);
                break;
              case 98:
                this.$ = [$$[$0]];
                break;
              case 99:
                $$[$0 - 1].push($$[$0]);
                break;
              case 100:
                this.$ = [$$[$0]];
                break;
              case 101:
                $$[$0 - 1].push($$[$0]);
                break;
            }
          },
          table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
          defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
          parseError: function parseError(str, hash3) {
            throw new Error(str);
          },
          parse: function parse9(input) {
            var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF2 = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined")
              this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function")
              this.parseError = this.yy.parseError;
            function popStack(n) {
              stack.length = stack.length - 2 * n;
              vstack.length = vstack.length - n;
              lstack.length = lstack.length - n;
            }
            function lex() {
              var token;
              token = self2.lexer.lex() || 1;
              if (typeof token !== "number") {
                token = self2.symbols_[token] || token;
              }
              return token;
            }
            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while (true) {
              state = stack[stack.length - 1];
              if (this.defaultActions[state]) {
                action = this.defaultActions[state];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
                }
                action = table[state] && table[state][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push("'" + this.terminals_[p] + "'");
                    }
                  if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
                }
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(this.lexer.yytext);
                  lstack.push(this.lexer.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  if (!preErrorSymbol) {
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                      recovering--;
                  } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }
                  r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                  if (typeof r !== "undefined") {
                    return r;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash3) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash3);
              } else {
                throw new Error(str);
              }
            },
            setInput: function setInput(input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
              if (this.options.ranges)
                this.yylloc.range = [0, 0];
              this.offset = 0;
              return this;
            },
            input: function input() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges)
                this.yylloc.range[1]++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function unput(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1)
                this.yylineno -= lines.length - 1;
              var r = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
              }
              return this;
            },
            more: function more() {
              this._more = true;
              return this;
            },
            less: function less(n) {
              this.unput(this.match.slice(n));
            },
            pastInput: function pastInput() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function upcomingInput() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            showPosition: function showPosition() {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function next() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match3, tempMatch, index, col, lines;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match3 || tempMatch[0].length > match3[0].length)) {
                  match3 = tempMatch;
                  index = i;
                  if (!this.options.flex)
                    break;
                }
              }
              if (match3) {
                lines = match3[0].match(/(?:\r\n?|\n).*/g);
                if (lines)
                  this.yylineno += lines.length;
                this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match3[0].length
                };
                this.yytext += match3[0];
                this.match += match3[0];
                this.matches = match3;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._input = this._input.slice(match3[0].length);
                this.matched += match3[0];
                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input)
                  this.done = false;
                if (token)
                  return token;
                else
                  return;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== "undefined") {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function topState() {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
          lexer2.options = {};
          lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            function strip(start, end) {
              return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
            }
            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
              case 0:
                if (yy_.yytext.slice(-2) === "\\\\") {
                  strip(0, 1);
                  this.begin("mu");
                } else if (yy_.yytext.slice(-1) === "\\") {
                  strip(0, 1);
                  this.begin("emu");
                } else {
                  this.begin("mu");
                }
                if (yy_.yytext)
                  return 15;
                break;
              case 1:
                return 15;
                break;
              case 2:
                this.popState();
                return 15;
                break;
              case 3:
                this.begin("raw");
                return 15;
                break;
              case 4:
                this.popState();
                if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                  return 15;
                } else {
                  strip(5, 9);
                  return "END_RAW_BLOCK";
                }
                break;
              case 5:
                return 15;
                break;
              case 6:
                this.popState();
                return 14;
                break;
              case 7:
                return 65;
                break;
              case 8:
                return 68;
                break;
              case 9:
                return 19;
                break;
              case 10:
                this.popState();
                this.begin("raw");
                return 23;
                break;
              case 11:
                return 55;
                break;
              case 12:
                return 60;
                break;
              case 13:
                return 29;
                break;
              case 14:
                return 47;
                break;
              case 15:
                this.popState();
                return 44;
                break;
              case 16:
                this.popState();
                return 44;
                break;
              case 17:
                return 34;
                break;
              case 18:
                return 39;
                break;
              case 19:
                return 51;
                break;
              case 20:
                return 48;
                break;
              case 21:
                this.unput(yy_.yytext);
                this.popState();
                this.begin("com");
                break;
              case 22:
                this.popState();
                return 14;
                break;
              case 23:
                return 48;
                break;
              case 24:
                return 73;
                break;
              case 25:
                return 72;
                break;
              case 26:
                return 72;
                break;
              case 27:
                return 87;
                break;
              case 28:
                break;
              case 29:
                this.popState();
                return 54;
                break;
              case 30:
                this.popState();
                return 33;
                break;
              case 31:
                yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                return 80;
                break;
              case 32:
                yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                return 80;
                break;
              case 33:
                return 85;
                break;
              case 34:
                return 82;
                break;
              case 35:
                return 82;
                break;
              case 36:
                return 83;
                break;
              case 37:
                return 84;
                break;
              case 38:
                return 81;
                break;
              case 39:
                return 75;
                break;
              case 40:
                return 77;
                break;
              case 41:
                return 72;
                break;
              case 42:
                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
                return 72;
                break;
              case 43:
                return "INVALID";
                break;
              case 44:
                return 5;
                break;
            }
          };
          lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
          lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
          return lexer2;
        }();
        parser.lexer = lexer;
        function Parser2() {
          this.yy = {};
        }
        Parser2.prototype = parser;
        parser.Parser = Parser2;
        return new Parser2();
      }();
      exports["default"] = handlebars;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
  var require_visitor = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      function Visitor() {
        this.parents = [];
      }
      Visitor.prototype = {
        constructor: Visitor,
        mutating: false,
        // Visits a given value. If mutating, will replace the value if necessary.
        acceptKey: function acceptKey(node2, name) {
          var value = this.accept(node2[name]);
          if (this.mutating) {
            if (value && !Visitor.prototype[value.type]) {
              throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node2.type);
            }
            node2[name] = value;
          }
        },
        // Performs an accept operation with added sanity check to ensure
        // required keys are not removed.
        acceptRequired: function acceptRequired(node2, name) {
          this.acceptKey(node2, name);
          if (!node2[name]) {
            throw new _exception2["default"](node2.type + " requires " + name);
          }
        },
        // Traverses a given array. If mutating, empty respnses will be removed
        // for child elements.
        acceptArray: function acceptArray(array2) {
          for (var i = 0, l = array2.length; i < l; i++) {
            this.acceptKey(array2, i);
            if (!array2[i]) {
              array2.splice(i, 1);
              i--;
              l--;
            }
          }
        },
        accept: function accept(object2) {
          if (!object2) {
            return;
          }
          if (!this[object2.type]) {
            throw new _exception2["default"]("Unknown type: " + object2.type, object2);
          }
          if (this.current) {
            this.parents.unshift(this.current);
          }
          this.current = object2;
          var ret4 = this[object2.type](object2);
          this.current = this.parents.shift();
          if (!this.mutating || ret4) {
            return ret4;
          } else if (ret4 !== false) {
            return object2;
          }
        },
        Program: function Program(program2) {
          this.acceptArray(program2.body);
        },
        MustacheStatement: visitSubExpression,
        Decorator: visitSubExpression,
        BlockStatement: visitBlock,
        DecoratorBlock: visitBlock,
        PartialStatement: visitPartial,
        PartialBlockStatement: function PartialBlockStatement(partial) {
          visitPartial.call(this, partial);
          this.acceptKey(partial, "program");
        },
        ContentStatement: function ContentStatement() {
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: visitSubExpression,
        PathExpression: function PathExpression() {
        },
        StringLiteral: function StringLiteral() {
        },
        NumberLiteral: function NumberLiteral() {
        },
        BooleanLiteral: function BooleanLiteral() {
        },
        UndefinedLiteral: function UndefinedLiteral() {
        },
        NullLiteral: function NullLiteral() {
        },
        Hash: function Hash2(hash3) {
          this.acceptArray(hash3.pairs);
        },
        HashPair: function HashPair(pair) {
          this.acceptRequired(pair, "value");
        }
      };
      function visitSubExpression(mustache) {
        this.acceptRequired(mustache, "path");
        this.acceptArray(mustache.params);
        this.acceptKey(mustache, "hash");
      }
      function visitBlock(block2) {
        visitSubExpression.call(this, block2);
        this.acceptKey(block2, "program");
        this.acceptKey(block2, "inverse");
      }
      function visitPartial(partial) {
        this.acceptRequired(partial, "name");
        this.acceptArray(partial.params);
        this.acceptKey(partial, "hash");
      }
      exports["default"] = Visitor;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
  var require_whitespace_control = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = require_visitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function WhitespaceControl() {
        var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
        this.options = options;
      }
      WhitespaceControl.prototype = new _visitor2["default"]();
      WhitespaceControl.prototype.Program = function(program2) {
        var doStandalone = !this.options.ignoreStandalone;
        var isRoot = !this.isRootSeen;
        this.isRootSeen = true;
        var body = program2.body;
        for (var i = 0, l = body.length; i < l; i++) {
          var current = body[i], strip = this.accept(current);
          if (!strip) {
            continue;
          }
          var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
          if (strip.close) {
            omitRight(body, i, true);
          }
          if (strip.open) {
            omitLeft(body, i, true);
          }
          if (doStandalone && inlineStandalone) {
            omitRight(body, i);
            if (omitLeft(body, i)) {
              if (current.type === "PartialStatement") {
                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
              }
            }
          }
          if (doStandalone && openStandalone) {
            omitRight((current.program || current.inverse).body);
            omitLeft(body, i);
          }
          if (doStandalone && closeStandalone) {
            omitRight(body, i);
            omitLeft((current.inverse || current.program).body);
          }
        }
        return program2;
      };
      WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block2) {
        this.accept(block2.program);
        this.accept(block2.inverse);
        var program2 = block2.program || block2.inverse, inverse = block2.program && block2.inverse, firstInverse = inverse, lastInverse = inverse;
        if (inverse && inverse.chained) {
          firstInverse = inverse.body[0].program;
          while (lastInverse.chained) {
            lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
          }
        }
        var strip = {
          open: block2.openStrip.open,
          close: block2.closeStrip.close,
          // Determine the standalone candiacy. Basically flag our content as being possibly standalone
          // so our parent can determine if we actually are standalone
          openStandalone: isNextWhitespace(program2.body),
          closeStandalone: isPrevWhitespace((firstInverse || program2).body)
        };
        if (block2.openStrip.close) {
          omitRight(program2.body, null, true);
        }
        if (inverse) {
          var inverseStrip = block2.inverseStrip;
          if (inverseStrip.open) {
            omitLeft(program2.body, null, true);
          }
          if (inverseStrip.close) {
            omitRight(firstInverse.body, null, true);
          }
          if (block2.closeStrip.open) {
            omitLeft(lastInverse.body, null, true);
          }
          if (!this.options.ignoreStandalone && isPrevWhitespace(program2.body) && isNextWhitespace(firstInverse.body)) {
            omitLeft(program2.body);
            omitRight(firstInverse.body);
          }
        } else if (block2.closeStrip.open) {
          omitLeft(program2.body, null, true);
        }
        return strip;
      };
      WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
        return mustache.strip;
      };
      WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node2) {
        var strip = node2.strip || {};
        return {
          inlineStandalone: true,
          open: strip.open,
          close: strip.close
        };
      };
      function isPrevWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = body.length;
        }
        var prev = body[i - 1], sibling = body[i - 2];
        if (!prev) {
          return isRoot;
        }
        if (prev.type === "ContentStatement") {
          return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
        }
      }
      function isNextWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = -1;
        }
        var next = body[i + 1], sibling = body[i + 2];
        if (!next) {
          return isRoot;
        }
        if (next.type === "ContentStatement") {
          return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
        }
      }
      function omitRight(body, i, multiple) {
        var current = body[i == null ? 0 : i + 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
        current.rightStripped = current.value !== original;
      }
      function omitLeft(body, i, multiple) {
        var current = body[i == null ? body.length - 1 : i - 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
        current.leftStripped = current.value !== original;
        return current.leftStripped;
      }
      exports["default"] = WhitespaceControl;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
  var require_helpers2 = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.SourceLocation = SourceLocation;
      exports.id = id;
      exports.stripFlags = stripFlags;
      exports.stripComment = stripComment;
      exports.preparePath = preparePath;
      exports.prepareMustache = prepareMustache;
      exports.prepareRawBlock = prepareRawBlock;
      exports.prepareBlock = prepareBlock;
      exports.prepareProgram = prepareProgram;
      exports.preparePartialBlock = preparePartialBlock;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      function validateClose(open, close) {
        close = close.path ? close.path.original : close;
        if (open.path.original !== close) {
          var errorNode = { loc: open.path.loc };
          throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
        }
      }
      function SourceLocation(source, locInfo) {
        this.source = source;
        this.start = {
          line: locInfo.first_line,
          column: locInfo.first_column
        };
        this.end = {
          line: locInfo.last_line,
          column: locInfo.last_column
        };
      }
      function id(token) {
        if (/^\[.*\]$/.test(token)) {
          return token.substring(1, token.length - 1);
        } else {
          return token;
        }
      }
      function stripFlags(open, close) {
        return {
          open: open.charAt(2) === "~",
          close: close.charAt(close.length - 3) === "~"
        };
      }
      function stripComment(comment) {
        return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
      }
      function preparePath(data, parts, loc) {
        loc = this.locInfo(loc);
        var original = data ? "@" : "", dig = [], depth = 0;
        for (var i = 0, l = parts.length; i < l; i++) {
          var part = parts[i].part, isLiteral = parts[i].original !== part;
          original += (parts[i].separator || "") + part;
          if (!isLiteral && (part === ".." || part === "." || part === "this")) {
            if (dig.length > 0) {
              throw new _exception2["default"]("Invalid path: " + original, { loc });
            } else if (part === "..") {
              depth++;
            }
          } else {
            dig.push(part);
          }
        }
        return {
          type: "PathExpression",
          data,
          depth,
          parts: dig,
          original,
          loc
        };
      }
      function prepareMustache(path6, params, hash3, open, strip, locInfo) {
        var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
        var decorator = /\*/.test(open);
        return {
          type: decorator ? "Decorator" : "MustacheStatement",
          path: path6,
          params,
          hash: hash3,
          escaped,
          strip,
          loc: this.locInfo(locInfo)
        };
      }
      function prepareRawBlock(openRawBlock, contents, close, locInfo) {
        validateClose(openRawBlock, close);
        locInfo = this.locInfo(locInfo);
        var program2 = {
          type: "Program",
          body: contents,
          strip: {},
          loc: locInfo
        };
        return {
          type: "BlockStatement",
          path: openRawBlock.path,
          params: openRawBlock.params,
          hash: openRawBlock.hash,
          program: program2,
          openStrip: {},
          inverseStrip: {},
          closeStrip: {},
          loc: locInfo
        };
      }
      function prepareBlock(openBlock, program2, inverseAndProgram, close, inverted, locInfo) {
        if (close && close.path) {
          validateClose(openBlock, close);
        }
        var decorator = /\*/.test(openBlock.open);
        program2.blockParams = openBlock.blockParams;
        var inverse = void 0, inverseStrip = void 0;
        if (inverseAndProgram) {
          if (decorator) {
            throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
          }
          if (inverseAndProgram.chain) {
            inverseAndProgram.program.body[0].closeStrip = close.strip;
          }
          inverseStrip = inverseAndProgram.strip;
          inverse = inverseAndProgram.program;
        }
        if (inverted) {
          inverted = inverse;
          inverse = program2;
          program2 = inverted;
        }
        return {
          type: decorator ? "DecoratorBlock" : "BlockStatement",
          path: openBlock.path,
          params: openBlock.params,
          hash: openBlock.hash,
          program: program2,
          inverse,
          openStrip: openBlock.strip,
          inverseStrip,
          closeStrip: close && close.strip,
          loc: this.locInfo(locInfo)
        };
      }
      function prepareProgram(statements, loc) {
        if (!loc && statements.length) {
          var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
          if (firstLoc && lastLoc) {
            loc = {
              source: firstLoc.source,
              start: {
                line: firstLoc.start.line,
                column: firstLoc.start.column
              },
              end: {
                line: lastLoc.end.line,
                column: lastLoc.end.column
              }
            };
          }
        }
        return {
          type: "Program",
          body: statements,
          strip: {},
          loc
        };
      }
      function preparePartialBlock(open, program2, close, locInfo) {
        validateClose(open, close);
        return {
          type: "PartialBlockStatement",
          name: open.path,
          params: open.params,
          hash: open.hash,
          program: program2,
          openStrip: open.strip,
          closeStrip: close && close.strip,
          loc: this.locInfo(locInfo)
        };
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
  var require_base2 = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.parseWithoutProcessing = parseWithoutProcessing;
      exports.parse = parse9;
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _parser = require_parser();
      var _parser2 = _interopRequireDefault(_parser);
      var _whitespaceControl = require_whitespace_control();
      var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
      var _helpers = require_helpers2();
      var Helpers = _interopRequireWildcard(_helpers);
      var _utils = require_utils();
      exports.parser = _parser2["default"];
      var yy = {};
      _utils.extend(yy, Helpers);
      function parseWithoutProcessing(input, options) {
        if (input.type === "Program") {
          return input;
        }
        _parser2["default"].yy = yy;
        yy.locInfo = function(locInfo) {
          return new yy.SourceLocation(options && options.srcName, locInfo);
        };
        var ast = _parser2["default"].parse(input);
        return ast;
      }
      function parse9(input, options) {
        var ast = parseWithoutProcessing(input, options);
        var strip = new _whitespaceControl2["default"](options);
        return strip.accept(ast);
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
  var require_compiler = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Compiler = Compiler;
      exports.precompile = precompile;
      exports.compile = compile;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = require_utils();
      var _ast = require_ast();
      var _ast2 = _interopRequireDefault(_ast);
      var slice = [].slice;
      function Compiler() {
      }
      Compiler.prototype = {
        compiler: Compiler,
        equals: function equals3(other) {
          var len = this.opcodes.length;
          if (other.opcodes.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
            if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
              return false;
            }
          }
          len = this.children.length;
          for (var i = 0; i < len; i++) {
            if (!this.children[i].equals(other.children[i])) {
              return false;
            }
          }
          return true;
        },
        guid: 0,
        compile: function compile2(program2, options) {
          this.sourceNode = [];
          this.opcodes = [];
          this.children = [];
          this.options = options;
          this.stringParams = options.stringParams;
          this.trackIds = options.trackIds;
          options.blockParams = options.blockParams || [];
          options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
            helperMissing: true,
            blockHelperMissing: true,
            each: true,
            "if": true,
            unless: true,
            "with": true,
            log: true,
            lookup: true
          }, options.knownHelpers);
          return this.accept(program2);
        },
        compileProgram: function compileProgram(program2) {
          var childCompiler = new this.compiler(), result = childCompiler.compile(program2, this.options), guid = this.guid++;
          this.usePartial = this.usePartial || result.usePartial;
          this.children[guid] = result;
          this.useDepths = this.useDepths || result.useDepths;
          return guid;
        },
        accept: function accept(node2) {
          if (!this[node2.type]) {
            throw new _exception2["default"]("Unknown type: " + node2.type, node2);
          }
          this.sourceNode.unshift(node2);
          var ret4 = this[node2.type](node2);
          this.sourceNode.shift();
          return ret4;
        },
        Program: function Program(program2) {
          this.options.blockParams.unshift(program2.blockParams);
          var body = program2.body, bodyLength = body.length;
          for (var i = 0; i < bodyLength; i++) {
            this.accept(body[i]);
          }
          this.options.blockParams.shift();
          this.isSimple = bodyLength === 1;
          this.blockParams = program2.blockParams ? program2.blockParams.length : 0;
          return this;
        },
        BlockStatement: function BlockStatement(block2) {
          transformLiteralToPath(block2);
          var program2 = block2.program, inverse = block2.inverse;
          program2 = program2 && this.compileProgram(program2);
          inverse = inverse && this.compileProgram(inverse);
          var type3 = this.classifySexpr(block2);
          if (type3 === "helper") {
            this.helperSexpr(block2, program2, inverse);
          } else if (type3 === "simple") {
            this.simpleSexpr(block2);
            this.opcode("pushProgram", program2);
            this.opcode("pushProgram", inverse);
            this.opcode("emptyHash");
            this.opcode("blockValue", block2.path.original);
          } else {
            this.ambiguousSexpr(block2, program2, inverse);
            this.opcode("pushProgram", program2);
            this.opcode("pushProgram", inverse);
            this.opcode("emptyHash");
            this.opcode("ambiguousBlockValue");
          }
          this.opcode("append");
        },
        DecoratorBlock: function DecoratorBlock(decorator) {
          var program2 = decorator.program && this.compileProgram(decorator.program);
          var params = this.setupFullMustacheParams(decorator, program2, void 0), path6 = decorator.path;
          this.useDecorators = true;
          this.opcode("registerDecorator", params.length, path6.original);
        },
        PartialStatement: function PartialStatement(partial) {
          this.usePartial = true;
          var program2 = partial.program;
          if (program2) {
            program2 = this.compileProgram(partial.program);
          }
          var params = partial.params;
          if (params.length > 1) {
            throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
          } else if (!params.length) {
            if (this.options.explicitPartialContext) {
              this.opcode("pushLiteral", "undefined");
            } else {
              params.push({ type: "PathExpression", parts: [], depth: 0 });
            }
          }
          var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
          if (isDynamic) {
            this.accept(partial.name);
          }
          this.setupFullMustacheParams(partial, program2, void 0, true);
          var indent2 = partial.indent || "";
          if (this.options.preventIndent && indent2) {
            this.opcode("appendContent", indent2);
            indent2 = "";
          }
          this.opcode("invokePartial", isDynamic, partialName, indent2);
          this.opcode("append");
        },
        PartialBlockStatement: function PartialBlockStatement(partialBlock) {
          this.PartialStatement(partialBlock);
        },
        MustacheStatement: function MustacheStatement(mustache) {
          this.SubExpression(mustache);
          if (mustache.escaped && !this.options.noEscape) {
            this.opcode("appendEscaped");
          } else {
            this.opcode("append");
          }
        },
        Decorator: function Decorator(decorator) {
          this.DecoratorBlock(decorator);
        },
        ContentStatement: function ContentStatement(content) {
          if (content.value) {
            this.opcode("appendContent", content.value);
          }
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: function SubExpression(sexpr) {
          transformLiteralToPath(sexpr);
          var type3 = this.classifySexpr(sexpr);
          if (type3 === "simple") {
            this.simpleSexpr(sexpr);
          } else if (type3 === "helper") {
            this.helperSexpr(sexpr);
          } else {
            this.ambiguousSexpr(sexpr);
          }
        },
        ambiguousSexpr: function ambiguousSexpr(sexpr, program2, inverse) {
          var path6 = sexpr.path, name = path6.parts[0], isBlock = program2 != null || inverse != null;
          this.opcode("getContext", path6.depth);
          this.opcode("pushProgram", program2);
          this.opcode("pushProgram", inverse);
          path6.strict = true;
          this.accept(path6);
          this.opcode("invokeAmbiguous", name, isBlock);
        },
        simpleSexpr: function simpleSexpr(sexpr) {
          var path6 = sexpr.path;
          path6.strict = true;
          this.accept(path6);
          this.opcode("resolvePossibleLambda");
        },
        helperSexpr: function helperSexpr(sexpr, program2, inverse) {
          var params = this.setupFullMustacheParams(sexpr, program2, inverse), path6 = sexpr.path, name = path6.parts[0];
          if (this.options.knownHelpers[name]) {
            this.opcode("invokeKnownHelper", params.length, name);
          } else if (this.options.knownHelpersOnly) {
            throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
          } else {
            path6.strict = true;
            path6.falsy = true;
            this.accept(path6);
            this.opcode("invokeHelper", params.length, path6.original, _ast2["default"].helpers.simpleId(path6));
          }
        },
        PathExpression: function PathExpression(path6) {
          this.addDepth(path6.depth);
          this.opcode("getContext", path6.depth);
          var name = path6.parts[0], scoped = _ast2["default"].helpers.scopedId(path6), blockParamId = !path6.depth && !scoped && this.blockParamIndex(name);
          if (blockParamId) {
            this.opcode("lookupBlockParam", blockParamId, path6.parts);
          } else if (!name) {
            this.opcode("pushContext");
          } else if (path6.data) {
            this.options.data = true;
            this.opcode("lookupData", path6.depth, path6.parts, path6.strict);
          } else {
            this.opcode("lookupOnContext", path6.parts, path6.falsy, path6.strict, scoped);
          }
        },
        StringLiteral: function StringLiteral(string2) {
          this.opcode("pushString", string2.value);
        },
        NumberLiteral: function NumberLiteral(number3) {
          this.opcode("pushLiteral", number3.value);
        },
        BooleanLiteral: function BooleanLiteral(bool) {
          this.opcode("pushLiteral", bool.value);
        },
        UndefinedLiteral: function UndefinedLiteral() {
          this.opcode("pushLiteral", "undefined");
        },
        NullLiteral: function NullLiteral() {
          this.opcode("pushLiteral", "null");
        },
        Hash: function Hash2(hash3) {
          var pairs = hash3.pairs, i = 0, l = pairs.length;
          this.opcode("pushHash");
          for (; i < l; i++) {
            this.pushParam(pairs[i].value);
          }
          while (i--) {
            this.opcode("assignToHash", pairs[i].key);
          }
          this.opcode("popHash");
        },
        // HELPERS
        opcode: function opcode(name) {
          this.opcodes.push({
            opcode: name,
            args: slice.call(arguments, 1),
            loc: this.sourceNode[0].loc
          });
        },
        addDepth: function addDepth(depth) {
          if (!depth) {
            return;
          }
          this.useDepths = true;
        },
        classifySexpr: function classifySexpr(sexpr) {
          var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
          var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
          var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
          var isEligible = !isBlockParam && (isHelper || isSimple);
          if (isEligible && !isHelper) {
            var _name = sexpr.path.parts[0], options = this.options;
            if (options.knownHelpers[_name]) {
              isHelper = true;
            } else if (options.knownHelpersOnly) {
              isEligible = false;
            }
          }
          if (isHelper) {
            return "helper";
          } else if (isEligible) {
            return "ambiguous";
          } else {
            return "simple";
          }
        },
        pushParams: function pushParams(params) {
          for (var i = 0, l = params.length; i < l; i++) {
            this.pushParam(params[i]);
          }
        },
        pushParam: function pushParam(val) {
          var value = val.value != null ? val.value : val.original || "";
          if (this.stringParams) {
            if (value.replace) {
              value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
            }
            if (val.depth) {
              this.addDepth(val.depth);
            }
            this.opcode("getContext", val.depth || 0);
            this.opcode("pushStringParam", value, val.type);
            if (val.type === "SubExpression") {
              this.accept(val);
            }
          } else {
            if (this.trackIds) {
              var blockParamIndex = void 0;
              if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
                blockParamIndex = this.blockParamIndex(val.parts[0]);
              }
              if (blockParamIndex) {
                var blockParamChild = val.parts.slice(1).join(".");
                this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
              } else {
                value = val.original || value;
                if (value.replace) {
                  value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
                }
                this.opcode("pushId", val.type, value);
              }
            }
            this.accept(val);
          }
        },
        setupFullMustacheParams: function setupFullMustacheParams(sexpr, program2, inverse, omitEmpty) {
          var params = sexpr.params;
          this.pushParams(params);
          this.opcode("pushProgram", program2);
          this.opcode("pushProgram", inverse);
          if (sexpr.hash) {
            this.accept(sexpr.hash);
          } else {
            this.opcode("emptyHash", omitEmpty);
          }
          return params;
        },
        blockParamIndex: function blockParamIndex(name) {
          for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
            var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
            if (blockParams && param >= 0) {
              return [depth, param];
            }
          }
        }
      };
      function precompile(input, options, env) {
        if (input == null || typeof input !== "string" && input.type !== "Program") {
          throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
        }
        options = options || {};
        if (!("data" in options)) {
          options.data = true;
        }
        if (options.compat) {
          options.useDepths = true;
        }
        var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
        return new env.JavaScriptCompiler().compile(environment, options);
      }
      function compile(input, options, env) {
        if (options === void 0)
          options = {};
        if (input == null || typeof input !== "string" && input.type !== "Program") {
          throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
        }
        options = _utils.extend({}, options);
        if (!("data" in options)) {
          options.data = true;
        }
        if (options.compat) {
          options.useDepths = true;
        }
        var compiled = void 0;
        function compileInput() {
          var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
          return env.template(templateSpec);
        }
        function ret4(context2, execOptions) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled.call(this, context2, execOptions);
        }
        ret4._setup = function(setupOptions) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled._setup(setupOptions);
        };
        ret4._child = function(i, data, blockParams, depths) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled._child(i, data, blockParams, depths);
        };
        return ret4;
      }
      function argEquals(a, b) {
        if (a === b) {
          return true;
        }
        if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
          for (var i = 0; i < a.length; i++) {
            if (!argEquals(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
      }
      function transformLiteralToPath(sexpr) {
        if (!sexpr.path.parts) {
          var literal = sexpr.path;
          sexpr.path = {
            type: "PathExpression",
            data: false,
            depth: 0,
            parts: [literal.original + ""],
            original: literal.original + "",
            loc: literal.loc
          };
        }
      }
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
  var require_base64 = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number3) {
        if (0 <= number3 && number3 < intToCharMap.length) {
          return intToCharMap[number3];
        }
        throw new TypeError("Must be between 0 and 63: " + number3);
      };
      exports.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
  var require_util2 = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match3 = aUrl.match(urlRegexp);
        if (!match3) {
          return null;
        }
        return {
          scheme: match3[1],
          auth: match3[2],
          host: match3[3],
          port: match3[4],
          path: match3[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize5(aPath) {
        var path6 = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path6 = url.path;
        }
        var isAbsolute = exports.isAbsolute(path6);
        var parts = path6.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path6 = parts.join("/");
        if (path6 === "") {
          path6 = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path6;
          return urlGenerate(url);
        }
        return path6;
      }
      exports.normalize = normalize5;
      function join10(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize5(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join10;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative2(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative2;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity2(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity2 : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity2 : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join10(urlGenerate(parsed), sourceURL);
        }
        return normalize5(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
  var require_array_set = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js"(exports) {
      var util = require_util2();
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js"(exports) {
      var util = require_util2();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util = require_util2();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, "generated");
        var original = util.getArg(aArgs, "original", null);
        var source = util.getArg(aArgs, "source", null);
        var name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ",";
            }
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map2 = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map2.file = this._file;
        }
        if (this._sourceRoot != null) {
          map2.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
        }
        return map2;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js
  var require_binary_search = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js"(exports) {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports.GREATEST_LOWER_BOUND
        );
        if (index < 0) {
          return -1;
        }
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
        return index;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js
  var require_quick_sort = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js"(exports) {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1;
          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }
      exports.quickSort = function(ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js
  var require_source_map_consumer = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js"(exports) {
      var util = require_util2();
      var binarySearch = require_binary_search();
      var ArraySet = require_array_set().ArraySet;
      var base64VLQ = require_base64_vlq();
      var quickSort = require_quick_sort().quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };
      SourceMapConsumer.prototype._version = 3;
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context2 = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function(mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context2);
      };
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, "line");
        var needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (aArgs.column === void 0) {
            var originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      };
      exports.SourceMapConsumer = SourceMapConsumer;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version3 = util.getArg(sourceMap, "version");
        var sources = util.getArg(sourceMap, "sources");
        var names = util.getArg(sourceMap, "names", []);
        var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        var mappings = util.getArg(sourceMap, "mappings");
        var file = util.getArg(sourceMap, "file", null);
        if (version3 != this._version) {
          throw new Error("Unsupported version: " + version3);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util.normalize).map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function(s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
      BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        var i;
        for (i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      };
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(
          smc._sources.toArray(),
          smc.sourceRoot
        );
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function(s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
        return smc;
      };
      BasicSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function() {
          return this._absoluteSources.slice();
        }
      });
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        while (index < length) {
          if (aStr.charAt(index) === ";") {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
          } else if (aStr.charAt(index) === ",") {
            index++;
          } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index, end);
            segment = cachedSegments[str];
            if (segment) {
              index += str.length;
            } else {
              segment = [];
              while (index < end) {
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
              }
              if (segment.length === 2) {
                throw new Error("Found a source, but no line and column");
              }
              if (segment.length === 3) {
                throw new Error("Found a source and line, but no column");
              }
              cachedSegments[str] = segment;
            }
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
              if (segment.length > 4) {
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === "number") {
              originalMappings.push(mapping);
            }
          }
        }
        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
        quickSort(originalMappings, util.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = Infinity;
        }
      };
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util.compareByGeneratedPositionsDeflated,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      };
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version3 = util.getArg(sourceMap, "version");
        var sections = util.getArg(sourceMap, "sections");
        if (version3 != this._version) {
          throw new Error("Unsupported version: " + version3);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function(s) {
          if (s.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          var offset = util.getArg(s, "offset");
          var offsetLine = util.getArg(offset, "line");
          var offsetColumn = util.getArg(offset, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
      IndexedSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function() {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }
      });
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret4 = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret4;
          }
        }
        return {
          line: null,
          column: null
        };
      };
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }
            var adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js
  var require_source_node = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js"(exports) {
      var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      var util = require_util2();
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node2 = new SourceNode();
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node2.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node2.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node2.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node2.setSourceContent(sourceFile, content);
          }
        });
        return node2;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node2.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node2.add(new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map2 = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map2.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map2.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map2.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map2.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map: map2 };
      };
      exports.SourceNode = SourceNode;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js
  var require_source_map = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js"(exports) {
      exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
      exports.SourceNode = require_source_node().SourceNode;
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
  var require_code_gen = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      var SourceNode = void 0;
      try {
        if (typeof define !== "function" || !define.amd) {
          SourceMap = require_source_map();
          SourceNode = SourceMap.SourceNode;
        }
      } catch (err2) {
      }
      var SourceMap;
      if (!SourceNode) {
        SourceNode = function(line, column, srcFile, chunks) {
          this.src = "";
          if (chunks) {
            this.add(chunks);
          }
        };
        SourceNode.prototype = {
          add: function add(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src += chunks;
          },
          prepend: function prepend(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src = chunks + this.src;
          },
          toStringWithSourceMap: function toStringWithSourceMap() {
            return { code: this.toString() };
          },
          toString: function toString3() {
            return this.src;
          }
        };
      }
      function castChunk(chunk, codeGen, loc) {
        if (_utils.isArray(chunk)) {
          var ret4 = [];
          for (var i = 0, len = chunk.length; i < len; i++) {
            ret4.push(codeGen.wrap(chunk[i], loc));
          }
          return ret4;
        } else if (typeof chunk === "boolean" || typeof chunk === "number") {
          return chunk + "";
        }
        return chunk;
      }
      function CodeGen(srcFile) {
        this.srcFile = srcFile;
        this.source = [];
      }
      CodeGen.prototype = {
        isEmpty: function isEmpty() {
          return !this.source.length;
        },
        prepend: function prepend(source, loc) {
          this.source.unshift(this.wrap(source, loc));
        },
        push: function push(source, loc) {
          this.source.push(this.wrap(source, loc));
        },
        merge: function merge() {
          var source = this.empty();
          this.each(function(line) {
            source.add(["  ", line, "\n"]);
          });
          return source;
        },
        each: function each(iter) {
          for (var i = 0, len = this.source.length; i < len; i++) {
            iter(this.source[i]);
          }
        },
        empty: function empty() {
          var loc = this.currentLocation || { start: {} };
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
        },
        wrap: function wrap3(chunk) {
          var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
          if (chunk instanceof SourceNode) {
            return chunk;
          }
          chunk = castChunk(chunk, this, loc);
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
        },
        functionCall: function functionCall(fn, type3, params) {
          params = this.generateList(params);
          return this.wrap([fn, type3 ? "." + type3 + "(" : "(", params, ")"]);
        },
        quotedString: function quotedString(str) {
          return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
        },
        objectLiteral: function objectLiteral(obj) {
          var _this = this;
          var pairs = [];
          Object.keys(obj).forEach(function(key) {
            var value = castChunk(obj[key], _this);
            if (value !== "undefined") {
              pairs.push([_this.quotedString(key), ":", value]);
            }
          });
          var ret4 = this.generateList(pairs);
          ret4.prepend("{");
          ret4.add("}");
          return ret4;
        },
        generateList: function generateList(entries) {
          var ret4 = this.empty();
          for (var i = 0, len = entries.length; i < len; i++) {
            if (i) {
              ret4.add(",");
            }
            ret4.add(castChunk(entries[i], this));
          }
          return ret4;
        },
        generateArray: function generateArray(entries) {
          var ret4 = this.generateList(entries);
          ret4.prepend("[");
          ret4.add("]");
          return ret4;
        }
      };
      exports["default"] = CodeGen;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
  var require_javascript_compiler = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _base = require_base();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = require_utils();
      var _codeGen = require_code_gen();
      var _codeGen2 = _interopRequireDefault(_codeGen);
      function Literal(value) {
        this.value = value;
      }
      function JavaScriptCompiler() {
      }
      JavaScriptCompiler.prototype = {
        // PUBLIC API: You can override these methods in a subclass to provide
        // alternative compiled forms for name lookup and buffering semantics
        nameLookup: function nameLookup(parent, name) {
          return this.internalNameLookup(parent, name);
        },
        depthedLookup: function depthedLookup(name) {
          return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
        },
        compilerInfo: function compilerInfo() {
          var revision = _base.COMPILER_REVISION, versions2 = _base.REVISION_CHANGES[revision];
          return [revision, versions2];
        },
        appendToBuffer: function appendToBuffer(source, location, explicit) {
          if (!_utils.isArray(source)) {
            source = [source];
          }
          source = this.source.wrap(source, location);
          if (this.environment.isSimple) {
            return ["return ", source, ";"];
          } else if (explicit) {
            return ["buffer += ", source, ";"];
          } else {
            source.appendToBuffer = true;
            return source;
          }
        },
        initializeBuffer: function initializeBuffer() {
          return this.quotedString("");
        },
        // END PUBLIC API
        internalNameLookup: function internalNameLookup(parent, name) {
          this.lookupPropertyFunctionIsUsed = true;
          return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
        },
        lookupPropertyFunctionIsUsed: false,
        compile: function compile(environment, options, context2, asObject) {
          this.environment = environment;
          this.options = options;
          this.stringParams = this.options.stringParams;
          this.trackIds = this.options.trackIds;
          this.precompile = !asObject;
          this.name = this.environment.name;
          this.isChild = !!context2;
          this.context = context2 || {
            decorators: [],
            programs: [],
            environments: []
          };
          this.preamble();
          this.stackSlot = 0;
          this.stackVars = [];
          this.aliases = {};
          this.registers = { list: [] };
          this.hashes = [];
          this.compileStack = [];
          this.inlineStack = [];
          this.blockParams = [];
          this.compileChildren(environment, options);
          this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
          this.useBlockParams = this.useBlockParams || environment.useBlockParams;
          var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
          for (i = 0, l = opcodes.length; i < l; i++) {
            opcode = opcodes[i];
            this.source.currentLocation = opcode.loc;
            firstLoc = firstLoc || opcode.loc;
            this[opcode.opcode].apply(this, opcode.args);
          }
          this.source.currentLocation = firstLoc;
          this.pushSource("");
          if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
            throw new _exception2["default"]("Compile completed with content left on stack");
          }
          if (!this.decorators.isEmpty()) {
            this.useDecorators = true;
            this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
            this.decorators.push("return fn;");
            if (asObject) {
              this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
            } else {
              this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
              this.decorators.push("}\n");
              this.decorators = this.decorators.merge();
            }
          } else {
            this.decorators = void 0;
          }
          var fn = this.createFunctionContext(asObject);
          if (!this.isChild) {
            var ret4 = {
              compiler: this.compilerInfo(),
              main: fn
            };
            if (this.decorators) {
              ret4.main_d = this.decorators;
              ret4.useDecorators = true;
            }
            var _context = this.context;
            var programs = _context.programs;
            var decorators = _context.decorators;
            for (i = 0, l = programs.length; i < l; i++) {
              if (programs[i]) {
                ret4[i] = programs[i];
                if (decorators[i]) {
                  ret4[i + "_d"] = decorators[i];
                  ret4.useDecorators = true;
                }
              }
            }
            if (this.environment.usePartial) {
              ret4.usePartial = true;
            }
            if (this.options.data) {
              ret4.useData = true;
            }
            if (this.useDepths) {
              ret4.useDepths = true;
            }
            if (this.useBlockParams) {
              ret4.useBlockParams = true;
            }
            if (this.options.compat) {
              ret4.compat = true;
            }
            if (!asObject) {
              ret4.compiler = JSON.stringify(ret4.compiler);
              this.source.currentLocation = { start: { line: 1, column: 0 } };
              ret4 = this.objectLiteral(ret4);
              if (options.srcName) {
                ret4 = ret4.toStringWithSourceMap({ file: options.destName });
                ret4.map = ret4.map && ret4.map.toString();
              } else {
                ret4 = ret4.toString();
              }
            } else {
              ret4.compilerOptions = this.options;
            }
            return ret4;
          } else {
            return fn;
          }
        },
        preamble: function preamble() {
          this.lastContext = 0;
          this.source = new _codeGen2["default"](this.options.srcName);
          this.decorators = new _codeGen2["default"](this.options.srcName);
        },
        createFunctionContext: function createFunctionContext(asObject) {
          var _this = this;
          var varDeclarations = "";
          var locals = this.stackVars.concat(this.registers.list);
          if (locals.length > 0) {
            varDeclarations += ", " + locals.join(", ");
          }
          var aliasCount = 0;
          Object.keys(this.aliases).forEach(function(alias) {
            var node2 = _this.aliases[alias];
            if (node2.children && node2.referenceCount > 1) {
              varDeclarations += ", alias" + ++aliasCount + "=" + alias;
              node2.children[0] = "alias" + aliasCount;
            }
          });
          if (this.lookupPropertyFunctionIsUsed) {
            varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
          }
          var params = ["container", "depth0", "helpers", "partials", "data"];
          if (this.useBlockParams || this.useDepths) {
            params.push("blockParams");
          }
          if (this.useDepths) {
            params.push("depths");
          }
          var source = this.mergeSource(varDeclarations);
          if (asObject) {
            params.push(source);
            return Function.apply(this, params);
          } else {
            return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
          }
        },
        mergeSource: function mergeSource(varDeclarations) {
          var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
          this.source.each(function(line) {
            if (line.appendToBuffer) {
              if (bufferStart) {
                line.prepend("  + ");
              } else {
                bufferStart = line;
              }
              bufferEnd = line;
            } else {
              if (bufferStart) {
                if (!sourceSeen) {
                  appendFirst = true;
                } else {
                  bufferStart.prepend("buffer += ");
                }
                bufferEnd.add(";");
                bufferStart = bufferEnd = void 0;
              }
              sourceSeen = true;
              if (!isSimple) {
                appendOnly = false;
              }
            }
          });
          if (appendOnly) {
            if (bufferStart) {
              bufferStart.prepend("return ");
              bufferEnd.add(";");
            } else if (!sourceSeen) {
              this.source.push('return "";');
            }
          } else {
            varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
            if (bufferStart) {
              bufferStart.prepend("return buffer + ");
              bufferEnd.add(";");
            } else {
              this.source.push("return buffer;");
            }
          }
          if (varDeclarations) {
            this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
          }
          return this.source.merge();
        },
        lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
          return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
        },
        // [blockValue]
        //
        // On stack, before: hash, inverse, program, value
        // On stack, after: return value of blockHelperMissing
        //
        // The purpose of this opcode is to take a block of the form
        // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
        // replace it on the stack with the result of properly
        // invoking blockHelperMissing.
        blockValue: function blockValue(name) {
          var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs(name, 0, params);
          var blockName = this.popStack();
          params.splice(1, 0, blockName);
          this.push(this.source.functionCall(blockHelperMissing, "call", params));
        },
        // [ambiguousBlockValue]
        //
        // On stack, before: hash, inverse, program, value
        // Compiler value, before: lastHelper=value of last found helper, if any
        // On stack, after, if no lastHelper: same as [blockValue]
        // On stack, after, if lastHelper: value
        ambiguousBlockValue: function ambiguousBlockValue() {
          var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs("", 0, params, true);
          this.flushInline();
          var current = this.topStack();
          params.splice(1, 0, current);
          this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
        },
        // [appendContent]
        //
        // On stack, before: ...
        // On stack, after: ...
        //
        // Appends the string value of `content` to the current buffer
        appendContent: function appendContent(content) {
          if (this.pendingContent) {
            content = this.pendingContent + content;
          } else {
            this.pendingLocation = this.source.currentLocation;
          }
          this.pendingContent = content;
        },
        // [append]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Coerces `value` to a String and appends it to the current buffer.
        //
        // If `value` is truthy, or 0, it is coerced into a string and appended
        // Otherwise, the empty string is appended
        append: function append() {
          if (this.isInline()) {
            this.replaceStack(function(current) {
              return [" != null ? ", current, ' : ""'];
            });
            this.pushSource(this.appendToBuffer(this.popStack()));
          } else {
            var local = this.popStack();
            this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
            if (this.environment.isSimple) {
              this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
            }
          }
        },
        // [appendEscaped]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Escape `value` and append it to the buffer
        appendEscaped: function appendEscaped() {
          this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
        },
        // [getContext]
        //
        // On stack, before: ...
        // On stack, after: ...
        // Compiler value, after: lastContext=depth
        //
        // Set the value of the `lastContext` compiler value to the depth
        getContext: function getContext(depth) {
          this.lastContext = depth;
        },
        // [pushContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext, ...
        //
        // Pushes the value of the current context onto the stack.
        pushContext: function pushContext() {
          this.pushStackLiteral(this.contextName(this.lastContext));
        },
        // [lookupOnContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext[name], ...
        //
        // Looks up the value of `name` on the current context and pushes
        // it onto the stack.
        lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
          var i = 0;
          if (!scoped && this.options.compat && !this.lastContext) {
            this.push(this.depthedLookup(parts[i++]));
          } else {
            this.pushContext();
          }
          this.resolvePath("context", parts, i, falsy, strict);
        },
        // [lookupBlockParam]
        //
        // On stack, before: ...
        // On stack, after: blockParam[name], ...
        //
        // Looks up the value of `parts` on the given block param and pushes
        // it onto the stack.
        lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
          this.useBlockParams = true;
          this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
          this.resolvePath("context", parts, 1);
        },
        // [lookupData]
        //
        // On stack, before: ...
        // On stack, after: data, ...
        //
        // Push the data lookup operator
        lookupData: function lookupData(depth, parts, strict) {
          if (!depth) {
            this.pushStackLiteral("data");
          } else {
            this.pushStackLiteral("container.data(data, " + depth + ")");
          }
          this.resolvePath("data", parts, 0, true, strict);
        },
        resolvePath: function resolvePath(type3, parts, i, falsy, strict) {
          var _this2 = this;
          if (this.options.strict || this.options.assumeObjects) {
            this.push(strictLookup(this.options.strict && strict, this, parts, i, type3));
            return;
          }
          var len = parts.length;
          for (; i < len; i++) {
            this.replaceStack(function(current) {
              var lookup = _this2.nameLookup(current, parts[i], type3);
              if (!falsy) {
                return [" != null ? ", lookup, " : ", current];
              } else {
                return [" && ", lookup];
              }
            });
          }
        },
        // [resolvePossibleLambda]
        //
        // On stack, before: value, ...
        // On stack, after: resolved value, ...
        //
        // If the `value` is a lambda, replace it on the stack by
        // the return value of the lambda
        resolvePossibleLambda: function resolvePossibleLambda() {
          this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
        },
        // [pushStringParam]
        //
        // On stack, before: ...
        // On stack, after: string, currentContext, ...
        //
        // This opcode is designed for use in string mode, which
        // provides the string value of a parameter along with its
        // depth rather than resolving it immediately.
        pushStringParam: function pushStringParam(string2, type3) {
          this.pushContext();
          this.pushString(type3);
          if (type3 !== "SubExpression") {
            if (typeof string2 === "string") {
              this.pushString(string2);
            } else {
              this.pushStackLiteral(string2);
            }
          }
        },
        emptyHash: function emptyHash(omitEmpty) {
          if (this.trackIds) {
            this.push("{}");
          }
          if (this.stringParams) {
            this.push("{}");
            this.push("{}");
          }
          this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
        },
        pushHash: function pushHash() {
          if (this.hash) {
            this.hashes.push(this.hash);
          }
          this.hash = { values: {}, types: [], contexts: [], ids: [] };
        },
        popHash: function popHash() {
          var hash3 = this.hash;
          this.hash = this.hashes.pop();
          if (this.trackIds) {
            this.push(this.objectLiteral(hash3.ids));
          }
          if (this.stringParams) {
            this.push(this.objectLiteral(hash3.contexts));
            this.push(this.objectLiteral(hash3.types));
          }
          this.push(this.objectLiteral(hash3.values));
        },
        // [pushString]
        //
        // On stack, before: ...
        // On stack, after: quotedString(string), ...
        //
        // Push a quoted version of `string` onto the stack
        pushString: function pushString(string2) {
          this.pushStackLiteral(this.quotedString(string2));
        },
        // [pushLiteral]
        //
        // On stack, before: ...
        // On stack, after: value, ...
        //
        // Pushes a value onto the stack. This operation prevents
        // the compiler from creating a temporary variable to hold
        // it.
        pushLiteral: function pushLiteral(value) {
          this.pushStackLiteral(value);
        },
        // [pushProgram]
        //
        // On stack, before: ...
        // On stack, after: program(guid), ...
        //
        // Push a program expression onto the stack. This takes
        // a compile-time guid and converts it into a runtime-accessible
        // expression.
        pushProgram: function pushProgram(guid) {
          if (guid != null) {
            this.pushStackLiteral(this.programExpression(guid));
          } else {
            this.pushStackLiteral(null);
          }
        },
        // [registerDecorator]
        //
        // On stack, before: hash, program, params..., ...
        // On stack, after: ...
        //
        // Pops off the decorator's parameters, invokes the decorator,
        // and inserts the decorator into the decorators list.
        registerDecorator: function registerDecorator(paramSize, name) {
          var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
          this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
        },
        // [invokeHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // Pops off the helper's parameters, invokes the helper,
        // and pushes the helper's return value onto the stack.
        //
        // If the helper is not found, `helperMissing` is called.
        invokeHelper: function invokeHelper(paramSize, name, isSimple) {
          var nonHelper = this.popStack(), helper2 = this.setupHelper(paramSize, name);
          var possibleFunctionCalls = [];
          if (isSimple) {
            possibleFunctionCalls.push(helper2.name);
          }
          possibleFunctionCalls.push(nonHelper);
          if (!this.options.strict) {
            possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
          }
          var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
          var functionCall = this.source.functionCall(functionLookupCode, "call", helper2.callParams);
          this.push(functionCall);
        },
        itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
          var result = [];
          result.push(items[0]);
          for (var i = 1; i < items.length; i++) {
            result.push(separator, items[i]);
          }
          return result;
        },
        // [invokeKnownHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // This operation is used when the helper is known to exist,
        // so a `helperMissing` fallback is not required.
        invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
          var helper2 = this.setupHelper(paramSize, name);
          this.push(this.source.functionCall(helper2.name, "call", helper2.callParams));
        },
        // [invokeAmbiguous]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of disambiguation
        //
        // This operation is used when an expression like `{{foo}}`
        // is provided, but we don't know at compile-time whether it
        // is a helper or a path.
        //
        // This operation emits more code than the other options,
        // and can be avoided by passing the `knownHelpers` and
        // `knownHelpersOnly` flags at compile-time.
        invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
          this.useRegister("helper");
          var nonHelper = this.popStack();
          this.emptyHash();
          var helper2 = this.setupHelper(0, name, helperCall);
          var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
          var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
          if (!this.options.strict) {
            lookup[0] = "(helper = ";
            lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
          }
          this.push(["(", lookup, helper2.paramsInit ? ["),(", helper2.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper2.callParams), " : helper))"]);
        },
        // [invokePartial]
        //
        // On stack, before: context, ...
        // On stack after: result of partial invocation
        //
        // This operation pops off a context, invokes a partial with that context,
        // and pushes the result of the invocation back.
        invokePartial: function invokePartial(isDynamic, name, indent2) {
          var params = [], options = this.setupParams(name, 1, params);
          if (isDynamic) {
            name = this.popStack();
            delete options.name;
          }
          if (indent2) {
            options.indent = JSON.stringify(indent2);
          }
          options.helpers = "helpers";
          options.partials = "partials";
          options.decorators = "container.decorators";
          if (!isDynamic) {
            params.unshift(this.nameLookup("partials", name, "partial"));
          } else {
            params.unshift(name);
          }
          if (this.options.compat) {
            options.depths = "depths";
          }
          options = this.objectLiteral(options);
          params.push(options);
          this.push(this.source.functionCall("container.invokePartial", "", params));
        },
        // [assignToHash]
        //
        // On stack, before: value, ..., hash, ...
        // On stack, after: ..., hash, ...
        //
        // Pops a value off the stack and assigns it to the current hash
        assignToHash: function assignToHash(key) {
          var value = this.popStack(), context2 = void 0, type3 = void 0, id = void 0;
          if (this.trackIds) {
            id = this.popStack();
          }
          if (this.stringParams) {
            type3 = this.popStack();
            context2 = this.popStack();
          }
          var hash3 = this.hash;
          if (context2) {
            hash3.contexts[key] = context2;
          }
          if (type3) {
            hash3.types[key] = type3;
          }
          if (id) {
            hash3.ids[key] = id;
          }
          hash3.values[key] = value;
        },
        pushId: function pushId(type3, name, child) {
          if (type3 === "BlockParam") {
            this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
          } else if (type3 === "PathExpression") {
            this.pushString(name);
          } else if (type3 === "SubExpression") {
            this.pushStackLiteral("true");
          } else {
            this.pushStackLiteral("null");
          }
        },
        // HELPERS
        compiler: JavaScriptCompiler,
        compileChildren: function compileChildren(environment, options) {
          var children = environment.children, child = void 0, compiler = void 0;
          for (var i = 0, l = children.length; i < l; i++) {
            child = children[i];
            compiler = new this.compiler();
            var existing = this.matchExistingProgram(child);
            if (existing == null) {
              this.context.programs.push("");
              var index = this.context.programs.length;
              child.index = index;
              child.name = "program" + index;
              this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
              this.context.decorators[index] = compiler.decorators;
              this.context.environments[index] = child;
              this.useDepths = this.useDepths || compiler.useDepths;
              this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
              child.useDepths = this.useDepths;
              child.useBlockParams = this.useBlockParams;
            } else {
              child.index = existing.index;
              child.name = "program" + existing.index;
              this.useDepths = this.useDepths || existing.useDepths;
              this.useBlockParams = this.useBlockParams || existing.useBlockParams;
            }
          }
        },
        matchExistingProgram: function matchExistingProgram(child) {
          for (var i = 0, len = this.context.environments.length; i < len; i++) {
            var environment = this.context.environments[i];
            if (environment && environment.equals(child)) {
              return environment;
            }
          }
        },
        programExpression: function programExpression(guid) {
          var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
          if (this.useBlockParams || this.useDepths) {
            programParams.push("blockParams");
          }
          if (this.useDepths) {
            programParams.push("depths");
          }
          return "container.program(" + programParams.join(", ") + ")";
        },
        useRegister: function useRegister(name) {
          if (!this.registers[name]) {
            this.registers[name] = true;
            this.registers.list.push(name);
          }
        },
        push: function push(expr) {
          if (!(expr instanceof Literal)) {
            expr = this.source.wrap(expr);
          }
          this.inlineStack.push(expr);
          return expr;
        },
        pushStackLiteral: function pushStackLiteral(item) {
          this.push(new Literal(item));
        },
        pushSource: function pushSource(source) {
          if (this.pendingContent) {
            this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
            this.pendingContent = void 0;
          }
          if (source) {
            this.source.push(source);
          }
        },
        replaceStack: function replaceStack(callback) {
          var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
          if (!this.isInline()) {
            throw new _exception2["default"]("replaceStack on non-inline");
          }
          var top = this.popStack(true);
          if (top instanceof Literal) {
            stack = [top.value];
            prefix = ["(", stack];
            usedLiteral = true;
          } else {
            createdStack = true;
            var _name = this.incrStack();
            prefix = ["((", this.push(_name), " = ", top, ")"];
            stack = this.topStack();
          }
          var item = callback.call(this, stack);
          if (!usedLiteral) {
            this.popStack();
          }
          if (createdStack) {
            this.stackSlot--;
          }
          this.push(prefix.concat(item, ")"));
        },
        incrStack: function incrStack() {
          this.stackSlot++;
          if (this.stackSlot > this.stackVars.length) {
            this.stackVars.push("stack" + this.stackSlot);
          }
          return this.topStackName();
        },
        topStackName: function topStackName() {
          return "stack" + this.stackSlot;
        },
        flushInline: function flushInline() {
          var inlineStack = this.inlineStack;
          this.inlineStack = [];
          for (var i = 0, len = inlineStack.length; i < len; i++) {
            var entry = inlineStack[i];
            if (entry instanceof Literal) {
              this.compileStack.push(entry);
            } else {
              var stack = this.incrStack();
              this.pushSource([stack, " = ", entry, ";"]);
              this.compileStack.push(stack);
            }
          }
        },
        isInline: function isInline() {
          return this.inlineStack.length;
        },
        popStack: function popStack(wrapped) {
          var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
          if (!wrapped && item instanceof Literal) {
            return item.value;
          } else {
            if (!inline) {
              if (!this.stackSlot) {
                throw new _exception2["default"]("Invalid stack pop");
              }
              this.stackSlot--;
            }
            return item;
          }
        },
        topStack: function topStack() {
          var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
          if (item instanceof Literal) {
            return item.value;
          } else {
            return item;
          }
        },
        contextName: function contextName(context2) {
          if (this.useDepths && context2) {
            return "depths[" + context2 + "]";
          } else {
            return "depth" + context2;
          }
        },
        quotedString: function quotedString(str) {
          return this.source.quotedString(str);
        },
        objectLiteral: function objectLiteral(obj) {
          return this.source.objectLiteral(obj);
        },
        aliasable: function aliasable(name) {
          var ret4 = this.aliases[name];
          if (ret4) {
            ret4.referenceCount++;
            return ret4;
          }
          ret4 = this.aliases[name] = this.source.wrap(name);
          ret4.aliasable = true;
          ret4.referenceCount = 1;
          return ret4;
        },
        setupHelper: function setupHelper(paramSize, name, blockHelper) {
          var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
          var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
          return {
            params,
            paramsInit,
            name: foundHelper,
            callParams: [callContext].concat(params)
          };
        },
        setupParams: function setupParams(helper2, paramSize, params) {
          var options = {}, contexts = [], types2 = [], ids = [], objectArgs = !params, param = void 0;
          if (objectArgs) {
            params = [];
          }
          options.name = this.quotedString(helper2);
          options.hash = this.popStack();
          if (this.trackIds) {
            options.hashIds = this.popStack();
          }
          if (this.stringParams) {
            options.hashTypes = this.popStack();
            options.hashContexts = this.popStack();
          }
          var inverse = this.popStack(), program2 = this.popStack();
          if (program2 || inverse) {
            options.fn = program2 || "container.noop";
            options.inverse = inverse || "container.noop";
          }
          var i = paramSize;
          while (i--) {
            param = this.popStack();
            params[i] = param;
            if (this.trackIds) {
              ids[i] = this.popStack();
            }
            if (this.stringParams) {
              types2[i] = this.popStack();
              contexts[i] = this.popStack();
            }
          }
          if (objectArgs) {
            options.args = this.source.generateArray(params);
          }
          if (this.trackIds) {
            options.ids = this.source.generateArray(ids);
          }
          if (this.stringParams) {
            options.types = this.source.generateArray(types2);
            options.contexts = this.source.generateArray(contexts);
          }
          if (this.options.data) {
            options.data = "data";
          }
          if (this.useBlockParams) {
            options.blockParams = "blockParams";
          }
          return options;
        },
        setupHelperArgs: function setupHelperArgs(helper2, paramSize, params, useRegister) {
          var options = this.setupParams(helper2, paramSize, params);
          options.loc = JSON.stringify(this.source.currentLocation);
          options = this.objectLiteral(options);
          if (useRegister) {
            this.useRegister("options");
            params.push("options");
            return ["options=", options];
          } else if (params) {
            params.push(options);
            return "";
          } else {
            return options;
          }
        }
      };
      (function() {
        var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
        for (var i = 0, l = reservedWords.length; i < l; i++) {
          compilerWords[reservedWords[i]] = true;
        }
      })();
      JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
      };
      function strictLookup(requireTerminal, compiler, parts, i, type3) {
        var stack = compiler.popStack(), len = parts.length;
        if (requireTerminal) {
          len--;
        }
        for (; i < len; i++) {
          stack = compiler.nameLookup(stack, parts[i], type3);
        }
        if (requireTerminal) {
          return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
        } else {
          return stack;
        }
      }
      exports["default"] = JavaScriptCompiler;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars.js
  var require_handlebars = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _handlebarsRuntime = require_handlebars_runtime();
      var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
      var _handlebarsCompilerAst = require_ast();
      var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
      var _handlebarsCompilerBase = require_base2();
      var _handlebarsCompilerCompiler = require_compiler();
      var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
      var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
      var _handlebarsCompilerVisitor = require_visitor();
      var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
      var _handlebarsNoConflict = require_no_conflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      var _create = _handlebarsRuntime2["default"].create;
      function create() {
        var hb = _create();
        hb.compile = function(input, options) {
          return _handlebarsCompilerCompiler.compile(input, options, hb);
        };
        hb.precompile = function(input, options) {
          return _handlebarsCompilerCompiler.precompile(input, options, hb);
        };
        hb.AST = _handlebarsCompilerAst2["default"];
        hb.Compiler = _handlebarsCompilerCompiler.Compiler;
        hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
        hb.Parser = _handlebarsCompilerBase.parser;
        hb.parse = _handlebarsCompilerBase.parse;
        hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
        return hb;
      }
      var inst = create();
      inst.create = create;
      _handlebarsNoConflict2["default"](inst);
      inst.Visitor = _handlebarsCompilerVisitor2["default"];
      inst["default"] = inst;
      exports["default"] = inst;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js
  var require_printer = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.print = print2;
      exports.PrintVisitor = PrintVisitor;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = require_visitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function print2(ast) {
        return new PrintVisitor().accept(ast);
      }
      function PrintVisitor() {
        this.padding = 0;
      }
      PrintVisitor.prototype = new _visitor2["default"]();
      PrintVisitor.prototype.pad = function(string2) {
        var out = "";
        for (var i = 0, l = this.padding; i < l; i++) {
          out += "  ";
        }
        out += string2 + "\n";
        return out;
      };
      PrintVisitor.prototype.Program = function(program2) {
        var out = "", body = program2.body, i = void 0, l = void 0;
        if (program2.blockParams) {
          var blockParams = "BLOCK PARAMS: [";
          for (i = 0, l = program2.blockParams.length; i < l; i++) {
            blockParams += " " + program2.blockParams[i];
          }
          blockParams += " ]";
          out += this.pad(blockParams);
        }
        for (i = 0, l = body.length; i < l; i++) {
          out += this.accept(body[i]);
        }
        this.padding--;
        return out;
      };
      PrintVisitor.prototype.MustacheStatement = function(mustache) {
        return this.pad("{{ " + this.SubExpression(mustache) + " }}");
      };
      PrintVisitor.prototype.Decorator = function(mustache) {
        return this.pad("{{ DIRECTIVE " + this.SubExpression(mustache) + " }}");
      };
      PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function(block2) {
        var out = "";
        out += this.pad((block2.type === "DecoratorBlock" ? "DIRECTIVE " : "") + "BLOCK:");
        this.padding++;
        out += this.pad(this.SubExpression(block2));
        if (block2.program) {
          out += this.pad("PROGRAM:");
          this.padding++;
          out += this.accept(block2.program);
          this.padding--;
        }
        if (block2.inverse) {
          if (block2.program) {
            this.padding++;
          }
          out += this.pad("{{^}}");
          this.padding++;
          out += this.accept(block2.inverse);
          this.padding--;
          if (block2.program) {
            this.padding--;
          }
        }
        this.padding--;
        return out;
      };
      PrintVisitor.prototype.PartialStatement = function(partial) {
        var content = "PARTIAL:" + partial.name.original;
        if (partial.params[0]) {
          content += " " + this.accept(partial.params[0]);
        }
        if (partial.hash) {
          content += " " + this.accept(partial.hash);
        }
        return this.pad("{{> " + content + " }}");
      };
      PrintVisitor.prototype.PartialBlockStatement = function(partial) {
        var content = "PARTIAL BLOCK:" + partial.name.original;
        if (partial.params[0]) {
          content += " " + this.accept(partial.params[0]);
        }
        if (partial.hash) {
          content += " " + this.accept(partial.hash);
        }
        content += " " + this.pad("PROGRAM:");
        this.padding++;
        content += this.accept(partial.program);
        this.padding--;
        return this.pad("{{> " + content + " }}");
      };
      PrintVisitor.prototype.ContentStatement = function(content) {
        return this.pad("CONTENT[ '" + content.value + "' ]");
      };
      PrintVisitor.prototype.CommentStatement = function(comment) {
        return this.pad("{{! '" + comment.value + "' }}");
      };
      PrintVisitor.prototype.SubExpression = function(sexpr) {
        var params = sexpr.params, paramStrings = [], hash3 = void 0;
        for (var i = 0, l = params.length; i < l; i++) {
          paramStrings.push(this.accept(params[i]));
        }
        params = "[" + paramStrings.join(", ") + "]";
        hash3 = sexpr.hash ? " " + this.accept(sexpr.hash) : "";
        return this.accept(sexpr.path) + " " + params + hash3;
      };
      PrintVisitor.prototype.PathExpression = function(id) {
        var path6 = id.parts.join("/");
        return (id.data ? "@" : "") + "PATH:" + path6;
      };
      PrintVisitor.prototype.StringLiteral = function(string2) {
        return '"' + string2.value + '"';
      };
      PrintVisitor.prototype.NumberLiteral = function(number3) {
        return "NUMBER{" + number3.value + "}";
      };
      PrintVisitor.prototype.BooleanLiteral = function(bool) {
        return "BOOLEAN{" + bool.value + "}";
      };
      PrintVisitor.prototype.UndefinedLiteral = function() {
        return "UNDEFINED";
      };
      PrintVisitor.prototype.NullLiteral = function() {
        return "NULL";
      };
      PrintVisitor.prototype.Hash = function(hash3) {
        var pairs = hash3.pairs, joinedPairs = [];
        for (var i = 0, l = pairs.length; i < l; i++) {
          joinedPairs.push(this.accept(pairs[i]));
        }
        return "HASH{" + joinedPairs.join(", ") + "}";
      };
      PrintVisitor.prototype.HashPair = function(pair) {
        return pair.key + "=" + this.accept(pair.value);
      };
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/lib/index.js"(exports, module) {
      var handlebars = require_handlebars()["default"];
      var printer = require_printer();
      handlebars.PrintVisitor = printer.PrintVisitor;
      handlebars.print = printer.print;
      module.exports = handlebars;
      function extension(module2, filename) {
        var fs5 = __require2("fs");
        var templateString = fs5.readFileSync(filename, "utf8");
        module2.exports = handlebars.compile(templateString);
      }
      if (typeof __require2 !== "undefined" && __require2.extensions) {
        __require2.extensions[".handlebars"] = extension;
        __require2.extensions[".hbs"] = extension;
      }
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/styles.js
  var require_styles = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/styles.js"(exports, module) {
      var styles = {};
      module["exports"] = styles;
      var codes3 = {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29],
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        grey: [90, 39],
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // legacy styles for colors pre v1.0.0
        blackBG: [40, 49],
        redBG: [41, 49],
        greenBG: [42, 49],
        yellowBG: [43, 49],
        blueBG: [44, 49],
        magentaBG: [45, 49],
        cyanBG: [46, 49],
        whiteBG: [47, 49]
      };
      Object.keys(codes3).forEach(function(key) {
        var val = codes3[key];
        var style = styles[key] = [];
        style.open = "\x1B[" + val[0] + "m";
        style.close = "\x1B[" + val[1] + "m";
      });
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/system/supports-colors.js
  var require_supports_colors = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/system/supports-colors.js"(exports, module) {
      var argv = process.argv;
      module.exports = function() {
        if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
          return false;
        }
        if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
          return true;
        }
        if (process.stdout && !process.stdout.isTTY) {
          return false;
        }
        if (process.platform === "win32") {
          return true;
        }
        if ("COLORTERM" in process.env) {
          return true;
        }
        if (process.env.TERM === "dumb") {
          return false;
        }
        if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
          return true;
        }
        return false;
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/trap.js
  var require_trap = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/trap.js"(exports, module) {
      module["exports"] = function runTheTrap(text, options) {
        var result = "";
        text = text || "Run the trap, drop the bass";
        text = text.split("");
        var trap = {
          a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
          b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
          c: ["\xA9", "\u023B", "\u03FE"],
          d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
          e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
          f: ["\u04FA"],
          g: ["\u0262"],
          h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
          i: ["\u0F0F"],
          j: ["\u0134"],
          k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
          l: ["\u0139"],
          m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
          n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
          o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
          p: ["\u01F7", "\u048E"],
          q: ["\u09CD"],
          r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
          s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
          t: ["\u0141", "\u0166", "\u0373"],
          u: ["\u01B1", "\u054D"],
          v: ["\u05D8"],
          w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
          x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
          y: ["\xA5", "\u04B0", "\u04CB"],
          z: ["\u01B5", "\u0240"]
        };
        text.forEach(function(c) {
          c = c.toLowerCase();
          var chars = trap[c] || [" "];
          var rand = Math.floor(Math.random() * chars.length);
          if (typeof trap[c] !== "undefined") {
            result += trap[c][rand];
          } else {
            result += c;
          }
        });
        return result;
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/zalgo.js
  var require_zalgo = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/zalgo.js"(exports, module) {
      module["exports"] = function zalgo(text, options) {
        text = text || "   he is here   ";
        var soul = {
          "up": [
            "\u030D",
            "\u030E",
            "\u0304",
            "\u0305",
            "\u033F",
            "\u0311",
            "\u0306",
            "\u0310",
            "\u0352",
            "\u0357",
            "\u0351",
            "\u0307",
            "\u0308",
            "\u030A",
            "\u0342",
            "\u0313",
            "\u0308",
            "\u034A",
            "\u034B",
            "\u034C",
            "\u0303",
            "\u0302",
            "\u030C",
            "\u0350",
            "\u0300",
            "\u0301",
            "\u030B",
            "\u030F",
            "\u0312",
            "\u0313",
            "\u0314",
            "\u033D",
            "\u0309",
            "\u0363",
            "\u0364",
            "\u0365",
            "\u0366",
            "\u0367",
            "\u0368",
            "\u0369",
            "\u036A",
            "\u036B",
            "\u036C",
            "\u036D",
            "\u036E",
            "\u036F",
            "\u033E",
            "\u035B",
            "\u0346",
            "\u031A"
          ],
          "down": [
            "\u0316",
            "\u0317",
            "\u0318",
            "\u0319",
            "\u031C",
            "\u031D",
            "\u031E",
            "\u031F",
            "\u0320",
            "\u0324",
            "\u0325",
            "\u0326",
            "\u0329",
            "\u032A",
            "\u032B",
            "\u032C",
            "\u032D",
            "\u032E",
            "\u032F",
            "\u0330",
            "\u0331",
            "\u0332",
            "\u0333",
            "\u0339",
            "\u033A",
            "\u033B",
            "\u033C",
            "\u0345",
            "\u0347",
            "\u0348",
            "\u0349",
            "\u034D",
            "\u034E",
            "\u0353",
            "\u0354",
            "\u0355",
            "\u0356",
            "\u0359",
            "\u035A",
            "\u0323"
          ],
          "mid": [
            "\u0315",
            "\u031B",
            "\u0300",
            "\u0301",
            "\u0358",
            "\u0321",
            "\u0322",
            "\u0327",
            "\u0328",
            "\u0334",
            "\u0335",
            "\u0336",
            "\u035C",
            "\u035D",
            "\u035E",
            "\u035F",
            "\u0360",
            "\u0362",
            "\u0338",
            "\u0337",
            "\u0361",
            " \u0489"
          ]
        }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
        function randomNumber(range) {
          var r = Math.floor(Math.random() * range);
          return r;
        }
        function is_char(character) {
          var bool = false;
          all.filter(function(i) {
            bool = i === character;
          });
          return bool;
        }
        function heComes(text2, options2) {
          var result = "", counts, l;
          options2 = options2 || {};
          options2["up"] = options2["up"] || true;
          options2["mid"] = options2["mid"] || true;
          options2["down"] = options2["down"] || true;
          options2["size"] = options2["size"] || "maxi";
          text2 = text2.split("");
          for (l in text2) {
            if (is_char(l)) {
              continue;
            }
            result = result + text2[l];
            counts = { "up": 0, "down": 0, "mid": 0 };
            switch (options2.size) {
              case "mini":
                counts.up = randomNumber(8);
                counts.min = randomNumber(2);
                counts.down = randomNumber(8);
                break;
              case "maxi":
                counts.up = randomNumber(16) + 3;
                counts.min = randomNumber(4) + 1;
                counts.down = randomNumber(64) + 3;
                break;
              default:
                counts.up = randomNumber(8) + 1;
                counts.mid = randomNumber(6) / 2;
                counts.down = randomNumber(8) + 1;
                break;
            }
            var arr = ["up", "mid", "down"];
            for (var d in arr) {
              var index = arr[d];
              for (var i = 0; i <= counts[index]; i++) {
                if (options2[index]) {
                  result = result + soul[index][randomNumber(soul[index].length)];
                }
              }
            }
          }
          return result;
        }
        return heComes(text);
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/america.js
  var require_america = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/america.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = function() {
        return function(letter, i, exploded) {
          if (letter === " ")
            return letter;
          switch (i % 3) {
            case 0:
              return colors.red(letter);
            case 1:
              return colors.white(letter);
            case 2:
              return colors.blue(letter);
          }
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/zebra.js
  var require_zebra = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/zebra.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/rainbow.js
  var require_rainbow = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/rainbow.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = function() {
        var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
        return function(letter, i, exploded) {
          if (letter === " ") {
            return letter;
          } else {
            return colors[rainbowColors[i++ % rainbowColors.length]](letter);
          }
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/random.js
  var require_random = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/random.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = function() {
        var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
        return function(letter, i, exploded) {
          return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/colors.js
  var require_colors = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/colors.js"(exports, module) {
      var colors = {};
      module["exports"] = colors;
      colors.themes = {};
      var ansiStyles = colors.styles = require_styles();
      var defineProps = Object.defineProperties;
      colors.supportsColor = require_supports_colors();
      if (typeof colors.enabled === "undefined") {
        colors.enabled = colors.supportsColor;
      }
      colors.stripColors = colors.strip = function(str) {
        return ("" + str).replace(/\x1B\[\d+m/g, "");
      };
      var stylize = colors.stylize = function stylize2(str, style) {
        return ansiStyles[style].open + str + ansiStyles[style].close;
      };
      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
      var escapeStringRegexp = function(str) {
        if (typeof str !== "string") {
          throw new TypeError("Expected a string");
        }
        return str.replace(matchOperatorsRe, "\\$&");
      };
      function build3(_styles) {
        var builder = function builder2() {
          return applyStyle.apply(builder2, arguments);
        };
        builder._styles = _styles;
        builder.__proto__ = proto;
        return builder;
      }
      var styles = function() {
        var ret4 = {};
        ansiStyles.grey = ansiStyles.gray;
        Object.keys(ansiStyles).forEach(function(key) {
          ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
          ret4[key] = {
            get: function() {
              return build3(this._styles.concat(key));
            }
          };
        });
        return ret4;
      }();
      var proto = defineProps(function colors2() {
      }, styles);
      function applyStyle() {
        var args = arguments;
        var argsLen = args.length;
        var str = argsLen !== 0 && String(arguments[0]);
        if (argsLen > 1) {
          for (var a = 1; a < argsLen; a++) {
            str += " " + args[a];
          }
        }
        if (!colors.enabled || !str) {
          return str;
        }
        var nestedStyles = this._styles;
        var i = nestedStyles.length;
        while (i--) {
          var code = ansiStyles[nestedStyles[i]];
          str = code.open + str.replace(code.closeRe, code.open) + code.close;
        }
        return str;
      }
      function applyTheme(theme) {
        for (var style in theme) {
          (function(style2) {
            colors[style2] = function(str) {
              return colors[theme[style2]](str);
            };
          })(style);
        }
      }
      colors.setTheme = function(theme) {
        if (typeof theme === "string") {
          try {
            colors.themes[theme] = __require2(theme);
            applyTheme(colors.themes[theme]);
            return colors.themes[theme];
          } catch (err2) {
            console.log(err2);
            return err2;
          }
        } else {
          applyTheme(theme);
        }
      };
      function init2() {
        var ret4 = {};
        Object.keys(styles).forEach(function(name) {
          ret4[name] = {
            get: function() {
              return build3([name]);
            }
          };
        });
        return ret4;
      }
      var sequencer = function sequencer2(map3, str) {
        var exploded = str.split(""), i = 0;
        exploded = exploded.map(map3);
        return exploded.join("");
      };
      colors.trap = require_trap();
      colors.zalgo = require_zalgo();
      colors.maps = {};
      colors.maps.america = require_america();
      colors.maps.zebra = require_zebra();
      colors.maps.rainbow = require_rainbow();
      colors.maps.random = require_random();
      for (map2 in colors.maps) {
        (function(map3) {
          colors[map3] = function(str) {
            return sequencer(colors.maps[map3], str);
          };
        })(map2);
      }
      var map2;
      defineProps(colors, init2());
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/safe.js
  var require_safe = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/safe.js"(exports, module) {
      var colors = require_colors();
      module["exports"] = colors;
    }
  });

  // ../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/utils.js"(exports) {
      exports.repeat = function(str, times) {
        return Array(times + 1).join(str);
      };
      exports.pad = function(str, len, pad, dir) {
        if (len + 1 >= str.length)
          switch (dir) {
            case "left":
              str = Array(len + 1 - str.length).join(pad) + str;
              break;
            case "both":
              var right = Math.ceil((padlen = len - str.length) / 2);
              var left = padlen - right;
              str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);
              break;
            default:
              str = str + Array(len + 1 - str.length).join(pad);
          }
        ;
        return str;
      };
      exports.truncate = function(str, length, chr) {
        chr = chr || "\u2026";
        return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
      };
      function options(defaults2, opts) {
        for (var p in opts) {
          if (p === "__proto__" || p === "constructor" || p === "prototype") {
            continue;
          }
          if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
            defaults2[p] = defaults2[p] || {};
            options(defaults2[p], opts[p]);
          } else {
            defaults2[p] = opts[p];
          }
        }
        return defaults2;
      }
      exports.options = options;
      exports.strlen = function(str) {
        var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
        var stripped = ("" + str).replace(code, "");
        var split3 = stripped.split("\n");
        return split3.reduce(function(memo, s) {
          return s.length > memo ? s.length : memo;
        }, 0);
      };
    }
  });

  // ../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/index.js
  var require_lib2 = __commonJS({
    "../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/index.js"(exports, module) {
      var colors = require_safe();
      var utils = require_utils2();
      var repeat = utils.repeat;
      var truncate = utils.truncate;
      var pad = utils.pad;
      function Table(options) {
        this.options = utils.options({
          chars: {
            "top": "\u2500",
            "top-mid": "\u252C",
            "top-left": "\u250C",
            "top-right": "\u2510",
            "bottom": "\u2500",
            "bottom-mid": "\u2534",
            "bottom-left": "\u2514",
            "bottom-right": "\u2518",
            "left": "\u2502",
            "left-mid": "\u251C",
            "mid": "\u2500",
            "mid-mid": "\u253C",
            "right": "\u2502",
            "right-mid": "\u2524",
            "middle": "\u2502"
          },
          truncate: "\u2026",
          colWidths: [],
          colAligns: [],
          style: {
            "padding-left": 1,
            "padding-right": 1,
            head: ["red"],
            border: ["grey"],
            compact: false
          },
          head: []
        }, options);
        if (options && options.rows) {
          for (var i = 0; i < options.rows.length; i++) {
            this.push(options.rows[i]);
          }
        }
      }
      Table.prototype.__proto__ = Array.prototype;
      Table.prototype.__defineGetter__("width", function() {
        var str = this.toString().split("\n");
        if (str.length)
          return str[0].length;
        return 0;
      });
      Table.prototype.render;
      Table.prototype.toString = function() {
        var ret4 = "", options = this.options, style = options.style, head = options.head, chars = options.chars, truncater = options.truncate, colWidths = options.colWidths || new Array(this.head.length), totalWidth = 0;
        if (!head.length && !this.length)
          return "";
        if (!colWidths.length) {
          var all_rows = this.slice(0);
          if (head.length) {
            all_rows = all_rows.concat([head]);
          }
          ;
          all_rows.forEach(function(cells) {
            if (typeof cells === "object" && cells.length) {
              extractColumnWidths(cells);
            } else {
              var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
              colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
              if (typeof value_cell === "object" && value_cell.length) {
                extractColumnWidths(value_cell, 1);
              } else {
                colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
              }
            }
          });
        }
        ;
        totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(
          function(a, b) {
            return a + b;
          }
        )) + colWidths.length + 1;
        function extractColumnWidths(arr, offset) {
          var offset = offset || 0;
          arr.forEach(function(cell, i) {
            colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
          });
        }
        ;
        function get_width(obj) {
          return typeof obj == "object" && obj.width != void 0 ? obj.width : (typeof obj == "object" ? utils.strlen(obj.text) : utils.strlen(obj)) + (style["padding-left"] || 0) + (style["padding-right"] || 0);
        }
        function line(line2, left, right, intersection) {
          var width = 0, line2 = left + repeat(line2, totalWidth - 2) + right;
          colWidths.forEach(function(w, i) {
            if (i == colWidths.length - 1)
              return;
            width += w + 1;
            line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
          });
          return applyStyles(options.style.border, line2);
        }
        ;
        function lineTop() {
          var l2 = line(
            chars.top,
            chars["top-left"] || chars.top,
            chars["top-right"] || chars.top,
            chars["top-mid"]
          );
          if (l2)
            ret4 += l2 + "\n";
        }
        ;
        function generateRow(items, style2) {
          var cells = [], max_height = 0;
          if (!Array.isArray(items) && typeof items === "object") {
            var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
            if (Array.isArray(value)) {
              items = value;
              items.unshift(key);
            } else {
              items = [key, value];
            }
          }
          items.forEach(function(item, i) {
            var contents = item.toString().split("\n").reduce(function(memo, l2) {
              memo.push(string2(l2, i));
              return memo;
            }, []);
            var height = contents.length;
            if (height > max_height) {
              max_height = height;
            }
            ;
            cells.push({ contents, height });
          });
          var lines = new Array(max_height);
          cells.forEach(function(cell, i) {
            cell.contents.forEach(function(line2, j2) {
              if (!lines[j2]) {
                lines[j2] = [];
              }
              ;
              if (style2 || first_cell_head && i === 0 && options.style.head) {
                line2 = applyStyles(options.style.head, line2);
              }
              lines[j2].push(line2);
            });
            for (var j = cell.height, l2 = max_height; j < l2; j++) {
              if (!lines[j]) {
                lines[j] = [];
              }
              ;
              lines[j].push(string2("", i));
            }
          });
          var ret5 = "";
          lines.forEach(function(line2, index) {
            if (ret5.length > 0) {
              ret5 += "\n" + applyStyles(options.style.border, chars.left);
            }
            ret5 += line2.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
          });
          return applyStyles(options.style.border, chars.left) + ret5;
        }
        ;
        function applyStyles(styles, subject) {
          if (!subject)
            return "";
          styles.forEach(function(style2) {
            subject = colors[style2](subject);
          });
          return subject;
        }
        ;
        function string2(str, index) {
          var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style["padding-left"] || 0) - (style["padding-right"] || 0), align = options.colAligns[index] || "left";
          return repeat(" ", style["padding-left"] || 0) + (length == width ? str : length < width ? pad(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat(" ", style["padding-right"] || 0);
        }
        ;
        if (head.length) {
          lineTop();
          ret4 += generateRow(head, style.head) + "\n";
        }
        if (this.length)
          this.forEach(function(cells, i) {
            if (!head.length && i == 0)
              lineTop();
            else {
              if (!style.compact || i < !!head.length ? 1 : cells.length == 0) {
                var l2 = line(
                  chars.mid,
                  chars["left-mid"],
                  chars["right-mid"],
                  chars["mid-mid"]
                );
                if (l2)
                  ret4 += l2 + "\n";
              }
            }
            if (cells.hasOwnProperty("length") && !cells.length) {
              return;
            } else {
              ret4 += generateRow(cells) + "\n";
            }
            ;
          });
        var l = line(
          chars.bottom,
          chars["bottom-left"] || chars.bottom,
          chars["bottom-right"] || chars.bottom,
          chars["bottom-mid"]
        );
        if (l)
          ret4 += l;
        else
          ret4 = ret4.slice(0, -1);
        return ret4;
      };
      module.exports = Table;
      module.exports.version = "0.0.1";
    }
  });

  // ../../node_modules/.pnpm/lodash.camelcase@4.3.0/node_modules/lodash.camelcase/index.js
  var require_lodash = __commonJS({
    "../../node_modules/.pnpm/lodash.camelcase@4.3.0/node_modules/lodash.camelcase/index.js"(exports, module) {
      var INFINITY = 1 / 0;
      var symbolTag = "[object Symbol]";
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
      var rsComboSymbolsRange = "\\u20d0-\\u20f0";
      var rsDingbatRange = "\\u2700-\\u27bf";
      var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
      var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
      var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
      var rsPunctuationRange = "\\u2000-\\u206f";
      var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
      var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsBreak = "[" + rsBreakRange + "]";
      var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
      var rsDigits = "\\d+";
      var rsDingbat = "[" + rsDingbatRange + "]";
      var rsLower = "[" + rsLowerRange + "]";
      var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsUpper = "[" + rsUpperRange + "]";
      var rsZWJ = "\\u200d";
      var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
      var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
      var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
      var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
        rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
        rsUpper + "+" + rsOptUpperContr,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "ss"
      };
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 ? array2.length : 0;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var Symbol2 = root.Symbol;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
      function baseSlice(array2, start, end) {
        var index = -1, length = array2.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array2[index + start];
        }
        return result;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castSlice(array2, start, end) {
        var length = array2.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array2 : baseSlice(array2, start, end);
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString3(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function isObjectLike2(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
      }
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      var camelCase3 = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      function capitalize(string2) {
        return upperFirst3(toString3(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString3(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      var upperFirst3 = createCaseFirst("toUpperCase");
      function words(string2, pattern, guard) {
        string2 = toString3(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      module.exports = camelCase3;
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/parser.js
  var require_parser2 = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/parser.js"(exports, module) {
      module.exports = function() {
        function peg$subclass(child, parent) {
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
        }
        function SyntaxError2(message, expected, found, offset, line, column) {
          this.message = message;
          this.expected = expected;
          this.found = found;
          this.offset = offset;
          this.line = line;
          this.column = column;
          this.name = "SyntaxError";
        }
        peg$subclass(SyntaxError2, Error);
        function parse9(input) {
          var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
            return nodes;
          }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
            addNode(node2("ObjectPath", name, line, column));
          }, peg$c12 = function(name) {
            addNode(node2("ArrayPath", name, line, column));
          }, peg$c13 = function(parts, name) {
            return parts.concat(name);
          }, peg$c14 = function(name) {
            return [name];
          }, peg$c15 = function(name) {
            return name;
          }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
            addNode(node2("Assign", value, line, column, key));
          }, peg$c21 = function(chars) {
            return chars.join("");
          }, peg$c22 = function(node3) {
            return node3.value;
          }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
            return node2("String", chars.join(""), line, column);
          }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
            return char;
          }, peg$c34 = function(char) {
            return char;
          }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
            return "";
          }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left, right) {
            return node2("Float", parseFloat(left + "e" + right), line, column);
          }, peg$c43 = function(text2) {
            return node2("Float", parseFloat(text2), line, column);
          }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
            return digits.join("");
          }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
            return "-" + digits.join("");
          }, peg$c50 = function(text2) {
            return node2("Integer", parseInt(text2, 10), line, column);
          }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
            return node2("Boolean", true, line, column);
          }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
            return node2("Boolean", false, line, column);
          }, peg$c57 = function() {
            return node2("Array", [], line, column);
          }, peg$c58 = function(value) {
            return node2("Array", value ? [value] : [], line, column);
          }, peg$c59 = function(values) {
            return node2("Array", values, line, column);
          }, peg$c60 = function(values, value) {
            return node2("Array", values.concat(value), line, column);
          }, peg$c61 = function(value) {
            return value;
          }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values) {
            return node2("InlineTable", values, line, column);
          }, peg$c69 = function(key, value) {
            return node2("InlineTableValue", value, line, column, key);
          }, peg$c70 = function(digits) {
            return "." + digits;
          }, peg$c71 = function(date2) {
            return date2.join("");
          }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time) {
            return time.join("");
          }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date2, time) {
            return node2("Date", /* @__PURE__ */ new Date(date2 + "T" + time + "Z"), line, column);
          }, peg$c80 = function(date2, time) {
            return node2("Date", /* @__PURE__ */ new Date(date2 + "T" + time), line, column);
          }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
            return "";
          }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
            return d.join("");
          }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
            return '"';
          }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
            return "\\";
          }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
            return "\b";
          }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
            return "	";
          }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
            return "\n";
          }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
            return "\f";
          }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
            return "\r";
          }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
            return convertCodePoint(digits.join(""));
          }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function text() {
            return input.substring(peg$reportedPos, peg$currPos);
          }
          function offset() {
            return peg$reportedPos;
          }
          function line() {
            return peg$computePosDetails(peg$reportedPos).line;
          }
          function column() {
            return peg$computePosDetails(peg$reportedPos).column;
          }
          function expected(description) {
            throw peg$buildException(
              null,
              [{ type: "other", description }],
              peg$reportedPos
            );
          }
          function error3(message) {
            throw peg$buildException(message, null, peg$reportedPos);
          }
          function peg$computePosDetails(pos) {
            function advance(details, startPos, endPos) {
              var p, ch;
              for (p = startPos; p < endPos; p++) {
                ch = input.charAt(p);
                if (ch === "\n") {
                  if (!details.seenCR) {
                    details.line++;
                  }
                  details.column = 1;
                  details.seenCR = false;
                } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                  details.line++;
                  details.column = 1;
                  details.seenCR = true;
                } else {
                  details.column++;
                  details.seenCR = false;
                }
              }
            }
            if (peg$cachedPos !== pos) {
              if (peg$cachedPos > pos) {
                peg$cachedPos = 0;
                peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
              }
              advance(peg$cachedPosDetails, peg$cachedPos, pos);
              peg$cachedPos = pos;
            }
            return peg$cachedPosDetails;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildException(message, expected2, pos) {
            function cleanupExpected(expected3) {
              var i = 1;
              expected3.sort(function(a, b) {
                if (a.description < b.description) {
                  return -1;
                } else if (a.description > b.description) {
                  return 1;
                } else {
                  return 0;
                }
              });
              while (i < expected3.length) {
                if (expected3[i - 1] === expected3[i]) {
                  expected3.splice(i, 1);
                } else {
                  i++;
                }
              }
            }
            function buildMessage(expected3, found2) {
              function stringEscape(s) {
                function hex(ch) {
                  return ch.charCodeAt(0).toString(16).toUpperCase();
                }
                return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                  return "\\x0" + hex(ch);
                }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                  return "\\x" + hex(ch);
                }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                  return "\\u0" + hex(ch);
                }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                  return "\\u" + hex(ch);
                });
              }
              var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
              for (i = 0; i < expected3.length; i++) {
                expectedDescs[i] = expected3[i].description;
              }
              expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
              foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
              return "Expected " + expectedDesc + " but " + foundDesc + " found.";
            }
            var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
            if (expected2 !== null) {
              cleanupExpected(expected2);
            }
            return new SyntaxError2(
              message !== null ? message : buildMessage(expected2, found),
              expected2,
              found,
              pos,
              posDetails.line,
              posDetails.column
            );
          }
          function peg$parsestart() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 0, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseline();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseline();
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c1();
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseline() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 1, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseexpression();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parsecomment();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parsecomment();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseNL();
                    if (s6 !== peg$FAILED) {
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseNL();
                      }
                    } else {
                      s5 = peg$c2;
                    }
                    if (s5 === peg$FAILED) {
                      s5 = peg$parseEOF();
                    }
                    if (s5 !== peg$FAILED) {
                      s1 = [s1, s2, s3, s4, s5];
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parseS();
                }
              } else {
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseNL();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parseNL();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 === peg$FAILED) {
                  s2 = peg$parseEOF();
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseNL();
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseexpression() {
            var s0;
            var key = peg$currPos * 49 + 2, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsecomment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsepath();
              if (s0 === peg$FAILED) {
                s0 = peg$parsetablearray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseassignment();
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsecomment() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 3, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s1 = peg$c3;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseNL();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = peg$c5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseNL();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseEOF();
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = peg$c5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c2;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c6);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c2;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsepath() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 4, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetable_key();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s5 = peg$c9;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c11(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetablearray() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            var key = peg$currPos * 49 + 5, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s2 = peg$c7;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsetable_key();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s6 = peg$c9;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s7 = peg$c9;
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                          }
                        }
                        if (s7 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c12(s4);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetable_key() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 6, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsedot_ended_table_key_part();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsedot_ended_table_key_part();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsetable_key_part();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c13(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsetable_key_part();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c14(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetable_key_part() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 7, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsequoted_key();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedot_ended_table_key_part() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 8, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsequoted_key();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s4 = peg$c16;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c17);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseS();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseS();
                      }
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c15(s2);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseassignment() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 9, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsekey();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c18;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsevalue();
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c20(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsequoted_key();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseS();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseS();
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s3 = peg$c18;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parseS();
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parseS();
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsevalue();
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c20(s1, s5);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsekey() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 10, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseASCII_BASIC();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseASCII_BASIC();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c21(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsequoted_key() {
            var s0, s1;
            var key = peg$currPos * 49 + 11, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsedouble_quoted_single_line_string();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c22(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsesingle_quoted_single_line_string();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c22(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsevalue() {
            var s0;
            var key = peg$currPos * 49 + 12, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsestring();
            if (s0 === peg$FAILED) {
              s0 = peg$parsedatetime();
              if (s0 === peg$FAILED) {
                s0 = peg$parsefloat();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseinteger();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseboolean();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsearray();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseinline_table();
                      }
                    }
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsestring() {
            var s0;
            var key = peg$currPos * 49 + 13, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsedouble_quoted_multiline_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsedouble_quoted_single_line_string();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesingle_quoted_multiline_string();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsesingle_quoted_single_line_string();
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedouble_quoted_multiline_string() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 14, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c23) {
              s1 = peg$c23;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsemultiline_string_char();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsemultiline_string_char();
                }
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c23) {
                    s4 = peg$c23;
                    peg$currPos += 3;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c24);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c26(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedouble_quoted_single_line_string() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 15, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
              s1 = peg$c27;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsestring_char();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsestring_char();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s3 = peg$c27;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c28);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesingle_quoted_multiline_string() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 16, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c29) {
              s1 = peg$c29;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsemultiline_literal_char();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsemultiline_literal_char();
                }
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c29) {
                    s4 = peg$c29;
                    peg$currPos += 3;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c30);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c26(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesingle_quoted_single_line_string() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 17, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c31;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseliteral_char();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseliteral_char();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c31;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c32);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsestring_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 18, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseESCAPED();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 34) {
                s2 = peg$c27;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = peg$c5;
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c33(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseliteral_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 19, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c31;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_string_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 20, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseESCAPED();
            if (s0 === peg$FAILED) {
              s0 = peg$parsemultiline_string_delim();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 3) === peg$c23) {
                  s2 = peg$c23;
                  peg$currPos += 3;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                peg$silentFails--;
                if (s2 === peg$FAILED) {
                  s1 = peg$c5;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
                if (s1 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c6);
                    }
                  }
                  if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c34(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_string_delim() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 21, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s1 = peg$c35;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c36);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseNLS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseNLS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c37();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_literal_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 22, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 3) === peg$c29) {
              s2 = peg$c29;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsefloat() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 23, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsefloat_text();
            if (s1 === peg$FAILED) {
              s1 = peg$parseinteger_text();
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 101) {
                s2 = peg$c38;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c39);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 69) {
                  s2 = peg$c40;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c41);
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseinteger_text();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c42(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsefloat_text();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c43(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsefloat_text() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 24, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c44;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s1 === peg$FAILED) {
              s1 = peg$c25;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseDIGITS();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGITS();
                  if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c47;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseDIGITS();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseDIGITS();
                    if (s5 !== peg$FAILED) {
                      s3 = [s3, s4, s5];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c49(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinteger() {
            var s0, s1;
            var key = peg$currPos * 49 + 25, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parseinteger_text();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c50(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinteger_text() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 26, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c44;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s1 === peg$FAILED) {
              s1 = peg$c25;
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseDIGIT_OR_UNDER();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                  s3 = peg$c5;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c46(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c47;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseDIGIT_OR_UNDER();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parseDIGIT_OR_UNDER();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$currPos;
                  peg$silentFails++;
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  peg$silentFails--;
                  if (s4 === peg$FAILED) {
                    s3 = peg$c5;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c2;
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c49(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseboolean() {
            var s0, s1;
            var key = peg$currPos * 49 + 27, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c53();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 5) === peg$c54) {
                s1 = peg$c54;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c55);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c56();
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 28, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearray_sep();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsearray_sep();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c57();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsearray_value();
                if (s2 === peg$FAILED) {
                  s2 = peg$c25;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c9;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c58(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                  s1 = peg$c7;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c8);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parsearray_value_list();
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$parsearray_value_list();
                    }
                  } else {
                    s2 = peg$c2;
                  }
                  if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s3 = peg$c9;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c59(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 91) {
                    s1 = peg$c7;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c8);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parsearray_value_list();
                    if (s3 !== peg$FAILED) {
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$parsearray_value_list();
                      }
                    } else {
                      s2 = peg$c2;
                    }
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parsearray_value();
                      if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s4 = peg$c9;
                          peg$currPos++;
                        } else {
                          s4 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                          }
                        }
                        if (s4 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c60(s2, s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_value() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 29, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsearray_sep();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsearray_sep();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsevalue();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsearray_sep();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsearray_sep();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_value_list() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 30, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsearray_sep();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsearray_sep();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsevalue();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsearray_sep();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsearray_sep();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s4 = peg$c62;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c63);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parsearray_sep();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parsearray_sep();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c61(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_sep() {
            var s0;
            var key = peg$currPos * 49 + 31, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseS();
            if (s0 === peg$FAILED) {
              s0 = peg$parseNL();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecomment();
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinline_table() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 32, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 123) {
              s1 = peg$c64;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c65);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseinline_table_assignment();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseinline_table_assignment();
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s5 = peg$c66;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c67);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c68(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinline_table_assignment() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 33, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s4 = peg$c18;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsevalue();
                      if (s6 !== peg$FAILED) {
                        s7 = [];
                        s8 = peg$parseS();
                        while (s8 !== peg$FAILED) {
                          s7.push(s8);
                          s8 = peg$parseS();
                        }
                        if (s7 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s8 = peg$c62;
                            peg$currPos++;
                          } else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c63);
                            }
                          }
                          if (s8 !== peg$FAILED) {
                            s9 = [];
                            s10 = peg$parseS();
                            while (s10 !== peg$FAILED) {
                              s9.push(s10);
                              s10 = peg$parseS();
                            }
                            if (s9 !== peg$FAILED) {
                              peg$reportedPos = s0;
                              s1 = peg$c69(s2, s6);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c2;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsekey();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 61) {
                      s4 = peg$c18;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c19);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseS();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseS();
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsevalue();
                        if (s6 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c69(s2, s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesecfragment() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 34, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s1 = peg$c16;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseDIGITS();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c70(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedate() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
            var key = peg$currPos * 49 + 35, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseDIGIT_OR_UNDER();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 45) {
                      s6 = peg$c47;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c48);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseDIGIT_OR_UNDER();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 45) {
                            s9 = peg$c47;
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c48);
                            }
                          }
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseDIGIT_OR_UNDER();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parseDIGIT_OR_UNDER();
                              if (s11 !== peg$FAILED) {
                                s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                                s1 = s2;
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c71(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetime() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 36, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c72;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c73);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseDIGIT_OR_UNDER();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s7 = peg$c72;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c73);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseDIGIT_OR_UNDER();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parsesecfragment();
                            if (s10 === peg$FAILED) {
                              s10 = peg$c25;
                            }
                            if (s10 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c74(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetime_with_offset() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
            var key = peg$currPos * 49 + 37, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c72;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c73);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseDIGIT_OR_UNDER();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s7 = peg$c72;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c73);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseDIGIT_OR_UNDER();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parsesecfragment();
                            if (s10 === peg$FAILED) {
                              s10 = peg$c25;
                            }
                            if (s10 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 45) {
                                s11 = peg$c47;
                                peg$currPos++;
                              } else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c48);
                                }
                              }
                              if (s11 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 43) {
                                  s11 = peg$c44;
                                  peg$currPos++;
                                } else {
                                  s11 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c45);
                                  }
                                }
                              }
                              if (s11 !== peg$FAILED) {
                                s12 = peg$parseDIGIT_OR_UNDER();
                                if (s12 !== peg$FAILED) {
                                  s13 = peg$parseDIGIT_OR_UNDER();
                                  if (s13 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 58) {
                                      s14 = peg$c72;
                                      peg$currPos++;
                                    } else {
                                      s14 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c73);
                                      }
                                    }
                                    if (s14 !== peg$FAILED) {
                                      s15 = peg$parseDIGIT_OR_UNDER();
                                      if (s15 !== peg$FAILED) {
                                        s16 = peg$parseDIGIT_OR_UNDER();
                                        if (s16 !== peg$FAILED) {
                                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                          s1 = s2;
                                        } else {
                                          peg$currPos = s1;
                                          s1 = peg$c2;
                                        }
                                      } else {
                                        peg$currPos = s1;
                                        s1 = peg$c2;
                                      }
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c74(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedatetime() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 38, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsedate();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 84) {
                s2 = peg$c75;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c76);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetime();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 90) {
                    s4 = peg$c77;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c78);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c79(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsedate();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 84) {
                  s2 = peg$c75;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c76);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsetime_with_offset();
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c80(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseS() {
            var s0;
            var key = peg$currPos * 49 + 39, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c81.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c82);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseNL() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 40, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (input.charCodeAt(peg$currPos) === 10) {
              s0 = peg$c83;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 13) {
                s1 = peg$c85;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c86);
                }
              }
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 10) {
                  s2 = peg$c83;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c84);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseNLS() {
            var s0;
            var key = peg$currPos * 49 + 41, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseNL();
            if (s0 === peg$FAILED) {
              s0 = peg$parseS();
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseEOF() {
            var s0, s1;
            var key = peg$currPos * 49 + 42, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = peg$c5;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseHEX() {
            var s0;
            var key = peg$currPos * 49 + 43, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c87.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c88);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseDIGIT_OR_UNDER() {
            var s0, s1;
            var key = peg$currPos * 49 + 44, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c89.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 95) {
                s1 = peg$c91;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c92);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c93();
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseASCII_BASIC() {
            var s0;
            var key = peg$currPos * 49 + 45, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c94.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c95);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseDIGITS() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 46, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c96(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseESCAPED() {
            var s0, s1;
            var key = peg$currPos * 49 + 47, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c97) {
              s1 = peg$c97;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c98);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c99();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c100) {
                s1 = peg$c100;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c101);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c102();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c103) {
                  s1 = peg$c103;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c104);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c105();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c106) {
                    s1 = peg$c106;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c107);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c108();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c109) {
                      s1 = peg$c109;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c110);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c111();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c112) {
                        s1 = peg$c112;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c113);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c114();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c115) {
                          s1 = peg$c115;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c116);
                          }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c117();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseESCAPED_UNICODE();
                        }
                      }
                    }
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseESCAPED_UNICODE() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 48, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c118) {
              s1 = peg$c118;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c119);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseHEX();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHEX();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseHEX();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseHEX();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseHEX();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseHEX();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseHEX();
                            if (s10 !== peg$FAILED) {
                              s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                              s2 = s3;
                            } else {
                              peg$currPos = s2;
                              s2 = peg$c2;
                            }
                          } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c120(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c121) {
                s1 = peg$c121;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c122);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseHEX();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseHEX();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseHEX();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseHEX();
                      if (s6 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c120(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          var nodes = [];
          function genError(err2, line2, col) {
            var ex = new Error(err2);
            ex.line = line2;
            ex.column = col;
            throw ex;
          }
          function addNode(node3) {
            nodes.push(node3);
          }
          function node2(type3, value, line2, column2, key) {
            var obj = { type: type3, value, line: line2(), column: column2() };
            if (key)
              obj.key = key;
            return obj;
          }
          function convertCodePoint(str, line2, col) {
            var num = parseInt("0x" + str);
            if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
              genError("Invalid Unicode escape code: " + str, line2, col);
            } else {
              return fromCodePoint(num);
            }
          }
          function fromCodePoint() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                result += String.fromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail({ type: "end", description: "end of input" });
            }
            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
          }
        }
        return {
          SyntaxError: SyntaxError2,
          parse: parse9
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js
  var require_compiler2 = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js"(exports, module) {
      "use strict";
      function compile(nodes) {
        var assignedPaths = [];
        var valueAssignments = [];
        var currentPath = "";
        var data = /* @__PURE__ */ Object.create(null);
        var context2 = data;
        var arrayMode = false;
        return reduce(nodes);
        function reduce(nodes2) {
          var node2;
          for (var i = 0; i < nodes2.length; i++) {
            node2 = nodes2[i];
            switch (node2.type) {
              case "Assign":
                assign(node2);
                break;
              case "ObjectPath":
                setPath(node2);
                break;
              case "ArrayPath":
                addTableArray(node2);
                break;
            }
          }
          return data;
        }
        function genError(err2, line, col) {
          var ex = new Error(err2);
          ex.line = line;
          ex.column = col;
          throw ex;
        }
        function assign(node2) {
          var key = node2.key;
          var value = node2.value;
          var line = node2.line;
          var column = node2.column;
          var fullPath;
          if (currentPath) {
            fullPath = currentPath + "." + key;
          } else {
            fullPath = key;
          }
          if (typeof context2[key] !== "undefined") {
            genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
          }
          context2[key] = reduceValueNode(value);
          if (!pathAssigned(fullPath)) {
            assignedPaths.push(fullPath);
            valueAssignments.push(fullPath);
          }
        }
        function pathAssigned(path6) {
          return assignedPaths.indexOf(path6) !== -1;
        }
        function reduceValueNode(node2) {
          if (node2.type === "Array") {
            return reduceArrayWithTypeChecking(node2.value);
          } else if (node2.type === "InlineTable") {
            return reduceInlineTableNode(node2.value);
          } else {
            return node2.value;
          }
        }
        function reduceInlineTableNode(values) {
          var obj = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < values.length; i++) {
            var val = values[i];
            if (val.value.type === "InlineTable") {
              obj[val.key] = reduceInlineTableNode(val.value.value);
            } else if (val.type === "InlineTableValue") {
              obj[val.key] = reduceValueNode(val.value);
            }
          }
          return obj;
        }
        function setPath(node2) {
          var path6 = node2.value;
          var quotedPath = path6.map(quoteDottedString).join(".");
          var line = node2.line;
          var column = node2.column;
          if (pathAssigned(quotedPath)) {
            genError("Cannot redefine existing key '" + path6 + "'.", line, column);
          }
          assignedPaths.push(quotedPath);
          context2 = deepRef(data, path6, /* @__PURE__ */ Object.create(null), line, column);
          currentPath = path6;
        }
        function addTableArray(node2) {
          var path6 = node2.value;
          var quotedPath = path6.map(quoteDottedString).join(".");
          var line = node2.line;
          var column = node2.column;
          if (!pathAssigned(quotedPath)) {
            assignedPaths.push(quotedPath);
          }
          assignedPaths = assignedPaths.filter(function(p) {
            return p.indexOf(quotedPath) !== 0;
          });
          assignedPaths.push(quotedPath);
          context2 = deepRef(data, path6, [], line, column);
          currentPath = quotedPath;
          if (context2 instanceof Array) {
            var newObj = /* @__PURE__ */ Object.create(null);
            context2.push(newObj);
            context2 = newObj;
          } else {
            genError("Cannot redefine existing key '" + path6 + "'.", line, column);
          }
        }
        function deepRef(start, keys4, value, line, column) {
          var traversed = [];
          var traversedPath = "";
          var path6 = keys4.join(".");
          var ctx = start;
          for (var i = 0; i < keys4.length; i++) {
            var key = keys4[i];
            traversed.push(key);
            traversedPath = traversed.join(".");
            if (typeof ctx[key] === "undefined") {
              if (i === keys4.length - 1) {
                ctx[key] = value;
              } else {
                ctx[key] = /* @__PURE__ */ Object.create(null);
              }
            } else if (i !== keys4.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
              genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
            }
            ctx = ctx[key];
            if (ctx instanceof Array && ctx.length && i < keys4.length - 1) {
              ctx = ctx[ctx.length - 1];
            }
          }
          return ctx;
        }
        function reduceArrayWithTypeChecking(array2) {
          var firstType = null;
          for (var i = 0; i < array2.length; i++) {
            var node2 = array2[i];
            if (firstType === null) {
              firstType = node2.type;
            } else {
              if (node2.type !== firstType) {
                genError("Cannot add value of type " + node2.type + " to array of type " + firstType + ".", node2.line, node2.column);
              }
            }
          }
          return array2.map(reduceValueNode);
        }
        function quoteDottedString(str) {
          if (str.indexOf(".") > -1) {
            return '"' + str + '"';
          } else {
            return str;
          }
        }
      }
      module.exports = {
        compile
      };
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/index.js
  var require_toml = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/index.js"(exports, module) {
      var parser = require_parser2();
      var compiler = require_compiler2();
      module.exports = {
        parse: function(input) {
          var nodes = parser.parse(input.toString());
          return compiler.compile(nodes);
        }
      };
    }
  });

  // ../../node_modules/.pnpm/webidl-conversions@7.0.0/node_modules/webidl-conversions/lib/index.js
  var require_lib3 = __commonJS({
    "../../node_modules/.pnpm/webidl-conversions@7.0.0/node_modules/webidl-conversions/lib/index.js"(exports) {
      "use strict";
      function makeException(ErrorType, message, options) {
        if (options.globals) {
          ErrorType = options.globals[ErrorType.name];
        }
        return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
      }
      function toNumber3(value, options) {
        if (typeof value === "bigint") {
          throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
        }
        if (!options.globals) {
          return Number(value);
        }
        return options.globals.Number(value);
      }
      function evenRound(x) {
        if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
          return censorNegativeZero(Math.floor(x));
        }
        return censorNegativeZero(Math.round(x));
      }
      function integerPart(n) {
        return censorNegativeZero(Math.trunc(n));
      }
      function sign(x) {
        return x < 0 ? -1 : 1;
      }
      function modulo(x, y) {
        const signMightNotMatch = x % y;
        if (sign(y) !== sign(signMightNotMatch)) {
          return signMightNotMatch + y;
        }
        return signMightNotMatch;
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function createIntegerConversion(bitLength, { unsigned }) {
        let lowerBound, upperBound;
        if (unsigned) {
          lowerBound = 0;
          upperBound = 2 ** bitLength - 1;
        } else {
          lowerBound = -(2 ** (bitLength - 1));
          upperBound = 2 ** (bitLength - 1) - 1;
        }
        const twoToTheBitLength = 2 ** bitLength;
        const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
        return (value, options = {}) => {
          let x = toNumber3(value, options);
          x = censorNegativeZero(x);
          if (options.enforceRange) {
            if (!Number.isFinite(x)) {
              throw makeException(TypeError, "is not a finite number", options);
            }
            x = integerPart(x);
            if (x < lowerBound || x > upperBound) {
              throw makeException(
                TypeError,
                `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
                options
              );
            }
            return x;
          }
          if (!Number.isNaN(x) && options.clamp) {
            x = Math.min(Math.max(x, lowerBound), upperBound);
            x = evenRound(x);
            return x;
          }
          if (!Number.isFinite(x) || x === 0) {
            return 0;
          }
          x = integerPart(x);
          if (x >= lowerBound && x <= upperBound) {
            return x;
          }
          x = modulo(x, twoToTheBitLength);
          if (!unsigned && x >= twoToOneLessThanTheBitLength) {
            return x - twoToTheBitLength;
          }
          return x;
        };
      }
      function createLongLongConversion(bitLength, { unsigned }) {
        const upperBound = Number.MAX_SAFE_INTEGER;
        const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
        const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
        return (value, options = {}) => {
          let x = toNumber3(value, options);
          x = censorNegativeZero(x);
          if (options.enforceRange) {
            if (!Number.isFinite(x)) {
              throw makeException(TypeError, "is not a finite number", options);
            }
            x = integerPart(x);
            if (x < lowerBound || x > upperBound) {
              throw makeException(
                TypeError,
                `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
                options
              );
            }
            return x;
          }
          if (!Number.isNaN(x) && options.clamp) {
            x = Math.min(Math.max(x, lowerBound), upperBound);
            x = evenRound(x);
            return x;
          }
          if (!Number.isFinite(x) || x === 0) {
            return 0;
          }
          let xBigInt = BigInt(integerPart(x));
          xBigInt = asBigIntN(bitLength, xBigInt);
          return Number(xBigInt);
        };
      }
      exports.any = (value) => {
        return value;
      };
      exports.undefined = () => {
        return void 0;
      };
      exports.boolean = (value) => {
        return Boolean(value);
      };
      exports.byte = createIntegerConversion(8, { unsigned: false });
      exports.octet = createIntegerConversion(8, { unsigned: true });
      exports.short = createIntegerConversion(16, { unsigned: false });
      exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
      exports.long = createIntegerConversion(32, { unsigned: false });
      exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
      exports["long long"] = createLongLongConversion(64, { unsigned: false });
      exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
      exports.double = (value, options = {}) => {
        const x = toNumber3(value, options);
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite floating-point value", options);
        }
        return x;
      };
      exports["unrestricted double"] = (value, options = {}) => {
        const x = toNumber3(value, options);
        return x;
      };
      exports.float = (value, options = {}) => {
        const x = toNumber3(value, options);
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite floating-point value", options);
        }
        if (Object.is(x, -0)) {
          return x;
        }
        const y = Math.fround(x);
        if (!Number.isFinite(y)) {
          throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
        }
        return y;
      };
      exports["unrestricted float"] = (value, options = {}) => {
        const x = toNumber3(value, options);
        if (isNaN(x)) {
          return x;
        }
        if (Object.is(x, -0)) {
          return x;
        }
        return Math.fround(x);
      };
      exports.DOMString = (value, options = {}) => {
        if (options.treatNullAsEmptyString && value === null) {
          return "";
        }
        if (typeof value === "symbol") {
          throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
        }
        const StringCtor = options.globals ? options.globals.String : String;
        return StringCtor(value);
      };
      exports.ByteString = (value, options = {}) => {
        const x = exports.DOMString(value, options);
        let c;
        for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
          if (c > 255) {
            throw makeException(TypeError, "is not a valid ByteString", options);
          }
        }
        return x;
      };
      exports.USVString = (value, options = {}) => {
        const S = exports.DOMString(value, options);
        const n = S.length;
        const U = [];
        for (let i = 0; i < n; ++i) {
          const c = S.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            U.push(String.fromCodePoint(c));
          } else if (56320 <= c && c <= 57343) {
            U.push(String.fromCodePoint(65533));
          } else if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
        return U.join("");
      };
      exports.object = (value, options = {}) => {
        if (value === null || typeof value !== "object" && typeof value !== "function") {
          throw makeException(TypeError, "is not an object", options);
        }
        return value;
      };
      var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
      var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
      function isNonSharedArrayBuffer(value) {
        try {
          abByteLengthGetter.call(value);
          return true;
        } catch {
          return false;
        }
      }
      function isSharedArrayBuffer(value) {
        try {
          sabByteLengthGetter.call(value);
          return true;
        } catch {
          return false;
        }
      }
      function isArrayBufferDetached(value) {
        try {
          new Uint8Array(value);
          return false;
        } catch {
          return true;
        }
      }
      exports.ArrayBuffer = (value, options = {}) => {
        if (!isNonSharedArrayBuffer(value)) {
          if (options.allowShared && !isSharedArrayBuffer(value)) {
            throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
          }
          throw makeException(TypeError, "is not an ArrayBuffer", options);
        }
        if (isArrayBufferDetached(value)) {
          throw makeException(TypeError, "is a detached ArrayBuffer", options);
        }
        return value;
      };
      var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
      exports.DataView = (value, options = {}) => {
        try {
          dvByteLengthGetter.call(value);
        } catch (e) {
          throw makeException(TypeError, "is not a DataView", options);
        }
        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
        }
        return value;
      };
      var typedArrayNameGetter = Object.getOwnPropertyDescriptor(
        Object.getPrototypeOf(Uint8Array).prototype,
        Symbol.toStringTag
      ).get;
      [
        Int8Array,
        Int16Array,
        Int32Array,
        Uint8Array,
        Uint16Array,
        Uint32Array,
        Uint8ClampedArray,
        Float32Array,
        Float64Array
      ].forEach((func) => {
        const { name } = func;
        const article = /^[AEIOU]/u.test(name) ? "an" : "a";
        exports[name] = (value, options = {}) => {
          if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
            throw makeException(TypeError, `is not ${article} ${name} object`, options);
          }
          if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
            throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
          }
          if (isArrayBufferDetached(value.buffer)) {
            throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
          }
          return value;
        };
      });
      exports.ArrayBufferView = (value, options = {}) => {
        if (!ArrayBuffer.isView(value)) {
          throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
        }
        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
        }
        return value;
      };
      exports.BufferSource = (value, options = {}) => {
        if (ArrayBuffer.isView(value)) {
          if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
            throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
          }
          if (isArrayBufferDetached(value.buffer)) {
            throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
          }
          return value;
        }
        if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
          throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
        }
        if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
          throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
        }
        if (isArrayBufferDetached(value)) {
          throw makeException(TypeError, "is a detached ArrayBuffer", options);
        }
        return value;
      };
      exports.DOMTimeStamp = exports["unsigned long long"];
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/utils.js
  var require_utils3 = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/utils.js"(exports, module) {
      "use strict";
      function isObject2(value) {
        return typeof value === "object" && value !== null || typeof value === "function";
      }
      var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
      function define2(target, source) {
        for (const key of Reflect.ownKeys(source)) {
          const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
          if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
            throw new TypeError(`Cannot redefine property: ${String(key)}`);
          }
        }
      }
      function newObjectInRealm(globalObject, object2) {
        const ctorRegistry = initCtorRegistry(globalObject);
        return Object.defineProperties(
          Object.create(ctorRegistry["%Object.prototype%"]),
          Object.getOwnPropertyDescriptors(object2)
        );
      }
      var wrapperSymbol = Symbol("wrapper");
      var implSymbol = Symbol("impl");
      var sameObjectCaches = Symbol("SameObject caches");
      var ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
      var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
      }).prototype);
      function initCtorRegistry(globalObject) {
        if (hasOwn(globalObject, ctorRegistrySymbol)) {
          return globalObject[ctorRegistrySymbol];
        }
        const ctorRegistry = /* @__PURE__ */ Object.create(null);
        ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
        ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(
          Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]())
        );
        try {
          ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(
            Object.getPrototypeOf(
              globalObject.eval("(async function* () {})").prototype
            )
          );
        } catch {
          ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
        }
        globalObject[ctorRegistrySymbol] = ctorRegistry;
        return ctorRegistry;
      }
      function getSameObject(wrapper, prop, creator) {
        if (!wrapper[sameObjectCaches]) {
          wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
        }
        if (prop in wrapper[sameObjectCaches]) {
          return wrapper[sameObjectCaches][prop];
        }
        wrapper[sameObjectCaches][prop] = creator();
        return wrapper[sameObjectCaches][prop];
      }
      function wrapperForImpl(impl) {
        return impl ? impl[wrapperSymbol] : null;
      }
      function implForWrapper(wrapper) {
        return wrapper ? wrapper[implSymbol] : null;
      }
      function tryWrapperForImpl(impl) {
        const wrapper = wrapperForImpl(impl);
        return wrapper ? wrapper : impl;
      }
      function tryImplForWrapper(wrapper) {
        const impl = implForWrapper(wrapper);
        return impl ? impl : wrapper;
      }
      var iterInternalSymbol = Symbol("internal");
      function isArrayIndexPropName(P) {
        if (typeof P !== "string") {
          return false;
        }
        const i = P >>> 0;
        if (i === 2 ** 32 - 1) {
          return false;
        }
        const s = `${i}`;
        if (P !== s) {
          return false;
        }
        return true;
      }
      var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
      function isArrayBuffer(value) {
        try {
          byteLengthGetter.call(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      function iteratorResult([key, value], kind) {
        let result;
        switch (kind) {
          case "key":
            result = key;
            break;
          case "value":
            result = value;
            break;
          case "key+value":
            result = [key, value];
            break;
        }
        return { value: result, done: false };
      }
      var supportsPropertyIndex = Symbol("supports property index");
      var supportedPropertyIndices = Symbol("supported property indices");
      var supportsPropertyName = Symbol("supports property name");
      var supportedPropertyNames = Symbol("supported property names");
      var indexedGet = Symbol("indexed property get");
      var indexedSetNew = Symbol("indexed property set new");
      var indexedSetExisting = Symbol("indexed property set existing");
      var namedGet = Symbol("named property get");
      var namedSetNew = Symbol("named property set new");
      var namedSetExisting = Symbol("named property set existing");
      var namedDelete = Symbol("named property delete");
      var asyncIteratorNext = Symbol("async iterator get the next iteration result");
      var asyncIteratorReturn = Symbol("async iterator return steps");
      var asyncIteratorInit = Symbol("async iterator initialization steps");
      var asyncIteratorEOI = Symbol("async iterator end of iteration");
      module.exports = exports = {
        isObject: isObject2,
        hasOwn,
        define: define2,
        newObjectInRealm,
        wrapperSymbol,
        implSymbol,
        getSameObject,
        ctorRegistrySymbol,
        initCtorRegistry,
        wrapperForImpl,
        implForWrapper,
        tryWrapperForImpl,
        tryImplForWrapper,
        iterInternalSymbol,
        isArrayBuffer,
        isArrayIndexPropName,
        supportsPropertyIndex,
        supportedPropertyIndices,
        supportsPropertyName,
        supportedPropertyNames,
        indexedGet,
        indexedSetNew,
        indexedSetExisting,
        namedGet,
        namedSetNew,
        namedSetExisting,
        namedDelete,
        asyncIteratorNext,
        asyncIteratorReturn,
        asyncIteratorInit,
        asyncIteratorEOI,
        iteratorResult
      };
    }
  });

  // ../../node_modules/.pnpm/punycode@2.3.1/node_modules/punycode/punycode.es6.js
  var punycode_es6_exports = {};
  __export(punycode_es6_exports, {
    decode: () => decode,
    default: () => punycode_es6_default,
    encode: () => encode,
    toASCII: () => toASCII,
    toUnicode: () => toUnicode,
    ucs2decode: () => ucs2decode,
    ucs2encode: () => ucs2encode
  });
  function error2(type3) {
    throw new RangeError(errors[type3]);
  }
  function map(array2, callback) {
    const result = [];
    let length = array2.length;
    while (length--) {
      result[length] = callback(array2[length]);
    }
    return result;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string2) {
    const output2 = [];
    let counter = 0;
    const length = string2.length;
    while (counter < length) {
      const value = string2.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string2.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output2.push(value);
          counter--;
        }
      } else {
        output2.push(value);
      }
    }
    return output2;
  }
  var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, ucs2encode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII, punycode, punycode_es6_default;
  var init_punycode_es6 = __esm({
    "../../node_modules/.pnpm/punycode@2.3.1/node_modules/punycode/punycode.es6.js"() {
      "use strict";
      maxInt = 2147483647;
      base = 36;
      tMin = 1;
      tMax = 26;
      skew = 38;
      damp = 700;
      initialBias = 72;
      initialN = 128;
      delimiter = "-";
      regexPunycode = /^xn--/;
      regexNonASCII = /[^\0-\x7F]/;
      regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      baseMinusTMin = base - tMin;
      floor = Math.floor;
      stringFromCharCode = String.fromCharCode;
      ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
      basicToDigit = function(codePoint) {
        if (codePoint >= 48 && codePoint < 58) {
          return 26 + (codePoint - 48);
        }
        if (codePoint >= 65 && codePoint < 91) {
          return codePoint - 65;
        }
        if (codePoint >= 97 && codePoint < 123) {
          return codePoint - 97;
        }
        return base;
      };
      digitToBasic = function(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      adapt = function(delta, numPoints, firstTime) {
        let k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      decode = function(input) {
        const output2 = [];
        const inputLength = input.length;
        let i = 0;
        let n = initialN;
        let bias = initialBias;
        let basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (let j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error2("not-basic");
          }
          output2.push(input.charCodeAt(j));
        }
        for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          const oldi = i;
          for (let w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error2("invalid-input");
            }
            const digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base) {
              error2("invalid-input");
            }
            if (digit > floor((maxInt - i) / w)) {
              error2("overflow");
            }
            i += digit * w;
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            const baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error2("overflow");
            }
            w *= baseMinusT;
          }
          const out = output2.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error2("overflow");
          }
          n += floor(i / out);
          i %= out;
          output2.splice(i++, 0, n);
        }
        return String.fromCodePoint(...output2);
      };
      encode = function(input) {
        const output2 = [];
        input = ucs2decode(input);
        const inputLength = input.length;
        let n = initialN;
        let delta = 0;
        let bias = initialBias;
        for (const currentValue of input) {
          if (currentValue < 128) {
            output2.push(stringFromCharCode(currentValue));
          }
        }
        const basicLength = output2.length;
        let handledCPCount = basicLength;
        if (basicLength) {
          output2.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          let m = maxInt;
          for (const currentValue of input) {
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          const handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error2("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (const currentValue of input) {
            if (currentValue < n && ++delta > maxInt) {
              error2("overflow");
            }
            if (currentValue === n) {
              let q = delta;
              for (let k = base; ; k += base) {
                const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                const qMinusT = q - t;
                const baseMinusT = base - t;
                output2.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output2.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output2.join("");
      };
      toUnicode = function(input) {
        return mapDomain(input, function(string2) {
          return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
        });
      };
      toASCII = function(input) {
        return mapDomain(input, function(string2) {
          return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
        });
      };
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.3.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      punycode_es6_default = punycode;
    }
  });

  // ../../node_modules/.pnpm/tr46@5.0.0/node_modules/tr46/lib/regexes.js
  var require_regexes = __commonJS({
    "../../node_modules/.pnpm/tr46@5.0.0/node_modules/tr46/lib/regexes.js"(exports, module) {
      "use strict";
      var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
      var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1715\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA82C\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{11070}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{1193D}\u{1193E}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}\u{11F41}\u{11F42}]/u;
      var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u0886\u0889-\u088D\u08A0-\u08A9\u08AF\u08B0\u08B3-\u08B8\u08BA-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{10F70}-\u{10F73}\u{10F76}-\u{10F81}\u{10FB0}\u{10FB2}\u{10FB3}\u{10FB8}\u{10FBB}\u{10FBC}\u{10FBE}\u{10FBF}\u{10FC1}\u{10FC4}\u{10FCA}\u{10FCB}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0858\u0860\u0862-\u0865\u0867-\u086A\u0870-\u0882\u0886\u0889-\u088E\u08A0-\u08AC\u08AE-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{10F70}-\u{10F81}\u{10FB0}\u{10FB2}-\u{10FB6}\u{10FB8}-\u{10FBF}\u{10FC1}-\u{10FC4}\u{10FC9}\u{10FCA}\u{1E900}-\u{1E943}]/u;
      var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
      var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
      var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
      var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0898-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2426\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E3\u31EF\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EFD}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6DB}\u{1D715}\u{1D74F}\u{1D789}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
      var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
      var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
      var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}]/u;
      var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B50-\u1B7E\u1B80-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E3\u31EF-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
      var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
      module.exports = {
        combiningMarks,
        combiningClassVirama,
        validZWNJ,
        bidiDomain,
        bidiS1LTR,
        bidiS1RTL,
        bidiS2,
        bidiS3,
        bidiS4EN,
        bidiS4AN,
        bidiS5,
        bidiS6
      };
    }
  });

  // ../../node_modules/.pnpm/tr46@5.0.0/node_modules/tr46/lib/mappingTable.json
  var require_mappingTable = __commonJS({
    "../../node_modules/.pnpm/tr46@5.0.0/node_modules/tr46/lib/mappingTable.json"(exports, module) {
      module.exports = [[[0, 44], 4], [[45, 46], 2], [47, 4], [[48, 57], 2], [[58, 64], 4], [65, 1, "a"], [66, 1, "b"], [67, 1, "c"], [68, 1, "d"], [69, 1, "e"], [70, 1, "f"], [71, 1, "g"], [72, 1, "h"], [73, 1, "i"], [74, 1, "j"], [75, 1, "k"], [76, 1, "l"], [77, 1, "m"], [78, 1, "n"], [79, 1, "o"], [80, 1, "p"], [81, 1, "q"], [82, 1, "r"], [83, 1, "s"], [84, 1, "t"], [85, 1, "u"], [86, 1, "v"], [87, 1, "w"], [88, 1, "x"], [89, 1, "y"], [90, 1, "z"], [[91, 96], 4], [[97, 122], 2], [[123, 127], 4], [[128, 159], 3], [160, 5, " "], [[161, 167], 2], [168, 5, " \u0308"], [169, 2], [170, 1, "a"], [[171, 172], 2], [173, 7], [174, 2], [175, 5, " \u0304"], [[176, 177], 2], [178, 1, "2"], [179, 1, "3"], [180, 5, " \u0301"], [181, 1, "\u03BC"], [182, 2], [183, 2], [184, 5, " \u0327"], [185, 1, "1"], [186, 1, "o"], [187, 2], [188, 1, "1\u20444"], [189, 1, "1\u20442"], [190, 1, "3\u20444"], [191, 2], [192, 1, "\xE0"], [193, 1, "\xE1"], [194, 1, "\xE2"], [195, 1, "\xE3"], [196, 1, "\xE4"], [197, 1, "\xE5"], [198, 1, "\xE6"], [199, 1, "\xE7"], [200, 1, "\xE8"], [201, 1, "\xE9"], [202, 1, "\xEA"], [203, 1, "\xEB"], [204, 1, "\xEC"], [205, 1, "\xED"], [206, 1, "\xEE"], [207, 1, "\xEF"], [208, 1, "\xF0"], [209, 1, "\xF1"], [210, 1, "\xF2"], [211, 1, "\xF3"], [212, 1, "\xF4"], [213, 1, "\xF5"], [214, 1, "\xF6"], [215, 2], [216, 1, "\xF8"], [217, 1, "\xF9"], [218, 1, "\xFA"], [219, 1, "\xFB"], [220, 1, "\xFC"], [221, 1, "\xFD"], [222, 1, "\xFE"], [223, 6, "ss"], [[224, 246], 2], [247, 2], [[248, 255], 2], [256, 1, "\u0101"], [257, 2], [258, 1, "\u0103"], [259, 2], [260, 1, "\u0105"], [261, 2], [262, 1, "\u0107"], [263, 2], [264, 1, "\u0109"], [265, 2], [266, 1, "\u010B"], [267, 2], [268, 1, "\u010D"], [269, 2], [270, 1, "\u010F"], [271, 2], [272, 1, "\u0111"], [273, 2], [274, 1, "\u0113"], [275, 2], [276, 1, "\u0115"], [277, 2], [278, 1, "\u0117"], [279, 2], [280, 1, "\u0119"], [281, 2], [282, 1, "\u011B"], [283, 2], [284, 1, "\u011D"], [285, 2], [286, 1, "\u011F"], [287, 2], [288, 1, "\u0121"], [289, 2], [290, 1, "\u0123"], [291, 2], [292, 1, "\u0125"], [293, 2], [294, 1, "\u0127"], [295, 2], [296, 1, "\u0129"], [297, 2], [298, 1, "\u012B"], [299, 2], [300, 1, "\u012D"], [301, 2], [302, 1, "\u012F"], [303, 2], [304, 1, "i\u0307"], [305, 2], [[306, 307], 1, "ij"], [308, 1, "\u0135"], [309, 2], [310, 1, "\u0137"], [[311, 312], 2], [313, 1, "\u013A"], [314, 2], [315, 1, "\u013C"], [316, 2], [317, 1, "\u013E"], [318, 2], [[319, 320], 1, "l\xB7"], [321, 1, "\u0142"], [322, 2], [323, 1, "\u0144"], [324, 2], [325, 1, "\u0146"], [326, 2], [327, 1, "\u0148"], [328, 2], [329, 1, "\u02BCn"], [330, 1, "\u014B"], [331, 2], [332, 1, "\u014D"], [333, 2], [334, 1, "\u014F"], [335, 2], [336, 1, "\u0151"], [337, 2], [338, 1, "\u0153"], [339, 2], [340, 1, "\u0155"], [341, 2], [342, 1, "\u0157"], [343, 2], [344, 1, "\u0159"], [345, 2], [346, 1, "\u015B"], [347, 2], [348, 1, "\u015D"], [349, 2], [350, 1, "\u015F"], [351, 2], [352, 1, "\u0161"], [353, 2], [354, 1, "\u0163"], [355, 2], [356, 1, "\u0165"], [357, 2], [358, 1, "\u0167"], [359, 2], [360, 1, "\u0169"], [361, 2], [362, 1, "\u016B"], [363, 2], [364, 1, "\u016D"], [365, 2], [366, 1, "\u016F"], [367, 2], [368, 1, "\u0171"], [369, 2], [370, 1, "\u0173"], [371, 2], [372, 1, "\u0175"], [373, 2], [374, 1, "\u0177"], [375, 2], [376, 1, "\xFF"], [377, 1, "\u017A"], [378, 2], [379, 1, "\u017C"], [380, 2], [381, 1, "\u017E"], [382, 2], [383, 1, "s"], [384, 2], [385, 1, "\u0253"], [386, 1, "\u0183"], [387, 2], [388, 1, "\u0185"], [389, 2], [390, 1, "\u0254"], [391, 1, "\u0188"], [392, 2], [393, 1, "\u0256"], [394, 1, "\u0257"], [395, 1, "\u018C"], [[396, 397], 2], [398, 1, "\u01DD"], [399, 1, "\u0259"], [400, 1, "\u025B"], [401, 1, "\u0192"], [402, 2], [403, 1, "\u0260"], [404, 1, "\u0263"], [405, 2], [406, 1, "\u0269"], [407, 1, "\u0268"], [408, 1, "\u0199"], [[409, 411], 2], [412, 1, "\u026F"], [413, 1, "\u0272"], [414, 2], [415, 1, "\u0275"], [416, 1, "\u01A1"], [417, 2], [418, 1, "\u01A3"], [419, 2], [420, 1, "\u01A5"], [421, 2], [422, 1, "\u0280"], [423, 1, "\u01A8"], [424, 2], [425, 1, "\u0283"], [[426, 427], 2], [428, 1, "\u01AD"], [429, 2], [430, 1, "\u0288"], [431, 1, "\u01B0"], [432, 2], [433, 1, "\u028A"], [434, 1, "\u028B"], [435, 1, "\u01B4"], [436, 2], [437, 1, "\u01B6"], [438, 2], [439, 1, "\u0292"], [440, 1, "\u01B9"], [[441, 443], 2], [444, 1, "\u01BD"], [[445, 451], 2], [[452, 454], 1, "d\u017E"], [[455, 457], 1, "lj"], [[458, 460], 1, "nj"], [461, 1, "\u01CE"], [462, 2], [463, 1, "\u01D0"], [464, 2], [465, 1, "\u01D2"], [466, 2], [467, 1, "\u01D4"], [468, 2], [469, 1, "\u01D6"], [470, 2], [471, 1, "\u01D8"], [472, 2], [473, 1, "\u01DA"], [474, 2], [475, 1, "\u01DC"], [[476, 477], 2], [478, 1, "\u01DF"], [479, 2], [480, 1, "\u01E1"], [481, 2], [482, 1, "\u01E3"], [483, 2], [484, 1, "\u01E5"], [485, 2], [486, 1, "\u01E7"], [487, 2], [488, 1, "\u01E9"], [489, 2], [490, 1, "\u01EB"], [491, 2], [492, 1, "\u01ED"], [493, 2], [494, 1, "\u01EF"], [[495, 496], 2], [[497, 499], 1, "dz"], [500, 1, "\u01F5"], [501, 2], [502, 1, "\u0195"], [503, 1, "\u01BF"], [504, 1, "\u01F9"], [505, 2], [506, 1, "\u01FB"], [507, 2], [508, 1, "\u01FD"], [509, 2], [510, 1, "\u01FF"], [511, 2], [512, 1, "\u0201"], [513, 2], [514, 1, "\u0203"], [515, 2], [516, 1, "\u0205"], [517, 2], [518, 1, "\u0207"], [519, 2], [520, 1, "\u0209"], [521, 2], [522, 1, "\u020B"], [523, 2], [524, 1, "\u020D"], [525, 2], [526, 1, "\u020F"], [527, 2], [528, 1, "\u0211"], [529, 2], [530, 1, "\u0213"], [531, 2], [532, 1, "\u0215"], [533, 2], [534, 1, "\u0217"], [535, 2], [536, 1, "\u0219"], [537, 2], [538, 1, "\u021B"], [539, 2], [540, 1, "\u021D"], [541, 2], [542, 1, "\u021F"], [543, 2], [544, 1, "\u019E"], [545, 2], [546, 1, "\u0223"], [547, 2], [548, 1, "\u0225"], [549, 2], [550, 1, "\u0227"], [551, 2], [552, 1, "\u0229"], [553, 2], [554, 1, "\u022B"], [555, 2], [556, 1, "\u022D"], [557, 2], [558, 1, "\u022F"], [559, 2], [560, 1, "\u0231"], [561, 2], [562, 1, "\u0233"], [563, 2], [[564, 566], 2], [[567, 569], 2], [570, 1, "\u2C65"], [571, 1, "\u023C"], [572, 2], [573, 1, "\u019A"], [574, 1, "\u2C66"], [[575, 576], 2], [577, 1, "\u0242"], [578, 2], [579, 1, "\u0180"], [580, 1, "\u0289"], [581, 1, "\u028C"], [582, 1, "\u0247"], [583, 2], [584, 1, "\u0249"], [585, 2], [586, 1, "\u024B"], [587, 2], [588, 1, "\u024D"], [589, 2], [590, 1, "\u024F"], [591, 2], [[592, 680], 2], [[681, 685], 2], [[686, 687], 2], [688, 1, "h"], [689, 1, "\u0266"], [690, 1, "j"], [691, 1, "r"], [692, 1, "\u0279"], [693, 1, "\u027B"], [694, 1, "\u0281"], [695, 1, "w"], [696, 1, "y"], [[697, 705], 2], [[706, 709], 2], [[710, 721], 2], [[722, 727], 2], [728, 5, " \u0306"], [729, 5, " \u0307"], [730, 5, " \u030A"], [731, 5, " \u0328"], [732, 5, " \u0303"], [733, 5, " \u030B"], [734, 2], [735, 2], [736, 1, "\u0263"], [737, 1, "l"], [738, 1, "s"], [739, 1, "x"], [740, 1, "\u0295"], [[741, 745], 2], [[746, 747], 2], [748, 2], [749, 2], [750, 2], [[751, 767], 2], [[768, 831], 2], [832, 1, "\u0300"], [833, 1, "\u0301"], [834, 2], [835, 1, "\u0313"], [836, 1, "\u0308\u0301"], [837, 1, "\u03B9"], [[838, 846], 2], [847, 7], [[848, 855], 2], [[856, 860], 2], [[861, 863], 2], [[864, 865], 2], [866, 2], [[867, 879], 2], [880, 1, "\u0371"], [881, 2], [882, 1, "\u0373"], [883, 2], [884, 1, "\u02B9"], [885, 2], [886, 1, "\u0377"], [887, 2], [[888, 889], 3], [890, 5, " \u03B9"], [[891, 893], 2], [894, 5, ";"], [895, 1, "\u03F3"], [[896, 899], 3], [900, 5, " \u0301"], [901, 5, " \u0308\u0301"], [902, 1, "\u03AC"], [903, 1, "\xB7"], [904, 1, "\u03AD"], [905, 1, "\u03AE"], [906, 1, "\u03AF"], [907, 3], [908, 1, "\u03CC"], [909, 3], [910, 1, "\u03CD"], [911, 1, "\u03CE"], [912, 2], [913, 1, "\u03B1"], [914, 1, "\u03B2"], [915, 1, "\u03B3"], [916, 1, "\u03B4"], [917, 1, "\u03B5"], [918, 1, "\u03B6"], [919, 1, "\u03B7"], [920, 1, "\u03B8"], [921, 1, "\u03B9"], [922, 1, "\u03BA"], [923, 1, "\u03BB"], [924, 1, "\u03BC"], [925, 1, "\u03BD"], [926, 1, "\u03BE"], [927, 1, "\u03BF"], [928, 1, "\u03C0"], [929, 1, "\u03C1"], [930, 3], [931, 1, "\u03C3"], [932, 1, "\u03C4"], [933, 1, "\u03C5"], [934, 1, "\u03C6"], [935, 1, "\u03C7"], [936, 1, "\u03C8"], [937, 1, "\u03C9"], [938, 1, "\u03CA"], [939, 1, "\u03CB"], [[940, 961], 2], [962, 6, "\u03C3"], [[963, 974], 2], [975, 1, "\u03D7"], [976, 1, "\u03B2"], [977, 1, "\u03B8"], [978, 1, "\u03C5"], [979, 1, "\u03CD"], [980, 1, "\u03CB"], [981, 1, "\u03C6"], [982, 1, "\u03C0"], [983, 2], [984, 1, "\u03D9"], [985, 2], [986, 1, "\u03DB"], [987, 2], [988, 1, "\u03DD"], [989, 2], [990, 1, "\u03DF"], [991, 2], [992, 1, "\u03E1"], [993, 2], [994, 1, "\u03E3"], [995, 2], [996, 1, "\u03E5"], [997, 2], [998, 1, "\u03E7"], [999, 2], [1e3, 1, "\u03E9"], [1001, 2], [1002, 1, "\u03EB"], [1003, 2], [1004, 1, "\u03ED"], [1005, 2], [1006, 1, "\u03EF"], [1007, 2], [1008, 1, "\u03BA"], [1009, 1, "\u03C1"], [1010, 1, "\u03C3"], [1011, 2], [1012, 1, "\u03B8"], [1013, 1, "\u03B5"], [1014, 2], [1015, 1, "\u03F8"], [1016, 2], [1017, 1, "\u03C3"], [1018, 1, "\u03FB"], [1019, 2], [1020, 2], [1021, 1, "\u037B"], [1022, 1, "\u037C"], [1023, 1, "\u037D"], [1024, 1, "\u0450"], [1025, 1, "\u0451"], [1026, 1, "\u0452"], [1027, 1, "\u0453"], [1028, 1, "\u0454"], [1029, 1, "\u0455"], [1030, 1, "\u0456"], [1031, 1, "\u0457"], [1032, 1, "\u0458"], [1033, 1, "\u0459"], [1034, 1, "\u045A"], [1035, 1, "\u045B"], [1036, 1, "\u045C"], [1037, 1, "\u045D"], [1038, 1, "\u045E"], [1039, 1, "\u045F"], [1040, 1, "\u0430"], [1041, 1, "\u0431"], [1042, 1, "\u0432"], [1043, 1, "\u0433"], [1044, 1, "\u0434"], [1045, 1, "\u0435"], [1046, 1, "\u0436"], [1047, 1, "\u0437"], [1048, 1, "\u0438"], [1049, 1, "\u0439"], [1050, 1, "\u043A"], [1051, 1, "\u043B"], [1052, 1, "\u043C"], [1053, 1, "\u043D"], [1054, 1, "\u043E"], [1055, 1, "\u043F"], [1056, 1, "\u0440"], [1057, 1, "\u0441"], [1058, 1, "\u0442"], [1059, 1, "\u0443"], [1060, 1, "\u0444"], [1061, 1, "\u0445"], [1062, 1, "\u0446"], [1063, 1, "\u0447"], [1064, 1, "\u0448"], [1065, 1, "\u0449"], [1066, 1, "\u044A"], [1067, 1, "\u044B"], [1068, 1, "\u044C"], [1069, 1, "\u044D"], [1070, 1, "\u044E"], [1071, 1, "\u044F"], [[1072, 1103], 2], [1104, 2], [[1105, 1116], 2], [1117, 2], [[1118, 1119], 2], [1120, 1, "\u0461"], [1121, 2], [1122, 1, "\u0463"], [1123, 2], [1124, 1, "\u0465"], [1125, 2], [1126, 1, "\u0467"], [1127, 2], [1128, 1, "\u0469"], [1129, 2], [1130, 1, "\u046B"], [1131, 2], [1132, 1, "\u046D"], [1133, 2], [1134, 1, "\u046F"], [1135, 2], [1136, 1, "\u0471"], [1137, 2], [1138, 1, "\u0473"], [1139, 2], [1140, 1, "\u0475"], [1141, 2], [1142, 1, "\u0477"], [1143, 2], [1144, 1, "\u0479"], [1145, 2], [1146, 1, "\u047B"], [1147, 2], [1148, 1, "\u047D"], [1149, 2], [1150, 1, "\u047F"], [1151, 2], [1152, 1, "\u0481"], [1153, 2], [1154, 2], [[1155, 1158], 2], [1159, 2], [[1160, 1161], 2], [1162, 1, "\u048B"], [1163, 2], [1164, 1, "\u048D"], [1165, 2], [1166, 1, "\u048F"], [1167, 2], [1168, 1, "\u0491"], [1169, 2], [1170, 1, "\u0493"], [1171, 2], [1172, 1, "\u0495"], [1173, 2], [1174, 1, "\u0497"], [1175, 2], [1176, 1, "\u0499"], [1177, 2], [1178, 1, "\u049B"], [1179, 2], [1180, 1, "\u049D"], [1181, 2], [1182, 1, "\u049F"], [1183, 2], [1184, 1, "\u04A1"], [1185, 2], [1186, 1, "\u04A3"], [1187, 2], [1188, 1, "\u04A5"], [1189, 2], [1190, 1, "\u04A7"], [1191, 2], [1192, 1, "\u04A9"], [1193, 2], [1194, 1, "\u04AB"], [1195, 2], [1196, 1, "\u04AD"], [1197, 2], [1198, 1, "\u04AF"], [1199, 2], [1200, 1, "\u04B1"], [1201, 2], [1202, 1, "\u04B3"], [1203, 2], [1204, 1, "\u04B5"], [1205, 2], [1206, 1, "\u04B7"], [1207, 2], [1208, 1, "\u04B9"], [1209, 2], [1210, 1, "\u04BB"], [1211, 2], [1212, 1, "\u04BD"], [1213, 2], [1214, 1, "\u04BF"], [1215, 2], [1216, 3], [1217, 1, "\u04C2"], [1218, 2], [1219, 1, "\u04C4"], [1220, 2], [1221, 1, "\u04C6"], [1222, 2], [1223, 1, "\u04C8"], [1224, 2], [1225, 1, "\u04CA"], [1226, 2], [1227, 1, "\u04CC"], [1228, 2], [1229, 1, "\u04CE"], [1230, 2], [1231, 2], [1232, 1, "\u04D1"], [1233, 2], [1234, 1, "\u04D3"], [1235, 2], [1236, 1, "\u04D5"], [1237, 2], [1238, 1, "\u04D7"], [1239, 2], [1240, 1, "\u04D9"], [1241, 2], [1242, 1, "\u04DB"], [1243, 2], [1244, 1, "\u04DD"], [1245, 2], [1246, 1, "\u04DF"], [1247, 2], [1248, 1, "\u04E1"], [1249, 2], [1250, 1, "\u04E3"], [1251, 2], [1252, 1, "\u04E5"], [1253, 2], [1254, 1, "\u04E7"], [1255, 2], [1256, 1, "\u04E9"], [1257, 2], [1258, 1, "\u04EB"], [1259, 2], [1260, 1, "\u04ED"], [1261, 2], [1262, 1, "\u04EF"], [1263, 2], [1264, 1, "\u04F1"], [1265, 2], [1266, 1, "\u04F3"], [1267, 2], [1268, 1, "\u04F5"], [1269, 2], [1270, 1, "\u04F7"], [1271, 2], [1272, 1, "\u04F9"], [1273, 2], [1274, 1, "\u04FB"], [1275, 2], [1276, 1, "\u04FD"], [1277, 2], [1278, 1, "\u04FF"], [1279, 2], [1280, 1, "\u0501"], [1281, 2], [1282, 1, "\u0503"], [1283, 2], [1284, 1, "\u0505"], [1285, 2], [1286, 1, "\u0507"], [1287, 2], [1288, 1, "\u0509"], [1289, 2], [1290, 1, "\u050B"], [1291, 2], [1292, 1, "\u050D"], [1293, 2], [1294, 1, "\u050F"], [1295, 2], [1296, 1, "\u0511"], [1297, 2], [1298, 1, "\u0513"], [1299, 2], [1300, 1, "\u0515"], [1301, 2], [1302, 1, "\u0517"], [1303, 2], [1304, 1, "\u0519"], [1305, 2], [1306, 1, "\u051B"], [1307, 2], [1308, 1, "\u051D"], [1309, 2], [1310, 1, "\u051F"], [1311, 2], [1312, 1, "\u0521"], [1313, 2], [1314, 1, "\u0523"], [1315, 2], [1316, 1, "\u0525"], [1317, 2], [1318, 1, "\u0527"], [1319, 2], [1320, 1, "\u0529"], [1321, 2], [1322, 1, "\u052B"], [1323, 2], [1324, 1, "\u052D"], [1325, 2], [1326, 1, "\u052F"], [1327, 2], [1328, 3], [1329, 1, "\u0561"], [1330, 1, "\u0562"], [1331, 1, "\u0563"], [1332, 1, "\u0564"], [1333, 1, "\u0565"], [1334, 1, "\u0566"], [1335, 1, "\u0567"], [1336, 1, "\u0568"], [1337, 1, "\u0569"], [1338, 1, "\u056A"], [1339, 1, "\u056B"], [1340, 1, "\u056C"], [1341, 1, "\u056D"], [1342, 1, "\u056E"], [1343, 1, "\u056F"], [1344, 1, "\u0570"], [1345, 1, "\u0571"], [1346, 1, "\u0572"], [1347, 1, "\u0573"], [1348, 1, "\u0574"], [1349, 1, "\u0575"], [1350, 1, "\u0576"], [1351, 1, "\u0577"], [1352, 1, "\u0578"], [1353, 1, "\u0579"], [1354, 1, "\u057A"], [1355, 1, "\u057B"], [1356, 1, "\u057C"], [1357, 1, "\u057D"], [1358, 1, "\u057E"], [1359, 1, "\u057F"], [1360, 1, "\u0580"], [1361, 1, "\u0581"], [1362, 1, "\u0582"], [1363, 1, "\u0583"], [1364, 1, "\u0584"], [1365, 1, "\u0585"], [1366, 1, "\u0586"], [[1367, 1368], 3], [1369, 2], [[1370, 1375], 2], [1376, 2], [[1377, 1414], 2], [1415, 1, "\u0565\u0582"], [1416, 2], [1417, 2], [1418, 2], [[1419, 1420], 3], [[1421, 1422], 2], [1423, 2], [1424, 3], [[1425, 1441], 2], [1442, 2], [[1443, 1455], 2], [[1456, 1465], 2], [1466, 2], [[1467, 1469], 2], [1470, 2], [1471, 2], [1472, 2], [[1473, 1474], 2], [1475, 2], [1476, 2], [1477, 2], [1478, 2], [1479, 2], [[1480, 1487], 3], [[1488, 1514], 2], [[1515, 1518], 3], [1519, 2], [[1520, 1524], 2], [[1525, 1535], 3], [[1536, 1539], 3], [1540, 3], [1541, 3], [[1542, 1546], 2], [1547, 2], [1548, 2], [[1549, 1551], 2], [[1552, 1557], 2], [[1558, 1562], 2], [1563, 2], [1564, 3], [1565, 2], [1566, 2], [1567, 2], [1568, 2], [[1569, 1594], 2], [[1595, 1599], 2], [1600, 2], [[1601, 1618], 2], [[1619, 1621], 2], [[1622, 1624], 2], [[1625, 1630], 2], [1631, 2], [[1632, 1641], 2], [[1642, 1645], 2], [[1646, 1647], 2], [[1648, 1652], 2], [1653, 1, "\u0627\u0674"], [1654, 1, "\u0648\u0674"], [1655, 1, "\u06C7\u0674"], [1656, 1, "\u064A\u0674"], [[1657, 1719], 2], [[1720, 1721], 2], [[1722, 1726], 2], [1727, 2], [[1728, 1742], 2], [1743, 2], [[1744, 1747], 2], [1748, 2], [[1749, 1756], 2], [1757, 3], [1758, 2], [[1759, 1768], 2], [1769, 2], [[1770, 1773], 2], [[1774, 1775], 2], [[1776, 1785], 2], [[1786, 1790], 2], [1791, 2], [[1792, 1805], 2], [1806, 3], [1807, 3], [[1808, 1836], 2], [[1837, 1839], 2], [[1840, 1866], 2], [[1867, 1868], 3], [[1869, 1871], 2], [[1872, 1901], 2], [[1902, 1919], 2], [[1920, 1968], 2], [1969, 2], [[1970, 1983], 3], [[1984, 2037], 2], [[2038, 2042], 2], [[2043, 2044], 3], [2045, 2], [[2046, 2047], 2], [[2048, 2093], 2], [[2094, 2095], 3], [[2096, 2110], 2], [2111, 3], [[2112, 2139], 2], [[2140, 2141], 3], [2142, 2], [2143, 3], [[2144, 2154], 2], [[2155, 2159], 3], [[2160, 2183], 2], [2184, 2], [[2185, 2190], 2], [2191, 3], [[2192, 2193], 3], [[2194, 2199], 3], [[2200, 2207], 2], [2208, 2], [2209, 2], [[2210, 2220], 2], [[2221, 2226], 2], [[2227, 2228], 2], [2229, 2], [[2230, 2237], 2], [[2238, 2247], 2], [[2248, 2258], 2], [2259, 2], [[2260, 2273], 2], [2274, 3], [2275, 2], [[2276, 2302], 2], [2303, 2], [2304, 2], [[2305, 2307], 2], [2308, 2], [[2309, 2361], 2], [[2362, 2363], 2], [[2364, 2381], 2], [2382, 2], [2383, 2], [[2384, 2388], 2], [2389, 2], [[2390, 2391], 2], [2392, 1, "\u0915\u093C"], [2393, 1, "\u0916\u093C"], [2394, 1, "\u0917\u093C"], [2395, 1, "\u091C\u093C"], [2396, 1, "\u0921\u093C"], [2397, 1, "\u0922\u093C"], [2398, 1, "\u092B\u093C"], [2399, 1, "\u092F\u093C"], [[2400, 2403], 2], [[2404, 2405], 2], [[2406, 2415], 2], [2416, 2], [[2417, 2418], 2], [[2419, 2423], 2], [2424, 2], [[2425, 2426], 2], [[2427, 2428], 2], [2429, 2], [[2430, 2431], 2], [2432, 2], [[2433, 2435], 2], [2436, 3], [[2437, 2444], 2], [[2445, 2446], 3], [[2447, 2448], 2], [[2449, 2450], 3], [[2451, 2472], 2], [2473, 3], [[2474, 2480], 2], [2481, 3], [2482, 2], [[2483, 2485], 3], [[2486, 2489], 2], [[2490, 2491], 3], [2492, 2], [2493, 2], [[2494, 2500], 2], [[2501, 2502], 3], [[2503, 2504], 2], [[2505, 2506], 3], [[2507, 2509], 2], [2510, 2], [[2511, 2518], 3], [2519, 2], [[2520, 2523], 3], [2524, 1, "\u09A1\u09BC"], [2525, 1, "\u09A2\u09BC"], [2526, 3], [2527, 1, "\u09AF\u09BC"], [[2528, 2531], 2], [[2532, 2533], 3], [[2534, 2545], 2], [[2546, 2554], 2], [2555, 2], [2556, 2], [2557, 2], [2558, 2], [[2559, 2560], 3], [2561, 2], [2562, 2], [2563, 2], [2564, 3], [[2565, 2570], 2], [[2571, 2574], 3], [[2575, 2576], 2], [[2577, 2578], 3], [[2579, 2600], 2], [2601, 3], [[2602, 2608], 2], [2609, 3], [2610, 2], [2611, 1, "\u0A32\u0A3C"], [2612, 3], [2613, 2], [2614, 1, "\u0A38\u0A3C"], [2615, 3], [[2616, 2617], 2], [[2618, 2619], 3], [2620, 2], [2621, 3], [[2622, 2626], 2], [[2627, 2630], 3], [[2631, 2632], 2], [[2633, 2634], 3], [[2635, 2637], 2], [[2638, 2640], 3], [2641, 2], [[2642, 2648], 3], [2649, 1, "\u0A16\u0A3C"], [2650, 1, "\u0A17\u0A3C"], [2651, 1, "\u0A1C\u0A3C"], [2652, 2], [2653, 3], [2654, 1, "\u0A2B\u0A3C"], [[2655, 2661], 3], [[2662, 2676], 2], [2677, 2], [2678, 2], [[2679, 2688], 3], [[2689, 2691], 2], [2692, 3], [[2693, 2699], 2], [2700, 2], [2701, 2], [2702, 3], [[2703, 2705], 2], [2706, 3], [[2707, 2728], 2], [2729, 3], [[2730, 2736], 2], [2737, 3], [[2738, 2739], 2], [2740, 3], [[2741, 2745], 2], [[2746, 2747], 3], [[2748, 2757], 2], [2758, 3], [[2759, 2761], 2], [2762, 3], [[2763, 2765], 2], [[2766, 2767], 3], [2768, 2], [[2769, 2783], 3], [2784, 2], [[2785, 2787], 2], [[2788, 2789], 3], [[2790, 2799], 2], [2800, 2], [2801, 2], [[2802, 2808], 3], [2809, 2], [[2810, 2815], 2], [2816, 3], [[2817, 2819], 2], [2820, 3], [[2821, 2828], 2], [[2829, 2830], 3], [[2831, 2832], 2], [[2833, 2834], 3], [[2835, 2856], 2], [2857, 3], [[2858, 2864], 2], [2865, 3], [[2866, 2867], 2], [2868, 3], [2869, 2], [[2870, 2873], 2], [[2874, 2875], 3], [[2876, 2883], 2], [2884, 2], [[2885, 2886], 3], [[2887, 2888], 2], [[2889, 2890], 3], [[2891, 2893], 2], [[2894, 2900], 3], [2901, 2], [[2902, 2903], 2], [[2904, 2907], 3], [2908, 1, "\u0B21\u0B3C"], [2909, 1, "\u0B22\u0B3C"], [2910, 3], [[2911, 2913], 2], [[2914, 2915], 2], [[2916, 2917], 3], [[2918, 2927], 2], [2928, 2], [2929, 2], [[2930, 2935], 2], [[2936, 2945], 3], [[2946, 2947], 2], [2948, 3], [[2949, 2954], 2], [[2955, 2957], 3], [[2958, 2960], 2], [2961, 3], [[2962, 2965], 2], [[2966, 2968], 3], [[2969, 2970], 2], [2971, 3], [2972, 2], [2973, 3], [[2974, 2975], 2], [[2976, 2978], 3], [[2979, 2980], 2], [[2981, 2983], 3], [[2984, 2986], 2], [[2987, 2989], 3], [[2990, 2997], 2], [2998, 2], [[2999, 3001], 2], [[3002, 3005], 3], [[3006, 3010], 2], [[3011, 3013], 3], [[3014, 3016], 2], [3017, 3], [[3018, 3021], 2], [[3022, 3023], 3], [3024, 2], [[3025, 3030], 3], [3031, 2], [[3032, 3045], 3], [3046, 2], [[3047, 3055], 2], [[3056, 3058], 2], [[3059, 3066], 2], [[3067, 3071], 3], [3072, 2], [[3073, 3075], 2], [3076, 2], [[3077, 3084], 2], [3085, 3], [[3086, 3088], 2], [3089, 3], [[3090, 3112], 2], [3113, 3], [[3114, 3123], 2], [3124, 2], [[3125, 3129], 2], [[3130, 3131], 3], [3132, 2], [3133, 2], [[3134, 3140], 2], [3141, 3], [[3142, 3144], 2], [3145, 3], [[3146, 3149], 2], [[3150, 3156], 3], [[3157, 3158], 2], [3159, 3], [[3160, 3161], 2], [3162, 2], [[3163, 3164], 3], [3165, 2], [[3166, 3167], 3], [[3168, 3169], 2], [[3170, 3171], 2], [[3172, 3173], 3], [[3174, 3183], 2], [[3184, 3190], 3], [3191, 2], [[3192, 3199], 2], [3200, 2], [3201, 2], [[3202, 3203], 2], [3204, 2], [[3205, 3212], 2], [3213, 3], [[3214, 3216], 2], [3217, 3], [[3218, 3240], 2], [3241, 3], [[3242, 3251], 2], [3252, 3], [[3253, 3257], 2], [[3258, 3259], 3], [[3260, 3261], 2], [[3262, 3268], 2], [3269, 3], [[3270, 3272], 2], [3273, 3], [[3274, 3277], 2], [[3278, 3284], 3], [[3285, 3286], 2], [[3287, 3292], 3], [3293, 2], [3294, 2], [3295, 3], [[3296, 3297], 2], [[3298, 3299], 2], [[3300, 3301], 3], [[3302, 3311], 2], [3312, 3], [[3313, 3314], 2], [3315, 2], [[3316, 3327], 3], [3328, 2], [3329, 2], [[3330, 3331], 2], [3332, 2], [[3333, 3340], 2], [3341, 3], [[3342, 3344], 2], [3345, 3], [[3346, 3368], 2], [3369, 2], [[3370, 3385], 2], [3386, 2], [[3387, 3388], 2], [3389, 2], [[3390, 3395], 2], [3396, 2], [3397, 3], [[3398, 3400], 2], [3401, 3], [[3402, 3405], 2], [3406, 2], [3407, 2], [[3408, 3411], 3], [[3412, 3414], 2], [3415, 2], [[3416, 3422], 2], [3423, 2], [[3424, 3425], 2], [[3426, 3427], 2], [[3428, 3429], 3], [[3430, 3439], 2], [[3440, 3445], 2], [[3446, 3448], 2], [3449, 2], [[3450, 3455], 2], [3456, 3], [3457, 2], [[3458, 3459], 2], [3460, 3], [[3461, 3478], 2], [[3479, 3481], 3], [[3482, 3505], 2], [3506, 3], [[3507, 3515], 2], [3516, 3], [3517, 2], [[3518, 3519], 3], [[3520, 3526], 2], [[3527, 3529], 3], [3530, 2], [[3531, 3534], 3], [[3535, 3540], 2], [3541, 3], [3542, 2], [3543, 3], [[3544, 3551], 2], [[3552, 3557], 3], [[3558, 3567], 2], [[3568, 3569], 3], [[3570, 3571], 2], [3572, 2], [[3573, 3584], 3], [[3585, 3634], 2], [3635, 1, "\u0E4D\u0E32"], [[3636, 3642], 2], [[3643, 3646], 3], [3647, 2], [[3648, 3662], 2], [3663, 2], [[3664, 3673], 2], [[3674, 3675], 2], [[3676, 3712], 3], [[3713, 3714], 2], [3715, 3], [3716, 2], [3717, 3], [3718, 2], [[3719, 3720], 2], [3721, 2], [3722, 2], [3723, 3], [3724, 2], [3725, 2], [[3726, 3731], 2], [[3732, 3735], 2], [3736, 2], [[3737, 3743], 2], [3744, 2], [[3745, 3747], 2], [3748, 3], [3749, 2], [3750, 3], [3751, 2], [[3752, 3753], 2], [[3754, 3755], 2], [3756, 2], [[3757, 3762], 2], [3763, 1, "\u0ECD\u0EB2"], [[3764, 3769], 2], [3770, 2], [[3771, 3773], 2], [[3774, 3775], 3], [[3776, 3780], 2], [3781, 3], [3782, 2], [3783, 3], [[3784, 3789], 2], [3790, 2], [3791, 3], [[3792, 3801], 2], [[3802, 3803], 3], [3804, 1, "\u0EAB\u0E99"], [3805, 1, "\u0EAB\u0EA1"], [[3806, 3807], 2], [[3808, 3839], 3], [3840, 2], [[3841, 3850], 2], [3851, 2], [3852, 1, "\u0F0B"], [[3853, 3863], 2], [[3864, 3865], 2], [[3866, 3871], 2], [[3872, 3881], 2], [[3882, 3892], 2], [3893, 2], [3894, 2], [3895, 2], [3896, 2], [3897, 2], [[3898, 3901], 2], [[3902, 3906], 2], [3907, 1, "\u0F42\u0FB7"], [[3908, 3911], 2], [3912, 3], [[3913, 3916], 2], [3917, 1, "\u0F4C\u0FB7"], [[3918, 3921], 2], [3922, 1, "\u0F51\u0FB7"], [[3923, 3926], 2], [3927, 1, "\u0F56\u0FB7"], [[3928, 3931], 2], [3932, 1, "\u0F5B\u0FB7"], [[3933, 3944], 2], [3945, 1, "\u0F40\u0FB5"], [3946, 2], [[3947, 3948], 2], [[3949, 3952], 3], [[3953, 3954], 2], [3955, 1, "\u0F71\u0F72"], [3956, 2], [3957, 1, "\u0F71\u0F74"], [3958, 1, "\u0FB2\u0F80"], [3959, 1, "\u0FB2\u0F71\u0F80"], [3960, 1, "\u0FB3\u0F80"], [3961, 1, "\u0FB3\u0F71\u0F80"], [[3962, 3968], 2], [3969, 1, "\u0F71\u0F80"], [[3970, 3972], 2], [3973, 2], [[3974, 3979], 2], [[3980, 3983], 2], [[3984, 3986], 2], [3987, 1, "\u0F92\u0FB7"], [[3988, 3989], 2], [3990, 2], [3991, 2], [3992, 3], [[3993, 3996], 2], [3997, 1, "\u0F9C\u0FB7"], [[3998, 4001], 2], [4002, 1, "\u0FA1\u0FB7"], [[4003, 4006], 2], [4007, 1, "\u0FA6\u0FB7"], [[4008, 4011], 2], [4012, 1, "\u0FAB\u0FB7"], [4013, 2], [[4014, 4016], 2], [[4017, 4023], 2], [4024, 2], [4025, 1, "\u0F90\u0FB5"], [[4026, 4028], 2], [4029, 3], [[4030, 4037], 2], [4038, 2], [[4039, 4044], 2], [4045, 3], [4046, 2], [4047, 2], [[4048, 4049], 2], [[4050, 4052], 2], [[4053, 4056], 2], [[4057, 4058], 2], [[4059, 4095], 3], [[4096, 4129], 2], [4130, 2], [[4131, 4135], 2], [4136, 2], [[4137, 4138], 2], [4139, 2], [[4140, 4146], 2], [[4147, 4149], 2], [[4150, 4153], 2], [[4154, 4159], 2], [[4160, 4169], 2], [[4170, 4175], 2], [[4176, 4185], 2], [[4186, 4249], 2], [[4250, 4253], 2], [[4254, 4255], 2], [[4256, 4293], 3], [4294, 3], [4295, 1, "\u2D27"], [[4296, 4300], 3], [4301, 1, "\u2D2D"], [[4302, 4303], 3], [[4304, 4342], 2], [[4343, 4344], 2], [[4345, 4346], 2], [4347, 2], [4348, 1, "\u10DC"], [[4349, 4351], 2], [[4352, 4441], 2], [[4442, 4446], 2], [[4447, 4448], 3], [[4449, 4514], 2], [[4515, 4519], 2], [[4520, 4601], 2], [[4602, 4607], 2], [[4608, 4614], 2], [4615, 2], [[4616, 4678], 2], [4679, 2], [4680, 2], [4681, 3], [[4682, 4685], 2], [[4686, 4687], 3], [[4688, 4694], 2], [4695, 3], [4696, 2], [4697, 3], [[4698, 4701], 2], [[4702, 4703], 3], [[4704, 4742], 2], [4743, 2], [4744, 2], [4745, 3], [[4746, 4749], 2], [[4750, 4751], 3], [[4752, 4782], 2], [4783, 2], [4784, 2], [4785, 3], [[4786, 4789], 2], [[4790, 4791], 3], [[4792, 4798], 2], [4799, 3], [4800, 2], [4801, 3], [[4802, 4805], 2], [[4806, 4807], 3], [[4808, 4814], 2], [4815, 2], [[4816, 4822], 2], [4823, 3], [[4824, 4846], 2], [4847, 2], [[4848, 4878], 2], [4879, 2], [4880, 2], [4881, 3], [[4882, 4885], 2], [[4886, 4887], 3], [[4888, 4894], 2], [4895, 2], [[4896, 4934], 2], [4935, 2], [[4936, 4954], 2], [[4955, 4956], 3], [[4957, 4958], 2], [4959, 2], [4960, 2], [[4961, 4988], 2], [[4989, 4991], 3], [[4992, 5007], 2], [[5008, 5017], 2], [[5018, 5023], 3], [[5024, 5108], 2], [5109, 2], [[5110, 5111], 3], [5112, 1, "\u13F0"], [5113, 1, "\u13F1"], [5114, 1, "\u13F2"], [5115, 1, "\u13F3"], [5116, 1, "\u13F4"], [5117, 1, "\u13F5"], [[5118, 5119], 3], [5120, 2], [[5121, 5740], 2], [[5741, 5742], 2], [[5743, 5750], 2], [[5751, 5759], 2], [5760, 3], [[5761, 5786], 2], [[5787, 5788], 2], [[5789, 5791], 3], [[5792, 5866], 2], [[5867, 5872], 2], [[5873, 5880], 2], [[5881, 5887], 3], [[5888, 5900], 2], [5901, 2], [[5902, 5908], 2], [5909, 2], [[5910, 5918], 3], [5919, 2], [[5920, 5940], 2], [[5941, 5942], 2], [[5943, 5951], 3], [[5952, 5971], 2], [[5972, 5983], 3], [[5984, 5996], 2], [5997, 3], [[5998, 6e3], 2], [6001, 3], [[6002, 6003], 2], [[6004, 6015], 3], [[6016, 6067], 2], [[6068, 6069], 3], [[6070, 6099], 2], [[6100, 6102], 2], [6103, 2], [[6104, 6107], 2], [6108, 2], [6109, 2], [[6110, 6111], 3], [[6112, 6121], 2], [[6122, 6127], 3], [[6128, 6137], 2], [[6138, 6143], 3], [[6144, 6149], 2], [6150, 3], [[6151, 6154], 2], [[6155, 6157], 7], [6158, 3], [6159, 7], [[6160, 6169], 2], [[6170, 6175], 3], [[6176, 6263], 2], [6264, 2], [[6265, 6271], 3], [[6272, 6313], 2], [6314, 2], [[6315, 6319], 3], [[6320, 6389], 2], [[6390, 6399], 3], [[6400, 6428], 2], [[6429, 6430], 2], [6431, 3], [[6432, 6443], 2], [[6444, 6447], 3], [[6448, 6459], 2], [[6460, 6463], 3], [6464, 2], [[6465, 6467], 3], [[6468, 6469], 2], [[6470, 6509], 2], [[6510, 6511], 3], [[6512, 6516], 2], [[6517, 6527], 3], [[6528, 6569], 2], [[6570, 6571], 2], [[6572, 6575], 3], [[6576, 6601], 2], [[6602, 6607], 3], [[6608, 6617], 2], [6618, 2], [[6619, 6621], 3], [[6622, 6623], 2], [[6624, 6655], 2], [[6656, 6683], 2], [[6684, 6685], 3], [[6686, 6687], 2], [[6688, 6750], 2], [6751, 3], [[6752, 6780], 2], [[6781, 6782], 3], [[6783, 6793], 2], [[6794, 6799], 3], [[6800, 6809], 2], [[6810, 6815], 3], [[6816, 6822], 2], [6823, 2], [[6824, 6829], 2], [[6830, 6831], 3], [[6832, 6845], 2], [6846, 2], [[6847, 6848], 2], [[6849, 6862], 2], [[6863, 6911], 3], [[6912, 6987], 2], [6988, 2], [[6989, 6991], 3], [[6992, 7001], 2], [[7002, 7018], 2], [[7019, 7027], 2], [[7028, 7036], 2], [[7037, 7038], 2], [7039, 3], [[7040, 7082], 2], [[7083, 7085], 2], [[7086, 7097], 2], [[7098, 7103], 2], [[7104, 7155], 2], [[7156, 7163], 3], [[7164, 7167], 2], [[7168, 7223], 2], [[7224, 7226], 3], [[7227, 7231], 2], [[7232, 7241], 2], [[7242, 7244], 3], [[7245, 7293], 2], [[7294, 7295], 2], [7296, 1, "\u0432"], [7297, 1, "\u0434"], [7298, 1, "\u043E"], [7299, 1, "\u0441"], [[7300, 7301], 1, "\u0442"], [7302, 1, "\u044A"], [7303, 1, "\u0463"], [7304, 1, "\uA64B"], [[7305, 7311], 3], [7312, 1, "\u10D0"], [7313, 1, "\u10D1"], [7314, 1, "\u10D2"], [7315, 1, "\u10D3"], [7316, 1, "\u10D4"], [7317, 1, "\u10D5"], [7318, 1, "\u10D6"], [7319, 1, "\u10D7"], [7320, 1, "\u10D8"], [7321, 1, "\u10D9"], [7322, 1, "\u10DA"], [7323, 1, "\u10DB"], [7324, 1, "\u10DC"], [7325, 1, "\u10DD"], [7326, 1, "\u10DE"], [7327, 1, "\u10DF"], [7328, 1, "\u10E0"], [7329, 1, "\u10E1"], [7330, 1, "\u10E2"], [7331, 1, "\u10E3"], [7332, 1, "\u10E4"], [7333, 1, "\u10E5"], [7334, 1, "\u10E6"], [7335, 1, "\u10E7"], [7336, 1, "\u10E8"], [7337, 1, "\u10E9"], [7338, 1, "\u10EA"], [7339, 1, "\u10EB"], [7340, 1, "\u10EC"], [7341, 1, "\u10ED"], [7342, 1, "\u10EE"], [7343, 1, "\u10EF"], [7344, 1, "\u10F0"], [7345, 1, "\u10F1"], [7346, 1, "\u10F2"], [7347, 1, "\u10F3"], [7348, 1, "\u10F4"], [7349, 1, "\u10F5"], [7350, 1, "\u10F6"], [7351, 1, "\u10F7"], [7352, 1, "\u10F8"], [7353, 1, "\u10F9"], [7354, 1, "\u10FA"], [[7355, 7356], 3], [7357, 1, "\u10FD"], [7358, 1, "\u10FE"], [7359, 1, "\u10FF"], [[7360, 7367], 2], [[7368, 7375], 3], [[7376, 7378], 2], [7379, 2], [[7380, 7410], 2], [[7411, 7414], 2], [7415, 2], [[7416, 7417], 2], [7418, 2], [[7419, 7423], 3], [[7424, 7467], 2], [7468, 1, "a"], [7469, 1, "\xE6"], [7470, 1, "b"], [7471, 2], [7472, 1, "d"], [7473, 1, "e"], [7474, 1, "\u01DD"], [7475, 1, "g"], [7476, 1, "h"], [7477, 1, "i"], [7478, 1, "j"], [7479, 1, "k"], [7480, 1, "l"], [7481, 1, "m"], [7482, 1, "n"], [7483, 2], [7484, 1, "o"], [7485, 1, "\u0223"], [7486, 1, "p"], [7487, 1, "r"], [7488, 1, "t"], [7489, 1, "u"], [7490, 1, "w"], [7491, 1, "a"], [7492, 1, "\u0250"], [7493, 1, "\u0251"], [7494, 1, "\u1D02"], [7495, 1, "b"], [7496, 1, "d"], [7497, 1, "e"], [7498, 1, "\u0259"], [7499, 1, "\u025B"], [7500, 1, "\u025C"], [7501, 1, "g"], [7502, 2], [7503, 1, "k"], [7504, 1, "m"], [7505, 1, "\u014B"], [7506, 1, "o"], [7507, 1, "\u0254"], [7508, 1, "\u1D16"], [7509, 1, "\u1D17"], [7510, 1, "p"], [7511, 1, "t"], [7512, 1, "u"], [7513, 1, "\u1D1D"], [7514, 1, "\u026F"], [7515, 1, "v"], [7516, 1, "\u1D25"], [7517, 1, "\u03B2"], [7518, 1, "\u03B3"], [7519, 1, "\u03B4"], [7520, 1, "\u03C6"], [7521, 1, "\u03C7"], [7522, 1, "i"], [7523, 1, "r"], [7524, 1, "u"], [7525, 1, "v"], [7526, 1, "\u03B2"], [7527, 1, "\u03B3"], [7528, 1, "\u03C1"], [7529, 1, "\u03C6"], [7530, 1, "\u03C7"], [7531, 2], [[7532, 7543], 2], [7544, 1, "\u043D"], [[7545, 7578], 2], [7579, 1, "\u0252"], [7580, 1, "c"], [7581, 1, "\u0255"], [7582, 1, "\xF0"], [7583, 1, "\u025C"], [7584, 1, "f"], [7585, 1, "\u025F"], [7586, 1, "\u0261"], [7587, 1, "\u0265"], [7588, 1, "\u0268"], [7589, 1, "\u0269"], [7590, 1, "\u026A"], [7591, 1, "\u1D7B"], [7592, 1, "\u029D"], [7593, 1, "\u026D"], [7594, 1, "\u1D85"], [7595, 1, "\u029F"], [7596, 1, "\u0271"], [7597, 1, "\u0270"], [7598, 1, "\u0272"], [7599, 1, "\u0273"], [7600, 1, "\u0274"], [7601, 1, "\u0275"], [7602, 1, "\u0278"], [7603, 1, "\u0282"], [7604, 1, "\u0283"], [7605, 1, "\u01AB"], [7606, 1, "\u0289"], [7607, 1, "\u028A"], [7608, 1, "\u1D1C"], [7609, 1, "\u028B"], [7610, 1, "\u028C"], [7611, 1, "z"], [7612, 1, "\u0290"], [7613, 1, "\u0291"], [7614, 1, "\u0292"], [7615, 1, "\u03B8"], [[7616, 7619], 2], [[7620, 7626], 2], [[7627, 7654], 2], [[7655, 7669], 2], [[7670, 7673], 2], [7674, 2], [7675, 2], [7676, 2], [7677, 2], [[7678, 7679], 2], [7680, 1, "\u1E01"], [7681, 2], [7682, 1, "\u1E03"], [7683, 2], [7684, 1, "\u1E05"], [7685, 2], [7686, 1, "\u1E07"], [7687, 2], [7688, 1, "\u1E09"], [7689, 2], [7690, 1, "\u1E0B"], [7691, 2], [7692, 1, "\u1E0D"], [7693, 2], [7694, 1, "\u1E0F"], [7695, 2], [7696, 1, "\u1E11"], [7697, 2], [7698, 1, "\u1E13"], [7699, 2], [7700, 1, "\u1E15"], [7701, 2], [7702, 1, "\u1E17"], [7703, 2], [7704, 1, "\u1E19"], [7705, 2], [7706, 1, "\u1E1B"], [7707, 2], [7708, 1, "\u1E1D"], [7709, 2], [7710, 1, "\u1E1F"], [7711, 2], [7712, 1, "\u1E21"], [7713, 2], [7714, 1, "\u1E23"], [7715, 2], [7716, 1, "\u1E25"], [7717, 2], [7718, 1, "\u1E27"], [7719, 2], [7720, 1, "\u1E29"], [7721, 2], [7722, 1, "\u1E2B"], [7723, 2], [7724, 1, "\u1E2D"], [7725, 2], [7726, 1, "\u1E2F"], [7727, 2], [7728, 1, "\u1E31"], [7729, 2], [7730, 1, "\u1E33"], [7731, 2], [7732, 1, "\u1E35"], [7733, 2], [7734, 1, "\u1E37"], [7735, 2], [7736, 1, "\u1E39"], [7737, 2], [7738, 1, "\u1E3B"], [7739, 2], [7740, 1, "\u1E3D"], [7741, 2], [7742, 1, "\u1E3F"], [7743, 2], [7744, 1, "\u1E41"], [7745, 2], [7746, 1, "\u1E43"], [7747, 2], [7748, 1, "\u1E45"], [7749, 2], [7750, 1, "\u1E47"], [7751, 2], [7752, 1, "\u1E49"], [7753, 2], [7754, 1, "\u1E4B"], [7755, 2], [7756, 1, "\u1E4D"], [7757, 2], [7758, 1, "\u1E4F"], [7759, 2], [7760, 1, "\u1E51"], [7761, 2], [7762, 1, "\u1E53"], [7763, 2], [7764, 1, "\u1E55"], [7765, 2], [7766, 1, "\u1E57"], [7767, 2], [7768, 1, "\u1E59"], [7769, 2], [7770, 1, "\u1E5B"], [7771, 2], [7772, 1, "\u1E5D"], [7773, 2], [7774, 1, "\u1E5F"], [7775, 2], [7776, 1, "\u1E61"], [7777, 2], [7778, 1, "\u1E63"], [7779, 2], [7780, 1, "\u1E65"], [7781, 2], [7782, 1, "\u1E67"], [7783, 2], [7784, 1, "\u1E69"], [7785, 2], [7786, 1, "\u1E6B"], [7787, 2], [7788, 1, "\u1E6D"], [7789, 2], [7790, 1, "\u1E6F"], [7791, 2], [7792, 1, "\u1E71"], [7793, 2], [7794, 1, "\u1E73"], [7795, 2], [7796, 1, "\u1E75"], [7797, 2], [7798, 1, "\u1E77"], [7799, 2], [7800, 1, "\u1E79"], [7801, 2], [7802, 1, "\u1E7B"], [7803, 2], [7804, 1, "\u1E7D"], [7805, 2], [7806, 1, "\u1E7F"], [7807, 2], [7808, 1, "\u1E81"], [7809, 2], [7810, 1, "\u1E83"], [7811, 2], [7812, 1, "\u1E85"], [7813, 2], [7814, 1, "\u1E87"], [7815, 2], [7816, 1, "\u1E89"], [7817, 2], [7818, 1, "\u1E8B"], [7819, 2], [7820, 1, "\u1E8D"], [7821, 2], [7822, 1, "\u1E8F"], [7823, 2], [7824, 1, "\u1E91"], [7825, 2], [7826, 1, "\u1E93"], [7827, 2], [7828, 1, "\u1E95"], [[7829, 7833], 2], [7834, 1, "a\u02BE"], [7835, 1, "\u1E61"], [[7836, 7837], 2], [7838, 1, "\xDF"], [7839, 2], [7840, 1, "\u1EA1"], [7841, 2], [7842, 1, "\u1EA3"], [7843, 2], [7844, 1, "\u1EA5"], [7845, 2], [7846, 1, "\u1EA7"], [7847, 2], [7848, 1, "\u1EA9"], [7849, 2], [7850, 1, "\u1EAB"], [7851, 2], [7852, 1, "\u1EAD"], [7853, 2], [7854, 1, "\u1EAF"], [7855, 2], [7856, 1, "\u1EB1"], [7857, 2], [7858, 1, "\u1EB3"], [7859, 2], [7860, 1, "\u1EB5"], [7861, 2], [7862, 1, "\u1EB7"], [7863, 2], [7864, 1, "\u1EB9"], [7865, 2], [7866, 1, "\u1EBB"], [7867, 2], [7868, 1, "\u1EBD"], [7869, 2], [7870, 1, "\u1EBF"], [7871, 2], [7872, 1, "\u1EC1"], [7873, 2], [7874, 1, "\u1EC3"], [7875, 2], [7876, 1, "\u1EC5"], [7877, 2], [7878, 1, "\u1EC7"], [7879, 2], [7880, 1, "\u1EC9"], [7881, 2], [7882, 1, "\u1ECB"], [7883, 2], [7884, 1, "\u1ECD"], [7885, 2], [7886, 1, "\u1ECF"], [7887, 2], [7888, 1, "\u1ED1"], [7889, 2], [7890, 1, "\u1ED3"], [7891, 2], [7892, 1, "\u1ED5"], [7893, 2], [7894, 1, "\u1ED7"], [7895, 2], [7896, 1, "\u1ED9"], [7897, 2], [7898, 1, "\u1EDB"], [7899, 2], [7900, 1, "\u1EDD"], [7901, 2], [7902, 1, "\u1EDF"], [7903, 2], [7904, 1, "\u1EE1"], [7905, 2], [7906, 1, "\u1EE3"], [7907, 2], [7908, 1, "\u1EE5"], [7909, 2], [7910, 1, "\u1EE7"], [7911, 2], [7912, 1, "\u1EE9"], [7913, 2], [7914, 1, "\u1EEB"], [7915, 2], [7916, 1, "\u1EED"], [7917, 2], [7918, 1, "\u1EEF"], [7919, 2], [7920, 1, "\u1EF1"], [7921, 2], [7922, 1, "\u1EF3"], [7923, 2], [7924, 1, "\u1EF5"], [7925, 2], [7926, 1, "\u1EF7"], [7927, 2], [7928, 1, "\u1EF9"], [7929, 2], [7930, 1, "\u1EFB"], [7931, 2], [7932, 1, "\u1EFD"], [7933, 2], [7934, 1, "\u1EFF"], [7935, 2], [[7936, 7943], 2], [7944, 1, "\u1F00"], [7945, 1, "\u1F01"], [7946, 1, "\u1F02"], [7947, 1, "\u1F03"], [7948, 1, "\u1F04"], [7949, 1, "\u1F05"], [7950, 1, "\u1F06"], [7951, 1, "\u1F07"], [[7952, 7957], 2], [[7958, 7959], 3], [7960, 1, "\u1F10"], [7961, 1, "\u1F11"], [7962, 1, "\u1F12"], [7963, 1, "\u1F13"], [7964, 1, "\u1F14"], [7965, 1, "\u1F15"], [[7966, 7967], 3], [[7968, 7975], 2], [7976, 1, "\u1F20"], [7977, 1, "\u1F21"], [7978, 1, "\u1F22"], [7979, 1, "\u1F23"], [7980, 1, "\u1F24"], [7981, 1, "\u1F25"], [7982, 1, "\u1F26"], [7983, 1, "\u1F27"], [[7984, 7991], 2], [7992, 1, "\u1F30"], [7993, 1, "\u1F31"], [7994, 1, "\u1F32"], [7995, 1, "\u1F33"], [7996, 1, "\u1F34"], [7997, 1, "\u1F35"], [7998, 1, "\u1F36"], [7999, 1, "\u1F37"], [[8e3, 8005], 2], [[8006, 8007], 3], [8008, 1, "\u1F40"], [8009, 1, "\u1F41"], [8010, 1, "\u1F42"], [8011, 1, "\u1F43"], [8012, 1, "\u1F44"], [8013, 1, "\u1F45"], [[8014, 8015], 3], [[8016, 8023], 2], [8024, 3], [8025, 1, "\u1F51"], [8026, 3], [8027, 1, "\u1F53"], [8028, 3], [8029, 1, "\u1F55"], [8030, 3], [8031, 1, "\u1F57"], [[8032, 8039], 2], [8040, 1, "\u1F60"], [8041, 1, "\u1F61"], [8042, 1, "\u1F62"], [8043, 1, "\u1F63"], [8044, 1, "\u1F64"], [8045, 1, "\u1F65"], [8046, 1, "\u1F66"], [8047, 1, "\u1F67"], [8048, 2], [8049, 1, "\u03AC"], [8050, 2], [8051, 1, "\u03AD"], [8052, 2], [8053, 1, "\u03AE"], [8054, 2], [8055, 1, "\u03AF"], [8056, 2], [8057, 1, "\u03CC"], [8058, 2], [8059, 1, "\u03CD"], [8060, 2], [8061, 1, "\u03CE"], [[8062, 8063], 3], [8064, 1, "\u1F00\u03B9"], [8065, 1, "\u1F01\u03B9"], [8066, 1, "\u1F02\u03B9"], [8067, 1, "\u1F03\u03B9"], [8068, 1, "\u1F04\u03B9"], [8069, 1, "\u1F05\u03B9"], [8070, 1, "\u1F06\u03B9"], [8071, 1, "\u1F07\u03B9"], [8072, 1, "\u1F00\u03B9"], [8073, 1, "\u1F01\u03B9"], [8074, 1, "\u1F02\u03B9"], [8075, 1, "\u1F03\u03B9"], [8076, 1, "\u1F04\u03B9"], [8077, 1, "\u1F05\u03B9"], [8078, 1, "\u1F06\u03B9"], [8079, 1, "\u1F07\u03B9"], [8080, 1, "\u1F20\u03B9"], [8081, 1, "\u1F21\u03B9"], [8082, 1, "\u1F22\u03B9"], [8083, 1, "\u1F23\u03B9"], [8084, 1, "\u1F24\u03B9"], [8085, 1, "\u1F25\u03B9"], [8086, 1, "\u1F26\u03B9"], [8087, 1, "\u1F27\u03B9"], [8088, 1, "\u1F20\u03B9"], [8089, 1, "\u1F21\u03B9"], [8090, 1, "\u1F22\u03B9"], [8091, 1, "\u1F23\u03B9"], [8092, 1, "\u1F24\u03B9"], [8093, 1, "\u1F25\u03B9"], [8094, 1, "\u1F26\u03B9"], [8095, 1, "\u1F27\u03B9"], [8096, 1, "\u1F60\u03B9"], [8097, 1, "\u1F61\u03B9"], [8098, 1, "\u1F62\u03B9"], [8099, 1, "\u1F63\u03B9"], [8100, 1, "\u1F64\u03B9"], [8101, 1, "\u1F65\u03B9"], [8102, 1, "\u1F66\u03B9"], [8103, 1, "\u1F67\u03B9"], [8104, 1, "\u1F60\u03B9"], [8105, 1, "\u1F61\u03B9"], [8106, 1, "\u1F62\u03B9"], [8107, 1, "\u1F63\u03B9"], [8108, 1, "\u1F64\u03B9"], [8109, 1, "\u1F65\u03B9"], [8110, 1, "\u1F66\u03B9"], [8111, 1, "\u1F67\u03B9"], [[8112, 8113], 2], [8114, 1, "\u1F70\u03B9"], [8115, 1, "\u03B1\u03B9"], [8116, 1, "\u03AC\u03B9"], [8117, 3], [8118, 2], [8119, 1, "\u1FB6\u03B9"], [8120, 1, "\u1FB0"], [8121, 1, "\u1FB1"], [8122, 1, "\u1F70"], [8123, 1, "\u03AC"], [8124, 1, "\u03B1\u03B9"], [8125, 5, " \u0313"], [8126, 1, "\u03B9"], [8127, 5, " \u0313"], [8128, 5, " \u0342"], [8129, 5, " \u0308\u0342"], [8130, 1, "\u1F74\u03B9"], [8131, 1, "\u03B7\u03B9"], [8132, 1, "\u03AE\u03B9"], [8133, 3], [8134, 2], [8135, 1, "\u1FC6\u03B9"], [8136, 1, "\u1F72"], [8137, 1, "\u03AD"], [8138, 1, "\u1F74"], [8139, 1, "\u03AE"], [8140, 1, "\u03B7\u03B9"], [8141, 5, " \u0313\u0300"], [8142, 5, " \u0313\u0301"], [8143, 5, " \u0313\u0342"], [[8144, 8146], 2], [8147, 1, "\u0390"], [[8148, 8149], 3], [[8150, 8151], 2], [8152, 1, "\u1FD0"], [8153, 1, "\u1FD1"], [8154, 1, "\u1F76"], [8155, 1, "\u03AF"], [8156, 3], [8157, 5, " \u0314\u0300"], [8158, 5, " \u0314\u0301"], [8159, 5, " \u0314\u0342"], [[8160, 8162], 2], [8163, 1, "\u03B0"], [[8164, 8167], 2], [8168, 1, "\u1FE0"], [8169, 1, "\u1FE1"], [8170, 1, "\u1F7A"], [8171, 1, "\u03CD"], [8172, 1, "\u1FE5"], [8173, 5, " \u0308\u0300"], [8174, 5, " \u0308\u0301"], [8175, 5, "`"], [[8176, 8177], 3], [8178, 1, "\u1F7C\u03B9"], [8179, 1, "\u03C9\u03B9"], [8180, 1, "\u03CE\u03B9"], [8181, 3], [8182, 2], [8183, 1, "\u1FF6\u03B9"], [8184, 1, "\u1F78"], [8185, 1, "\u03CC"], [8186, 1, "\u1F7C"], [8187, 1, "\u03CE"], [8188, 1, "\u03C9\u03B9"], [8189, 5, " \u0301"], [8190, 5, " \u0314"], [8191, 3], [[8192, 8202], 5, " "], [8203, 7], [[8204, 8205], 6, ""], [[8206, 8207], 3], [8208, 2], [8209, 1, "\u2010"], [[8210, 8214], 2], [8215, 5, " \u0333"], [[8216, 8227], 2], [[8228, 8230], 3], [8231, 2], [[8232, 8238], 3], [8239, 5, " "], [[8240, 8242], 2], [8243, 1, "\u2032\u2032"], [8244, 1, "\u2032\u2032\u2032"], [8245, 2], [8246, 1, "\u2035\u2035"], [8247, 1, "\u2035\u2035\u2035"], [[8248, 8251], 2], [8252, 5, "!!"], [8253, 2], [8254, 5, " \u0305"], [[8255, 8262], 2], [8263, 5, "??"], [8264, 5, "?!"], [8265, 5, "!?"], [[8266, 8269], 2], [[8270, 8274], 2], [[8275, 8276], 2], [[8277, 8278], 2], [8279, 1, "\u2032\u2032\u2032\u2032"], [[8280, 8286], 2], [8287, 5, " "], [8288, 7], [[8289, 8291], 3], [8292, 7], [8293, 3], [[8294, 8297], 3], [[8298, 8303], 3], [8304, 1, "0"], [8305, 1, "i"], [[8306, 8307], 3], [8308, 1, "4"], [8309, 1, "5"], [8310, 1, "6"], [8311, 1, "7"], [8312, 1, "8"], [8313, 1, "9"], [8314, 5, "+"], [8315, 1, "\u2212"], [8316, 5, "="], [8317, 5, "("], [8318, 5, ")"], [8319, 1, "n"], [8320, 1, "0"], [8321, 1, "1"], [8322, 1, "2"], [8323, 1, "3"], [8324, 1, "4"], [8325, 1, "5"], [8326, 1, "6"], [8327, 1, "7"], [8328, 1, "8"], [8329, 1, "9"], [8330, 5, "+"], [8331, 1, "\u2212"], [8332, 5, "="], [8333, 5, "("], [8334, 5, ")"], [8335, 3], [8336, 1, "a"], [8337, 1, "e"], [8338, 1, "o"], [8339, 1, "x"], [8340, 1, "\u0259"], [8341, 1, "h"], [8342, 1, "k"], [8343, 1, "l"], [8344, 1, "m"], [8345, 1, "n"], [8346, 1, "p"], [8347, 1, "s"], [8348, 1, "t"], [[8349, 8351], 3], [[8352, 8359], 2], [8360, 1, "rs"], [[8361, 8362], 2], [8363, 2], [8364, 2], [[8365, 8367], 2], [[8368, 8369], 2], [[8370, 8373], 2], [[8374, 8376], 2], [8377, 2], [8378, 2], [[8379, 8381], 2], [8382, 2], [8383, 2], [8384, 2], [[8385, 8399], 3], [[8400, 8417], 2], [[8418, 8419], 2], [[8420, 8426], 2], [8427, 2], [[8428, 8431], 2], [8432, 2], [[8433, 8447], 3], [8448, 5, "a/c"], [8449, 5, "a/s"], [8450, 1, "c"], [8451, 1, "\xB0c"], [8452, 2], [8453, 5, "c/o"], [8454, 5, "c/u"], [8455, 1, "\u025B"], [8456, 2], [8457, 1, "\xB0f"], [8458, 1, "g"], [[8459, 8462], 1, "h"], [8463, 1, "\u0127"], [[8464, 8465], 1, "i"], [[8466, 8467], 1, "l"], [8468, 2], [8469, 1, "n"], [8470, 1, "no"], [[8471, 8472], 2], [8473, 1, "p"], [8474, 1, "q"], [[8475, 8477], 1, "r"], [[8478, 8479], 2], [8480, 1, "sm"], [8481, 1, "tel"], [8482, 1, "tm"], [8483, 2], [8484, 1, "z"], [8485, 2], [8486, 1, "\u03C9"], [8487, 2], [8488, 1, "z"], [8489, 2], [8490, 1, "k"], [8491, 1, "\xE5"], [8492, 1, "b"], [8493, 1, "c"], [8494, 2], [[8495, 8496], 1, "e"], [8497, 1, "f"], [8498, 3], [8499, 1, "m"], [8500, 1, "o"], [8501, 1, "\u05D0"], [8502, 1, "\u05D1"], [8503, 1, "\u05D2"], [8504, 1, "\u05D3"], [8505, 1, "i"], [8506, 2], [8507, 1, "fax"], [8508, 1, "\u03C0"], [[8509, 8510], 1, "\u03B3"], [8511, 1, "\u03C0"], [8512, 1, "\u2211"], [[8513, 8516], 2], [[8517, 8518], 1, "d"], [8519, 1, "e"], [8520, 1, "i"], [8521, 1, "j"], [[8522, 8523], 2], [8524, 2], [8525, 2], [8526, 2], [8527, 2], [8528, 1, "1\u20447"], [8529, 1, "1\u20449"], [8530, 1, "1\u204410"], [8531, 1, "1\u20443"], [8532, 1, "2\u20443"], [8533, 1, "1\u20445"], [8534, 1, "2\u20445"], [8535, 1, "3\u20445"], [8536, 1, "4\u20445"], [8537, 1, "1\u20446"], [8538, 1, "5\u20446"], [8539, 1, "1\u20448"], [8540, 1, "3\u20448"], [8541, 1, "5\u20448"], [8542, 1, "7\u20448"], [8543, 1, "1\u2044"], [8544, 1, "i"], [8545, 1, "ii"], [8546, 1, "iii"], [8547, 1, "iv"], [8548, 1, "v"], [8549, 1, "vi"], [8550, 1, "vii"], [8551, 1, "viii"], [8552, 1, "ix"], [8553, 1, "x"], [8554, 1, "xi"], [8555, 1, "xii"], [8556, 1, "l"], [8557, 1, "c"], [8558, 1, "d"], [8559, 1, "m"], [8560, 1, "i"], [8561, 1, "ii"], [8562, 1, "iii"], [8563, 1, "iv"], [8564, 1, "v"], [8565, 1, "vi"], [8566, 1, "vii"], [8567, 1, "viii"], [8568, 1, "ix"], [8569, 1, "x"], [8570, 1, "xi"], [8571, 1, "xii"], [8572, 1, "l"], [8573, 1, "c"], [8574, 1, "d"], [8575, 1, "m"], [[8576, 8578], 2], [8579, 3], [8580, 2], [[8581, 8584], 2], [8585, 1, "0\u20443"], [[8586, 8587], 2], [[8588, 8591], 3], [[8592, 8682], 2], [[8683, 8691], 2], [[8692, 8703], 2], [[8704, 8747], 2], [8748, 1, "\u222B\u222B"], [8749, 1, "\u222B\u222B\u222B"], [8750, 2], [8751, 1, "\u222E\u222E"], [8752, 1, "\u222E\u222E\u222E"], [[8753, 8945], 2], [[8946, 8959], 2], [8960, 2], [8961, 2], [[8962, 9e3], 2], [9001, 1, "\u3008"], [9002, 1, "\u3009"], [[9003, 9082], 2], [9083, 2], [9084, 2], [[9085, 9114], 2], [[9115, 9166], 2], [[9167, 9168], 2], [[9169, 9179], 2], [[9180, 9191], 2], [9192, 2], [[9193, 9203], 2], [[9204, 9210], 2], [[9211, 9214], 2], [9215, 2], [[9216, 9252], 2], [[9253, 9254], 2], [[9255, 9279], 3], [[9280, 9290], 2], [[9291, 9311], 3], [9312, 1, "1"], [9313, 1, "2"], [9314, 1, "3"], [9315, 1, "4"], [9316, 1, "5"], [9317, 1, "6"], [9318, 1, "7"], [9319, 1, "8"], [9320, 1, "9"], [9321, 1, "10"], [9322, 1, "11"], [9323, 1, "12"], [9324, 1, "13"], [9325, 1, "14"], [9326, 1, "15"], [9327, 1, "16"], [9328, 1, "17"], [9329, 1, "18"], [9330, 1, "19"], [9331, 1, "20"], [9332, 5, "(1)"], [9333, 5, "(2)"], [9334, 5, "(3)"], [9335, 5, "(4)"], [9336, 5, "(5)"], [9337, 5, "(6)"], [9338, 5, "(7)"], [9339, 5, "(8)"], [9340, 5, "(9)"], [9341, 5, "(10)"], [9342, 5, "(11)"], [9343, 5, "(12)"], [9344, 5, "(13)"], [9345, 5, "(14)"], [9346, 5, "(15)"], [9347, 5, "(16)"], [9348, 5, "(17)"], [9349, 5, "(18)"], [9350, 5, "(19)"], [9351, 5, "(20)"], [[9352, 9371], 3], [9372, 5, "(a)"], [9373, 5, "(b)"], [9374, 5, "(c)"], [9375, 5, "(d)"], [9376, 5, "(e)"], [9377, 5, "(f)"], [9378, 5, "(g)"], [9379, 5, "(h)"], [9380, 5, "(i)"], [9381, 5, "(j)"], [9382, 5, "(k)"], [9383, 5, "(l)"], [9384, 5, "(m)"], [9385, 5, "(n)"], [9386, 5, "(o)"], [9387, 5, "(p)"], [9388, 5, "(q)"], [9389, 5, "(r)"], [9390, 5, "(s)"], [9391, 5, "(t)"], [9392, 5, "(u)"], [9393, 5, "(v)"], [9394, 5, "(w)"], [9395, 5, "(x)"], [9396, 5, "(y)"], [9397, 5, "(z)"], [9398, 1, "a"], [9399, 1, "b"], [9400, 1, "c"], [9401, 1, "d"], [9402, 1, "e"], [9403, 1, "f"], [9404, 1, "g"], [9405, 1, "h"], [9406, 1, "i"], [9407, 1, "j"], [9408, 1, "k"], [9409, 1, "l"], [9410, 1, "m"], [9411, 1, "n"], [9412, 1, "o"], [9413, 1, "p"], [9414, 1, "q"], [9415, 1, "r"], [9416, 1, "s"], [9417, 1, "t"], [9418, 1, "u"], [9419, 1, "v"], [9420, 1, "w"], [9421, 1, "x"], [9422, 1, "y"], [9423, 1, "z"], [9424, 1, "a"], [9425, 1, "b"], [9426, 1, "c"], [9427, 1, "d"], [9428, 1, "e"], [9429, 1, "f"], [9430, 1, "g"], [9431, 1, "h"], [9432, 1, "i"], [9433, 1, "j"], [9434, 1, "k"], [9435, 1, "l"], [9436, 1, "m"], [9437, 1, "n"], [9438, 1, "o"], [9439, 1, "p"], [9440, 1, "q"], [9441, 1, "r"], [9442, 1, "s"], [9443, 1, "t"], [9444, 1, "u"], [9445, 1, "v"], [9446, 1, "w"], [9447, 1, "x"], [9448, 1, "y"], [9449, 1, "z"], [9450, 1, "0"], [[9451, 9470], 2], [9471, 2], [[9472, 9621], 2], [[9622, 9631], 2], [[9632, 9711], 2], [[9712, 9719], 2], [[9720, 9727], 2], [[9728, 9747], 2], [[9748, 9749], 2], [[9750, 9751], 2], [9752, 2], [9753, 2], [[9754, 9839], 2], [[9840, 9841], 2], [[9842, 9853], 2], [[9854, 9855], 2], [[9856, 9865], 2], [[9866, 9873], 2], [[9874, 9884], 2], [9885, 2], [[9886, 9887], 2], [[9888, 9889], 2], [[9890, 9905], 2], [9906, 2], [[9907, 9916], 2], [[9917, 9919], 2], [[9920, 9923], 2], [[9924, 9933], 2], [9934, 2], [[9935, 9953], 2], [9954, 2], [9955, 2], [[9956, 9959], 2], [[9960, 9983], 2], [9984, 2], [[9985, 9988], 2], [9989, 2], [[9990, 9993], 2], [[9994, 9995], 2], [[9996, 10023], 2], [10024, 2], [[10025, 10059], 2], [10060, 2], [10061, 2], [10062, 2], [[10063, 10066], 2], [[10067, 10069], 2], [10070, 2], [10071, 2], [[10072, 10078], 2], [[10079, 10080], 2], [[10081, 10087], 2], [[10088, 10101], 2], [[10102, 10132], 2], [[10133, 10135], 2], [[10136, 10159], 2], [10160, 2], [[10161, 10174], 2], [10175, 2], [[10176, 10182], 2], [[10183, 10186], 2], [10187, 2], [10188, 2], [10189, 2], [[10190, 10191], 2], [[10192, 10219], 2], [[10220, 10223], 2], [[10224, 10239], 2], [[10240, 10495], 2], [[10496, 10763], 2], [10764, 1, "\u222B\u222B\u222B\u222B"], [[10765, 10867], 2], [10868, 5, "::="], [10869, 5, "=="], [10870, 5, "==="], [[10871, 10971], 2], [10972, 1, "\u2ADD\u0338"], [[10973, 11007], 2], [[11008, 11021], 2], [[11022, 11027], 2], [[11028, 11034], 2], [[11035, 11039], 2], [[11040, 11043], 2], [[11044, 11084], 2], [[11085, 11087], 2], [[11088, 11092], 2], [[11093, 11097], 2], [[11098, 11123], 2], [[11124, 11125], 3], [[11126, 11157], 2], [11158, 3], [11159, 2], [[11160, 11193], 2], [[11194, 11196], 2], [[11197, 11208], 2], [11209, 2], [[11210, 11217], 2], [11218, 2], [[11219, 11243], 2], [[11244, 11247], 2], [[11248, 11262], 2], [11263, 2], [11264, 1, "\u2C30"], [11265, 1, "\u2C31"], [11266, 1, "\u2C32"], [11267, 1, "\u2C33"], [11268, 1, "\u2C34"], [11269, 1, "\u2C35"], [11270, 1, "\u2C36"], [11271, 1, "\u2C37"], [11272, 1, "\u2C38"], [11273, 1, "\u2C39"], [11274, 1, "\u2C3A"], [11275, 1, "\u2C3B"], [11276, 1, "\u2C3C"], [11277, 1, "\u2C3D"], [11278, 1, "\u2C3E"], [11279, 1, "\u2C3F"], [11280, 1, "\u2C40"], [11281, 1, "\u2C41"], [11282, 1, "\u2C42"], [11283, 1, "\u2C43"], [11284, 1, "\u2C44"], [11285, 1, "\u2C45"], [11286, 1, "\u2C46"], [11287, 1, "\u2C47"], [11288, 1, "\u2C48"], [11289, 1, "\u2C49"], [11290, 1, "\u2C4A"], [11291, 1, "\u2C4B"], [11292, 1, "\u2C4C"], [11293, 1, "\u2C4D"], [11294, 1, "\u2C4E"], [11295, 1, "\u2C4F"], [11296, 1, "\u2C50"], [11297, 1, "\u2C51"], [11298, 1, "\u2C52"], [11299, 1, "\u2C53"], [11300, 1, "\u2C54"], [11301, 1, "\u2C55"], [11302, 1, "\u2C56"], [11303, 1, "\u2C57"], [11304, 1, "\u2C58"], [11305, 1, "\u2C59"], [11306, 1, "\u2C5A"], [11307, 1, "\u2C5B"], [11308, 1, "\u2C5C"], [11309, 1, "\u2C5D"], [11310, 1, "\u2C5E"], [11311, 1, "\u2C5F"], [[11312, 11358], 2], [11359, 2], [11360, 1, "\u2C61"], [11361, 2], [11362, 1, "\u026B"], [11363, 1, "\u1D7D"], [11364, 1, "\u027D"], [[11365, 11366], 2], [11367, 1, "\u2C68"], [11368, 2], [11369, 1, "\u2C6A"], [11370, 2], [11371, 1, "\u2C6C"], [11372, 2], [11373, 1, "\u0251"], [11374, 1, "\u0271"], [11375, 1, "\u0250"], [11376, 1, "\u0252"], [11377, 2], [11378, 1, "\u2C73"], [11379, 2], [11380, 2], [11381, 1, "\u2C76"], [[11382, 11383], 2], [[11384, 11387], 2], [11388, 1, "j"], [11389, 1, "v"], [11390, 1, "\u023F"], [11391, 1, "\u0240"], [11392, 1, "\u2C81"], [11393, 2], [11394, 1, "\u2C83"], [11395, 2], [11396, 1, "\u2C85"], [11397, 2], [11398, 1, "\u2C87"], [11399, 2], [11400, 1, "\u2C89"], [11401, 2], [11402, 1, "\u2C8B"], [11403, 2], [11404, 1, "\u2C8D"], [11405, 2], [11406, 1, "\u2C8F"], [11407, 2], [11408, 1, "\u2C91"], [11409, 2], [11410, 1, "\u2C93"], [11411, 2], [11412, 1, "\u2C95"], [11413, 2], [11414, 1, "\u2C97"], [11415, 2], [11416, 1, "\u2C99"], [11417, 2], [11418, 1, "\u2C9B"], [11419, 2], [11420, 1, "\u2C9D"], [11421, 2], [11422, 1, "\u2C9F"], [11423, 2], [11424, 1, "\u2CA1"], [11425, 2], [11426, 1, "\u2CA3"], [11427, 2], [11428, 1, "\u2CA5"], [11429, 2], [11430, 1, "\u2CA7"], [11431, 2], [11432, 1, "\u2CA9"], [11433, 2], [11434, 1, "\u2CAB"], [11435, 2], [11436, 1, "\u2CAD"], [11437, 2], [11438, 1, "\u2CAF"], [11439, 2], [11440, 1, "\u2CB1"], [11441, 2], [11442, 1, "\u2CB3"], [11443, 2], [11444, 1, "\u2CB5"], [11445, 2], [11446, 1, "\u2CB7"], [11447, 2], [11448, 1, "\u2CB9"], [11449, 2], [11450, 1, "\u2CBB"], [11451, 2], [11452, 1, "\u2CBD"], [11453, 2], [11454, 1, "\u2CBF"], [11455, 2], [11456, 1, "\u2CC1"], [11457, 2], [11458, 1, "\u2CC3"], [11459, 2], [11460, 1, "\u2CC5"], [11461, 2], [11462, 1, "\u2CC7"], [11463, 2], [11464, 1, "\u2CC9"], [11465, 2], [11466, 1, "\u2CCB"], [11467, 2], [11468, 1, "\u2CCD"], [11469, 2], [11470, 1, "\u2CCF"], [11471, 2], [11472, 1, "\u2CD1"], [11473, 2], [11474, 1, "\u2CD3"], [11475, 2], [11476, 1, "\u2CD5"], [11477, 2], [11478, 1, "\u2CD7"], [11479, 2], [11480, 1, "\u2CD9"], [11481, 2], [11482, 1, "\u2CDB"], [11483, 2], [11484, 1, "\u2CDD"], [11485, 2], [11486, 1, "\u2CDF"], [11487, 2], [11488, 1, "\u2CE1"], [11489, 2], [11490, 1, "\u2CE3"], [[11491, 11492], 2], [[11493, 11498], 2], [11499, 1, "\u2CEC"], [11500, 2], [11501, 1, "\u2CEE"], [[11502, 11505], 2], [11506, 1, "\u2CF3"], [11507, 2], [[11508, 11512], 3], [[11513, 11519], 2], [[11520, 11557], 2], [11558, 3], [11559, 2], [[11560, 11564], 3], [11565, 2], [[11566, 11567], 3], [[11568, 11621], 2], [[11622, 11623], 2], [[11624, 11630], 3], [11631, 1, "\u2D61"], [11632, 2], [[11633, 11646], 3], [11647, 2], [[11648, 11670], 2], [[11671, 11679], 3], [[11680, 11686], 2], [11687, 3], [[11688, 11694], 2], [11695, 3], [[11696, 11702], 2], [11703, 3], [[11704, 11710], 2], [11711, 3], [[11712, 11718], 2], [11719, 3], [[11720, 11726], 2], [11727, 3], [[11728, 11734], 2], [11735, 3], [[11736, 11742], 2], [11743, 3], [[11744, 11775], 2], [[11776, 11799], 2], [[11800, 11803], 2], [[11804, 11805], 2], [[11806, 11822], 2], [11823, 2], [11824, 2], [11825, 2], [[11826, 11835], 2], [[11836, 11842], 2], [[11843, 11844], 2], [[11845, 11849], 2], [[11850, 11854], 2], [11855, 2], [[11856, 11858], 2], [[11859, 11869], 2], [[11870, 11903], 3], [[11904, 11929], 2], [11930, 3], [[11931, 11934], 2], [11935, 1, "\u6BCD"], [[11936, 12018], 2], [12019, 1, "\u9F9F"], [[12020, 12031], 3], [12032, 1, "\u4E00"], [12033, 1, "\u4E28"], [12034, 1, "\u4E36"], [12035, 1, "\u4E3F"], [12036, 1, "\u4E59"], [12037, 1, "\u4E85"], [12038, 1, "\u4E8C"], [12039, 1, "\u4EA0"], [12040, 1, "\u4EBA"], [12041, 1, "\u513F"], [12042, 1, "\u5165"], [12043, 1, "\u516B"], [12044, 1, "\u5182"], [12045, 1, "\u5196"], [12046, 1, "\u51AB"], [12047, 1, "\u51E0"], [12048, 1, "\u51F5"], [12049, 1, "\u5200"], [12050, 1, "\u529B"], [12051, 1, "\u52F9"], [12052, 1, "\u5315"], [12053, 1, "\u531A"], [12054, 1, "\u5338"], [12055, 1, "\u5341"], [12056, 1, "\u535C"], [12057, 1, "\u5369"], [12058, 1, "\u5382"], [12059, 1, "\u53B6"], [12060, 1, "\u53C8"], [12061, 1, "\u53E3"], [12062, 1, "\u56D7"], [12063, 1, "\u571F"], [12064, 1, "\u58EB"], [12065, 1, "\u5902"], [12066, 1, "\u590A"], [12067, 1, "\u5915"], [12068, 1, "\u5927"], [12069, 1, "\u5973"], [12070, 1, "\u5B50"], [12071, 1, "\u5B80"], [12072, 1, "\u5BF8"], [12073, 1, "\u5C0F"], [12074, 1, "\u5C22"], [12075, 1, "\u5C38"], [12076, 1, "\u5C6E"], [12077, 1, "\u5C71"], [12078, 1, "\u5DDB"], [12079, 1, "\u5DE5"], [12080, 1, "\u5DF1"], [12081, 1, "\u5DFE"], [12082, 1, "\u5E72"], [12083, 1, "\u5E7A"], [12084, 1, "\u5E7F"], [12085, 1, "\u5EF4"], [12086, 1, "\u5EFE"], [12087, 1, "\u5F0B"], [12088, 1, "\u5F13"], [12089, 1, "\u5F50"], [12090, 1, "\u5F61"], [12091, 1, "\u5F73"], [12092, 1, "\u5FC3"], [12093, 1, "\u6208"], [12094, 1, "\u6236"], [12095, 1, "\u624B"], [12096, 1, "\u652F"], [12097, 1, "\u6534"], [12098, 1, "\u6587"], [12099, 1, "\u6597"], [12100, 1, "\u65A4"], [12101, 1, "\u65B9"], [12102, 1, "\u65E0"], [12103, 1, "\u65E5"], [12104, 1, "\u66F0"], [12105, 1, "\u6708"], [12106, 1, "\u6728"], [12107, 1, "\u6B20"], [12108, 1, "\u6B62"], [12109, 1, "\u6B79"], [12110, 1, "\u6BB3"], [12111, 1, "\u6BCB"], [12112, 1, "\u6BD4"], [12113, 1, "\u6BDB"], [12114, 1, "\u6C0F"], [12115, 1, "\u6C14"], [12116, 1, "\u6C34"], [12117, 1, "\u706B"], [12118, 1, "\u722A"], [12119, 1, "\u7236"], [12120, 1, "\u723B"], [12121, 1, "\u723F"], [12122, 1, "\u7247"], [12123, 1, "\u7259"], [12124, 1, "\u725B"], [12125, 1, "\u72AC"], [12126, 1, "\u7384"], [12127, 1, "\u7389"], [12128, 1, "\u74DC"], [12129, 1, "\u74E6"], [12130, 1, "\u7518"], [12131, 1, "\u751F"], [12132, 1, "\u7528"], [12133, 1, "\u7530"], [12134, 1, "\u758B"], [12135, 1, "\u7592"], [12136, 1, "\u7676"], [12137, 1, "\u767D"], [12138, 1, "\u76AE"], [12139, 1, "\u76BF"], [12140, 1, "\u76EE"], [12141, 1, "\u77DB"], [12142, 1, "\u77E2"], [12143, 1, "\u77F3"], [12144, 1, "\u793A"], [12145, 1, "\u79B8"], [12146, 1, "\u79BE"], [12147, 1, "\u7A74"], [12148, 1, "\u7ACB"], [12149, 1, "\u7AF9"], [12150, 1, "\u7C73"], [12151, 1, "\u7CF8"], [12152, 1, "\u7F36"], [12153, 1, "\u7F51"], [12154, 1, "\u7F8A"], [12155, 1, "\u7FBD"], [12156, 1, "\u8001"], [12157, 1, "\u800C"], [12158, 1, "\u8012"], [12159, 1, "\u8033"], [12160, 1, "\u807F"], [12161, 1, "\u8089"], [12162, 1, "\u81E3"], [12163, 1, "\u81EA"], [12164, 1, "\u81F3"], [12165, 1, "\u81FC"], [12166, 1, "\u820C"], [12167, 1, "\u821B"], [12168, 1, "\u821F"], [12169, 1, "\u826E"], [12170, 1, "\u8272"], [12171, 1, "\u8278"], [12172, 1, "\u864D"], [12173, 1, "\u866B"], [12174, 1, "\u8840"], [12175, 1, "\u884C"], [12176, 1, "\u8863"], [12177, 1, "\u897E"], [12178, 1, "\u898B"], [12179, 1, "\u89D2"], [12180, 1, "\u8A00"], [12181, 1, "\u8C37"], [12182, 1, "\u8C46"], [12183, 1, "\u8C55"], [12184, 1, "\u8C78"], [12185, 1, "\u8C9D"], [12186, 1, "\u8D64"], [12187, 1, "\u8D70"], [12188, 1, "\u8DB3"], [12189, 1, "\u8EAB"], [12190, 1, "\u8ECA"], [12191, 1, "\u8F9B"], [12192, 1, "\u8FB0"], [12193, 1, "\u8FB5"], [12194, 1, "\u9091"], [12195, 1, "\u9149"], [12196, 1, "\u91C6"], [12197, 1, "\u91CC"], [12198, 1, "\u91D1"], [12199, 1, "\u9577"], [12200, 1, "\u9580"], [12201, 1, "\u961C"], [12202, 1, "\u96B6"], [12203, 1, "\u96B9"], [12204, 1, "\u96E8"], [12205, 1, "\u9751"], [12206, 1, "\u975E"], [12207, 1, "\u9762"], [12208, 1, "\u9769"], [12209, 1, "\u97CB"], [12210, 1, "\u97ED"], [12211, 1, "\u97F3"], [12212, 1, "\u9801"], [12213, 1, "\u98A8"], [12214, 1, "\u98DB"], [12215, 1, "\u98DF"], [12216, 1, "\u9996"], [12217, 1, "\u9999"], [12218, 1, "\u99AC"], [12219, 1, "\u9AA8"], [12220, 1, "\u9AD8"], [12221, 1, "\u9ADF"], [12222, 1, "\u9B25"], [12223, 1, "\u9B2F"], [12224, 1, "\u9B32"], [12225, 1, "\u9B3C"], [12226, 1, "\u9B5A"], [12227, 1, "\u9CE5"], [12228, 1, "\u9E75"], [12229, 1, "\u9E7F"], [12230, 1, "\u9EA5"], [12231, 1, "\u9EBB"], [12232, 1, "\u9EC3"], [12233, 1, "\u9ECD"], [12234, 1, "\u9ED1"], [12235, 1, "\u9EF9"], [12236, 1, "\u9EFD"], [12237, 1, "\u9F0E"], [12238, 1, "\u9F13"], [12239, 1, "\u9F20"], [12240, 1, "\u9F3B"], [12241, 1, "\u9F4A"], [12242, 1, "\u9F52"], [12243, 1, "\u9F8D"], [12244, 1, "\u9F9C"], [12245, 1, "\u9FA0"], [[12246, 12271], 3], [[12272, 12283], 3], [[12284, 12287], 3], [12288, 5, " "], [12289, 2], [12290, 1, "."], [[12291, 12292], 2], [[12293, 12295], 2], [[12296, 12329], 2], [[12330, 12333], 2], [[12334, 12341], 2], [12342, 1, "\u3012"], [12343, 2], [12344, 1, "\u5341"], [12345, 1, "\u5344"], [12346, 1, "\u5345"], [12347, 2], [12348, 2], [12349, 2], [12350, 2], [12351, 2], [12352, 3], [[12353, 12436], 2], [[12437, 12438], 2], [[12439, 12440], 3], [[12441, 12442], 2], [12443, 5, " \u3099"], [12444, 5, " \u309A"], [[12445, 12446], 2], [12447, 1, "\u3088\u308A"], [12448, 2], [[12449, 12542], 2], [12543, 1, "\u30B3\u30C8"], [[12544, 12548], 3], [[12549, 12588], 2], [12589, 2], [12590, 2], [12591, 2], [12592, 3], [12593, 1, "\u1100"], [12594, 1, "\u1101"], [12595, 1, "\u11AA"], [12596, 1, "\u1102"], [12597, 1, "\u11AC"], [12598, 1, "\u11AD"], [12599, 1, "\u1103"], [12600, 1, "\u1104"], [12601, 1, "\u1105"], [12602, 1, "\u11B0"], [12603, 1, "\u11B1"], [12604, 1, "\u11B2"], [12605, 1, "\u11B3"], [12606, 1, "\u11B4"], [12607, 1, "\u11B5"], [12608, 1, "\u111A"], [12609, 1, "\u1106"], [12610, 1, "\u1107"], [12611, 1, "\u1108"], [12612, 1, "\u1121"], [12613, 1, "\u1109"], [12614, 1, "\u110A"], [12615, 1, "\u110B"], [12616, 1, "\u110C"], [12617, 1, "\u110D"], [12618, 1, "\u110E"], [12619, 1, "\u110F"], [12620, 1, "\u1110"], [12621, 1, "\u1111"], [12622, 1, "\u1112"], [12623, 1, "\u1161"], [12624, 1, "\u1162"], [12625, 1, "\u1163"], [12626, 1, "\u1164"], [12627, 1, "\u1165"], [12628, 1, "\u1166"], [12629, 1, "\u1167"], [12630, 1, "\u1168"], [12631, 1, "\u1169"], [12632, 1, "\u116A"], [12633, 1, "\u116B"], [12634, 1, "\u116C"], [12635, 1, "\u116D"], [12636, 1, "\u116E"], [12637, 1, "\u116F"], [12638, 1, "\u1170"], [12639, 1, "\u1171"], [12640, 1, "\u1172"], [12641, 1, "\u1173"], [12642, 1, "\u1174"], [12643, 1, "\u1175"], [12644, 3], [12645, 1, "\u1114"], [12646, 1, "\u1115"], [12647, 1, "\u11C7"], [12648, 1, "\u11C8"], [12649, 1, "\u11CC"], [12650, 1, "\u11CE"], [12651, 1, "\u11D3"], [12652, 1, "\u11D7"], [12653, 1, "\u11D9"], [12654, 1, "\u111C"], [12655, 1, "\u11DD"], [12656, 1, "\u11DF"], [12657, 1, "\u111D"], [12658, 1, "\u111E"], [12659, 1, "\u1120"], [12660, 1, "\u1122"], [12661, 1, "\u1123"], [12662, 1, "\u1127"], [12663, 1, "\u1129"], [12664, 1, "\u112B"], [12665, 1, "\u112C"], [12666, 1, "\u112D"], [12667, 1, "\u112E"], [12668, 1, "\u112F"], [12669, 1, "\u1132"], [12670, 1, "\u1136"], [12671, 1, "\u1140"], [12672, 1, "\u1147"], [12673, 1, "\u114C"], [12674, 1, "\u11F1"], [12675, 1, "\u11F2"], [12676, 1, "\u1157"], [12677, 1, "\u1158"], [12678, 1, "\u1159"], [12679, 1, "\u1184"], [12680, 1, "\u1185"], [12681, 1, "\u1188"], [12682, 1, "\u1191"], [12683, 1, "\u1192"], [12684, 1, "\u1194"], [12685, 1, "\u119E"], [12686, 1, "\u11A1"], [12687, 3], [[12688, 12689], 2], [12690, 1, "\u4E00"], [12691, 1, "\u4E8C"], [12692, 1, "\u4E09"], [12693, 1, "\u56DB"], [12694, 1, "\u4E0A"], [12695, 1, "\u4E2D"], [12696, 1, "\u4E0B"], [12697, 1, "\u7532"], [12698, 1, "\u4E59"], [12699, 1, "\u4E19"], [12700, 1, "\u4E01"], [12701, 1, "\u5929"], [12702, 1, "\u5730"], [12703, 1, "\u4EBA"], [[12704, 12727], 2], [[12728, 12730], 2], [[12731, 12735], 2], [[12736, 12751], 2], [[12752, 12771], 2], [[12772, 12782], 3], [12783, 3], [[12784, 12799], 2], [12800, 5, "(\u1100)"], [12801, 5, "(\u1102)"], [12802, 5, "(\u1103)"], [12803, 5, "(\u1105)"], [12804, 5, "(\u1106)"], [12805, 5, "(\u1107)"], [12806, 5, "(\u1109)"], [12807, 5, "(\u110B)"], [12808, 5, "(\u110C)"], [12809, 5, "(\u110E)"], [12810, 5, "(\u110F)"], [12811, 5, "(\u1110)"], [12812, 5, "(\u1111)"], [12813, 5, "(\u1112)"], [12814, 5, "(\uAC00)"], [12815, 5, "(\uB098)"], [12816, 5, "(\uB2E4)"], [12817, 5, "(\uB77C)"], [12818, 5, "(\uB9C8)"], [12819, 5, "(\uBC14)"], [12820, 5, "(\uC0AC)"], [12821, 5, "(\uC544)"], [12822, 5, "(\uC790)"], [12823, 5, "(\uCC28)"], [12824, 5, "(\uCE74)"], [12825, 5, "(\uD0C0)"], [12826, 5, "(\uD30C)"], [12827, 5, "(\uD558)"], [12828, 5, "(\uC8FC)"], [12829, 5, "(\uC624\uC804)"], [12830, 5, "(\uC624\uD6C4)"], [12831, 3], [12832, 5, "(\u4E00)"], [12833, 5, "(\u4E8C)"], [12834, 5, "(\u4E09)"], [12835, 5, "(\u56DB)"], [12836, 5, "(\u4E94)"], [12837, 5, "(\u516D)"], [12838, 5, "(\u4E03)"], [12839, 5, "(\u516B)"], [12840, 5, "(\u4E5D)"], [12841, 5, "(\u5341)"], [12842, 5, "(\u6708)"], [12843, 5, "(\u706B)"], [12844, 5, "(\u6C34)"], [12845, 5, "(\u6728)"], [12846, 5, "(\u91D1)"], [12847, 5, "(\u571F)"], [12848, 5, "(\u65E5)"], [12849, 5, "(\u682A)"], [12850, 5, "(\u6709)"], [12851, 5, "(\u793E)"], [12852, 5, "(\u540D)"], [12853, 5, "(\u7279)"], [12854, 5, "(\u8CA1)"], [12855, 5, "(\u795D)"], [12856, 5, "(\u52B4)"], [12857, 5, "(\u4EE3)"], [12858, 5, "(\u547C)"], [12859, 5, "(\u5B66)"], [12860, 5, "(\u76E3)"], [12861, 5, "(\u4F01)"], [12862, 5, "(\u8CC7)"], [12863, 5, "(\u5354)"], [12864, 5, "(\u796D)"], [12865, 5, "(\u4F11)"], [12866, 5, "(\u81EA)"], [12867, 5, "(\u81F3)"], [12868, 1, "\u554F"], [12869, 1, "\u5E7C"], [12870, 1, "\u6587"], [12871, 1, "\u7B8F"], [[12872, 12879], 2], [12880, 1, "pte"], [12881, 1, "21"], [12882, 1, "22"], [12883, 1, "23"], [12884, 1, "24"], [12885, 1, "25"], [12886, 1, "26"], [12887, 1, "27"], [12888, 1, "28"], [12889, 1, "29"], [12890, 1, "30"], [12891, 1, "31"], [12892, 1, "32"], [12893, 1, "33"], [12894, 1, "34"], [12895, 1, "35"], [12896, 1, "\u1100"], [12897, 1, "\u1102"], [12898, 1, "\u1103"], [12899, 1, "\u1105"], [12900, 1, "\u1106"], [12901, 1, "\u1107"], [12902, 1, "\u1109"], [12903, 1, "\u110B"], [12904, 1, "\u110C"], [12905, 1, "\u110E"], [12906, 1, "\u110F"], [12907, 1, "\u1110"], [12908, 1, "\u1111"], [12909, 1, "\u1112"], [12910, 1, "\uAC00"], [12911, 1, "\uB098"], [12912, 1, "\uB2E4"], [12913, 1, "\uB77C"], [12914, 1, "\uB9C8"], [12915, 1, "\uBC14"], [12916, 1, "\uC0AC"], [12917, 1, "\uC544"], [12918, 1, "\uC790"], [12919, 1, "\uCC28"], [12920, 1, "\uCE74"], [12921, 1, "\uD0C0"], [12922, 1, "\uD30C"], [12923, 1, "\uD558"], [12924, 1, "\uCC38\uACE0"], [12925, 1, "\uC8FC\uC758"], [12926, 1, "\uC6B0"], [12927, 2], [12928, 1, "\u4E00"], [12929, 1, "\u4E8C"], [12930, 1, "\u4E09"], [12931, 1, "\u56DB"], [12932, 1, "\u4E94"], [12933, 1, "\u516D"], [12934, 1, "\u4E03"], [12935, 1, "\u516B"], [12936, 1, "\u4E5D"], [12937, 1, "\u5341"], [12938, 1, "\u6708"], [12939, 1, "\u706B"], [12940, 1, "\u6C34"], [12941, 1, "\u6728"], [12942, 1, "\u91D1"], [12943, 1, "\u571F"], [12944, 1, "\u65E5"], [12945, 1, "\u682A"], [12946, 1, "\u6709"], [12947, 1, "\u793E"], [12948, 1, "\u540D"], [12949, 1, "\u7279"], [12950, 1, "\u8CA1"], [12951, 1, "\u795D"], [12952, 1, "\u52B4"], [12953, 1, "\u79D8"], [12954, 1, "\u7537"], [12955, 1, "\u5973"], [12956, 1, "\u9069"], [12957, 1, "\u512A"], [12958, 1, "\u5370"], [12959, 1, "\u6CE8"], [12960, 1, "\u9805"], [12961, 1, "\u4F11"], [12962, 1, "\u5199"], [12963, 1, "\u6B63"], [12964, 1, "\u4E0A"], [12965, 1, "\u4E2D"], [12966, 1, "\u4E0B"], [12967, 1, "\u5DE6"], [12968, 1, "\u53F3"], [12969, 1, "\u533B"], [12970, 1, "\u5B97"], [12971, 1, "\u5B66"], [12972, 1, "\u76E3"], [12973, 1, "\u4F01"], [12974, 1, "\u8CC7"], [12975, 1, "\u5354"], [12976, 1, "\u591C"], [12977, 1, "36"], [12978, 1, "37"], [12979, 1, "38"], [12980, 1, "39"], [12981, 1, "40"], [12982, 1, "41"], [12983, 1, "42"], [12984, 1, "43"], [12985, 1, "44"], [12986, 1, "45"], [12987, 1, "46"], [12988, 1, "47"], [12989, 1, "48"], [12990, 1, "49"], [12991, 1, "50"], [12992, 1, "1\u6708"], [12993, 1, "2\u6708"], [12994, 1, "3\u6708"], [12995, 1, "4\u6708"], [12996, 1, "5\u6708"], [12997, 1, "6\u6708"], [12998, 1, "7\u6708"], [12999, 1, "8\u6708"], [13e3, 1, "9\u6708"], [13001, 1, "10\u6708"], [13002, 1, "11\u6708"], [13003, 1, "12\u6708"], [13004, 1, "hg"], [13005, 1, "erg"], [13006, 1, "ev"], [13007, 1, "ltd"], [13008, 1, "\u30A2"], [13009, 1, "\u30A4"], [13010, 1, "\u30A6"], [13011, 1, "\u30A8"], [13012, 1, "\u30AA"], [13013, 1, "\u30AB"], [13014, 1, "\u30AD"], [13015, 1, "\u30AF"], [13016, 1, "\u30B1"], [13017, 1, "\u30B3"], [13018, 1, "\u30B5"], [13019, 1, "\u30B7"], [13020, 1, "\u30B9"], [13021, 1, "\u30BB"], [13022, 1, "\u30BD"], [13023, 1, "\u30BF"], [13024, 1, "\u30C1"], [13025, 1, "\u30C4"], [13026, 1, "\u30C6"], [13027, 1, "\u30C8"], [13028, 1, "\u30CA"], [13029, 1, "\u30CB"], [13030, 1, "\u30CC"], [13031, 1, "\u30CD"], [13032, 1, "\u30CE"], [13033, 1, "\u30CF"], [13034, 1, "\u30D2"], [13035, 1, "\u30D5"], [13036, 1, "\u30D8"], [13037, 1, "\u30DB"], [13038, 1, "\u30DE"], [13039, 1, "\u30DF"], [13040, 1, "\u30E0"], [13041, 1, "\u30E1"], [13042, 1, "\u30E2"], [13043, 1, "\u30E4"], [13044, 1, "\u30E6"], [13045, 1, "\u30E8"], [13046, 1, "\u30E9"], [13047, 1, "\u30EA"], [13048, 1, "\u30EB"], [13049, 1, "\u30EC"], [13050, 1, "\u30ED"], [13051, 1, "\u30EF"], [13052, 1, "\u30F0"], [13053, 1, "\u30F1"], [13054, 1, "\u30F2"], [13055, 1, "\u4EE4\u548C"], [13056, 1, "\u30A2\u30D1\u30FC\u30C8"], [13057, 1, "\u30A2\u30EB\u30D5\u30A1"], [13058, 1, "\u30A2\u30F3\u30DA\u30A2"], [13059, 1, "\u30A2\u30FC\u30EB"], [13060, 1, "\u30A4\u30CB\u30F3\u30B0"], [13061, 1, "\u30A4\u30F3\u30C1"], [13062, 1, "\u30A6\u30A9\u30F3"], [13063, 1, "\u30A8\u30B9\u30AF\u30FC\u30C9"], [13064, 1, "\u30A8\u30FC\u30AB\u30FC"], [13065, 1, "\u30AA\u30F3\u30B9"], [13066, 1, "\u30AA\u30FC\u30E0"], [13067, 1, "\u30AB\u30A4\u30EA"], [13068, 1, "\u30AB\u30E9\u30C3\u30C8"], [13069, 1, "\u30AB\u30ED\u30EA\u30FC"], [13070, 1, "\u30AC\u30ED\u30F3"], [13071, 1, "\u30AC\u30F3\u30DE"], [13072, 1, "\u30AE\u30AC"], [13073, 1, "\u30AE\u30CB\u30FC"], [13074, 1, "\u30AD\u30E5\u30EA\u30FC"], [13075, 1, "\u30AE\u30EB\u30C0\u30FC"], [13076, 1, "\u30AD\u30ED"], [13077, 1, "\u30AD\u30ED\u30B0\u30E9\u30E0"], [13078, 1, "\u30AD\u30ED\u30E1\u30FC\u30C8\u30EB"], [13079, 1, "\u30AD\u30ED\u30EF\u30C3\u30C8"], [13080, 1, "\u30B0\u30E9\u30E0"], [13081, 1, "\u30B0\u30E9\u30E0\u30C8\u30F3"], [13082, 1, "\u30AF\u30EB\u30BC\u30A4\u30ED"], [13083, 1, "\u30AF\u30ED\u30FC\u30CD"], [13084, 1, "\u30B1\u30FC\u30B9"], [13085, 1, "\u30B3\u30EB\u30CA"], [13086, 1, "\u30B3\u30FC\u30DD"], [13087, 1, "\u30B5\u30A4\u30AF\u30EB"], [13088, 1, "\u30B5\u30F3\u30C1\u30FC\u30E0"], [13089, 1, "\u30B7\u30EA\u30F3\u30B0"], [13090, 1, "\u30BB\u30F3\u30C1"], [13091, 1, "\u30BB\u30F3\u30C8"], [13092, 1, "\u30C0\u30FC\u30B9"], [13093, 1, "\u30C7\u30B7"], [13094, 1, "\u30C9\u30EB"], [13095, 1, "\u30C8\u30F3"], [13096, 1, "\u30CA\u30CE"], [13097, 1, "\u30CE\u30C3\u30C8"], [13098, 1, "\u30CF\u30A4\u30C4"], [13099, 1, "\u30D1\u30FC\u30BB\u30F3\u30C8"], [13100, 1, "\u30D1\u30FC\u30C4"], [13101, 1, "\u30D0\u30FC\u30EC\u30EB"], [13102, 1, "\u30D4\u30A2\u30B9\u30C8\u30EB"], [13103, 1, "\u30D4\u30AF\u30EB"], [13104, 1, "\u30D4\u30B3"], [13105, 1, "\u30D3\u30EB"], [13106, 1, "\u30D5\u30A1\u30E9\u30C3\u30C9"], [13107, 1, "\u30D5\u30A3\u30FC\u30C8"], [13108, 1, "\u30D6\u30C3\u30B7\u30A7\u30EB"], [13109, 1, "\u30D5\u30E9\u30F3"], [13110, 1, "\u30D8\u30AF\u30BF\u30FC\u30EB"], [13111, 1, "\u30DA\u30BD"], [13112, 1, "\u30DA\u30CB\u30D2"], [13113, 1, "\u30D8\u30EB\u30C4"], [13114, 1, "\u30DA\u30F3\u30B9"], [13115, 1, "\u30DA\u30FC\u30B8"], [13116, 1, "\u30D9\u30FC\u30BF"], [13117, 1, "\u30DD\u30A4\u30F3\u30C8"], [13118, 1, "\u30DC\u30EB\u30C8"], [13119, 1, "\u30DB\u30F3"], [13120, 1, "\u30DD\u30F3\u30C9"], [13121, 1, "\u30DB\u30FC\u30EB"], [13122, 1, "\u30DB\u30FC\u30F3"], [13123, 1, "\u30DE\u30A4\u30AF\u30ED"], [13124, 1, "\u30DE\u30A4\u30EB"], [13125, 1, "\u30DE\u30C3\u30CF"], [13126, 1, "\u30DE\u30EB\u30AF"], [13127, 1, "\u30DE\u30F3\u30B7\u30E7\u30F3"], [13128, 1, "\u30DF\u30AF\u30ED\u30F3"], [13129, 1, "\u30DF\u30EA"], [13130, 1, "\u30DF\u30EA\u30D0\u30FC\u30EB"], [13131, 1, "\u30E1\u30AC"], [13132, 1, "\u30E1\u30AC\u30C8\u30F3"], [13133, 1, "\u30E1\u30FC\u30C8\u30EB"], [13134, 1, "\u30E4\u30FC\u30C9"], [13135, 1, "\u30E4\u30FC\u30EB"], [13136, 1, "\u30E6\u30A2\u30F3"], [13137, 1, "\u30EA\u30C3\u30C8\u30EB"], [13138, 1, "\u30EA\u30E9"], [13139, 1, "\u30EB\u30D4\u30FC"], [13140, 1, "\u30EB\u30FC\u30D6\u30EB"], [13141, 1, "\u30EC\u30E0"], [13142, 1, "\u30EC\u30F3\u30C8\u30B2\u30F3"], [13143, 1, "\u30EF\u30C3\u30C8"], [13144, 1, "0\u70B9"], [13145, 1, "1\u70B9"], [13146, 1, "2\u70B9"], [13147, 1, "3\u70B9"], [13148, 1, "4\u70B9"], [13149, 1, "5\u70B9"], [13150, 1, "6\u70B9"], [13151, 1, "7\u70B9"], [13152, 1, "8\u70B9"], [13153, 1, "9\u70B9"], [13154, 1, "10\u70B9"], [13155, 1, "11\u70B9"], [13156, 1, "12\u70B9"], [13157, 1, "13\u70B9"], [13158, 1, "14\u70B9"], [13159, 1, "15\u70B9"], [13160, 1, "16\u70B9"], [13161, 1, "17\u70B9"], [13162, 1, "18\u70B9"], [13163, 1, "19\u70B9"], [13164, 1, "20\u70B9"], [13165, 1, "21\u70B9"], [13166, 1, "22\u70B9"], [13167, 1, "23\u70B9"], [13168, 1, "24\u70B9"], [13169, 1, "hpa"], [13170, 1, "da"], [13171, 1, "au"], [13172, 1, "bar"], [13173, 1, "ov"], [13174, 1, "pc"], [13175, 1, "dm"], [13176, 1, "dm2"], [13177, 1, "dm3"], [13178, 1, "iu"], [13179, 1, "\u5E73\u6210"], [13180, 1, "\u662D\u548C"], [13181, 1, "\u5927\u6B63"], [13182, 1, "\u660E\u6CBB"], [13183, 1, "\u682A\u5F0F\u4F1A\u793E"], [13184, 1, "pa"], [13185, 1, "na"], [13186, 1, "\u03BCa"], [13187, 1, "ma"], [13188, 1, "ka"], [13189, 1, "kb"], [13190, 1, "mb"], [13191, 1, "gb"], [13192, 1, "cal"], [13193, 1, "kcal"], [13194, 1, "pf"], [13195, 1, "nf"], [13196, 1, "\u03BCf"], [13197, 1, "\u03BCg"], [13198, 1, "mg"], [13199, 1, "kg"], [13200, 1, "hz"], [13201, 1, "khz"], [13202, 1, "mhz"], [13203, 1, "ghz"], [13204, 1, "thz"], [13205, 1, "\u03BCl"], [13206, 1, "ml"], [13207, 1, "dl"], [13208, 1, "kl"], [13209, 1, "fm"], [13210, 1, "nm"], [13211, 1, "\u03BCm"], [13212, 1, "mm"], [13213, 1, "cm"], [13214, 1, "km"], [13215, 1, "mm2"], [13216, 1, "cm2"], [13217, 1, "m2"], [13218, 1, "km2"], [13219, 1, "mm3"], [13220, 1, "cm3"], [13221, 1, "m3"], [13222, 1, "km3"], [13223, 1, "m\u2215s"], [13224, 1, "m\u2215s2"], [13225, 1, "pa"], [13226, 1, "kpa"], [13227, 1, "mpa"], [13228, 1, "gpa"], [13229, 1, "rad"], [13230, 1, "rad\u2215s"], [13231, 1, "rad\u2215s2"], [13232, 1, "ps"], [13233, 1, "ns"], [13234, 1, "\u03BCs"], [13235, 1, "ms"], [13236, 1, "pv"], [13237, 1, "nv"], [13238, 1, "\u03BCv"], [13239, 1, "mv"], [13240, 1, "kv"], [13241, 1, "mv"], [13242, 1, "pw"], [13243, 1, "nw"], [13244, 1, "\u03BCw"], [13245, 1, "mw"], [13246, 1, "kw"], [13247, 1, "mw"], [13248, 1, "k\u03C9"], [13249, 1, "m\u03C9"], [13250, 3], [13251, 1, "bq"], [13252, 1, "cc"], [13253, 1, "cd"], [13254, 1, "c\u2215kg"], [13255, 3], [13256, 1, "db"], [13257, 1, "gy"], [13258, 1, "ha"], [13259, 1, "hp"], [13260, 1, "in"], [13261, 1, "kk"], [13262, 1, "km"], [13263, 1, "kt"], [13264, 1, "lm"], [13265, 1, "ln"], [13266, 1, "log"], [13267, 1, "lx"], [13268, 1, "mb"], [13269, 1, "mil"], [13270, 1, "mol"], [13271, 1, "ph"], [13272, 3], [13273, 1, "ppm"], [13274, 1, "pr"], [13275, 1, "sr"], [13276, 1, "sv"], [13277, 1, "wb"], [13278, 1, "v\u2215m"], [13279, 1, "a\u2215m"], [13280, 1, "1\u65E5"], [13281, 1, "2\u65E5"], [13282, 1, "3\u65E5"], [13283, 1, "4\u65E5"], [13284, 1, "5\u65E5"], [13285, 1, "6\u65E5"], [13286, 1, "7\u65E5"], [13287, 1, "8\u65E5"], [13288, 1, "9\u65E5"], [13289, 1, "10\u65E5"], [13290, 1, "11\u65E5"], [13291, 1, "12\u65E5"], [13292, 1, "13\u65E5"], [13293, 1, "14\u65E5"], [13294, 1, "15\u65E5"], [13295, 1, "16\u65E5"], [13296, 1, "17\u65E5"], [13297, 1, "18\u65E5"], [13298, 1, "19\u65E5"], [13299, 1, "20\u65E5"], [13300, 1, "21\u65E5"], [13301, 1, "22\u65E5"], [13302, 1, "23\u65E5"], [13303, 1, "24\u65E5"], [13304, 1, "25\u65E5"], [13305, 1, "26\u65E5"], [13306, 1, "27\u65E5"], [13307, 1, "28\u65E5"], [13308, 1, "29\u65E5"], [13309, 1, "30\u65E5"], [13310, 1, "31\u65E5"], [13311, 1, "gal"], [[13312, 19893], 2], [[19894, 19903], 2], [[19904, 19967], 2], [[19968, 40869], 2], [[40870, 40891], 2], [[40892, 40899], 2], [[40900, 40907], 2], [40908, 2], [[40909, 40917], 2], [[40918, 40938], 2], [[40939, 40943], 2], [[40944, 40956], 2], [[40957, 40959], 2], [[40960, 42124], 2], [[42125, 42127], 3], [[42128, 42145], 2], [[42146, 42147], 2], [[42148, 42163], 2], [42164, 2], [[42165, 42176], 2], [42177, 2], [[42178, 42180], 2], [42181, 2], [42182, 2], [[42183, 42191], 3], [[42192, 42237], 2], [[42238, 42239], 2], [[42240, 42508], 2], [[42509, 42511], 2], [[42512, 42539], 2], [[42540, 42559], 3], [42560, 1, "\uA641"], [42561, 2], [42562, 1, "\uA643"], [42563, 2], [42564, 1, "\uA645"], [42565, 2], [42566, 1, "\uA647"], [42567, 2], [42568, 1, "\uA649"], [42569, 2], [42570, 1, "\uA64B"], [42571, 2], [42572, 1, "\uA64D"], [42573, 2], [42574, 1, "\uA64F"], [42575, 2], [42576, 1, "\uA651"], [42577, 2], [42578, 1, "\uA653"], [42579, 2], [42580, 1, "\uA655"], [42581, 2], [42582, 1, "\uA657"], [42583, 2], [42584, 1, "\uA659"], [42585, 2], [42586, 1, "\uA65B"], [42587, 2], [42588, 1, "\uA65D"], [42589, 2], [42590, 1, "\uA65F"], [42591, 2], [42592, 1, "\uA661"], [42593, 2], [42594, 1, "\uA663"], [42595, 2], [42596, 1, "\uA665"], [42597, 2], [42598, 1, "\uA667"], [42599, 2], [42600, 1, "\uA669"], [42601, 2], [42602, 1, "\uA66B"], [42603, 2], [42604, 1, "\uA66D"], [[42605, 42607], 2], [[42608, 42611], 2], [[42612, 42619], 2], [[42620, 42621], 2], [42622, 2], [42623, 2], [42624, 1, "\uA681"], [42625, 2], [42626, 1, "\uA683"], [42627, 2], [42628, 1, "\uA685"], [42629, 2], [42630, 1, "\uA687"], [42631, 2], [42632, 1, "\uA689"], [42633, 2], [42634, 1, "\uA68B"], [42635, 2], [42636, 1, "\uA68D"], [42637, 2], [42638, 1, "\uA68F"], [42639, 2], [42640, 1, "\uA691"], [42641, 2], [42642, 1, "\uA693"], [42643, 2], [42644, 1, "\uA695"], [42645, 2], [42646, 1, "\uA697"], [42647, 2], [42648, 1, "\uA699"], [42649, 2], [42650, 1, "\uA69B"], [42651, 2], [42652, 1, "\u044A"], [42653, 1, "\u044C"], [42654, 2], [42655, 2], [[42656, 42725], 2], [[42726, 42735], 2], [[42736, 42737], 2], [[42738, 42743], 2], [[42744, 42751], 3], [[42752, 42774], 2], [[42775, 42778], 2], [[42779, 42783], 2], [[42784, 42785], 2], [42786, 1, "\uA723"], [42787, 2], [42788, 1, "\uA725"], [42789, 2], [42790, 1, "\uA727"], [42791, 2], [42792, 1, "\uA729"], [42793, 2], [42794, 1, "\uA72B"], [42795, 2], [42796, 1, "\uA72D"], [42797, 2], [42798, 1, "\uA72F"], [[42799, 42801], 2], [42802, 1, "\uA733"], [42803, 2], [42804, 1, "\uA735"], [42805, 2], [42806, 1, "\uA737"], [42807, 2], [42808, 1, "\uA739"], [42809, 2], [42810, 1, "\uA73B"], [42811, 2], [42812, 1, "\uA73D"], [42813, 2], [42814, 1, "\uA73F"], [42815, 2], [42816, 1, "\uA741"], [42817, 2], [42818, 1, "\uA743"], [42819, 2], [42820, 1, "\uA745"], [42821, 2], [42822, 1, "\uA747"], [42823, 2], [42824, 1, "\uA749"], [42825, 2], [42826, 1, "\uA74B"], [42827, 2], [42828, 1, "\uA74D"], [42829, 2], [42830, 1, "\uA74F"], [42831, 2], [42832, 1, "\uA751"], [42833, 2], [42834, 1, "\uA753"], [42835, 2], [42836, 1, "\uA755"], [42837, 2], [42838, 1, "\uA757"], [42839, 2], [42840, 1, "\uA759"], [42841, 2], [42842, 1, "\uA75B"], [42843, 2], [42844, 1, "\uA75D"], [42845, 2], [42846, 1, "\uA75F"], [42847, 2], [42848, 1, "\uA761"], [42849, 2], [42850, 1, "\uA763"], [42851, 2], [42852, 1, "\uA765"], [42853, 2], [42854, 1, "\uA767"], [42855, 2], [42856, 1, "\uA769"], [42857, 2], [42858, 1, "\uA76B"], [42859, 2], [42860, 1, "\uA76D"], [42861, 2], [42862, 1, "\uA76F"], [42863, 2], [42864, 1, "\uA76F"], [[42865, 42872], 2], [42873, 1, "\uA77A"], [42874, 2], [42875, 1, "\uA77C"], [42876, 2], [42877, 1, "\u1D79"], [42878, 1, "\uA77F"], [42879, 2], [42880, 1, "\uA781"], [42881, 2], [42882, 1, "\uA783"], [42883, 2], [42884, 1, "\uA785"], [42885, 2], [42886, 1, "\uA787"], [[42887, 42888], 2], [[42889, 42890], 2], [42891, 1, "\uA78C"], [42892, 2], [42893, 1, "\u0265"], [42894, 2], [42895, 2], [42896, 1, "\uA791"], [42897, 2], [42898, 1, "\uA793"], [42899, 2], [[42900, 42901], 2], [42902, 1, "\uA797"], [42903, 2], [42904, 1, "\uA799"], [42905, 2], [42906, 1, "\uA79B"], [42907, 2], [42908, 1, "\uA79D"], [42909, 2], [42910, 1, "\uA79F"], [42911, 2], [42912, 1, "\uA7A1"], [42913, 2], [42914, 1, "\uA7A3"], [42915, 2], [42916, 1, "\uA7A5"], [42917, 2], [42918, 1, "\uA7A7"], [42919, 2], [42920, 1, "\uA7A9"], [42921, 2], [42922, 1, "\u0266"], [42923, 1, "\u025C"], [42924, 1, "\u0261"], [42925, 1, "\u026C"], [42926, 1, "\u026A"], [42927, 2], [42928, 1, "\u029E"], [42929, 1, "\u0287"], [42930, 1, "\u029D"], [42931, 1, "\uAB53"], [42932, 1, "\uA7B5"], [42933, 2], [42934, 1, "\uA7B7"], [42935, 2], [42936, 1, "\uA7B9"], [42937, 2], [42938, 1, "\uA7BB"], [42939, 2], [42940, 1, "\uA7BD"], [42941, 2], [42942, 1, "\uA7BF"], [42943, 2], [42944, 1, "\uA7C1"], [42945, 2], [42946, 1, "\uA7C3"], [42947, 2], [42948, 1, "\uA794"], [42949, 1, "\u0282"], [42950, 1, "\u1D8E"], [42951, 1, "\uA7C8"], [42952, 2], [42953, 1, "\uA7CA"], [42954, 2], [[42955, 42959], 3], [42960, 1, "\uA7D1"], [42961, 2], [42962, 3], [42963, 2], [42964, 3], [42965, 2], [42966, 1, "\uA7D7"], [42967, 2], [42968, 1, "\uA7D9"], [42969, 2], [[42970, 42993], 3], [42994, 1, "c"], [42995, 1, "f"], [42996, 1, "q"], [42997, 1, "\uA7F6"], [42998, 2], [42999, 2], [43e3, 1, "\u0127"], [43001, 1, "\u0153"], [43002, 2], [[43003, 43007], 2], [[43008, 43047], 2], [[43048, 43051], 2], [43052, 2], [[43053, 43055], 3], [[43056, 43065], 2], [[43066, 43071], 3], [[43072, 43123], 2], [[43124, 43127], 2], [[43128, 43135], 3], [[43136, 43204], 2], [43205, 2], [[43206, 43213], 3], [[43214, 43215], 2], [[43216, 43225], 2], [[43226, 43231], 3], [[43232, 43255], 2], [[43256, 43258], 2], [43259, 2], [43260, 2], [43261, 2], [[43262, 43263], 2], [[43264, 43309], 2], [[43310, 43311], 2], [[43312, 43347], 2], [[43348, 43358], 3], [43359, 2], [[43360, 43388], 2], [[43389, 43391], 3], [[43392, 43456], 2], [[43457, 43469], 2], [43470, 3], [[43471, 43481], 2], [[43482, 43485], 3], [[43486, 43487], 2], [[43488, 43518], 2], [43519, 3], [[43520, 43574], 2], [[43575, 43583], 3], [[43584, 43597], 2], [[43598, 43599], 3], [[43600, 43609], 2], [[43610, 43611], 3], [[43612, 43615], 2], [[43616, 43638], 2], [[43639, 43641], 2], [[43642, 43643], 2], [[43644, 43647], 2], [[43648, 43714], 2], [[43715, 43738], 3], [[43739, 43741], 2], [[43742, 43743], 2], [[43744, 43759], 2], [[43760, 43761], 2], [[43762, 43766], 2], [[43767, 43776], 3], [[43777, 43782], 2], [[43783, 43784], 3], [[43785, 43790], 2], [[43791, 43792], 3], [[43793, 43798], 2], [[43799, 43807], 3], [[43808, 43814], 2], [43815, 3], [[43816, 43822], 2], [43823, 3], [[43824, 43866], 2], [43867, 2], [43868, 1, "\uA727"], [43869, 1, "\uAB37"], [43870, 1, "\u026B"], [43871, 1, "\uAB52"], [[43872, 43875], 2], [[43876, 43877], 2], [[43878, 43879], 2], [43880, 2], [43881, 1, "\u028D"], [[43882, 43883], 2], [[43884, 43887], 3], [43888, 1, "\u13A0"], [43889, 1, "\u13A1"], [43890, 1, "\u13A2"], [43891, 1, "\u13A3"], [43892, 1, "\u13A4"], [43893, 1, "\u13A5"], [43894, 1, "\u13A6"], [43895, 1, "\u13A7"], [43896, 1, "\u13A8"], [43897, 1, "\u13A9"], [43898, 1, "\u13AA"], [43899, 1, "\u13AB"], [43900, 1, "\u13AC"], [43901, 1, "\u13AD"], [43902, 1, "\u13AE"], [43903, 1, "\u13AF"], [43904, 1, "\u13B0"], [43905, 1, "\u13B1"], [43906, 1, "\u13B2"], [43907, 1, "\u13B3"], [43908, 1, "\u13B4"], [43909, 1, "\u13B5"], [43910, 1, "\u13B6"], [43911, 1, "\u13B7"], [43912, 1, "\u13B8"], [43913, 1, "\u13B9"], [43914, 1, "\u13BA"], [43915, 1, "\u13BB"], [43916, 1, "\u13BC"], [43917, 1, "\u13BD"], [43918, 1, "\u13BE"], [43919, 1, "\u13BF"], [43920, 1, "\u13C0"], [43921, 1, "\u13C1"], [43922, 1, "\u13C2"], [43923, 1, "\u13C3"], [43924, 1, "\u13C4"], [43925, 1, "\u13C5"], [43926, 1, "\u13C6"], [43927, 1, "\u13C7"], [43928, 1, "\u13C8"], [43929, 1, "\u13C9"], [43930, 1, "\u13CA"], [43931, 1, "\u13CB"], [43932, 1, "\u13CC"], [43933, 1, "\u13CD"], [43934, 1, "\u13CE"], [43935, 1, "\u13CF"], [43936, 1, "\u13D0"], [43937, 1, "\u13D1"], [43938, 1, "\u13D2"], [43939, 1, "\u13D3"], [43940, 1, "\u13D4"], [43941, 1, "\u13D5"], [43942, 1, "\u13D6"], [43943, 1, "\u13D7"], [43944, 1, "\u13D8"], [43945, 1, "\u13D9"], [43946, 1, "\u13DA"], [43947, 1, "\u13DB"], [43948, 1, "\u13DC"], [43949, 1, "\u13DD"], [43950, 1, "\u13DE"], [43951, 1, "\u13DF"], [43952, 1, "\u13E0"], [43953, 1, "\u13E1"], [43954, 1, "\u13E2"], [43955, 1, "\u13E3"], [43956, 1, "\u13E4"], [43957, 1, "\u13E5"], [43958, 1, "\u13E6"], [43959, 1, "\u13E7"], [43960, 1, "\u13E8"], [43961, 1, "\u13E9"], [43962, 1, "\u13EA"], [43963, 1, "\u13EB"], [43964, 1, "\u13EC"], [43965, 1, "\u13ED"], [43966, 1, "\u13EE"], [43967, 1, "\u13EF"], [[43968, 44010], 2], [44011, 2], [[44012, 44013], 2], [[44014, 44015], 3], [[44016, 44025], 2], [[44026, 44031], 3], [[44032, 55203], 2], [[55204, 55215], 3], [[55216, 55238], 2], [[55239, 55242], 3], [[55243, 55291], 2], [[55292, 55295], 3], [[55296, 57343], 3], [[57344, 63743], 3], [63744, 1, "\u8C48"], [63745, 1, "\u66F4"], [63746, 1, "\u8ECA"], [63747, 1, "\u8CC8"], [63748, 1, "\u6ED1"], [63749, 1, "\u4E32"], [63750, 1, "\u53E5"], [[63751, 63752], 1, "\u9F9C"], [63753, 1, "\u5951"], [63754, 1, "\u91D1"], [63755, 1, "\u5587"], [63756, 1, "\u5948"], [63757, 1, "\u61F6"], [63758, 1, "\u7669"], [63759, 1, "\u7F85"], [63760, 1, "\u863F"], [63761, 1, "\u87BA"], [63762, 1, "\u88F8"], [63763, 1, "\u908F"], [63764, 1, "\u6A02"], [63765, 1, "\u6D1B"], [63766, 1, "\u70D9"], [63767, 1, "\u73DE"], [63768, 1, "\u843D"], [63769, 1, "\u916A"], [63770, 1, "\u99F1"], [63771, 1, "\u4E82"], [63772, 1, "\u5375"], [63773, 1, "\u6B04"], [63774, 1, "\u721B"], [63775, 1, "\u862D"], [63776, 1, "\u9E1E"], [63777, 1, "\u5D50"], [63778, 1, "\u6FEB"], [63779, 1, "\u85CD"], [63780, 1, "\u8964"], [63781, 1, "\u62C9"], [63782, 1, "\u81D8"], [63783, 1, "\u881F"], [63784, 1, "\u5ECA"], [63785, 1, "\u6717"], [63786, 1, "\u6D6A"], [63787, 1, "\u72FC"], [63788, 1, "\u90CE"], [63789, 1, "\u4F86"], [63790, 1, "\u51B7"], [63791, 1, "\u52DE"], [63792, 1, "\u64C4"], [63793, 1, "\u6AD3"], [63794, 1, "\u7210"], [63795, 1, "\u76E7"], [63796, 1, "\u8001"], [63797, 1, "\u8606"], [63798, 1, "\u865C"], [63799, 1, "\u8DEF"], [63800, 1, "\u9732"], [63801, 1, "\u9B6F"], [63802, 1, "\u9DFA"], [63803, 1, "\u788C"], [63804, 1, "\u797F"], [63805, 1, "\u7DA0"], [63806, 1, "\u83C9"], [63807, 1, "\u9304"], [63808, 1, "\u9E7F"], [63809, 1, "\u8AD6"], [63810, 1, "\u58DF"], [63811, 1, "\u5F04"], [63812, 1, "\u7C60"], [63813, 1, "\u807E"], [63814, 1, "\u7262"], [63815, 1, "\u78CA"], [63816, 1, "\u8CC2"], [63817, 1, "\u96F7"], [63818, 1, "\u58D8"], [63819, 1, "\u5C62"], [63820, 1, "\u6A13"], [63821, 1, "\u6DDA"], [63822, 1, "\u6F0F"], [63823, 1, "\u7D2F"], [63824, 1, "\u7E37"], [63825, 1, "\u964B"], [63826, 1, "\u52D2"], [63827, 1, "\u808B"], [63828, 1, "\u51DC"], [63829, 1, "\u51CC"], [63830, 1, "\u7A1C"], [63831, 1, "\u7DBE"], [63832, 1, "\u83F1"], [63833, 1, "\u9675"], [63834, 1, "\u8B80"], [63835, 1, "\u62CF"], [63836, 1, "\u6A02"], [63837, 1, "\u8AFE"], [63838, 1, "\u4E39"], [63839, 1, "\u5BE7"], [63840, 1, "\u6012"], [63841, 1, "\u7387"], [63842, 1, "\u7570"], [63843, 1, "\u5317"], [63844, 1, "\u78FB"], [63845, 1, "\u4FBF"], [63846, 1, "\u5FA9"], [63847, 1, "\u4E0D"], [63848, 1, "\u6CCC"], [63849, 1, "\u6578"], [63850, 1, "\u7D22"], [63851, 1, "\u53C3"], [63852, 1, "\u585E"], [63853, 1, "\u7701"], [63854, 1, "\u8449"], [63855, 1, "\u8AAA"], [63856, 1, "\u6BBA"], [63857, 1, "\u8FB0"], [63858, 1, "\u6C88"], [63859, 1, "\u62FE"], [63860, 1, "\u82E5"], [63861, 1, "\u63A0"], [63862, 1, "\u7565"], [63863, 1, "\u4EAE"], [63864, 1, "\u5169"], [63865, 1, "\u51C9"], [63866, 1, "\u6881"], [63867, 1, "\u7CE7"], [63868, 1, "\u826F"], [63869, 1, "\u8AD2"], [63870, 1, "\u91CF"], [63871, 1, "\u52F5"], [63872, 1, "\u5442"], [63873, 1, "\u5973"], [63874, 1, "\u5EEC"], [63875, 1, "\u65C5"], [63876, 1, "\u6FFE"], [63877, 1, "\u792A"], [63878, 1, "\u95AD"], [63879, 1, "\u9A6A"], [63880, 1, "\u9E97"], [63881, 1, "\u9ECE"], [63882, 1, "\u529B"], [63883, 1, "\u66C6"], [63884, 1, "\u6B77"], [63885, 1, "\u8F62"], [63886, 1, "\u5E74"], [63887, 1, "\u6190"], [63888, 1, "\u6200"], [63889, 1, "\u649A"], [63890, 1, "\u6F23"], [63891, 1, "\u7149"], [63892, 1, "\u7489"], [63893, 1, "\u79CA"], [63894, 1, "\u7DF4"], [63895, 1, "\u806F"], [63896, 1, "\u8F26"], [63897, 1, "\u84EE"], [63898, 1, "\u9023"], [63899, 1, "\u934A"], [63900, 1, "\u5217"], [63901, 1, "\u52A3"], [63902, 1, "\u54BD"], [63903, 1, "\u70C8"], [63904, 1, "\u88C2"], [63905, 1, "\u8AAA"], [63906, 1, "\u5EC9"], [63907, 1, "\u5FF5"], [63908, 1, "\u637B"], [63909, 1, "\u6BAE"], [63910, 1, "\u7C3E"], [63911, 1, "\u7375"], [63912, 1, "\u4EE4"], [63913, 1, "\u56F9"], [63914, 1, "\u5BE7"], [63915, 1, "\u5DBA"], [63916, 1, "\u601C"], [63917, 1, "\u73B2"], [63918, 1, "\u7469"], [63919, 1, "\u7F9A"], [63920, 1, "\u8046"], [63921, 1, "\u9234"], [63922, 1, "\u96F6"], [63923, 1, "\u9748"], [63924, 1, "\u9818"], [63925, 1, "\u4F8B"], [63926, 1, "\u79AE"], [63927, 1, "\u91B4"], [63928, 1, "\u96B8"], [63929, 1, "\u60E1"], [63930, 1, "\u4E86"], [63931, 1, "\u50DA"], [63932, 1, "\u5BEE"], [63933, 1, "\u5C3F"], [63934, 1, "\u6599"], [63935, 1, "\u6A02"], [63936, 1, "\u71CE"], [63937, 1, "\u7642"], [63938, 1, "\u84FC"], [63939, 1, "\u907C"], [63940, 1, "\u9F8D"], [63941, 1, "\u6688"], [63942, 1, "\u962E"], [63943, 1, "\u5289"], [63944, 1, "\u677B"], [63945, 1, "\u67F3"], [63946, 1, "\u6D41"], [63947, 1, "\u6E9C"], [63948, 1, "\u7409"], [63949, 1, "\u7559"], [63950, 1, "\u786B"], [63951, 1, "\u7D10"], [63952, 1, "\u985E"], [63953, 1, "\u516D"], [63954, 1, "\u622E"], [63955, 1, "\u9678"], [63956, 1, "\u502B"], [63957, 1, "\u5D19"], [63958, 1, "\u6DEA"], [63959, 1, "\u8F2A"], [63960, 1, "\u5F8B"], [63961, 1, "\u6144"], [63962, 1, "\u6817"], [63963, 1, "\u7387"], [63964, 1, "\u9686"], [63965, 1, "\u5229"], [63966, 1, "\u540F"], [63967, 1, "\u5C65"], [63968, 1, "\u6613"], [63969, 1, "\u674E"], [63970, 1, "\u68A8"], [63971, 1, "\u6CE5"], [63972, 1, "\u7406"], [63973, 1, "\u75E2"], [63974, 1, "\u7F79"], [63975, 1, "\u88CF"], [63976, 1, "\u88E1"], [63977, 1, "\u91CC"], [63978, 1, "\u96E2"], [63979, 1, "\u533F"], [63980, 1, "\u6EBA"], [63981, 1, "\u541D"], [63982, 1, "\u71D0"], [63983, 1, "\u7498"], [63984, 1, "\u85FA"], [63985, 1, "\u96A3"], [63986, 1, "\u9C57"], [63987, 1, "\u9E9F"], [63988, 1, "\u6797"], [63989, 1, "\u6DCB"], [63990, 1, "\u81E8"], [63991, 1, "\u7ACB"], [63992, 1, "\u7B20"], [63993, 1, "\u7C92"], [63994, 1, "\u72C0"], [63995, 1, "\u7099"], [63996, 1, "\u8B58"], [63997, 1, "\u4EC0"], [63998, 1, "\u8336"], [63999, 1, "\u523A"], [64e3, 1, "\u5207"], [64001, 1, "\u5EA6"], [64002, 1, "\u62D3"], [64003, 1, "\u7CD6"], [64004, 1, "\u5B85"], [64005, 1, "\u6D1E"], [64006, 1, "\u66B4"], [64007, 1, "\u8F3B"], [64008, 1, "\u884C"], [64009, 1, "\u964D"], [64010, 1, "\u898B"], [64011, 1, "\u5ED3"], [64012, 1, "\u5140"], [64013, 1, "\u55C0"], [[64014, 64015], 2], [64016, 1, "\u585A"], [64017, 2], [64018, 1, "\u6674"], [[64019, 64020], 2], [64021, 1, "\u51DE"], [64022, 1, "\u732A"], [64023, 1, "\u76CA"], [64024, 1, "\u793C"], [64025, 1, "\u795E"], [64026, 1, "\u7965"], [64027, 1, "\u798F"], [64028, 1, "\u9756"], [64029, 1, "\u7CBE"], [64030, 1, "\u7FBD"], [64031, 2], [64032, 1, "\u8612"], [64033, 2], [64034, 1, "\u8AF8"], [[64035, 64036], 2], [64037, 1, "\u9038"], [64038, 1, "\u90FD"], [[64039, 64041], 2], [64042, 1, "\u98EF"], [64043, 1, "\u98FC"], [64044, 1, "\u9928"], [64045, 1, "\u9DB4"], [64046, 1, "\u90DE"], [64047, 1, "\u96B7"], [64048, 1, "\u4FAE"], [64049, 1, "\u50E7"], [64050, 1, "\u514D"], [64051, 1, "\u52C9"], [64052, 1, "\u52E4"], [64053, 1, "\u5351"], [64054, 1, "\u559D"], [64055, 1, "\u5606"], [64056, 1, "\u5668"], [64057, 1, "\u5840"], [64058, 1, "\u58A8"], [64059, 1, "\u5C64"], [64060, 1, "\u5C6E"], [64061, 1, "\u6094"], [64062, 1, "\u6168"], [64063, 1, "\u618E"], [64064, 1, "\u61F2"], [64065, 1, "\u654F"], [64066, 1, "\u65E2"], [64067, 1, "\u6691"], [64068, 1, "\u6885"], [64069, 1, "\u6D77"], [64070, 1, "\u6E1A"], [64071, 1, "\u6F22"], [64072, 1, "\u716E"], [64073, 1, "\u722B"], [64074, 1, "\u7422"], [64075, 1, "\u7891"], [64076, 1, "\u793E"], [64077, 1, "\u7949"], [64078, 1, "\u7948"], [64079, 1, "\u7950"], [64080, 1, "\u7956"], [64081, 1, "\u795D"], [64082, 1, "\u798D"], [64083, 1, "\u798E"], [64084, 1, "\u7A40"], [64085, 1, "\u7A81"], [64086, 1, "\u7BC0"], [64087, 1, "\u7DF4"], [64088, 1, "\u7E09"], [64089, 1, "\u7E41"], [64090, 1, "\u7F72"], [64091, 1, "\u8005"], [64092, 1, "\u81ED"], [[64093, 64094], 1, "\u8279"], [64095, 1, "\u8457"], [64096, 1, "\u8910"], [64097, 1, "\u8996"], [64098, 1, "\u8B01"], [64099, 1, "\u8B39"], [64100, 1, "\u8CD3"], [64101, 1, "\u8D08"], [64102, 1, "\u8FB6"], [64103, 1, "\u9038"], [64104, 1, "\u96E3"], [64105, 1, "\u97FF"], [64106, 1, "\u983B"], [64107, 1, "\u6075"], [64108, 1, "\u{242EE}"], [64109, 1, "\u8218"], [[64110, 64111], 3], [64112, 1, "\u4E26"], [64113, 1, "\u51B5"], [64114, 1, "\u5168"], [64115, 1, "\u4F80"], [64116, 1, "\u5145"], [64117, 1, "\u5180"], [64118, 1, "\u52C7"], [64119, 1, "\u52FA"], [64120, 1, "\u559D"], [64121, 1, "\u5555"], [64122, 1, "\u5599"], [64123, 1, "\u55E2"], [64124, 1, "\u585A"], [64125, 1, "\u58B3"], [64126, 1, "\u5944"], [64127, 1, "\u5954"], [64128, 1, "\u5A62"], [64129, 1, "\u5B28"], [64130, 1, "\u5ED2"], [64131, 1, "\u5ED9"], [64132, 1, "\u5F69"], [64133, 1, "\u5FAD"], [64134, 1, "\u60D8"], [64135, 1, "\u614E"], [64136, 1, "\u6108"], [64137, 1, "\u618E"], [64138, 1, "\u6160"], [64139, 1, "\u61F2"], [64140, 1, "\u6234"], [64141, 1, "\u63C4"], [64142, 1, "\u641C"], [64143, 1, "\u6452"], [64144, 1, "\u6556"], [64145, 1, "\u6674"], [64146, 1, "\u6717"], [64147, 1, "\u671B"], [64148, 1, "\u6756"], [64149, 1, "\u6B79"], [64150, 1, "\u6BBA"], [64151, 1, "\u6D41"], [64152, 1, "\u6EDB"], [64153, 1, "\u6ECB"], [64154, 1, "\u6F22"], [64155, 1, "\u701E"], [64156, 1, "\u716E"], [64157, 1, "\u77A7"], [64158, 1, "\u7235"], [64159, 1, "\u72AF"], [64160, 1, "\u732A"], [64161, 1, "\u7471"], [64162, 1, "\u7506"], [64163, 1, "\u753B"], [64164, 1, "\u761D"], [64165, 1, "\u761F"], [64166, 1, "\u76CA"], [64167, 1, "\u76DB"], [64168, 1, "\u76F4"], [64169, 1, "\u774A"], [64170, 1, "\u7740"], [64171, 1, "\u78CC"], [64172, 1, "\u7AB1"], [64173, 1, "\u7BC0"], [64174, 1, "\u7C7B"], [64175, 1, "\u7D5B"], [64176, 1, "\u7DF4"], [64177, 1, "\u7F3E"], [64178, 1, "\u8005"], [64179, 1, "\u8352"], [64180, 1, "\u83EF"], [64181, 1, "\u8779"], [64182, 1, "\u8941"], [64183, 1, "\u8986"], [64184, 1, "\u8996"], [64185, 1, "\u8ABF"], [64186, 1, "\u8AF8"], [64187, 1, "\u8ACB"], [64188, 1, "\u8B01"], [64189, 1, "\u8AFE"], [64190, 1, "\u8AED"], [64191, 1, "\u8B39"], [64192, 1, "\u8B8A"], [64193, 1, "\u8D08"], [64194, 1, "\u8F38"], [64195, 1, "\u9072"], [64196, 1, "\u9199"], [64197, 1, "\u9276"], [64198, 1, "\u967C"], [64199, 1, "\u96E3"], [64200, 1, "\u9756"], [64201, 1, "\u97DB"], [64202, 1, "\u97FF"], [64203, 1, "\u980B"], [64204, 1, "\u983B"], [64205, 1, "\u9B12"], [64206, 1, "\u9F9C"], [64207, 1, "\u{2284A}"], [64208, 1, "\u{22844}"], [64209, 1, "\u{233D5}"], [64210, 1, "\u3B9D"], [64211, 1, "\u4018"], [64212, 1, "\u4039"], [64213, 1, "\u{25249}"], [64214, 1, "\u{25CD0}"], [64215, 1, "\u{27ED3}"], [64216, 1, "\u9F43"], [64217, 1, "\u9F8E"], [[64218, 64255], 3], [64256, 1, "ff"], [64257, 1, "fi"], [64258, 1, "fl"], [64259, 1, "ffi"], [64260, 1, "ffl"], [[64261, 64262], 1, "st"], [[64263, 64274], 3], [64275, 1, "\u0574\u0576"], [64276, 1, "\u0574\u0565"], [64277, 1, "\u0574\u056B"], [64278, 1, "\u057E\u0576"], [64279, 1, "\u0574\u056D"], [[64280, 64284], 3], [64285, 1, "\u05D9\u05B4"], [64286, 2], [64287, 1, "\u05F2\u05B7"], [64288, 1, "\u05E2"], [64289, 1, "\u05D0"], [64290, 1, "\u05D3"], [64291, 1, "\u05D4"], [64292, 1, "\u05DB"], [64293, 1, "\u05DC"], [64294, 1, "\u05DD"], [64295, 1, "\u05E8"], [64296, 1, "\u05EA"], [64297, 5, "+"], [64298, 1, "\u05E9\u05C1"], [64299, 1, "\u05E9\u05C2"], [64300, 1, "\u05E9\u05BC\u05C1"], [64301, 1, "\u05E9\u05BC\u05C2"], [64302, 1, "\u05D0\u05B7"], [64303, 1, "\u05D0\u05B8"], [64304, 1, "\u05D0\u05BC"], [64305, 1, "\u05D1\u05BC"], [64306, 1, "\u05D2\u05BC"], [64307, 1, "\u05D3\u05BC"], [64308, 1, "\u05D4\u05BC"], [64309, 1, "\u05D5\u05BC"], [64310, 1, "\u05D6\u05BC"], [64311, 3], [64312, 1, "\u05D8\u05BC"], [64313, 1, "\u05D9\u05BC"], [64314, 1, "\u05DA\u05BC"], [64315, 1, "\u05DB\u05BC"], [64316, 1, "\u05DC\u05BC"], [64317, 3], [64318, 1, "\u05DE\u05BC"], [64319, 3], [64320, 1, "\u05E0\u05BC"], [64321, 1, "\u05E1\u05BC"], [64322, 3], [64323, 1, "\u05E3\u05BC"], [64324, 1, "\u05E4\u05BC"], [64325, 3], [64326, 1, "\u05E6\u05BC"], [64327, 1, "\u05E7\u05BC"], [64328, 1, "\u05E8\u05BC"], [64329, 1, "\u05E9\u05BC"], [64330, 1, "\u05EA\u05BC"], [64331, 1, "\u05D5\u05B9"], [64332, 1, "\u05D1\u05BF"], [64333, 1, "\u05DB\u05BF"], [64334, 1, "\u05E4\u05BF"], [64335, 1, "\u05D0\u05DC"], [[64336, 64337], 1, "\u0671"], [[64338, 64341], 1, "\u067B"], [[64342, 64345], 1, "\u067E"], [[64346, 64349], 1, "\u0680"], [[64350, 64353], 1, "\u067A"], [[64354, 64357], 1, "\u067F"], [[64358, 64361], 1, "\u0679"], [[64362, 64365], 1, "\u06A4"], [[64366, 64369], 1, "\u06A6"], [[64370, 64373], 1, "\u0684"], [[64374, 64377], 1, "\u0683"], [[64378, 64381], 1, "\u0686"], [[64382, 64385], 1, "\u0687"], [[64386, 64387], 1, "\u068D"], [[64388, 64389], 1, "\u068C"], [[64390, 64391], 1, "\u068E"], [[64392, 64393], 1, "\u0688"], [[64394, 64395], 1, "\u0698"], [[64396, 64397], 1, "\u0691"], [[64398, 64401], 1, "\u06A9"], [[64402, 64405], 1, "\u06AF"], [[64406, 64409], 1, "\u06B3"], [[64410, 64413], 1, "\u06B1"], [[64414, 64415], 1, "\u06BA"], [[64416, 64419], 1, "\u06BB"], [[64420, 64421], 1, "\u06C0"], [[64422, 64425], 1, "\u06C1"], [[64426, 64429], 1, "\u06BE"], [[64430, 64431], 1, "\u06D2"], [[64432, 64433], 1, "\u06D3"], [[64434, 64449], 2], [64450, 2], [[64451, 64466], 3], [[64467, 64470], 1, "\u06AD"], [[64471, 64472], 1, "\u06C7"], [[64473, 64474], 1, "\u06C6"], [[64475, 64476], 1, "\u06C8"], [64477, 1, "\u06C7\u0674"], [[64478, 64479], 1, "\u06CB"], [[64480, 64481], 1, "\u06C5"], [[64482, 64483], 1, "\u06C9"], [[64484, 64487], 1, "\u06D0"], [[64488, 64489], 1, "\u0649"], [[64490, 64491], 1, "\u0626\u0627"], [[64492, 64493], 1, "\u0626\u06D5"], [[64494, 64495], 1, "\u0626\u0648"], [[64496, 64497], 1, "\u0626\u06C7"], [[64498, 64499], 1, "\u0626\u06C6"], [[64500, 64501], 1, "\u0626\u06C8"], [[64502, 64504], 1, "\u0626\u06D0"], [[64505, 64507], 1, "\u0626\u0649"], [[64508, 64511], 1, "\u06CC"], [64512, 1, "\u0626\u062C"], [64513, 1, "\u0626\u062D"], [64514, 1, "\u0626\u0645"], [64515, 1, "\u0626\u0649"], [64516, 1, "\u0626\u064A"], [64517, 1, "\u0628\u062C"], [64518, 1, "\u0628\u062D"], [64519, 1, "\u0628\u062E"], [64520, 1, "\u0628\u0645"], [64521, 1, "\u0628\u0649"], [64522, 1, "\u0628\u064A"], [64523, 1, "\u062A\u062C"], [64524, 1, "\u062A\u062D"], [64525, 1, "\u062A\u062E"], [64526, 1, "\u062A\u0645"], [64527, 1, "\u062A\u0649"], [64528, 1, "\u062A\u064A"], [64529, 1, "\u062B\u062C"], [64530, 1, "\u062B\u0645"], [64531, 1, "\u062B\u0649"], [64532, 1, "\u062B\u064A"], [64533, 1, "\u062C\u062D"], [64534, 1, "\u062C\u0645"], [64535, 1, "\u062D\u062C"], [64536, 1, "\u062D\u0645"], [64537, 1, "\u062E\u062C"], [64538, 1, "\u062E\u062D"], [64539, 1, "\u062E\u0645"], [64540, 1, "\u0633\u062C"], [64541, 1, "\u0633\u062D"], [64542, 1, "\u0633\u062E"], [64543, 1, "\u0633\u0645"], [64544, 1, "\u0635\u062D"], [64545, 1, "\u0635\u0645"], [64546, 1, "\u0636\u062C"], [64547, 1, "\u0636\u062D"], [64548, 1, "\u0636\u062E"], [64549, 1, "\u0636\u0645"], [64550, 1, "\u0637\u062D"], [64551, 1, "\u0637\u0645"], [64552, 1, "\u0638\u0645"], [64553, 1, "\u0639\u062C"], [64554, 1, "\u0639\u0645"], [64555, 1, "\u063A\u062C"], [64556, 1, "\u063A\u0645"], [64557, 1, "\u0641\u062C"], [64558, 1, "\u0641\u062D"], [64559, 1, "\u0641\u062E"], [64560, 1, "\u0641\u0645"], [64561, 1, "\u0641\u0649"], [64562, 1, "\u0641\u064A"], [64563, 1, "\u0642\u062D"], [64564, 1, "\u0642\u0645"], [64565, 1, "\u0642\u0649"], [64566, 1, "\u0642\u064A"], [64567, 1, "\u0643\u0627"], [64568, 1, "\u0643\u062C"], [64569, 1, "\u0643\u062D"], [64570, 1, "\u0643\u062E"], [64571, 1, "\u0643\u0644"], [64572, 1, "\u0643\u0645"], [64573, 1, "\u0643\u0649"], [64574, 1, "\u0643\u064A"], [64575, 1, "\u0644\u062C"], [64576, 1, "\u0644\u062D"], [64577, 1, "\u0644\u062E"], [64578, 1, "\u0644\u0645"], [64579, 1, "\u0644\u0649"], [64580, 1, "\u0644\u064A"], [64581, 1, "\u0645\u062C"], [64582, 1, "\u0645\u062D"], [64583, 1, "\u0645\u062E"], [64584, 1, "\u0645\u0645"], [64585, 1, "\u0645\u0649"], [64586, 1, "\u0645\u064A"], [64587, 1, "\u0646\u062C"], [64588, 1, "\u0646\u062D"], [64589, 1, "\u0646\u062E"], [64590, 1, "\u0646\u0645"], [64591, 1, "\u0646\u0649"], [64592, 1, "\u0646\u064A"], [64593, 1, "\u0647\u062C"], [64594, 1, "\u0647\u0645"], [64595, 1, "\u0647\u0649"], [64596, 1, "\u0647\u064A"], [64597, 1, "\u064A\u062C"], [64598, 1, "\u064A\u062D"], [64599, 1, "\u064A\u062E"], [64600, 1, "\u064A\u0645"], [64601, 1, "\u064A\u0649"], [64602, 1, "\u064A\u064A"], [64603, 1, "\u0630\u0670"], [64604, 1, "\u0631\u0670"], [64605, 1, "\u0649\u0670"], [64606, 5, " \u064C\u0651"], [64607, 5, " \u064D\u0651"], [64608, 5, " \u064E\u0651"], [64609, 5, " \u064F\u0651"], [64610, 5, " \u0650\u0651"], [64611, 5, " \u0651\u0670"], [64612, 1, "\u0626\u0631"], [64613, 1, "\u0626\u0632"], [64614, 1, "\u0626\u0645"], [64615, 1, "\u0626\u0646"], [64616, 1, "\u0626\u0649"], [64617, 1, "\u0626\u064A"], [64618, 1, "\u0628\u0631"], [64619, 1, "\u0628\u0632"], [64620, 1, "\u0628\u0645"], [64621, 1, "\u0628\u0646"], [64622, 1, "\u0628\u0649"], [64623, 1, "\u0628\u064A"], [64624, 1, "\u062A\u0631"], [64625, 1, "\u062A\u0632"], [64626, 1, "\u062A\u0645"], [64627, 1, "\u062A\u0646"], [64628, 1, "\u062A\u0649"], [64629, 1, "\u062A\u064A"], [64630, 1, "\u062B\u0631"], [64631, 1, "\u062B\u0632"], [64632, 1, "\u062B\u0645"], [64633, 1, "\u062B\u0646"], [64634, 1, "\u062B\u0649"], [64635, 1, "\u062B\u064A"], [64636, 1, "\u0641\u0649"], [64637, 1, "\u0641\u064A"], [64638, 1, "\u0642\u0649"], [64639, 1, "\u0642\u064A"], [64640, 1, "\u0643\u0627"], [64641, 1, "\u0643\u0644"], [64642, 1, "\u0643\u0645"], [64643, 1, "\u0643\u0649"], [64644, 1, "\u0643\u064A"], [64645, 1, "\u0644\u0645"], [64646, 1, "\u0644\u0649"], [64647, 1, "\u0644\u064A"], [64648, 1, "\u0645\u0627"], [64649, 1, "\u0645\u0645"], [64650, 1, "\u0646\u0631"], [64651, 1, "\u0646\u0632"], [64652, 1, "\u0646\u0645"], [64653, 1, "\u0646\u0646"], [64654, 1, "\u0646\u0649"], [64655, 1, "\u0646\u064A"], [64656, 1, "\u0649\u0670"], [64657, 1, "\u064A\u0631"], [64658, 1, "\u064A\u0632"], [64659, 1, "\u064A\u0645"], [64660, 1, "\u064A\u0646"], [64661, 1, "\u064A\u0649"], [64662, 1, "\u064A\u064A"], [64663, 1, "\u0626\u062C"], [64664, 1, "\u0626\u062D"], [64665, 1, "\u0626\u062E"], [64666, 1, "\u0626\u0645"], [64667, 1, "\u0626\u0647"], [64668, 1, "\u0628\u062C"], [64669, 1, "\u0628\u062D"], [64670, 1, "\u0628\u062E"], [64671, 1, "\u0628\u0645"], [64672, 1, "\u0628\u0647"], [64673, 1, "\u062A\u062C"], [64674, 1, "\u062A\u062D"], [64675, 1, "\u062A\u062E"], [64676, 1, "\u062A\u0645"], [64677, 1, "\u062A\u0647"], [64678, 1, "\u062B\u0645"], [64679, 1, "\u062C\u062D"], [64680, 1, "\u062C\u0645"], [64681, 1, "\u062D\u062C"], [64682, 1, "\u062D\u0645"], [64683, 1, "\u062E\u062C"], [64684, 1, "\u062E\u0645"], [64685, 1, "\u0633\u062C"], [64686, 1, "\u0633\u062D"], [64687, 1, "\u0633\u062E"], [64688, 1, "\u0633\u0645"], [64689, 1, "\u0635\u062D"], [64690, 1, "\u0635\u062E"], [64691, 1, "\u0635\u0645"], [64692, 1, "\u0636\u062C"], [64693, 1, "\u0636\u062D"], [64694, 1, "\u0636\u062E"], [64695, 1, "\u0636\u0645"], [64696, 1, "\u0637\u062D"], [64697, 1, "\u0638\u0645"], [64698, 1, "\u0639\u062C"], [64699, 1, "\u0639\u0645"], [64700, 1, "\u063A\u062C"], [64701, 1, "\u063A\u0645"], [64702, 1, "\u0641\u062C"], [64703, 1, "\u0641\u062D"], [64704, 1, "\u0641\u062E"], [64705, 1, "\u0641\u0645"], [64706, 1, "\u0642\u062D"], [64707, 1, "\u0642\u0645"], [64708, 1, "\u0643\u062C"], [64709, 1, "\u0643\u062D"], [64710, 1, "\u0643\u062E"], [64711, 1, "\u0643\u0644"], [64712, 1, "\u0643\u0645"], [64713, 1, "\u0644\u062C"], [64714, 1, "\u0644\u062D"], [64715, 1, "\u0644\u062E"], [64716, 1, "\u0644\u0645"], [64717, 1, "\u0644\u0647"], [64718, 1, "\u0645\u062C"], [64719, 1, "\u0645\u062D"], [64720, 1, "\u0645\u062E"], [64721, 1, "\u0645\u0645"], [64722, 1, "\u0646\u062C"], [64723, 1, "\u0646\u062D"], [64724, 1, "\u0646\u062E"], [64725, 1, "\u0646\u0645"], [64726, 1, "\u0646\u0647"], [64727, 1, "\u0647\u062C"], [64728, 1, "\u0647\u0645"], [64729, 1, "\u0647\u0670"], [64730, 1, "\u064A\u062C"], [64731, 1, "\u064A\u062D"], [64732, 1, "\u064A\u062E"], [64733, 1, "\u064A\u0645"], [64734, 1, "\u064A\u0647"], [64735, 1, "\u0626\u0645"], [64736, 1, "\u0626\u0647"], [64737, 1, "\u0628\u0645"], [64738, 1, "\u0628\u0647"], [64739, 1, "\u062A\u0645"], [64740, 1, "\u062A\u0647"], [64741, 1, "\u062B\u0645"], [64742, 1, "\u062B\u0647"], [64743, 1, "\u0633\u0645"], [64744, 1, "\u0633\u0647"], [64745, 1, "\u0634\u0645"], [64746, 1, "\u0634\u0647"], [64747, 1, "\u0643\u0644"], [64748, 1, "\u0643\u0645"], [64749, 1, "\u0644\u0645"], [64750, 1, "\u0646\u0645"], [64751, 1, "\u0646\u0647"], [64752, 1, "\u064A\u0645"], [64753, 1, "\u064A\u0647"], [64754, 1, "\u0640\u064E\u0651"], [64755, 1, "\u0640\u064F\u0651"], [64756, 1, "\u0640\u0650\u0651"], [64757, 1, "\u0637\u0649"], [64758, 1, "\u0637\u064A"], [64759, 1, "\u0639\u0649"], [64760, 1, "\u0639\u064A"], [64761, 1, "\u063A\u0649"], [64762, 1, "\u063A\u064A"], [64763, 1, "\u0633\u0649"], [64764, 1, "\u0633\u064A"], [64765, 1, "\u0634\u0649"], [64766, 1, "\u0634\u064A"], [64767, 1, "\u062D\u0649"], [64768, 1, "\u062D\u064A"], [64769, 1, "\u062C\u0649"], [64770, 1, "\u062C\u064A"], [64771, 1, "\u062E\u0649"], [64772, 1, "\u062E\u064A"], [64773, 1, "\u0635\u0649"], [64774, 1, "\u0635\u064A"], [64775, 1, "\u0636\u0649"], [64776, 1, "\u0636\u064A"], [64777, 1, "\u0634\u062C"], [64778, 1, "\u0634\u062D"], [64779, 1, "\u0634\u062E"], [64780, 1, "\u0634\u0645"], [64781, 1, "\u0634\u0631"], [64782, 1, "\u0633\u0631"], [64783, 1, "\u0635\u0631"], [64784, 1, "\u0636\u0631"], [64785, 1, "\u0637\u0649"], [64786, 1, "\u0637\u064A"], [64787, 1, "\u0639\u0649"], [64788, 1, "\u0639\u064A"], [64789, 1, "\u063A\u0649"], [64790, 1, "\u063A\u064A"], [64791, 1, "\u0633\u0649"], [64792, 1, "\u0633\u064A"], [64793, 1, "\u0634\u0649"], [64794, 1, "\u0634\u064A"], [64795, 1, "\u062D\u0649"], [64796, 1, "\u062D\u064A"], [64797, 1, "\u062C\u0649"], [64798, 1, "\u062C\u064A"], [64799, 1, "\u062E\u0649"], [64800, 1, "\u062E\u064A"], [64801, 1, "\u0635\u0649"], [64802, 1, "\u0635\u064A"], [64803, 1, "\u0636\u0649"], [64804, 1, "\u0636\u064A"], [64805, 1, "\u0634\u062C"], [64806, 1, "\u0634\u062D"], [64807, 1, "\u0634\u062E"], [64808, 1, "\u0634\u0645"], [64809, 1, "\u0634\u0631"], [64810, 1, "\u0633\u0631"], [64811, 1, "\u0635\u0631"], [64812, 1, "\u0636\u0631"], [64813, 1, "\u0634\u062C"], [64814, 1, "\u0634\u062D"], [64815, 1, "\u0634\u062E"], [64816, 1, "\u0634\u0645"], [64817, 1, "\u0633\u0647"], [64818, 1, "\u0634\u0647"], [64819, 1, "\u0637\u0645"], [64820, 1, "\u0633\u062C"], [64821, 1, "\u0633\u062D"], [64822, 1, "\u0633\u062E"], [64823, 1, "\u0634\u062C"], [64824, 1, "\u0634\u062D"], [64825, 1, "\u0634\u062E"], [64826, 1, "\u0637\u0645"], [64827, 1, "\u0638\u0645"], [[64828, 64829], 1, "\u0627\u064B"], [[64830, 64831], 2], [[64832, 64847], 2], [64848, 1, "\u062A\u062C\u0645"], [[64849, 64850], 1, "\u062A\u062D\u062C"], [64851, 1, "\u062A\u062D\u0645"], [64852, 1, "\u062A\u062E\u0645"], [64853, 1, "\u062A\u0645\u062C"], [64854, 1, "\u062A\u0645\u062D"], [64855, 1, "\u062A\u0645\u062E"], [[64856, 64857], 1, "\u062C\u0645\u062D"], [64858, 1, "\u062D\u0645\u064A"], [64859, 1, "\u062D\u0645\u0649"], [64860, 1, "\u0633\u062D\u062C"], [64861, 1, "\u0633\u062C\u062D"], [64862, 1, "\u0633\u062C\u0649"], [[64863, 64864], 1, "\u0633\u0645\u062D"], [64865, 1, "\u0633\u0645\u062C"], [[64866, 64867], 1, "\u0633\u0645\u0645"], [[64868, 64869], 1, "\u0635\u062D\u062D"], [64870, 1, "\u0635\u0645\u0645"], [[64871, 64872], 1, "\u0634\u062D\u0645"], [64873, 1, "\u0634\u062C\u064A"], [[64874, 64875], 1, "\u0634\u0645\u062E"], [[64876, 64877], 1, "\u0634\u0645\u0645"], [64878, 1, "\u0636\u062D\u0649"], [[64879, 64880], 1, "\u0636\u062E\u0645"], [[64881, 64882], 1, "\u0637\u0645\u062D"], [64883, 1, "\u0637\u0645\u0645"], [64884, 1, "\u0637\u0645\u064A"], [64885, 1, "\u0639\u062C\u0645"], [[64886, 64887], 1, "\u0639\u0645\u0645"], [64888, 1, "\u0639\u0645\u0649"], [64889, 1, "\u063A\u0645\u0645"], [64890, 1, "\u063A\u0645\u064A"], [64891, 1, "\u063A\u0645\u0649"], [[64892, 64893], 1, "\u0641\u062E\u0645"], [64894, 1, "\u0642\u0645\u062D"], [64895, 1, "\u0642\u0645\u0645"], [64896, 1, "\u0644\u062D\u0645"], [64897, 1, "\u0644\u062D\u064A"], [64898, 1, "\u0644\u062D\u0649"], [[64899, 64900], 1, "\u0644\u062C\u062C"], [[64901, 64902], 1, "\u0644\u062E\u0645"], [[64903, 64904], 1, "\u0644\u0645\u062D"], [64905, 1, "\u0645\u062D\u062C"], [64906, 1, "\u0645\u062D\u0645"], [64907, 1, "\u0645\u062D\u064A"], [64908, 1, "\u0645\u062C\u062D"], [64909, 1, "\u0645\u062C\u0645"], [64910, 1, "\u0645\u062E\u062C"], [64911, 1, "\u0645\u062E\u0645"], [[64912, 64913], 3], [64914, 1, "\u0645\u062C\u062E"], [64915, 1, "\u0647\u0645\u062C"], [64916, 1, "\u0647\u0645\u0645"], [64917, 1, "\u0646\u062D\u0645"], [64918, 1, "\u0646\u062D\u0649"], [[64919, 64920], 1, "\u0646\u062C\u0645"], [64921, 1, "\u0646\u062C\u0649"], [64922, 1, "\u0646\u0645\u064A"], [64923, 1, "\u0646\u0645\u0649"], [[64924, 64925], 1, "\u064A\u0645\u0645"], [64926, 1, "\u0628\u062E\u064A"], [64927, 1, "\u062A\u062C\u064A"], [64928, 1, "\u062A\u062C\u0649"], [64929, 1, "\u062A\u062E\u064A"], [64930, 1, "\u062A\u062E\u0649"], [64931, 1, "\u062A\u0645\u064A"], [64932, 1, "\u062A\u0645\u0649"], [64933, 1, "\u062C\u0645\u064A"], [64934, 1, "\u062C\u062D\u0649"], [64935, 1, "\u062C\u0645\u0649"], [64936, 1, "\u0633\u062E\u0649"], [64937, 1, "\u0635\u062D\u064A"], [64938, 1, "\u0634\u062D\u064A"], [64939, 1, "\u0636\u062D\u064A"], [64940, 1, "\u0644\u062C\u064A"], [64941, 1, "\u0644\u0645\u064A"], [64942, 1, "\u064A\u062D\u064A"], [64943, 1, "\u064A\u062C\u064A"], [64944, 1, "\u064A\u0645\u064A"], [64945, 1, "\u0645\u0645\u064A"], [64946, 1, "\u0642\u0645\u064A"], [64947, 1, "\u0646\u062D\u064A"], [64948, 1, "\u0642\u0645\u062D"], [64949, 1, "\u0644\u062D\u0645"], [64950, 1, "\u0639\u0645\u064A"], [64951, 1, "\u0643\u0645\u064A"], [64952, 1, "\u0646\u062C\u062D"], [64953, 1, "\u0645\u062E\u064A"], [64954, 1, "\u0644\u062C\u0645"], [64955, 1, "\u0643\u0645\u0645"], [64956, 1, "\u0644\u062C\u0645"], [64957, 1, "\u0646\u062C\u062D"], [64958, 1, "\u062C\u062D\u064A"], [64959, 1, "\u062D\u062C\u064A"], [64960, 1, "\u0645\u062C\u064A"], [64961, 1, "\u0641\u0645\u064A"], [64962, 1, "\u0628\u062D\u064A"], [64963, 1, "\u0643\u0645\u0645"], [64964, 1, "\u0639\u062C\u0645"], [64965, 1, "\u0635\u0645\u0645"], [64966, 1, "\u0633\u062E\u064A"], [64967, 1, "\u0646\u062C\u064A"], [[64968, 64974], 3], [64975, 2], [[64976, 65007], 3], [65008, 1, "\u0635\u0644\u06D2"], [65009, 1, "\u0642\u0644\u06D2"], [65010, 1, "\u0627\u0644\u0644\u0647"], [65011, 1, "\u0627\u0643\u0628\u0631"], [65012, 1, "\u0645\u062D\u0645\u062F"], [65013, 1, "\u0635\u0644\u0639\u0645"], [65014, 1, "\u0631\u0633\u0648\u0644"], [65015, 1, "\u0639\u0644\u064A\u0647"], [65016, 1, "\u0648\u0633\u0644\u0645"], [65017, 1, "\u0635\u0644\u0649"], [65018, 5, "\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 \u0639\u0644\u064A\u0647 \u0648\u0633\u0644\u0645"], [65019, 5, "\u062C\u0644 \u062C\u0644\u0627\u0644\u0647"], [65020, 1, "\u0631\u06CC\u0627\u0644"], [65021, 2], [[65022, 65023], 2], [[65024, 65039], 7], [65040, 5, ","], [65041, 1, "\u3001"], [65042, 3], [65043, 5, ":"], [65044, 5, ";"], [65045, 5, "!"], [65046, 5, "?"], [65047, 1, "\u3016"], [65048, 1, "\u3017"], [65049, 3], [[65050, 65055], 3], [[65056, 65059], 2], [[65060, 65062], 2], [[65063, 65069], 2], [[65070, 65071], 2], [65072, 3], [65073, 1, "\u2014"], [65074, 1, "\u2013"], [[65075, 65076], 5, "_"], [65077, 5, "("], [65078, 5, ")"], [65079, 5, "{"], [65080, 5, "}"], [65081, 1, "\u3014"], [65082, 1, "\u3015"], [65083, 1, "\u3010"], [65084, 1, "\u3011"], [65085, 1, "\u300A"], [65086, 1, "\u300B"], [65087, 1, "\u3008"], [65088, 1, "\u3009"], [65089, 1, "\u300C"], [65090, 1, "\u300D"], [65091, 1, "\u300E"], [65092, 1, "\u300F"], [[65093, 65094], 2], [65095, 5, "["], [65096, 5, "]"], [[65097, 65100], 5, " \u0305"], [[65101, 65103], 5, "_"], [65104, 5, ","], [65105, 1, "\u3001"], [65106, 3], [65107, 3], [65108, 5, ";"], [65109, 5, ":"], [65110, 5, "?"], [65111, 5, "!"], [65112, 1, "\u2014"], [65113, 5, "("], [65114, 5, ")"], [65115, 5, "{"], [65116, 5, "}"], [65117, 1, "\u3014"], [65118, 1, "\u3015"], [65119, 5, "#"], [65120, 5, "&"], [65121, 5, "*"], [65122, 5, "+"], [65123, 1, "-"], [65124, 5, "<"], [65125, 5, ">"], [65126, 5, "="], [65127, 3], [65128, 5, "\\"], [65129, 5, "$"], [65130, 5, "%"], [65131, 5, "@"], [[65132, 65135], 3], [65136, 5, " \u064B"], [65137, 1, "\u0640\u064B"], [65138, 5, " \u064C"], [65139, 2], [65140, 5, " \u064D"], [65141, 3], [65142, 5, " \u064E"], [65143, 1, "\u0640\u064E"], [65144, 5, " \u064F"], [65145, 1, "\u0640\u064F"], [65146, 5, " \u0650"], [65147, 1, "\u0640\u0650"], [65148, 5, " \u0651"], [65149, 1, "\u0640\u0651"], [65150, 5, " \u0652"], [65151, 1, "\u0640\u0652"], [65152, 1, "\u0621"], [[65153, 65154], 1, "\u0622"], [[65155, 65156], 1, "\u0623"], [[65157, 65158], 1, "\u0624"], [[65159, 65160], 1, "\u0625"], [[65161, 65164], 1, "\u0626"], [[65165, 65166], 1, "\u0627"], [[65167, 65170], 1, "\u0628"], [[65171, 65172], 1, "\u0629"], [[65173, 65176], 1, "\u062A"], [[65177, 65180], 1, "\u062B"], [[65181, 65184], 1, "\u062C"], [[65185, 65188], 1, "\u062D"], [[65189, 65192], 1, "\u062E"], [[65193, 65194], 1, "\u062F"], [[65195, 65196], 1, "\u0630"], [[65197, 65198], 1, "\u0631"], [[65199, 65200], 1, "\u0632"], [[65201, 65204], 1, "\u0633"], [[65205, 65208], 1, "\u0634"], [[65209, 65212], 1, "\u0635"], [[65213, 65216], 1, "\u0636"], [[65217, 65220], 1, "\u0637"], [[65221, 65224], 1, "\u0638"], [[65225, 65228], 1, "\u0639"], [[65229, 65232], 1, "\u063A"], [[65233, 65236], 1, "\u0641"], [[65237, 65240], 1, "\u0642"], [[65241, 65244], 1, "\u0643"], [[65245, 65248], 1, "\u0644"], [[65249, 65252], 1, "\u0645"], [[65253, 65256], 1, "\u0646"], [[65257, 65260], 1, "\u0647"], [[65261, 65262], 1, "\u0648"], [[65263, 65264], 1, "\u0649"], [[65265, 65268], 1, "\u064A"], [[65269, 65270], 1, "\u0644\u0622"], [[65271, 65272], 1, "\u0644\u0623"], [[65273, 65274], 1, "\u0644\u0625"], [[65275, 65276], 1, "\u0644\u0627"], [[65277, 65278], 3], [65279, 7], [65280, 3], [65281, 5, "!"], [65282, 5, '"'], [65283, 5, "#"], [65284, 5, "$"], [65285, 5, "%"], [65286, 5, "&"], [65287, 5, "'"], [65288, 5, "("], [65289, 5, ")"], [65290, 5, "*"], [65291, 5, "+"], [65292, 5, ","], [65293, 1, "-"], [65294, 1, "."], [65295, 5, "/"], [65296, 1, "0"], [65297, 1, "1"], [65298, 1, "2"], [65299, 1, "3"], [65300, 1, "4"], [65301, 1, "5"], [65302, 1, "6"], [65303, 1, "7"], [65304, 1, "8"], [65305, 1, "9"], [65306, 5, ":"], [65307, 5, ";"], [65308, 5, "<"], [65309, 5, "="], [65310, 5, ">"], [65311, 5, "?"], [65312, 5, "@"], [65313, 1, "a"], [65314, 1, "b"], [65315, 1, "c"], [65316, 1, "d"], [65317, 1, "e"], [65318, 1, "f"], [65319, 1, "g"], [65320, 1, "h"], [65321, 1, "i"], [65322, 1, "j"], [65323, 1, "k"], [65324, 1, "l"], [65325, 1, "m"], [65326, 1, "n"], [65327, 1, "o"], [65328, 1, "p"], [65329, 1, "q"], [65330, 1, "r"], [65331, 1, "s"], [65332, 1, "t"], [65333, 1, "u"], [65334, 1, "v"], [65335, 1, "w"], [65336, 1, "x"], [65337, 1, "y"], [65338, 1, "z"], [65339, 5, "["], [65340, 5, "\\"], [65341, 5, "]"], [65342, 5, "^"], [65343, 5, "_"], [65344, 5, "`"], [65345, 1, "a"], [65346, 1, "b"], [65347, 1, "c"], [65348, 1, "d"], [65349, 1, "e"], [65350, 1, "f"], [65351, 1, "g"], [65352, 1, "h"], [65353, 1, "i"], [65354, 1, "j"], [65355, 1, "k"], [65356, 1, "l"], [65357, 1, "m"], [65358, 1, "n"], [65359, 1, "o"], [65360, 1, "p"], [65361, 1, "q"], [65362, 1, "r"], [65363, 1, "s"], [65364, 1, "t"], [65365, 1, "u"], [65366, 1, "v"], [65367, 1, "w"], [65368, 1, "x"], [65369, 1, "y"], [65370, 1, "z"], [65371, 5, "{"], [65372, 5, "|"], [65373, 5, "}"], [65374, 5, "~"], [65375, 1, "\u2985"], [65376, 1, "\u2986"], [65377, 1, "."], [65378, 1, "\u300C"], [65379, 1, "\u300D"], [65380, 1, "\u3001"], [65381, 1, "\u30FB"], [65382, 1, "\u30F2"], [65383, 1, "\u30A1"], [65384, 1, "\u30A3"], [65385, 1, "\u30A5"], [65386, 1, "\u30A7"], [65387, 1, "\u30A9"], [65388, 1, "\u30E3"], [65389, 1, "\u30E5"], [65390, 1, "\u30E7"], [65391, 1, "\u30C3"], [65392, 1, "\u30FC"], [65393, 1, "\u30A2"], [65394, 1, "\u30A4"], [65395, 1, "\u30A6"], [65396, 1, "\u30A8"], [65397, 1, "\u30AA"], [65398, 1, "\u30AB"], [65399, 1, "\u30AD"], [65400, 1, "\u30AF"], [65401, 1, "\u30B1"], [65402, 1, "\u30B3"], [65403, 1, "\u30B5"], [65404, 1, "\u30B7"], [65405, 1, "\u30B9"], [65406, 1, "\u30BB"], [65407, 1, "\u30BD"], [65408, 1, "\u30BF"], [65409, 1, "\u30C1"], [65410, 1, "\u30C4"], [65411, 1, "\u30C6"], [65412, 1, "\u30C8"], [65413, 1, "\u30CA"], [65414, 1, "\u30CB"], [65415, 1, "\u30CC"], [65416, 1, "\u30CD"], [65417, 1, "\u30CE"], [65418, 1, "\u30CF"], [65419, 1, "\u30D2"], [65420, 1, "\u30D5"], [65421, 1, "\u30D8"], [65422, 1, "\u30DB"], [65423, 1, "\u30DE"], [65424, 1, "\u30DF"], [65425, 1, "\u30E0"], [65426, 1, "\u30E1"], [65427, 1, "\u30E2"], [65428, 1, "\u30E4"], [65429, 1, "\u30E6"], [65430, 1, "\u30E8"], [65431, 1, "\u30E9"], [65432, 1, "\u30EA"], [65433, 1, "\u30EB"], [65434, 1, "\u30EC"], [65435, 1, "\u30ED"], [65436, 1, "\u30EF"], [65437, 1, "\u30F3"], [65438, 1, "\u3099"], [65439, 1, "\u309A"], [65440, 3], [65441, 1, "\u1100"], [65442, 1, "\u1101"], [65443, 1, "\u11AA"], [65444, 1, "\u1102"], [65445, 1, "\u11AC"], [65446, 1, "\u11AD"], [65447, 1, "\u1103"], [65448, 1, "\u1104"], [65449, 1, "\u1105"], [65450, 1, "\u11B0"], [65451, 1, "\u11B1"], [65452, 1, "\u11B2"], [65453, 1, "\u11B3"], [65454, 1, "\u11B4"], [65455, 1, "\u11B5"], [65456, 1, "\u111A"], [65457, 1, "\u1106"], [65458, 1, "\u1107"], [65459, 1, "\u1108"], [65460, 1, "\u1121"], [65461, 1, "\u1109"], [65462, 1, "\u110A"], [65463, 1, "\u110B"], [65464, 1, "\u110C"], [65465, 1, "\u110D"], [65466, 1, "\u110E"], [65467, 1, "\u110F"], [65468, 1, "\u1110"], [65469, 1, "\u1111"], [65470, 1, "\u1112"], [[65471, 65473], 3], [65474, 1, "\u1161"], [65475, 1, "\u1162"], [65476, 1, "\u1163"], [65477, 1, "\u1164"], [65478, 1, "\u1165"], [65479, 1, "\u1166"], [[65480, 65481], 3], [65482, 1, "\u1167"], [65483, 1, "\u1168"], [65484, 1, "\u1169"], [65485, 1, "\u116A"], [65486, 1, "\u116B"], [65487, 1, "\u116C"], [[65488, 65489], 3], [65490, 1, "\u116D"], [65491, 1, "\u116E"], [65492, 1, "\u116F"], [65493, 1, "\u1170"], [65494, 1, "\u1171"], [65495, 1, "\u1172"], [[65496, 65497], 3], [65498, 1, "\u1173"], [65499, 1, "\u1174"], [65500, 1, "\u1175"], [[65501, 65503], 3], [65504, 1, "\xA2"], [65505, 1, "\xA3"], [65506, 1, "\xAC"], [65507, 5, " \u0304"], [65508, 1, "\xA6"], [65509, 1, "\xA5"], [65510, 1, "\u20A9"], [65511, 3], [65512, 1, "\u2502"], [65513, 1, "\u2190"], [65514, 1, "\u2191"], [65515, 1, "\u2192"], [65516, 1, "\u2193"], [65517, 1, "\u25A0"], [65518, 1, "\u25CB"], [[65519, 65528], 3], [[65529, 65531], 3], [65532, 3], [65533, 3], [[65534, 65535], 3], [[65536, 65547], 2], [65548, 3], [[65549, 65574], 2], [65575, 3], [[65576, 65594], 2], [65595, 3], [[65596, 65597], 2], [65598, 3], [[65599, 65613], 2], [[65614, 65615], 3], [[65616, 65629], 2], [[65630, 65663], 3], [[65664, 65786], 2], [[65787, 65791], 3], [[65792, 65794], 2], [[65795, 65798], 3], [[65799, 65843], 2], [[65844, 65846], 3], [[65847, 65855], 2], [[65856, 65930], 2], [[65931, 65932], 2], [[65933, 65934], 2], [65935, 3], [[65936, 65947], 2], [65948, 2], [[65949, 65951], 3], [65952, 2], [[65953, 65999], 3], [[66e3, 66044], 2], [66045, 2], [[66046, 66175], 3], [[66176, 66204], 2], [[66205, 66207], 3], [[66208, 66256], 2], [[66257, 66271], 3], [66272, 2], [[66273, 66299], 2], [[66300, 66303], 3], [[66304, 66334], 2], [66335, 2], [[66336, 66339], 2], [[66340, 66348], 3], [[66349, 66351], 2], [[66352, 66368], 2], [66369, 2], [[66370, 66377], 2], [66378, 2], [[66379, 66383], 3], [[66384, 66426], 2], [[66427, 66431], 3], [[66432, 66461], 2], [66462, 3], [66463, 2], [[66464, 66499], 2], [[66500, 66503], 3], [[66504, 66511], 2], [[66512, 66517], 2], [[66518, 66559], 3], [66560, 1, "\u{10428}"], [66561, 1, "\u{10429}"], [66562, 1, "\u{1042A}"], [66563, 1, "\u{1042B}"], [66564, 1, "\u{1042C}"], [66565, 1, "\u{1042D}"], [66566, 1, "\u{1042E}"], [66567, 1, "\u{1042F}"], [66568, 1, "\u{10430}"], [66569, 1, "\u{10431}"], [66570, 1, "\u{10432}"], [66571, 1, "\u{10433}"], [66572, 1, "\u{10434}"], [66573, 1, "\u{10435}"], [66574, 1, "\u{10436}"], [66575, 1, "\u{10437}"], [66576, 1, "\u{10438}"], [66577, 1, "\u{10439}"], [66578, 1, "\u{1043A}"], [66579, 1, "\u{1043B}"], [66580, 1, "\u{1043C}"], [66581, 1, "\u{1043D}"], [66582, 1, "\u{1043E}"], [66583, 1, "\u{1043F}"], [66584, 1, "\u{10440}"], [66585, 1, "\u{10441}"], [66586, 1, "\u{10442}"], [66587, 1, "\u{10443}"], [66588, 1, "\u{10444}"], [66589, 1, "\u{10445}"], [66590, 1, "\u{10446}"], [66591, 1, "\u{10447}"], [66592, 1, "\u{10448}"], [66593, 1, "\u{10449}"], [66594, 1, "\u{1044A}"], [66595, 1, "\u{1044B}"], [66596, 1, "\u{1044C}"], [66597, 1, "\u{1044D}"], [66598, 1, "\u{1044E}"], [66599, 1, "\u{1044F}"], [[66600, 66637], 2], [[66638, 66717], 2], [[66718, 66719], 3], [[66720, 66729], 2], [[66730, 66735], 3], [66736, 1, "\u{104D8}"], [66737, 1, "\u{104D9}"], [66738, 1, "\u{104DA}"], [66739, 1, "\u{104DB}"], [66740, 1, "\u{104DC}"], [66741, 1, "\u{104DD}"], [66742, 1, "\u{104DE}"], [66743, 1, "\u{104DF}"], [66744, 1, "\u{104E0}"], [66745, 1, "\u{104E1}"], [66746, 1, "\u{104E2}"], [66747, 1, "\u{104E3}"], [66748, 1, "\u{104E4}"], [66749, 1, "\u{104E5}"], [66750, 1, "\u{104E6}"], [66751, 1, "\u{104E7}"], [66752, 1, "\u{104E8}"], [66753, 1, "\u{104E9}"], [66754, 1, "\u{104EA}"], [66755, 1, "\u{104EB}"], [66756, 1, "\u{104EC}"], [66757, 1, "\u{104ED}"], [66758, 1, "\u{104EE}"], [66759, 1, "\u{104EF}"], [66760, 1, "\u{104F0}"], [66761, 1, "\u{104F1}"], [66762, 1, "\u{104F2}"], [66763, 1, "\u{104F3}"], [66764, 1, "\u{104F4}"], [66765, 1, "\u{104F5}"], [66766, 1, "\u{104F6}"], [66767, 1, "\u{104F7}"], [66768, 1, "\u{104F8}"], [66769, 1, "\u{104F9}"], [66770, 1, "\u{104FA}"], [66771, 1, "\u{104FB}"], [[66772, 66775], 3], [[66776, 66811], 2], [[66812, 66815], 3], [[66816, 66855], 2], [[66856, 66863], 3], [[66864, 66915], 2], [[66916, 66926], 3], [66927, 2], [66928, 1, "\u{10597}"], [66929, 1, "\u{10598}"], [66930, 1, "\u{10599}"], [66931, 1, "\u{1059A}"], [66932, 1, "\u{1059B}"], [66933, 1, "\u{1059C}"], [66934, 1, "\u{1059D}"], [66935, 1, "\u{1059E}"], [66936, 1, "\u{1059F}"], [66937, 1, "\u{105A0}"], [66938, 1, "\u{105A1}"], [66939, 3], [66940, 1, "\u{105A3}"], [66941, 1, "\u{105A4}"], [66942, 1, "\u{105A5}"], [66943, 1, "\u{105A6}"], [66944, 1, "\u{105A7}"], [66945, 1, "\u{105A8}"], [66946, 1, "\u{105A9}"], [66947, 1, "\u{105AA}"], [66948, 1, "\u{105AB}"], [66949, 1, "\u{105AC}"], [66950, 1, "\u{105AD}"], [66951, 1, "\u{105AE}"], [66952, 1, "\u{105AF}"], [66953, 1, "\u{105B0}"], [66954, 1, "\u{105B1}"], [66955, 3], [66956, 1, "\u{105B3}"], [66957, 1, "\u{105B4}"], [66958, 1, "\u{105B5}"], [66959, 1, "\u{105B6}"], [66960, 1, "\u{105B7}"], [66961, 1, "\u{105B8}"], [66962, 1, "\u{105B9}"], [66963, 3], [66964, 1, "\u{105BB}"], [66965, 1, "\u{105BC}"], [66966, 3], [[66967, 66977], 2], [66978, 3], [[66979, 66993], 2], [66994, 3], [[66995, 67001], 2], [67002, 3], [[67003, 67004], 2], [[67005, 67071], 3], [[67072, 67382], 2], [[67383, 67391], 3], [[67392, 67413], 2], [[67414, 67423], 3], [[67424, 67431], 2], [[67432, 67455], 3], [67456, 2], [67457, 1, "\u02D0"], [67458, 1, "\u02D1"], [67459, 1, "\xE6"], [67460, 1, "\u0299"], [67461, 1, "\u0253"], [67462, 3], [67463, 1, "\u02A3"], [67464, 1, "\uAB66"], [67465, 1, "\u02A5"], [67466, 1, "\u02A4"], [67467, 1, "\u0256"], [67468, 1, "\u0257"], [67469, 1, "\u1D91"], [67470, 1, "\u0258"], [67471, 1, "\u025E"], [67472, 1, "\u02A9"], [67473, 1, "\u0264"], [67474, 1, "\u0262"], [67475, 1, "\u0260"], [67476, 1, "\u029B"], [67477, 1, "\u0127"], [67478, 1, "\u029C"], [67479, 1, "\u0267"], [67480, 1, "\u0284"], [67481, 1, "\u02AA"], [67482, 1, "\u02AB"], [67483, 1, "\u026C"], [67484, 1, "\u{1DF04}"], [67485, 1, "\uA78E"], [67486, 1, "\u026E"], [67487, 1, "\u{1DF05}"], [67488, 1, "\u028E"], [67489, 1, "\u{1DF06}"], [67490, 1, "\xF8"], [67491, 1, "\u0276"], [67492, 1, "\u0277"], [67493, 1, "q"], [67494, 1, "\u027A"], [67495, 1, "\u{1DF08}"], [67496, 1, "\u027D"], [67497, 1, "\u027E"], [67498, 1, "\u0280"], [67499, 1, "\u02A8"], [67500, 1, "\u02A6"], [67501, 1, "\uAB67"], [67502, 1, "\u02A7"], [67503, 1, "\u0288"], [67504, 1, "\u2C71"], [67505, 3], [67506, 1, "\u028F"], [67507, 1, "\u02A1"], [67508, 1, "\u02A2"], [67509, 1, "\u0298"], [67510, 1, "\u01C0"], [67511, 1, "\u01C1"], [67512, 1, "\u01C2"], [67513, 1, "\u{1DF0A}"], [67514, 1, "\u{1DF1E}"], [[67515, 67583], 3], [[67584, 67589], 2], [[67590, 67591], 3], [67592, 2], [67593, 3], [[67594, 67637], 2], [67638, 3], [[67639, 67640], 2], [[67641, 67643], 3], [67644, 2], [[67645, 67646], 3], [67647, 2], [[67648, 67669], 2], [67670, 3], [[67671, 67679], 2], [[67680, 67702], 2], [[67703, 67711], 2], [[67712, 67742], 2], [[67743, 67750], 3], [[67751, 67759], 2], [[67760, 67807], 3], [[67808, 67826], 2], [67827, 3], [[67828, 67829], 2], [[67830, 67834], 3], [[67835, 67839], 2], [[67840, 67861], 2], [[67862, 67865], 2], [[67866, 67867], 2], [[67868, 67870], 3], [67871, 2], [[67872, 67897], 2], [[67898, 67902], 3], [67903, 2], [[67904, 67967], 3], [[67968, 68023], 2], [[68024, 68027], 3], [[68028, 68029], 2], [[68030, 68031], 2], [[68032, 68047], 2], [[68048, 68049], 3], [[68050, 68095], 2], [[68096, 68099], 2], [68100, 3], [[68101, 68102], 2], [[68103, 68107], 3], [[68108, 68115], 2], [68116, 3], [[68117, 68119], 2], [68120, 3], [[68121, 68147], 2], [[68148, 68149], 2], [[68150, 68151], 3], [[68152, 68154], 2], [[68155, 68158], 3], [68159, 2], [[68160, 68167], 2], [68168, 2], [[68169, 68175], 3], [[68176, 68184], 2], [[68185, 68191], 3], [[68192, 68220], 2], [[68221, 68223], 2], [[68224, 68252], 2], [[68253, 68255], 2], [[68256, 68287], 3], [[68288, 68295], 2], [68296, 2], [[68297, 68326], 2], [[68327, 68330], 3], [[68331, 68342], 2], [[68343, 68351], 3], [[68352, 68405], 2], [[68406, 68408], 3], [[68409, 68415], 2], [[68416, 68437], 2], [[68438, 68439], 3], [[68440, 68447], 2], [[68448, 68466], 2], [[68467, 68471], 3], [[68472, 68479], 2], [[68480, 68497], 2], [[68498, 68504], 3], [[68505, 68508], 2], [[68509, 68520], 3], [[68521, 68527], 2], [[68528, 68607], 3], [[68608, 68680], 2], [[68681, 68735], 3], [68736, 1, "\u{10CC0}"], [68737, 1, "\u{10CC1}"], [68738, 1, "\u{10CC2}"], [68739, 1, "\u{10CC3}"], [68740, 1, "\u{10CC4}"], [68741, 1, "\u{10CC5}"], [68742, 1, "\u{10CC6}"], [68743, 1, "\u{10CC7}"], [68744, 1, "\u{10CC8}"], [68745, 1, "\u{10CC9}"], [68746, 1, "\u{10CCA}"], [68747, 1, "\u{10CCB}"], [68748, 1, "\u{10CCC}"], [68749, 1, "\u{10CCD}"], [68750, 1, "\u{10CCE}"], [68751, 1, "\u{10CCF}"], [68752, 1, "\u{10CD0}"], [68753, 1, "\u{10CD1}"], [68754, 1, "\u{10CD2}"], [68755, 1, "\u{10CD3}"], [68756, 1, "\u{10CD4}"], [68757, 1, "\u{10CD5}"], [68758, 1, "\u{10CD6}"], [68759, 1, "\u{10CD7}"], [68760, 1, "\u{10CD8}"], [68761, 1, "\u{10CD9}"], [68762, 1, "\u{10CDA}"], [68763, 1, "\u{10CDB}"], [68764, 1, "\u{10CDC}"], [68765, 1, "\u{10CDD}"], [68766, 1, "\u{10CDE}"], [68767, 1, "\u{10CDF}"], [68768, 1, "\u{10CE0}"], [68769, 1, "\u{10CE1}"], [68770, 1, "\u{10CE2}"], [68771, 1, "\u{10CE3}"], [68772, 1, "\u{10CE4}"], [68773, 1, "\u{10CE5}"], [68774, 1, "\u{10CE6}"], [68775, 1, "\u{10CE7}"], [68776, 1, "\u{10CE8}"], [68777, 1, "\u{10CE9}"], [68778, 1, "\u{10CEA}"], [68779, 1, "\u{10CEB}"], [68780, 1, "\u{10CEC}"], [68781, 1, "\u{10CED}"], [68782, 1, "\u{10CEE}"], [68783, 1, "\u{10CEF}"], [68784, 1, "\u{10CF0}"], [68785, 1, "\u{10CF1}"], [68786, 1, "\u{10CF2}"], [[68787, 68799], 3], [[68800, 68850], 2], [[68851, 68857], 3], [[68858, 68863], 2], [[68864, 68903], 2], [[68904, 68911], 3], [[68912, 68921], 2], [[68922, 69215], 3], [[69216, 69246], 2], [69247, 3], [[69248, 69289], 2], [69290, 3], [[69291, 69292], 2], [69293, 2], [[69294, 69295], 3], [[69296, 69297], 2], [[69298, 69372], 3], [[69373, 69375], 2], [[69376, 69404], 2], [[69405, 69414], 2], [69415, 2], [[69416, 69423], 3], [[69424, 69456], 2], [[69457, 69465], 2], [[69466, 69487], 3], [[69488, 69509], 2], [[69510, 69513], 2], [[69514, 69551], 3], [[69552, 69572], 2], [[69573, 69579], 2], [[69580, 69599], 3], [[69600, 69622], 2], [[69623, 69631], 3], [[69632, 69702], 2], [[69703, 69709], 2], [[69710, 69713], 3], [[69714, 69733], 2], [[69734, 69743], 2], [[69744, 69749], 2], [[69750, 69758], 3], [69759, 2], [[69760, 69818], 2], [[69819, 69820], 2], [69821, 3], [[69822, 69825], 2], [69826, 2], [[69827, 69836], 3], [69837, 3], [[69838, 69839], 3], [[69840, 69864], 2], [[69865, 69871], 3], [[69872, 69881], 2], [[69882, 69887], 3], [[69888, 69940], 2], [69941, 3], [[69942, 69951], 2], [[69952, 69955], 2], [[69956, 69958], 2], [69959, 2], [[69960, 69967], 3], [[69968, 70003], 2], [[70004, 70005], 2], [70006, 2], [[70007, 70015], 3], [[70016, 70084], 2], [[70085, 70088], 2], [[70089, 70092], 2], [70093, 2], [[70094, 70095], 2], [[70096, 70105], 2], [70106, 2], [70107, 2], [70108, 2], [[70109, 70111], 2], [70112, 3], [[70113, 70132], 2], [[70133, 70143], 3], [[70144, 70161], 2], [70162, 3], [[70163, 70199], 2], [[70200, 70205], 2], [70206, 2], [[70207, 70209], 2], [[70210, 70271], 3], [[70272, 70278], 2], [70279, 3], [70280, 2], [70281, 3], [[70282, 70285], 2], [70286, 3], [[70287, 70301], 2], [70302, 3], [[70303, 70312], 2], [70313, 2], [[70314, 70319], 3], [[70320, 70378], 2], [[70379, 70383], 3], [[70384, 70393], 2], [[70394, 70399], 3], [70400, 2], [[70401, 70403], 2], [70404, 3], [[70405, 70412], 2], [[70413, 70414], 3], [[70415, 70416], 2], [[70417, 70418], 3], [[70419, 70440], 2], [70441, 3], [[70442, 70448], 2], [70449, 3], [[70450, 70451], 2], [70452, 3], [[70453, 70457], 2], [70458, 3], [70459, 2], [[70460, 70468], 2], [[70469, 70470], 3], [[70471, 70472], 2], [[70473, 70474], 3], [[70475, 70477], 2], [[70478, 70479], 3], [70480, 2], [[70481, 70486], 3], [70487, 2], [[70488, 70492], 3], [[70493, 70499], 2], [[70500, 70501], 3], [[70502, 70508], 2], [[70509, 70511], 3], [[70512, 70516], 2], [[70517, 70655], 3], [[70656, 70730], 2], [[70731, 70735], 2], [[70736, 70745], 2], [70746, 2], [70747, 2], [70748, 3], [70749, 2], [70750, 2], [70751, 2], [[70752, 70753], 2], [[70754, 70783], 3], [[70784, 70853], 2], [70854, 2], [70855, 2], [[70856, 70863], 3], [[70864, 70873], 2], [[70874, 71039], 3], [[71040, 71093], 2], [[71094, 71095], 3], [[71096, 71104], 2], [[71105, 71113], 2], [[71114, 71127], 2], [[71128, 71133], 2], [[71134, 71167], 3], [[71168, 71232], 2], [[71233, 71235], 2], [71236, 2], [[71237, 71247], 3], [[71248, 71257], 2], [[71258, 71263], 3], [[71264, 71276], 2], [[71277, 71295], 3], [[71296, 71351], 2], [71352, 2], [71353, 2], [[71354, 71359], 3], [[71360, 71369], 2], [[71370, 71423], 3], [[71424, 71449], 2], [71450, 2], [[71451, 71452], 3], [[71453, 71467], 2], [[71468, 71471], 3], [[71472, 71481], 2], [[71482, 71487], 2], [[71488, 71494], 2], [[71495, 71679], 3], [[71680, 71738], 2], [71739, 2], [[71740, 71839], 3], [71840, 1, "\u{118C0}"], [71841, 1, "\u{118C1}"], [71842, 1, "\u{118C2}"], [71843, 1, "\u{118C3}"], [71844, 1, "\u{118C4}"], [71845, 1, "\u{118C5}"], [71846, 1, "\u{118C6}"], [71847, 1, "\u{118C7}"], [71848, 1, "\u{118C8}"], [71849, 1, "\u{118C9}"], [71850, 1, "\u{118CA}"], [71851, 1, "\u{118CB}"], [71852, 1, "\u{118CC}"], [71853, 1, "\u{118CD}"], [71854, 1, "\u{118CE}"], [71855, 1, "\u{118CF}"], [71856, 1, "\u{118D0}"], [71857, 1, "\u{118D1}"], [71858, 1, "\u{118D2}"], [71859, 1, "\u{118D3}"], [71860, 1, "\u{118D4}"], [71861, 1, "\u{118D5}"], [71862, 1, "\u{118D6}"], [71863, 1, "\u{118D7}"], [71864, 1, "\u{118D8}"], [71865, 1, "\u{118D9}"], [71866, 1, "\u{118DA}"], [71867, 1, "\u{118DB}"], [71868, 1, "\u{118DC}"], [71869, 1, "\u{118DD}"], [71870, 1, "\u{118DE}"], [71871, 1, "\u{118DF}"], [[71872, 71913], 2], [[71914, 71922], 2], [[71923, 71934], 3], [71935, 2], [[71936, 71942], 2], [[71943, 71944], 3], [71945, 2], [[71946, 71947], 3], [[71948, 71955], 2], [71956, 3], [[71957, 71958], 2], [71959, 3], [[71960, 71989], 2], [71990, 3], [[71991, 71992], 2], [[71993, 71994], 3], [[71995, 72003], 2], [[72004, 72006], 2], [[72007, 72015], 3], [[72016, 72025], 2], [[72026, 72095], 3], [[72096, 72103], 2], [[72104, 72105], 3], [[72106, 72151], 2], [[72152, 72153], 3], [[72154, 72161], 2], [72162, 2], [[72163, 72164], 2], [[72165, 72191], 3], [[72192, 72254], 2], [[72255, 72262], 2], [72263, 2], [[72264, 72271], 3], [[72272, 72323], 2], [[72324, 72325], 2], [[72326, 72345], 2], [[72346, 72348], 2], [72349, 2], [[72350, 72354], 2], [[72355, 72367], 3], [[72368, 72383], 2], [[72384, 72440], 2], [[72441, 72447], 3], [[72448, 72457], 2], [[72458, 72703], 3], [[72704, 72712], 2], [72713, 3], [[72714, 72758], 2], [72759, 3], [[72760, 72768], 2], [[72769, 72773], 2], [[72774, 72783], 3], [[72784, 72793], 2], [[72794, 72812], 2], [[72813, 72815], 3], [[72816, 72817], 2], [[72818, 72847], 2], [[72848, 72849], 3], [[72850, 72871], 2], [72872, 3], [[72873, 72886], 2], [[72887, 72959], 3], [[72960, 72966], 2], [72967, 3], [[72968, 72969], 2], [72970, 3], [[72971, 73014], 2], [[73015, 73017], 3], [73018, 2], [73019, 3], [[73020, 73021], 2], [73022, 3], [[73023, 73031], 2], [[73032, 73039], 3], [[73040, 73049], 2], [[73050, 73055], 3], [[73056, 73061], 2], [73062, 3], [[73063, 73064], 2], [73065, 3], [[73066, 73102], 2], [73103, 3], [[73104, 73105], 2], [73106, 3], [[73107, 73112], 2], [[73113, 73119], 3], [[73120, 73129], 2], [[73130, 73439], 3], [[73440, 73462], 2], [[73463, 73464], 2], [[73465, 73471], 3], [[73472, 73488], 2], [73489, 3], [[73490, 73530], 2], [[73531, 73533], 3], [[73534, 73538], 2], [[73539, 73551], 2], [[73552, 73561], 2], [[73562, 73647], 3], [73648, 2], [[73649, 73663], 3], [[73664, 73713], 2], [[73714, 73726], 3], [73727, 2], [[73728, 74606], 2], [[74607, 74648], 2], [74649, 2], [[74650, 74751], 3], [[74752, 74850], 2], [[74851, 74862], 2], [74863, 3], [[74864, 74867], 2], [74868, 2], [[74869, 74879], 3], [[74880, 75075], 2], [[75076, 77711], 3], [[77712, 77808], 2], [[77809, 77810], 2], [[77811, 77823], 3], [[77824, 78894], 2], [78895, 2], [[78896, 78904], 3], [[78905, 78911], 3], [[78912, 78933], 2], [[78934, 82943], 3], [[82944, 83526], 2], [[83527, 92159], 3], [[92160, 92728], 2], [[92729, 92735], 3], [[92736, 92766], 2], [92767, 3], [[92768, 92777], 2], [[92778, 92781], 3], [[92782, 92783], 2], [[92784, 92862], 2], [92863, 3], [[92864, 92873], 2], [[92874, 92879], 3], [[92880, 92909], 2], [[92910, 92911], 3], [[92912, 92916], 2], [92917, 2], [[92918, 92927], 3], [[92928, 92982], 2], [[92983, 92991], 2], [[92992, 92995], 2], [[92996, 92997], 2], [[92998, 93007], 3], [[93008, 93017], 2], [93018, 3], [[93019, 93025], 2], [93026, 3], [[93027, 93047], 2], [[93048, 93052], 3], [[93053, 93071], 2], [[93072, 93759], 3], [93760, 1, "\u{16E60}"], [93761, 1, "\u{16E61}"], [93762, 1, "\u{16E62}"], [93763, 1, "\u{16E63}"], [93764, 1, "\u{16E64}"], [93765, 1, "\u{16E65}"], [93766, 1, "\u{16E66}"], [93767, 1, "\u{16E67}"], [93768, 1, "\u{16E68}"], [93769, 1, "\u{16E69}"], [93770, 1, "\u{16E6A}"], [93771, 1, "\u{16E6B}"], [93772, 1, "\u{16E6C}"], [93773, 1, "\u{16E6D}"], [93774, 1, "\u{16E6E}"], [93775, 1, "\u{16E6F}"], [93776, 1, "\u{16E70}"], [93777, 1, "\u{16E71}"], [93778, 1, "\u{16E72}"], [93779, 1, "\u{16E73}"], [93780, 1, "\u{16E74}"], [93781, 1, "\u{16E75}"], [93782, 1, "\u{16E76}"], [93783, 1, "\u{16E77}"], [93784, 1, "\u{16E78}"], [93785, 1, "\u{16E79}"], [93786, 1, "\u{16E7A}"], [93787, 1, "\u{16E7B}"], [93788, 1, "\u{16E7C}"], [93789, 1, "\u{16E7D}"], [93790, 1, "\u{16E7E}"], [93791, 1, "\u{16E7F}"], [[93792, 93823], 2], [[93824, 93850], 2], [[93851, 93951], 3], [[93952, 94020], 2], [[94021, 94026], 2], [[94027, 94030], 3], [94031, 2], [[94032, 94078], 2], [[94079, 94087], 2], [[94088, 94094], 3], [[94095, 94111], 2], [[94112, 94175], 3], [94176, 2], [94177, 2], [94178, 2], [94179, 2], [94180, 2], [[94181, 94191], 3], [[94192, 94193], 2], [[94194, 94207], 3], [[94208, 100332], 2], [[100333, 100337], 2], [[100338, 100343], 2], [[100344, 100351], 3], [[100352, 101106], 2], [[101107, 101589], 2], [[101590, 101631], 3], [[101632, 101640], 2], [[101641, 110575], 3], [[110576, 110579], 2], [110580, 3], [[110581, 110587], 2], [110588, 3], [[110589, 110590], 2], [110591, 3], [[110592, 110593], 2], [[110594, 110878], 2], [[110879, 110882], 2], [[110883, 110897], 3], [110898, 2], [[110899, 110927], 3], [[110928, 110930], 2], [[110931, 110932], 3], [110933, 2], [[110934, 110947], 3], [[110948, 110951], 2], [[110952, 110959], 3], [[110960, 111355], 2], [[111356, 113663], 3], [[113664, 113770], 2], [[113771, 113775], 3], [[113776, 113788], 2], [[113789, 113791], 3], [[113792, 113800], 2], [[113801, 113807], 3], [[113808, 113817], 2], [[113818, 113819], 3], [113820, 2], [[113821, 113822], 2], [113823, 2], [[113824, 113827], 7], [[113828, 118527], 3], [[118528, 118573], 2], [[118574, 118575], 3], [[118576, 118598], 2], [[118599, 118607], 3], [[118608, 118723], 2], [[118724, 118783], 3], [[118784, 119029], 2], [[119030, 119039], 3], [[119040, 119078], 2], [[119079, 119080], 3], [119081, 2], [[119082, 119133], 2], [119134, 1, "\u{1D157}\u{1D165}"], [119135, 1, "\u{1D158}\u{1D165}"], [119136, 1, "\u{1D158}\u{1D165}\u{1D16E}"], [119137, 1, "\u{1D158}\u{1D165}\u{1D16F}"], [119138, 1, "\u{1D158}\u{1D165}\u{1D170}"], [119139, 1, "\u{1D158}\u{1D165}\u{1D171}"], [119140, 1, "\u{1D158}\u{1D165}\u{1D172}"], [[119141, 119154], 2], [[119155, 119162], 3], [[119163, 119226], 2], [119227, 1, "\u{1D1B9}\u{1D165}"], [119228, 1, "\u{1D1BA}\u{1D165}"], [119229, 1, "\u{1D1B9}\u{1D165}\u{1D16E}"], [119230, 1, "\u{1D1BA}\u{1D165}\u{1D16E}"], [119231, 1, "\u{1D1B9}\u{1D165}\u{1D16F}"], [119232, 1, "\u{1D1BA}\u{1D165}\u{1D16F}"], [[119233, 119261], 2], [[119262, 119272], 2], [[119273, 119274], 2], [[119275, 119295], 3], [[119296, 119365], 2], [[119366, 119487], 3], [[119488, 119507], 2], [[119508, 119519], 3], [[119520, 119539], 2], [[119540, 119551], 3], [[119552, 119638], 2], [[119639, 119647], 3], [[119648, 119665], 2], [[119666, 119672], 2], [[119673, 119807], 3], [119808, 1, "a"], [119809, 1, "b"], [119810, 1, "c"], [119811, 1, "d"], [119812, 1, "e"], [119813, 1, "f"], [119814, 1, "g"], [119815, 1, "h"], [119816, 1, "i"], [119817, 1, "j"], [119818, 1, "k"], [119819, 1, "l"], [119820, 1, "m"], [119821, 1, "n"], [119822, 1, "o"], [119823, 1, "p"], [119824, 1, "q"], [119825, 1, "r"], [119826, 1, "s"], [119827, 1, "t"], [119828, 1, "u"], [119829, 1, "v"], [119830, 1, "w"], [119831, 1, "x"], [119832, 1, "y"], [119833, 1, "z"], [119834, 1, "a"], [119835, 1, "b"], [119836, 1, "c"], [119837, 1, "d"], [119838, 1, "e"], [119839, 1, "f"], [119840, 1, "g"], [119841, 1, "h"], [119842, 1, "i"], [119843, 1, "j"], [119844, 1, "k"], [119845, 1, "l"], [119846, 1, "m"], [119847, 1, "n"], [119848, 1, "o"], [119849, 1, "p"], [119850, 1, "q"], [119851, 1, "r"], [119852, 1, "s"], [119853, 1, "t"], [119854, 1, "u"], [119855, 1, "v"], [119856, 1, "w"], [119857, 1, "x"], [119858, 1, "y"], [119859, 1, "z"], [119860, 1, "a"], [119861, 1, "b"], [119862, 1, "c"], [119863, 1, "d"], [119864, 1, "e"], [119865, 1, "f"], [119866, 1, "g"], [119867, 1, "h"], [119868, 1, "i"], [119869, 1, "j"], [119870, 1, "k"], [119871, 1, "l"], [119872, 1, "m"], [119873, 1, "n"], [119874, 1, "o"], [119875, 1, "p"], [119876, 1, "q"], [119877, 1, "r"], [119878, 1, "s"], [119879, 1, "t"], [119880, 1, "u"], [119881, 1, "v"], [119882, 1, "w"], [119883, 1, "x"], [119884, 1, "y"], [119885, 1, "z"], [119886, 1, "a"], [119887, 1, "b"], [119888, 1, "c"], [119889, 1, "d"], [119890, 1, "e"], [119891, 1, "f"], [119892, 1, "g"], [119893, 3], [119894, 1, "i"], [119895, 1, "j"], [119896, 1, "k"], [119897, 1, "l"], [119898, 1, "m"], [119899, 1, "n"], [119900, 1, "o"], [119901, 1, "p"], [119902, 1, "q"], [119903, 1, "r"], [119904, 1, "s"], [119905, 1, "t"], [119906, 1, "u"], [119907, 1, "v"], [119908, 1, "w"], [119909, 1, "x"], [119910, 1, "y"], [119911, 1, "z"], [119912, 1, "a"], [119913, 1, "b"], [119914, 1, "c"], [119915, 1, "d"], [119916, 1, "e"], [119917, 1, "f"], [119918, 1, "g"], [119919, 1, "h"], [119920, 1, "i"], [119921, 1, "j"], [119922, 1, "k"], [119923, 1, "l"], [119924, 1, "m"], [119925, 1, "n"], [119926, 1, "o"], [119927, 1, "p"], [119928, 1, "q"], [119929, 1, "r"], [119930, 1, "s"], [119931, 1, "t"], [119932, 1, "u"], [119933, 1, "v"], [119934, 1, "w"], [119935, 1, "x"], [119936, 1, "y"], [119937, 1, "z"], [119938, 1, "a"], [119939, 1, "b"], [119940, 1, "c"], [119941, 1, "d"], [119942, 1, "e"], [119943, 1, "f"], [119944, 1, "g"], [119945, 1, "h"], [119946, 1, "i"], [119947, 1, "j"], [119948, 1, "k"], [119949, 1, "l"], [119950, 1, "m"], [119951, 1, "n"], [119952, 1, "o"], [119953, 1, "p"], [119954, 1, "q"], [119955, 1, "r"], [119956, 1, "s"], [119957, 1, "t"], [119958, 1, "u"], [119959, 1, "v"], [119960, 1, "w"], [119961, 1, "x"], [119962, 1, "y"], [119963, 1, "z"], [119964, 1, "a"], [119965, 3], [119966, 1, "c"], [119967, 1, "d"], [[119968, 119969], 3], [119970, 1, "g"], [[119971, 119972], 3], [119973, 1, "j"], [119974, 1, "k"], [[119975, 119976], 3], [119977, 1, "n"], [119978, 1, "o"], [119979, 1, "p"], [119980, 1, "q"], [119981, 3], [119982, 1, "s"], [119983, 1, "t"], [119984, 1, "u"], [119985, 1, "v"], [119986, 1, "w"], [119987, 1, "x"], [119988, 1, "y"], [119989, 1, "z"], [119990, 1, "a"], [119991, 1, "b"], [119992, 1, "c"], [119993, 1, "d"], [119994, 3], [119995, 1, "f"], [119996, 3], [119997, 1, "h"], [119998, 1, "i"], [119999, 1, "j"], [12e4, 1, "k"], [120001, 1, "l"], [120002, 1, "m"], [120003, 1, "n"], [120004, 3], [120005, 1, "p"], [120006, 1, "q"], [120007, 1, "r"], [120008, 1, "s"], [120009, 1, "t"], [120010, 1, "u"], [120011, 1, "v"], [120012, 1, "w"], [120013, 1, "x"], [120014, 1, "y"], [120015, 1, "z"], [120016, 1, "a"], [120017, 1, "b"], [120018, 1, "c"], [120019, 1, "d"], [120020, 1, "e"], [120021, 1, "f"], [120022, 1, "g"], [120023, 1, "h"], [120024, 1, "i"], [120025, 1, "j"], [120026, 1, "k"], [120027, 1, "l"], [120028, 1, "m"], [120029, 1, "n"], [120030, 1, "o"], [120031, 1, "p"], [120032, 1, "q"], [120033, 1, "r"], [120034, 1, "s"], [120035, 1, "t"], [120036, 1, "u"], [120037, 1, "v"], [120038, 1, "w"], [120039, 1, "x"], [120040, 1, "y"], [120041, 1, "z"], [120042, 1, "a"], [120043, 1, "b"], [120044, 1, "c"], [120045, 1, "d"], [120046, 1, "e"], [120047, 1, "f"], [120048, 1, "g"], [120049, 1, "h"], [120050, 1, "i"], [120051, 1, "j"], [120052, 1, "k"], [120053, 1, "l"], [120054, 1, "m"], [120055, 1, "n"], [120056, 1, "o"], [120057, 1, "p"], [120058, 1, "q"], [120059, 1, "r"], [120060, 1, "s"], [120061, 1, "t"], [120062, 1, "u"], [120063, 1, "v"], [120064, 1, "w"], [120065, 1, "x"], [120066, 1, "y"], [120067, 1, "z"], [120068, 1, "a"], [120069, 1, "b"], [120070, 3], [120071, 1, "d"], [120072, 1, "e"], [120073, 1, "f"], [120074, 1, "g"], [[120075, 120076], 3], [120077, 1, "j"], [120078, 1, "k"], [120079, 1, "l"], [120080, 1, "m"], [120081, 1, "n"], [120082, 1, "o"], [120083, 1, "p"], [120084, 1, "q"], [120085, 3], [120086, 1, "s"], [120087, 1, "t"], [120088, 1, "u"], [120089, 1, "v"], [120090, 1, "w"], [120091, 1, "x"], [120092, 1, "y"], [120093, 3], [120094, 1, "a"], [120095, 1, "b"], [120096, 1, "c"], [120097, 1, "d"], [120098, 1, "e"], [120099, 1, "f"], [120100, 1, "g"], [120101, 1, "h"], [120102, 1, "i"], [120103, 1, "j"], [120104, 1, "k"], [120105, 1, "l"], [120106, 1, "m"], [120107, 1, "n"], [120108, 1, "o"], [120109, 1, "p"], [120110, 1, "q"], [120111, 1, "r"], [120112, 1, "s"], [120113, 1, "t"], [120114, 1, "u"], [120115, 1, "v"], [120116, 1, "w"], [120117, 1, "x"], [120118, 1, "y"], [120119, 1, "z"], [120120, 1, "a"], [120121, 1, "b"], [120122, 3], [120123, 1, "d"], [120124, 1, "e"], [120125, 1, "f"], [120126, 1, "g"], [120127, 3], [120128, 1, "i"], [120129, 1, "j"], [120130, 1, "k"], [120131, 1, "l"], [120132, 1, "m"], [120133, 3], [120134, 1, "o"], [[120135, 120137], 3], [120138, 1, "s"], [120139, 1, "t"], [120140, 1, "u"], [120141, 1, "v"], [120142, 1, "w"], [120143, 1, "x"], [120144, 1, "y"], [120145, 3], [120146, 1, "a"], [120147, 1, "b"], [120148, 1, "c"], [120149, 1, "d"], [120150, 1, "e"], [120151, 1, "f"], [120152, 1, "g"], [120153, 1, "h"], [120154, 1, "i"], [120155, 1, "j"], [120156, 1, "k"], [120157, 1, "l"], [120158, 1, "m"], [120159, 1, "n"], [120160, 1, "o"], [120161, 1, "p"], [120162, 1, "q"], [120163, 1, "r"], [120164, 1, "s"], [120165, 1, "t"], [120166, 1, "u"], [120167, 1, "v"], [120168, 1, "w"], [120169, 1, "x"], [120170, 1, "y"], [120171, 1, "z"], [120172, 1, "a"], [120173, 1, "b"], [120174, 1, "c"], [120175, 1, "d"], [120176, 1, "e"], [120177, 1, "f"], [120178, 1, "g"], [120179, 1, "h"], [120180, 1, "i"], [120181, 1, "j"], [120182, 1, "k"], [120183, 1, "l"], [120184, 1, "m"], [120185, 1, "n"], [120186, 1, "o"], [120187, 1, "p"], [120188, 1, "q"], [120189, 1, "r"], [120190, 1, "s"], [120191, 1, "t"], [120192, 1, "u"], [120193, 1, "v"], [120194, 1, "w"], [120195, 1, "x"], [120196, 1, "y"], [120197, 1, "z"], [120198, 1, "a"], [120199, 1, "b"], [120200, 1, "c"], [120201, 1, "d"], [120202, 1, "e"], [120203, 1, "f"], [120204, 1, "g"], [120205, 1, "h"], [120206, 1, "i"], [120207, 1, "j"], [120208, 1, "k"], [120209, 1, "l"], [120210, 1, "m"], [120211, 1, "n"], [120212, 1, "o"], [120213, 1, "p"], [120214, 1, "q"], [120215, 1, "r"], [120216, 1, "s"], [120217, 1, "t"], [120218, 1, "u"], [120219, 1, "v"], [120220, 1, "w"], [120221, 1, "x"], [120222, 1, "y"], [120223, 1, "z"], [120224, 1, "a"], [120225, 1, "b"], [120226, 1, "c"], [120227, 1, "d"], [120228, 1, "e"], [120229, 1, "f"], [120230, 1, "g"], [120231, 1, "h"], [120232, 1, "i"], [120233, 1, "j"], [120234, 1, "k"], [120235, 1, "l"], [120236, 1, "m"], [120237, 1, "n"], [120238, 1, "o"], [120239, 1, "p"], [120240, 1, "q"], [120241, 1, "r"], [120242, 1, "s"], [120243, 1, "t"], [120244, 1, "u"], [120245, 1, "v"], [120246, 1, "w"], [120247, 1, "x"], [120248, 1, "y"], [120249, 1, "z"], [120250, 1, "a"], [120251, 1, "b"], [120252, 1, "c"], [120253, 1, "d"], [120254, 1, "e"], [120255, 1, "f"], [120256, 1, "g"], [120257, 1, "h"], [120258, 1, "i"], [120259, 1, "j"], [120260, 1, "k"], [120261, 1, "l"], [120262, 1, "m"], [120263, 1, "n"], [120264, 1, "o"], [120265, 1, "p"], [120266, 1, "q"], [120267, 1, "r"], [120268, 1, "s"], [120269, 1, "t"], [120270, 1, "u"], [120271, 1, "v"], [120272, 1, "w"], [120273, 1, "x"], [120274, 1, "y"], [120275, 1, "z"], [120276, 1, "a"], [120277, 1, "b"], [120278, 1, "c"], [120279, 1, "d"], [120280, 1, "e"], [120281, 1, "f"], [120282, 1, "g"], [120283, 1, "h"], [120284, 1, "i"], [120285, 1, "j"], [120286, 1, "k"], [120287, 1, "l"], [120288, 1, "m"], [120289, 1, "n"], [120290, 1, "o"], [120291, 1, "p"], [120292, 1, "q"], [120293, 1, "r"], [120294, 1, "s"], [120295, 1, "t"], [120296, 1, "u"], [120297, 1, "v"], [120298, 1, "w"], [120299, 1, "x"], [120300, 1, "y"], [120301, 1, "z"], [120302, 1, "a"], [120303, 1, "b"], [120304, 1, "c"], [120305, 1, "d"], [120306, 1, "e"], [120307, 1, "f"], [120308, 1, "g"], [120309, 1, "h"], [120310, 1, "i"], [120311, 1, "j"], [120312, 1, "k"], [120313, 1, "l"], [120314, 1, "m"], [120315, 1, "n"], [120316, 1, "o"], [120317, 1, "p"], [120318, 1, "q"], [120319, 1, "r"], [120320, 1, "s"], [120321, 1, "t"], [120322, 1, "u"], [120323, 1, "v"], [120324, 1, "w"], [120325, 1, "x"], [120326, 1, "y"], [120327, 1, "z"], [120328, 1, "a"], [120329, 1, "b"], [120330, 1, "c"], [120331, 1, "d"], [120332, 1, "e"], [120333, 1, "f"], [120334, 1, "g"], [120335, 1, "h"], [120336, 1, "i"], [120337, 1, "j"], [120338, 1, "k"], [120339, 1, "l"], [120340, 1, "m"], [120341, 1, "n"], [120342, 1, "o"], [120343, 1, "p"], [120344, 1, "q"], [120345, 1, "r"], [120346, 1, "s"], [120347, 1, "t"], [120348, 1, "u"], [120349, 1, "v"], [120350, 1, "w"], [120351, 1, "x"], [120352, 1, "y"], [120353, 1, "z"], [120354, 1, "a"], [120355, 1, "b"], [120356, 1, "c"], [120357, 1, "d"], [120358, 1, "e"], [120359, 1, "f"], [120360, 1, "g"], [120361, 1, "h"], [120362, 1, "i"], [120363, 1, "j"], [120364, 1, "k"], [120365, 1, "l"], [120366, 1, "m"], [120367, 1, "n"], [120368, 1, "o"], [120369, 1, "p"], [120370, 1, "q"], [120371, 1, "r"], [120372, 1, "s"], [120373, 1, "t"], [120374, 1, "u"], [120375, 1, "v"], [120376, 1, "w"], [120377, 1, "x"], [120378, 1, "y"], [120379, 1, "z"], [120380, 1, "a"], [120381, 1, "b"], [120382, 1, "c"], [120383, 1, "d"], [120384, 1, "e"], [120385, 1, "f"], [120386, 1, "g"], [120387, 1, "h"], [120388, 1, "i"], [120389, 1, "j"], [120390, 1, "k"], [120391, 1, "l"], [120392, 1, "m"], [120393, 1, "n"], [120394, 1, "o"], [120395, 1, "p"], [120396, 1, "q"], [120397, 1, "r"], [120398, 1, "s"], [120399, 1, "t"], [120400, 1, "u"], [120401, 1, "v"], [120402, 1, "w"], [120403, 1, "x"], [120404, 1, "y"], [120405, 1, "z"], [120406, 1, "a"], [120407, 1, "b"], [120408, 1, "c"], [120409, 1, "d"], [120410, 1, "e"], [120411, 1, "f"], [120412, 1, "g"], [120413, 1, "h"], [120414, 1, "i"], [120415, 1, "j"], [120416, 1, "k"], [120417, 1, "l"], [120418, 1, "m"], [120419, 1, "n"], [120420, 1, "o"], [120421, 1, "p"], [120422, 1, "q"], [120423, 1, "r"], [120424, 1, "s"], [120425, 1, "t"], [120426, 1, "u"], [120427, 1, "v"], [120428, 1, "w"], [120429, 1, "x"], [120430, 1, "y"], [120431, 1, "z"], [120432, 1, "a"], [120433, 1, "b"], [120434, 1, "c"], [120435, 1, "d"], [120436, 1, "e"], [120437, 1, "f"], [120438, 1, "g"], [120439, 1, "h"], [120440, 1, "i"], [120441, 1, "j"], [120442, 1, "k"], [120443, 1, "l"], [120444, 1, "m"], [120445, 1, "n"], [120446, 1, "o"], [120447, 1, "p"], [120448, 1, "q"], [120449, 1, "r"], [120450, 1, "s"], [120451, 1, "t"], [120452, 1, "u"], [120453, 1, "v"], [120454, 1, "w"], [120455, 1, "x"], [120456, 1, "y"], [120457, 1, "z"], [120458, 1, "a"], [120459, 1, "b"], [120460, 1, "c"], [120461, 1, "d"], [120462, 1, "e"], [120463, 1, "f"], [120464, 1, "g"], [120465, 1, "h"], [120466, 1, "i"], [120467, 1, "j"], [120468, 1, "k"], [120469, 1, "l"], [120470, 1, "m"], [120471, 1, "n"], [120472, 1, "o"], [120473, 1, "p"], [120474, 1, "q"], [120475, 1, "r"], [120476, 1, "s"], [120477, 1, "t"], [120478, 1, "u"], [120479, 1, "v"], [120480, 1, "w"], [120481, 1, "x"], [120482, 1, "y"], [120483, 1, "z"], [120484, 1, "\u0131"], [120485, 1, "\u0237"], [[120486, 120487], 3], [120488, 1, "\u03B1"], [120489, 1, "\u03B2"], [120490, 1, "\u03B3"], [120491, 1, "\u03B4"], [120492, 1, "\u03B5"], [120493, 1, "\u03B6"], [120494, 1, "\u03B7"], [120495, 1, "\u03B8"], [120496, 1, "\u03B9"], [120497, 1, "\u03BA"], [120498, 1, "\u03BB"], [120499, 1, "\u03BC"], [120500, 1, "\u03BD"], [120501, 1, "\u03BE"], [120502, 1, "\u03BF"], [120503, 1, "\u03C0"], [120504, 1, "\u03C1"], [120505, 1, "\u03B8"], [120506, 1, "\u03C3"], [120507, 1, "\u03C4"], [120508, 1, "\u03C5"], [120509, 1, "\u03C6"], [120510, 1, "\u03C7"], [120511, 1, "\u03C8"], [120512, 1, "\u03C9"], [120513, 1, "\u2207"], [120514, 1, "\u03B1"], [120515, 1, "\u03B2"], [120516, 1, "\u03B3"], [120517, 1, "\u03B4"], [120518, 1, "\u03B5"], [120519, 1, "\u03B6"], [120520, 1, "\u03B7"], [120521, 1, "\u03B8"], [120522, 1, "\u03B9"], [120523, 1, "\u03BA"], [120524, 1, "\u03BB"], [120525, 1, "\u03BC"], [120526, 1, "\u03BD"], [120527, 1, "\u03BE"], [120528, 1, "\u03BF"], [120529, 1, "\u03C0"], [120530, 1, "\u03C1"], [[120531, 120532], 1, "\u03C3"], [120533, 1, "\u03C4"], [120534, 1, "\u03C5"], [120535, 1, "\u03C6"], [120536, 1, "\u03C7"], [120537, 1, "\u03C8"], [120538, 1, "\u03C9"], [120539, 1, "\u2202"], [120540, 1, "\u03B5"], [120541, 1, "\u03B8"], [120542, 1, "\u03BA"], [120543, 1, "\u03C6"], [120544, 1, "\u03C1"], [120545, 1, "\u03C0"], [120546, 1, "\u03B1"], [120547, 1, "\u03B2"], [120548, 1, "\u03B3"], [120549, 1, "\u03B4"], [120550, 1, "\u03B5"], [120551, 1, "\u03B6"], [120552, 1, "\u03B7"], [120553, 1, "\u03B8"], [120554, 1, "\u03B9"], [120555, 1, "\u03BA"], [120556, 1, "\u03BB"], [120557, 1, "\u03BC"], [120558, 1, "\u03BD"], [120559, 1, "\u03BE"], [120560, 1, "\u03BF"], [120561, 1, "\u03C0"], [120562, 1, "\u03C1"], [120563, 1, "\u03B8"], [120564, 1, "\u03C3"], [120565, 1, "\u03C4"], [120566, 1, "\u03C5"], [120567, 1, "\u03C6"], [120568, 1, "\u03C7"], [120569, 1, "\u03C8"], [120570, 1, "\u03C9"], [120571, 1, "\u2207"], [120572, 1, "\u03B1"], [120573, 1, "\u03B2"], [120574, 1, "\u03B3"], [120575, 1, "\u03B4"], [120576, 1, "\u03B5"], [120577, 1, "\u03B6"], [120578, 1, "\u03B7"], [120579, 1, "\u03B8"], [120580, 1, "\u03B9"], [120581, 1, "\u03BA"], [120582, 1, "\u03BB"], [120583, 1, "\u03BC"], [120584, 1, "\u03BD"], [120585, 1, "\u03BE"], [120586, 1, "\u03BF"], [120587, 1, "\u03C0"], [120588, 1, "\u03C1"], [[120589, 120590], 1, "\u03C3"], [120591, 1, "\u03C4"], [120592, 1, "\u03C5"], [120593, 1, "\u03C6"], [120594, 1, "\u03C7"], [120595, 1, "\u03C8"], [120596, 1, "\u03C9"], [120597, 1, "\u2202"], [120598, 1, "\u03B5"], [120599, 1, "\u03B8"], [120600, 1, "\u03BA"], [120601, 1, "\u03C6"], [120602, 1, "\u03C1"], [120603, 1, "\u03C0"], [120604, 1, "\u03B1"], [120605, 1, "\u03B2"], [120606, 1, "\u03B3"], [120607, 1, "\u03B4"], [120608, 1, "\u03B5"], [120609, 1, "\u03B6"], [120610, 1, "\u03B7"], [120611, 1, "\u03B8"], [120612, 1, "\u03B9"], [120613, 1, "\u03BA"], [120614, 1, "\u03BB"], [120615, 1, "\u03BC"], [120616, 1, "\u03BD"], [120617, 1, "\u03BE"], [120618, 1, "\u03BF"], [120619, 1, "\u03C0"], [120620, 1, "\u03C1"], [120621, 1, "\u03B8"], [120622, 1, "\u03C3"], [120623, 1, "\u03C4"], [120624, 1, "\u03C5"], [120625, 1, "\u03C6"], [120626, 1, "\u03C7"], [120627, 1, "\u03C8"], [120628, 1, "\u03C9"], [120629, 1, "\u2207"], [120630, 1, "\u03B1"], [120631, 1, "\u03B2"], [120632, 1, "\u03B3"], [120633, 1, "\u03B4"], [120634, 1, "\u03B5"], [120635, 1, "\u03B6"], [120636, 1, "\u03B7"], [120637, 1, "\u03B8"], [120638, 1, "\u03B9"], [120639, 1, "\u03BA"], [120640, 1, "\u03BB"], [120641, 1, "\u03BC"], [120642, 1, "\u03BD"], [120643, 1, "\u03BE"], [120644, 1, "\u03BF"], [120645, 1, "\u03C0"], [120646, 1, "\u03C1"], [[120647, 120648], 1, "\u03C3"], [120649, 1, "\u03C4"], [120650, 1, "\u03C5"], [120651, 1, "\u03C6"], [120652, 1, "\u03C7"], [120653, 1, "\u03C8"], [120654, 1, "\u03C9"], [120655, 1, "\u2202"], [120656, 1, "\u03B5"], [120657, 1, "\u03B8"], [120658, 1, "\u03BA"], [120659, 1, "\u03C6"], [120660, 1, "\u03C1"], [120661, 1, "\u03C0"], [120662, 1, "\u03B1"], [120663, 1, "\u03B2"], [120664, 1, "\u03B3"], [120665, 1, "\u03B4"], [120666, 1, "\u03B5"], [120667, 1, "\u03B6"], [120668, 1, "\u03B7"], [120669, 1, "\u03B8"], [120670, 1, "\u03B9"], [120671, 1, "\u03BA"], [120672, 1, "\u03BB"], [120673, 1, "\u03BC"], [120674, 1, "\u03BD"], [120675, 1, "\u03BE"], [120676, 1, "\u03BF"], [120677, 1, "\u03C0"], [120678, 1, "\u03C1"], [120679, 1, "\u03B8"], [120680, 1, "\u03C3"], [120681, 1, "\u03C4"], [120682, 1, "\u03C5"], [120683, 1, "\u03C6"], [120684, 1, "\u03C7"], [120685, 1, "\u03C8"], [120686, 1, "\u03C9"], [120687, 1, "\u2207"], [120688, 1, "\u03B1"], [120689, 1, "\u03B2"], [120690, 1, "\u03B3"], [120691, 1, "\u03B4"], [120692, 1, "\u03B5"], [120693, 1, "\u03B6"], [120694, 1, "\u03B7"], [120695, 1, "\u03B8"], [120696, 1, "\u03B9"], [120697, 1, "\u03BA"], [120698, 1, "\u03BB"], [120699, 1, "\u03BC"], [120700, 1, "\u03BD"], [120701, 1, "\u03BE"], [120702, 1, "\u03BF"], [120703, 1, "\u03C0"], [120704, 1, "\u03C1"], [[120705, 120706], 1, "\u03C3"], [120707, 1, "\u03C4"], [120708, 1, "\u03C5"], [120709, 1, "\u03C6"], [120710, 1, "\u03C7"], [120711, 1, "\u03C8"], [120712, 1, "\u03C9"], [120713, 1, "\u2202"], [120714, 1, "\u03B5"], [120715, 1, "\u03B8"], [120716, 1, "\u03BA"], [120717, 1, "\u03C6"], [120718, 1, "\u03C1"], [120719, 1, "\u03C0"], [120720, 1, "\u03B1"], [120721, 1, "\u03B2"], [120722, 1, "\u03B3"], [120723, 1, "\u03B4"], [120724, 1, "\u03B5"], [120725, 1, "\u03B6"], [120726, 1, "\u03B7"], [120727, 1, "\u03B8"], [120728, 1, "\u03B9"], [120729, 1, "\u03BA"], [120730, 1, "\u03BB"], [120731, 1, "\u03BC"], [120732, 1, "\u03BD"], [120733, 1, "\u03BE"], [120734, 1, "\u03BF"], [120735, 1, "\u03C0"], [120736, 1, "\u03C1"], [120737, 1, "\u03B8"], [120738, 1, "\u03C3"], [120739, 1, "\u03C4"], [120740, 1, "\u03C5"], [120741, 1, "\u03C6"], [120742, 1, "\u03C7"], [120743, 1, "\u03C8"], [120744, 1, "\u03C9"], [120745, 1, "\u2207"], [120746, 1, "\u03B1"], [120747, 1, "\u03B2"], [120748, 1, "\u03B3"], [120749, 1, "\u03B4"], [120750, 1, "\u03B5"], [120751, 1, "\u03B6"], [120752, 1, "\u03B7"], [120753, 1, "\u03B8"], [120754, 1, "\u03B9"], [120755, 1, "\u03BA"], [120756, 1, "\u03BB"], [120757, 1, "\u03BC"], [120758, 1, "\u03BD"], [120759, 1, "\u03BE"], [120760, 1, "\u03BF"], [120761, 1, "\u03C0"], [120762, 1, "\u03C1"], [[120763, 120764], 1, "\u03C3"], [120765, 1, "\u03C4"], [120766, 1, "\u03C5"], [120767, 1, "\u03C6"], [120768, 1, "\u03C7"], [120769, 1, "\u03C8"], [120770, 1, "\u03C9"], [120771, 1, "\u2202"], [120772, 1, "\u03B5"], [120773, 1, "\u03B8"], [120774, 1, "\u03BA"], [120775, 1, "\u03C6"], [120776, 1, "\u03C1"], [120777, 1, "\u03C0"], [[120778, 120779], 1, "\u03DD"], [[120780, 120781], 3], [120782, 1, "0"], [120783, 1, "1"], [120784, 1, "2"], [120785, 1, "3"], [120786, 1, "4"], [120787, 1, "5"], [120788, 1, "6"], [120789, 1, "7"], [120790, 1, "8"], [120791, 1, "9"], [120792, 1, "0"], [120793, 1, "1"], [120794, 1, "2"], [120795, 1, "3"], [120796, 1, "4"], [120797, 1, "5"], [120798, 1, "6"], [120799, 1, "7"], [120800, 1, "8"], [120801, 1, "9"], [120802, 1, "0"], [120803, 1, "1"], [120804, 1, "2"], [120805, 1, "3"], [120806, 1, "4"], [120807, 1, "5"], [120808, 1, "6"], [120809, 1, "7"], [120810, 1, "8"], [120811, 1, "9"], [120812, 1, "0"], [120813, 1, "1"], [120814, 1, "2"], [120815, 1, "3"], [120816, 1, "4"], [120817, 1, "5"], [120818, 1, "6"], [120819, 1, "7"], [120820, 1, "8"], [120821, 1, "9"], [120822, 1, "0"], [120823, 1, "1"], [120824, 1, "2"], [120825, 1, "3"], [120826, 1, "4"], [120827, 1, "5"], [120828, 1, "6"], [120829, 1, "7"], [120830, 1, "8"], [120831, 1, "9"], [[120832, 121343], 2], [[121344, 121398], 2], [[121399, 121402], 2], [[121403, 121452], 2], [[121453, 121460], 2], [121461, 2], [[121462, 121475], 2], [121476, 2], [[121477, 121483], 2], [[121484, 121498], 3], [[121499, 121503], 2], [121504, 3], [[121505, 121519], 2], [[121520, 122623], 3], [[122624, 122654], 2], [[122655, 122660], 3], [[122661, 122666], 2], [[122667, 122879], 3], [[122880, 122886], 2], [122887, 3], [[122888, 122904], 2], [[122905, 122906], 3], [[122907, 122913], 2], [122914, 3], [[122915, 122916], 2], [122917, 3], [[122918, 122922], 2], [[122923, 122927], 3], [122928, 1, "\u0430"], [122929, 1, "\u0431"], [122930, 1, "\u0432"], [122931, 1, "\u0433"], [122932, 1, "\u0434"], [122933, 1, "\u0435"], [122934, 1, "\u0436"], [122935, 1, "\u0437"], [122936, 1, "\u0438"], [122937, 1, "\u043A"], [122938, 1, "\u043B"], [122939, 1, "\u043C"], [122940, 1, "\u043E"], [122941, 1, "\u043F"], [122942, 1, "\u0440"], [122943, 1, "\u0441"], [122944, 1, "\u0442"], [122945, 1, "\u0443"], [122946, 1, "\u0444"], [122947, 1, "\u0445"], [122948, 1, "\u0446"], [122949, 1, "\u0447"], [122950, 1, "\u0448"], [122951, 1, "\u044B"], [122952, 1, "\u044D"], [122953, 1, "\u044E"], [122954, 1, "\uA689"], [122955, 1, "\u04D9"], [122956, 1, "\u0456"], [122957, 1, "\u0458"], [122958, 1, "\u04E9"], [122959, 1, "\u04AF"], [122960, 1, "\u04CF"], [122961, 1, "\u0430"], [122962, 1, "\u0431"], [122963, 1, "\u0432"], [122964, 1, "\u0433"], [122965, 1, "\u0434"], [122966, 1, "\u0435"], [122967, 1, "\u0436"], [122968, 1, "\u0437"], [122969, 1, "\u0438"], [122970, 1, "\u043A"], [122971, 1, "\u043B"], [122972, 1, "\u043E"], [122973, 1, "\u043F"], [122974, 1, "\u0441"], [122975, 1, "\u0443"], [122976, 1, "\u0444"], [122977, 1, "\u0445"], [122978, 1, "\u0446"], [122979, 1, "\u0447"], [122980, 1, "\u0448"], [122981, 1, "\u044A"], [122982, 1, "\u044B"], [122983, 1, "\u0491"], [122984, 1, "\u0456"], [122985, 1, "\u0455"], [122986, 1, "\u045F"], [122987, 1, "\u04AB"], [122988, 1, "\uA651"], [122989, 1, "\u04B1"], [[122990, 123022], 3], [123023, 2], [[123024, 123135], 3], [[123136, 123180], 2], [[123181, 123183], 3], [[123184, 123197], 2], [[123198, 123199], 3], [[123200, 123209], 2], [[123210, 123213], 3], [123214, 2], [123215, 2], [[123216, 123535], 3], [[123536, 123566], 2], [[123567, 123583], 3], [[123584, 123641], 2], [[123642, 123646], 3], [123647, 2], [[123648, 124111], 3], [[124112, 124153], 2], [[124154, 124895], 3], [[124896, 124902], 2], [124903, 3], [[124904, 124907], 2], [124908, 3], [[124909, 124910], 2], [124911, 3], [[124912, 124926], 2], [124927, 3], [[124928, 125124], 2], [[125125, 125126], 3], [[125127, 125135], 2], [[125136, 125142], 2], [[125143, 125183], 3], [125184, 1, "\u{1E922}"], [125185, 1, "\u{1E923}"], [125186, 1, "\u{1E924}"], [125187, 1, "\u{1E925}"], [125188, 1, "\u{1E926}"], [125189, 1, "\u{1E927}"], [125190, 1, "\u{1E928}"], [125191, 1, "\u{1E929}"], [125192, 1, "\u{1E92A}"], [125193, 1, "\u{1E92B}"], [125194, 1, "\u{1E92C}"], [125195, 1, "\u{1E92D}"], [125196, 1, "\u{1E92E}"], [125197, 1, "\u{1E92F}"], [125198, 1, "\u{1E930}"], [125199, 1, "\u{1E931}"], [125200, 1, "\u{1E932}"], [125201, 1, "\u{1E933}"], [125202, 1, "\u{1E934}"], [125203, 1, "\u{1E935}"], [125204, 1, "\u{1E936}"], [125205, 1, "\u{1E937}"], [125206, 1, "\u{1E938}"], [125207, 1, "\u{1E939}"], [125208, 1, "\u{1E93A}"], [125209, 1, "\u{1E93B}"], [125210, 1, "\u{1E93C}"], [125211, 1, "\u{1E93D}"], [125212, 1, "\u{1E93E}"], [125213, 1, "\u{1E93F}"], [125214, 1, "\u{1E940}"], [125215, 1, "\u{1E941}"], [125216, 1, "\u{1E942}"], [125217, 1, "\u{1E943}"], [[125218, 125258], 2], [125259, 2], [[125260, 125263], 3], [[125264, 125273], 2], [[125274, 125277], 3], [[125278, 125279], 2], [[125280, 126064], 3], [[126065, 126132], 2], [[126133, 126208], 3], [[126209, 126269], 2], [[126270, 126463], 3], [126464, 1, "\u0627"], [126465, 1, "\u0628"], [126466, 1, "\u062C"], [126467, 1, "\u062F"], [126468, 3], [126469, 1, "\u0648"], [126470, 1, "\u0632"], [126471, 1, "\u062D"], [126472, 1, "\u0637"], [126473, 1, "\u064A"], [126474, 1, "\u0643"], [126475, 1, "\u0644"], [126476, 1, "\u0645"], [126477, 1, "\u0646"], [126478, 1, "\u0633"], [126479, 1, "\u0639"], [126480, 1, "\u0641"], [126481, 1, "\u0635"], [126482, 1, "\u0642"], [126483, 1, "\u0631"], [126484, 1, "\u0634"], [126485, 1, "\u062A"], [126486, 1, "\u062B"], [126487, 1, "\u062E"], [126488, 1, "\u0630"], [126489, 1, "\u0636"], [126490, 1, "\u0638"], [126491, 1, "\u063A"], [126492, 1, "\u066E"], [126493, 1, "\u06BA"], [126494, 1, "\u06A1"], [126495, 1, "\u066F"], [126496, 3], [126497, 1, "\u0628"], [126498, 1, "\u062C"], [126499, 3], [126500, 1, "\u0647"], [[126501, 126502], 3], [126503, 1, "\u062D"], [126504, 3], [126505, 1, "\u064A"], [126506, 1, "\u0643"], [126507, 1, "\u0644"], [126508, 1, "\u0645"], [126509, 1, "\u0646"], [126510, 1, "\u0633"], [126511, 1, "\u0639"], [126512, 1, "\u0641"], [126513, 1, "\u0635"], [126514, 1, "\u0642"], [126515, 3], [126516, 1, "\u0634"], [126517, 1, "\u062A"], [126518, 1, "\u062B"], [126519, 1, "\u062E"], [126520, 3], [126521, 1, "\u0636"], [126522, 3], [126523, 1, "\u063A"], [[126524, 126529], 3], [126530, 1, "\u062C"], [[126531, 126534], 3], [126535, 1, "\u062D"], [126536, 3], [126537, 1, "\u064A"], [126538, 3], [126539, 1, "\u0644"], [126540, 3], [126541, 1, "\u0646"], [126542, 1, "\u0633"], [126543, 1, "\u0639"], [126544, 3], [126545, 1, "\u0635"], [126546, 1, "\u0642"], [126547, 3], [126548, 1, "\u0634"], [[126549, 126550], 3], [126551, 1, "\u062E"], [126552, 3], [126553, 1, "\u0636"], [126554, 3], [126555, 1, "\u063A"], [126556, 3], [126557, 1, "\u06BA"], [126558, 3], [126559, 1, "\u066F"], [126560, 3], [126561, 1, "\u0628"], [126562, 1, "\u062C"], [126563, 3], [126564, 1, "\u0647"], [[126565, 126566], 3], [126567, 1, "\u062D"], [126568, 1, "\u0637"], [126569, 1, "\u064A"], [126570, 1, "\u0643"], [126571, 3], [126572, 1, "\u0645"], [126573, 1, "\u0646"], [126574, 1, "\u0633"], [126575, 1, "\u0639"], [126576, 1, "\u0641"], [126577, 1, "\u0635"], [126578, 1, "\u0642"], [126579, 3], [126580, 1, "\u0634"], [126581, 1, "\u062A"], [126582, 1, "\u062B"], [126583, 1, "\u062E"], [126584, 3], [126585, 1, "\u0636"], [126586, 1, "\u0638"], [126587, 1, "\u063A"], [126588, 1, "\u066E"], [126589, 3], [126590, 1, "\u06A1"], [126591, 3], [126592, 1, "\u0627"], [126593, 1, "\u0628"], [126594, 1, "\u062C"], [126595, 1, "\u062F"], [126596, 1, "\u0647"], [126597, 1, "\u0648"], [126598, 1, "\u0632"], [126599, 1, "\u062D"], [126600, 1, "\u0637"], [126601, 1, "\u064A"], [126602, 3], [126603, 1, "\u0644"], [126604, 1, "\u0645"], [126605, 1, "\u0646"], [126606, 1, "\u0633"], [126607, 1, "\u0639"], [126608, 1, "\u0641"], [126609, 1, "\u0635"], [126610, 1, "\u0642"], [126611, 1, "\u0631"], [126612, 1, "\u0634"], [126613, 1, "\u062A"], [126614, 1, "\u062B"], [126615, 1, "\u062E"], [126616, 1, "\u0630"], [126617, 1, "\u0636"], [126618, 1, "\u0638"], [126619, 1, "\u063A"], [[126620, 126624], 3], [126625, 1, "\u0628"], [126626, 1, "\u062C"], [126627, 1, "\u062F"], [126628, 3], [126629, 1, "\u0648"], [126630, 1, "\u0632"], [126631, 1, "\u062D"], [126632, 1, "\u0637"], [126633, 1, "\u064A"], [126634, 3], [126635, 1, "\u0644"], [126636, 1, "\u0645"], [126637, 1, "\u0646"], [126638, 1, "\u0633"], [126639, 1, "\u0639"], [126640, 1, "\u0641"], [126641, 1, "\u0635"], [126642, 1, "\u0642"], [126643, 1, "\u0631"], [126644, 1, "\u0634"], [126645, 1, "\u062A"], [126646, 1, "\u062B"], [126647, 1, "\u062E"], [126648, 1, "\u0630"], [126649, 1, "\u0636"], [126650, 1, "\u0638"], [126651, 1, "\u063A"], [[126652, 126703], 3], [[126704, 126705], 2], [[126706, 126975], 3], [[126976, 127019], 2], [[127020, 127023], 3], [[127024, 127123], 2], [[127124, 127135], 3], [[127136, 127150], 2], [[127151, 127152], 3], [[127153, 127166], 2], [127167, 2], [127168, 3], [[127169, 127183], 2], [127184, 3], [[127185, 127199], 2], [[127200, 127221], 2], [[127222, 127231], 3], [127232, 3], [127233, 5, "0,"], [127234, 5, "1,"], [127235, 5, "2,"], [127236, 5, "3,"], [127237, 5, "4,"], [127238, 5, "5,"], [127239, 5, "6,"], [127240, 5, "7,"], [127241, 5, "8,"], [127242, 5, "9,"], [[127243, 127244], 2], [[127245, 127247], 2], [127248, 5, "(a)"], [127249, 5, "(b)"], [127250, 5, "(c)"], [127251, 5, "(d)"], [127252, 5, "(e)"], [127253, 5, "(f)"], [127254, 5, "(g)"], [127255, 5, "(h)"], [127256, 5, "(i)"], [127257, 5, "(j)"], [127258, 5, "(k)"], [127259, 5, "(l)"], [127260, 5, "(m)"], [127261, 5, "(n)"], [127262, 5, "(o)"], [127263, 5, "(p)"], [127264, 5, "(q)"], [127265, 5, "(r)"], [127266, 5, "(s)"], [127267, 5, "(t)"], [127268, 5, "(u)"], [127269, 5, "(v)"], [127270, 5, "(w)"], [127271, 5, "(x)"], [127272, 5, "(y)"], [127273, 5, "(z)"], [127274, 1, "\u3014s\u3015"], [127275, 1, "c"], [127276, 1, "r"], [127277, 1, "cd"], [127278, 1, "wz"], [127279, 2], [127280, 1, "a"], [127281, 1, "b"], [127282, 1, "c"], [127283, 1, "d"], [127284, 1, "e"], [127285, 1, "f"], [127286, 1, "g"], [127287, 1, "h"], [127288, 1, "i"], [127289, 1, "j"], [127290, 1, "k"], [127291, 1, "l"], [127292, 1, "m"], [127293, 1, "n"], [127294, 1, "o"], [127295, 1, "p"], [127296, 1, "q"], [127297, 1, "r"], [127298, 1, "s"], [127299, 1, "t"], [127300, 1, "u"], [127301, 1, "v"], [127302, 1, "w"], [127303, 1, "x"], [127304, 1, "y"], [127305, 1, "z"], [127306, 1, "hv"], [127307, 1, "mv"], [127308, 1, "sd"], [127309, 1, "ss"], [127310, 1, "ppv"], [127311, 1, "wc"], [[127312, 127318], 2], [127319, 2], [[127320, 127326], 2], [127327, 2], [[127328, 127337], 2], [127338, 1, "mc"], [127339, 1, "md"], [127340, 1, "mr"], [[127341, 127343], 2], [[127344, 127352], 2], [127353, 2], [127354, 2], [[127355, 127356], 2], [[127357, 127358], 2], [127359, 2], [[127360, 127369], 2], [[127370, 127373], 2], [[127374, 127375], 2], [127376, 1, "dj"], [[127377, 127386], 2], [[127387, 127404], 2], [127405, 2], [[127406, 127461], 3], [[127462, 127487], 2], [127488, 1, "\u307B\u304B"], [127489, 1, "\u30B3\u30B3"], [127490, 1, "\u30B5"], [[127491, 127503], 3], [127504, 1, "\u624B"], [127505, 1, "\u5B57"], [127506, 1, "\u53CC"], [127507, 1, "\u30C7"], [127508, 1, "\u4E8C"], [127509, 1, "\u591A"], [127510, 1, "\u89E3"], [127511, 1, "\u5929"], [127512, 1, "\u4EA4"], [127513, 1, "\u6620"], [127514, 1, "\u7121"], [127515, 1, "\u6599"], [127516, 1, "\u524D"], [127517, 1, "\u5F8C"], [127518, 1, "\u518D"], [127519, 1, "\u65B0"], [127520, 1, "\u521D"], [127521, 1, "\u7D42"], [127522, 1, "\u751F"], [127523, 1, "\u8CA9"], [127524, 1, "\u58F0"], [127525, 1, "\u5439"], [127526, 1, "\u6F14"], [127527, 1, "\u6295"], [127528, 1, "\u6355"], [127529, 1, "\u4E00"], [127530, 1, "\u4E09"], [127531, 1, "\u904A"], [127532, 1, "\u5DE6"], [127533, 1, "\u4E2D"], [127534, 1, "\u53F3"], [127535, 1, "\u6307"], [127536, 1, "\u8D70"], [127537, 1, "\u6253"], [127538, 1, "\u7981"], [127539, 1, "\u7A7A"], [127540, 1, "\u5408"], [127541, 1, "\u6E80"], [127542, 1, "\u6709"], [127543, 1, "\u6708"], [127544, 1, "\u7533"], [127545, 1, "\u5272"], [127546, 1, "\u55B6"], [127547, 1, "\u914D"], [[127548, 127551], 3], [127552, 1, "\u3014\u672C\u3015"], [127553, 1, "\u3014\u4E09\u3015"], [127554, 1, "\u3014\u4E8C\u3015"], [127555, 1, "\u3014\u5B89\u3015"], [127556, 1, "\u3014\u70B9\u3015"], [127557, 1, "\u3014\u6253\u3015"], [127558, 1, "\u3014\u76D7\u3015"], [127559, 1, "\u3014\u52DD\u3015"], [127560, 1, "\u3014\u6557\u3015"], [[127561, 127567], 3], [127568, 1, "\u5F97"], [127569, 1, "\u53EF"], [[127570, 127583], 3], [[127584, 127589], 2], [[127590, 127743], 3], [[127744, 127776], 2], [[127777, 127788], 2], [[127789, 127791], 2], [[127792, 127797], 2], [127798, 2], [[127799, 127868], 2], [127869, 2], [[127870, 127871], 2], [[127872, 127891], 2], [[127892, 127903], 2], [[127904, 127940], 2], [127941, 2], [[127942, 127946], 2], [[127947, 127950], 2], [[127951, 127955], 2], [[127956, 127967], 2], [[127968, 127984], 2], [[127985, 127991], 2], [[127992, 127999], 2], [[128e3, 128062], 2], [128063, 2], [128064, 2], [128065, 2], [[128066, 128247], 2], [128248, 2], [[128249, 128252], 2], [[128253, 128254], 2], [128255, 2], [[128256, 128317], 2], [[128318, 128319], 2], [[128320, 128323], 2], [[128324, 128330], 2], [[128331, 128335], 2], [[128336, 128359], 2], [[128360, 128377], 2], [128378, 2], [[128379, 128419], 2], [128420, 2], [[128421, 128506], 2], [[128507, 128511], 2], [128512, 2], [[128513, 128528], 2], [128529, 2], [[128530, 128532], 2], [128533, 2], [128534, 2], [128535, 2], [128536, 2], [128537, 2], [128538, 2], [128539, 2], [[128540, 128542], 2], [128543, 2], [[128544, 128549], 2], [[128550, 128551], 2], [[128552, 128555], 2], [128556, 2], [128557, 2], [[128558, 128559], 2], [[128560, 128563], 2], [128564, 2], [[128565, 128576], 2], [[128577, 128578], 2], [[128579, 128580], 2], [[128581, 128591], 2], [[128592, 128639], 2], [[128640, 128709], 2], [[128710, 128719], 2], [128720, 2], [[128721, 128722], 2], [[128723, 128724], 2], [128725, 2], [[128726, 128727], 2], [[128728, 128731], 3], [128732, 2], [[128733, 128735], 2], [[128736, 128748], 2], [[128749, 128751], 3], [[128752, 128755], 2], [[128756, 128758], 2], [[128759, 128760], 2], [128761, 2], [128762, 2], [[128763, 128764], 2], [[128765, 128767], 3], [[128768, 128883], 2], [[128884, 128886], 2], [[128887, 128890], 3], [[128891, 128895], 2], [[128896, 128980], 2], [[128981, 128984], 2], [128985, 2], [[128986, 128991], 3], [[128992, 129003], 2], [[129004, 129007], 3], [129008, 2], [[129009, 129023], 3], [[129024, 129035], 2], [[129036, 129039], 3], [[129040, 129095], 2], [[129096, 129103], 3], [[129104, 129113], 2], [[129114, 129119], 3], [[129120, 129159], 2], [[129160, 129167], 3], [[129168, 129197], 2], [[129198, 129199], 3], [[129200, 129201], 2], [[129202, 129279], 3], [[129280, 129291], 2], [129292, 2], [[129293, 129295], 2], [[129296, 129304], 2], [[129305, 129310], 2], [129311, 2], [[129312, 129319], 2], [[129320, 129327], 2], [129328, 2], [[129329, 129330], 2], [[129331, 129342], 2], [129343, 2], [[129344, 129355], 2], [129356, 2], [[129357, 129359], 2], [[129360, 129374], 2], [[129375, 129387], 2], [[129388, 129392], 2], [129393, 2], [129394, 2], [[129395, 129398], 2], [[129399, 129400], 2], [129401, 2], [129402, 2], [129403, 2], [[129404, 129407], 2], [[129408, 129412], 2], [[129413, 129425], 2], [[129426, 129431], 2], [[129432, 129442], 2], [[129443, 129444], 2], [[129445, 129450], 2], [[129451, 129453], 2], [[129454, 129455], 2], [[129456, 129465], 2], [[129466, 129471], 2], [129472, 2], [[129473, 129474], 2], [[129475, 129482], 2], [129483, 2], [129484, 2], [[129485, 129487], 2], [[129488, 129510], 2], [[129511, 129535], 2], [[129536, 129619], 2], [[129620, 129631], 3], [[129632, 129645], 2], [[129646, 129647], 3], [[129648, 129651], 2], [129652, 2], [[129653, 129655], 2], [[129656, 129658], 2], [[129659, 129660], 2], [[129661, 129663], 3], [[129664, 129666], 2], [[129667, 129670], 2], [[129671, 129672], 2], [[129673, 129679], 3], [[129680, 129685], 2], [[129686, 129704], 2], [[129705, 129708], 2], [[129709, 129711], 2], [[129712, 129718], 2], [[129719, 129722], 2], [[129723, 129725], 2], [129726, 3], [129727, 2], [[129728, 129730], 2], [[129731, 129733], 2], [[129734, 129741], 3], [[129742, 129743], 2], [[129744, 129750], 2], [[129751, 129753], 2], [[129754, 129755], 2], [[129756, 129759], 3], [[129760, 129767], 2], [129768, 2], [[129769, 129775], 3], [[129776, 129782], 2], [[129783, 129784], 2], [[129785, 129791], 3], [[129792, 129938], 2], [129939, 3], [[129940, 129994], 2], [[129995, 130031], 3], [130032, 1, "0"], [130033, 1, "1"], [130034, 1, "2"], [130035, 1, "3"], [130036, 1, "4"], [130037, 1, "5"], [130038, 1, "6"], [130039, 1, "7"], [130040, 1, "8"], [130041, 1, "9"], [[130042, 131069], 3], [[131070, 131071], 3], [[131072, 173782], 2], [[173783, 173789], 2], [[173790, 173791], 2], [[173792, 173823], 3], [[173824, 177972], 2], [[177973, 177976], 2], [177977, 2], [[177978, 177983], 3], [[177984, 178205], 2], [[178206, 178207], 3], [[178208, 183969], 2], [[183970, 183983], 3], [[183984, 191456], 2], [[191457, 191471], 3], [[191472, 192093], 2], [[192094, 194559], 3], [194560, 1, "\u4E3D"], [194561, 1, "\u4E38"], [194562, 1, "\u4E41"], [194563, 1, "\u{20122}"], [194564, 1, "\u4F60"], [194565, 1, "\u4FAE"], [194566, 1, "\u4FBB"], [194567, 1, "\u5002"], [194568, 1, "\u507A"], [194569, 1, "\u5099"], [194570, 1, "\u50E7"], [194571, 1, "\u50CF"], [194572, 1, "\u349E"], [194573, 1, "\u{2063A}"], [194574, 1, "\u514D"], [194575, 1, "\u5154"], [194576, 1, "\u5164"], [194577, 1, "\u5177"], [194578, 1, "\u{2051C}"], [194579, 1, "\u34B9"], [194580, 1, "\u5167"], [194581, 1, "\u518D"], [194582, 1, "\u{2054B}"], [194583, 1, "\u5197"], [194584, 1, "\u51A4"], [194585, 1, "\u4ECC"], [194586, 1, "\u51AC"], [194587, 1, "\u51B5"], [194588, 1, "\u{291DF}"], [194589, 1, "\u51F5"], [194590, 1, "\u5203"], [194591, 1, "\u34DF"], [194592, 1, "\u523B"], [194593, 1, "\u5246"], [194594, 1, "\u5272"], [194595, 1, "\u5277"], [194596, 1, "\u3515"], [194597, 1, "\u52C7"], [194598, 1, "\u52C9"], [194599, 1, "\u52E4"], [194600, 1, "\u52FA"], [194601, 1, "\u5305"], [194602, 1, "\u5306"], [194603, 1, "\u5317"], [194604, 1, "\u5349"], [194605, 1, "\u5351"], [194606, 1, "\u535A"], [194607, 1, "\u5373"], [194608, 1, "\u537D"], [[194609, 194611], 1, "\u537F"], [194612, 1, "\u{20A2C}"], [194613, 1, "\u7070"], [194614, 1, "\u53CA"], [194615, 1, "\u53DF"], [194616, 1, "\u{20B63}"], [194617, 1, "\u53EB"], [194618, 1, "\u53F1"], [194619, 1, "\u5406"], [194620, 1, "\u549E"], [194621, 1, "\u5438"], [194622, 1, "\u5448"], [194623, 1, "\u5468"], [194624, 1, "\u54A2"], [194625, 1, "\u54F6"], [194626, 1, "\u5510"], [194627, 1, "\u5553"], [194628, 1, "\u5563"], [[194629, 194630], 1, "\u5584"], [194631, 1, "\u5599"], [194632, 1, "\u55AB"], [194633, 1, "\u55B3"], [194634, 1, "\u55C2"], [194635, 1, "\u5716"], [194636, 1, "\u5606"], [194637, 1, "\u5717"], [194638, 1, "\u5651"], [194639, 1, "\u5674"], [194640, 1, "\u5207"], [194641, 1, "\u58EE"], [194642, 1, "\u57CE"], [194643, 1, "\u57F4"], [194644, 1, "\u580D"], [194645, 1, "\u578B"], [194646, 1, "\u5832"], [194647, 1, "\u5831"], [194648, 1, "\u58AC"], [194649, 1, "\u{214E4}"], [194650, 1, "\u58F2"], [194651, 1, "\u58F7"], [194652, 1, "\u5906"], [194653, 1, "\u591A"], [194654, 1, "\u5922"], [194655, 1, "\u5962"], [194656, 1, "\u{216A8}"], [194657, 1, "\u{216EA}"], [194658, 1, "\u59EC"], [194659, 1, "\u5A1B"], [194660, 1, "\u5A27"], [194661, 1, "\u59D8"], [194662, 1, "\u5A66"], [194663, 1, "\u36EE"], [194664, 3], [194665, 1, "\u5B08"], [[194666, 194667], 1, "\u5B3E"], [194668, 1, "\u{219C8}"], [194669, 1, "\u5BC3"], [194670, 1, "\u5BD8"], [194671, 1, "\u5BE7"], [194672, 1, "\u5BF3"], [194673, 1, "\u{21B18}"], [194674, 1, "\u5BFF"], [194675, 1, "\u5C06"], [194676, 3], [194677, 1, "\u5C22"], [194678, 1, "\u3781"], [194679, 1, "\u5C60"], [194680, 1, "\u5C6E"], [194681, 1, "\u5CC0"], [194682, 1, "\u5C8D"], [194683, 1, "\u{21DE4}"], [194684, 1, "\u5D43"], [194685, 1, "\u{21DE6}"], [194686, 1, "\u5D6E"], [194687, 1, "\u5D6B"], [194688, 1, "\u5D7C"], [194689, 1, "\u5DE1"], [194690, 1, "\u5DE2"], [194691, 1, "\u382F"], [194692, 1, "\u5DFD"], [194693, 1, "\u5E28"], [194694, 1, "\u5E3D"], [194695, 1, "\u5E69"], [194696, 1, "\u3862"], [194697, 1, "\u{22183}"], [194698, 1, "\u387C"], [194699, 1, "\u5EB0"], [194700, 1, "\u5EB3"], [194701, 1, "\u5EB6"], [194702, 1, "\u5ECA"], [194703, 1, "\u{2A392}"], [194704, 1, "\u5EFE"], [[194705, 194706], 1, "\u{22331}"], [194707, 1, "\u8201"], [[194708, 194709], 1, "\u5F22"], [194710, 1, "\u38C7"], [194711, 1, "\u{232B8}"], [194712, 1, "\u{261DA}"], [194713, 1, "\u5F62"], [194714, 1, "\u5F6B"], [194715, 1, "\u38E3"], [194716, 1, "\u5F9A"], [194717, 1, "\u5FCD"], [194718, 1, "\u5FD7"], [194719, 1, "\u5FF9"], [194720, 1, "\u6081"], [194721, 1, "\u393A"], [194722, 1, "\u391C"], [194723, 1, "\u6094"], [194724, 1, "\u{226D4}"], [194725, 1, "\u60C7"], [194726, 1, "\u6148"], [194727, 1, "\u614C"], [194728, 1, "\u614E"], [194729, 1, "\u614C"], [194730, 1, "\u617A"], [194731, 1, "\u618E"], [194732, 1, "\u61B2"], [194733, 1, "\u61A4"], [194734, 1, "\u61AF"], [194735, 1, "\u61DE"], [194736, 1, "\u61F2"], [194737, 1, "\u61F6"], [194738, 1, "\u6210"], [194739, 1, "\u621B"], [194740, 1, "\u625D"], [194741, 1, "\u62B1"], [194742, 1, "\u62D4"], [194743, 1, "\u6350"], [194744, 1, "\u{22B0C}"], [194745, 1, "\u633D"], [194746, 1, "\u62FC"], [194747, 1, "\u6368"], [194748, 1, "\u6383"], [194749, 1, "\u63E4"], [194750, 1, "\u{22BF1}"], [194751, 1, "\u6422"], [194752, 1, "\u63C5"], [194753, 1, "\u63A9"], [194754, 1, "\u3A2E"], [194755, 1, "\u6469"], [194756, 1, "\u647E"], [194757, 1, "\u649D"], [194758, 1, "\u6477"], [194759, 1, "\u3A6C"], [194760, 1, "\u654F"], [194761, 1, "\u656C"], [194762, 1, "\u{2300A}"], [194763, 1, "\u65E3"], [194764, 1, "\u66F8"], [194765, 1, "\u6649"], [194766, 1, "\u3B19"], [194767, 1, "\u6691"], [194768, 1, "\u3B08"], [194769, 1, "\u3AE4"], [194770, 1, "\u5192"], [194771, 1, "\u5195"], [194772, 1, "\u6700"], [194773, 1, "\u669C"], [194774, 1, "\u80AD"], [194775, 1, "\u43D9"], [194776, 1, "\u6717"], [194777, 1, "\u671B"], [194778, 1, "\u6721"], [194779, 1, "\u675E"], [194780, 1, "\u6753"], [194781, 1, "\u{233C3}"], [194782, 1, "\u3B49"], [194783, 1, "\u67FA"], [194784, 1, "\u6785"], [194785, 1, "\u6852"], [194786, 1, "\u6885"], [194787, 1, "\u{2346D}"], [194788, 1, "\u688E"], [194789, 1, "\u681F"], [194790, 1, "\u6914"], [194791, 1, "\u3B9D"], [194792, 1, "\u6942"], [194793, 1, "\u69A3"], [194794, 1, "\u69EA"], [194795, 1, "\u6AA8"], [194796, 1, "\u{236A3}"], [194797, 1, "\u6ADB"], [194798, 1, "\u3C18"], [194799, 1, "\u6B21"], [194800, 1, "\u{238A7}"], [194801, 1, "\u6B54"], [194802, 1, "\u3C4E"], [194803, 1, "\u6B72"], [194804, 1, "\u6B9F"], [194805, 1, "\u6BBA"], [194806, 1, "\u6BBB"], [194807, 1, "\u{23A8D}"], [194808, 1, "\u{21D0B}"], [194809, 1, "\u{23AFA}"], [194810, 1, "\u6C4E"], [194811, 1, "\u{23CBC}"], [194812, 1, "\u6CBF"], [194813, 1, "\u6CCD"], [194814, 1, "\u6C67"], [194815, 1, "\u6D16"], [194816, 1, "\u6D3E"], [194817, 1, "\u6D77"], [194818, 1, "\u6D41"], [194819, 1, "\u6D69"], [194820, 1, "\u6D78"], [194821, 1, "\u6D85"], [194822, 1, "\u{23D1E}"], [194823, 1, "\u6D34"], [194824, 1, "\u6E2F"], [194825, 1, "\u6E6E"], [194826, 1, "\u3D33"], [194827, 1, "\u6ECB"], [194828, 1, "\u6EC7"], [194829, 1, "\u{23ED1}"], [194830, 1, "\u6DF9"], [194831, 1, "\u6F6E"], [194832, 1, "\u{23F5E}"], [194833, 1, "\u{23F8E}"], [194834, 1, "\u6FC6"], [194835, 1, "\u7039"], [194836, 1, "\u701E"], [194837, 1, "\u701B"], [194838, 1, "\u3D96"], [194839, 1, "\u704A"], [194840, 1, "\u707D"], [194841, 1, "\u7077"], [194842, 1, "\u70AD"], [194843, 1, "\u{20525}"], [194844, 1, "\u7145"], [194845, 1, "\u{24263}"], [194846, 1, "\u719C"], [194847, 3], [194848, 1, "\u7228"], [194849, 1, "\u7235"], [194850, 1, "\u7250"], [194851, 1, "\u{24608}"], [194852, 1, "\u7280"], [194853, 1, "\u7295"], [194854, 1, "\u{24735}"], [194855, 1, "\u{24814}"], [194856, 1, "\u737A"], [194857, 1, "\u738B"], [194858, 1, "\u3EAC"], [194859, 1, "\u73A5"], [[194860, 194861], 1, "\u3EB8"], [194862, 1, "\u7447"], [194863, 1, "\u745C"], [194864, 1, "\u7471"], [194865, 1, "\u7485"], [194866, 1, "\u74CA"], [194867, 1, "\u3F1B"], [194868, 1, "\u7524"], [194869, 1, "\u{24C36}"], [194870, 1, "\u753E"], [194871, 1, "\u{24C92}"], [194872, 1, "\u7570"], [194873, 1, "\u{2219F}"], [194874, 1, "\u7610"], [194875, 1, "\u{24FA1}"], [194876, 1, "\u{24FB8}"], [194877, 1, "\u{25044}"], [194878, 1, "\u3FFC"], [194879, 1, "\u4008"], [194880, 1, "\u76F4"], [194881, 1, "\u{250F3}"], [194882, 1, "\u{250F2}"], [194883, 1, "\u{25119}"], [194884, 1, "\u{25133}"], [194885, 1, "\u771E"], [[194886, 194887], 1, "\u771F"], [194888, 1, "\u774A"], [194889, 1, "\u4039"], [194890, 1, "\u778B"], [194891, 1, "\u4046"], [194892, 1, "\u4096"], [194893, 1, "\u{2541D}"], [194894, 1, "\u784E"], [194895, 1, "\u788C"], [194896, 1, "\u78CC"], [194897, 1, "\u40E3"], [194898, 1, "\u{25626}"], [194899, 1, "\u7956"], [194900, 1, "\u{2569A}"], [194901, 1, "\u{256C5}"], [194902, 1, "\u798F"], [194903, 1, "\u79EB"], [194904, 1, "\u412F"], [194905, 1, "\u7A40"], [194906, 1, "\u7A4A"], [194907, 1, "\u7A4F"], [194908, 1, "\u{2597C}"], [[194909, 194910], 1, "\u{25AA7}"], [194911, 3], [194912, 1, "\u4202"], [194913, 1, "\u{25BAB}"], [194914, 1, "\u7BC6"], [194915, 1, "\u7BC9"], [194916, 1, "\u4227"], [194917, 1, "\u{25C80}"], [194918, 1, "\u7CD2"], [194919, 1, "\u42A0"], [194920, 1, "\u7CE8"], [194921, 1, "\u7CE3"], [194922, 1, "\u7D00"], [194923, 1, "\u{25F86}"], [194924, 1, "\u7D63"], [194925, 1, "\u4301"], [194926, 1, "\u7DC7"], [194927, 1, "\u7E02"], [194928, 1, "\u7E45"], [194929, 1, "\u4334"], [194930, 1, "\u{26228}"], [194931, 1, "\u{26247}"], [194932, 1, "\u4359"], [194933, 1, "\u{262D9}"], [194934, 1, "\u7F7A"], [194935, 1, "\u{2633E}"], [194936, 1, "\u7F95"], [194937, 1, "\u7FFA"], [194938, 1, "\u8005"], [194939, 1, "\u{264DA}"], [194940, 1, "\u{26523}"], [194941, 1, "\u8060"], [194942, 1, "\u{265A8}"], [194943, 1, "\u8070"], [194944, 1, "\u{2335F}"], [194945, 1, "\u43D5"], [194946, 1, "\u80B2"], [194947, 1, "\u8103"], [194948, 1, "\u440B"], [194949, 1, "\u813E"], [194950, 1, "\u5AB5"], [194951, 1, "\u{267A7}"], [194952, 1, "\u{267B5}"], [194953, 1, "\u{23393}"], [194954, 1, "\u{2339C}"], [194955, 1, "\u8201"], [194956, 1, "\u8204"], [194957, 1, "\u8F9E"], [194958, 1, "\u446B"], [194959, 1, "\u8291"], [194960, 1, "\u828B"], [194961, 1, "\u829D"], [194962, 1, "\u52B3"], [194963, 1, "\u82B1"], [194964, 1, "\u82B3"], [194965, 1, "\u82BD"], [194966, 1, "\u82E6"], [194967, 1, "\u{26B3C}"], [194968, 1, "\u82E5"], [194969, 1, "\u831D"], [194970, 1, "\u8363"], [194971, 1, "\u83AD"], [194972, 1, "\u8323"], [194973, 1, "\u83BD"], [194974, 1, "\u83E7"], [194975, 1, "\u8457"], [194976, 1, "\u8353"], [194977, 1, "\u83CA"], [194978, 1, "\u83CC"], [194979, 1, "\u83DC"], [194980, 1, "\u{26C36}"], [194981, 1, "\u{26D6B}"], [194982, 1, "\u{26CD5}"], [194983, 1, "\u452B"], [194984, 1, "\u84F1"], [194985, 1, "\u84F3"], [194986, 1, "\u8516"], [194987, 1, "\u{273CA}"], [194988, 1, "\u8564"], [194989, 1, "\u{26F2C}"], [194990, 1, "\u455D"], [194991, 1, "\u4561"], [194992, 1, "\u{26FB1}"], [194993, 1, "\u{270D2}"], [194994, 1, "\u456B"], [194995, 1, "\u8650"], [194996, 1, "\u865C"], [194997, 1, "\u8667"], [194998, 1, "\u8669"], [194999, 1, "\u86A9"], [195e3, 1, "\u8688"], [195001, 1, "\u870E"], [195002, 1, "\u86E2"], [195003, 1, "\u8779"], [195004, 1, "\u8728"], [195005, 1, "\u876B"], [195006, 1, "\u8786"], [195007, 3], [195008, 1, "\u87E1"], [195009, 1, "\u8801"], [195010, 1, "\u45F9"], [195011, 1, "\u8860"], [195012, 1, "\u8863"], [195013, 1, "\u{27667}"], [195014, 1, "\u88D7"], [195015, 1, "\u88DE"], [195016, 1, "\u4635"], [195017, 1, "\u88FA"], [195018, 1, "\u34BB"], [195019, 1, "\u{278AE}"], [195020, 1, "\u{27966}"], [195021, 1, "\u46BE"], [195022, 1, "\u46C7"], [195023, 1, "\u8AA0"], [195024, 1, "\u8AED"], [195025, 1, "\u8B8A"], [195026, 1, "\u8C55"], [195027, 1, "\u{27CA8}"], [195028, 1, "\u8CAB"], [195029, 1, "\u8CC1"], [195030, 1, "\u8D1B"], [195031, 1, "\u8D77"], [195032, 1, "\u{27F2F}"], [195033, 1, "\u{20804}"], [195034, 1, "\u8DCB"], [195035, 1, "\u8DBC"], [195036, 1, "\u8DF0"], [195037, 1, "\u{208DE}"], [195038, 1, "\u8ED4"], [195039, 1, "\u8F38"], [195040, 1, "\u{285D2}"], [195041, 1, "\u{285ED}"], [195042, 1, "\u9094"], [195043, 1, "\u90F1"], [195044, 1, "\u9111"], [195045, 1, "\u{2872E}"], [195046, 1, "\u911B"], [195047, 1, "\u9238"], [195048, 1, "\u92D7"], [195049, 1, "\u92D8"], [195050, 1, "\u927C"], [195051, 1, "\u93F9"], [195052, 1, "\u9415"], [195053, 1, "\u{28BFA}"], [195054, 1, "\u958B"], [195055, 1, "\u4995"], [195056, 1, "\u95B7"], [195057, 1, "\u{28D77}"], [195058, 1, "\u49E6"], [195059, 1, "\u96C3"], [195060, 1, "\u5DB2"], [195061, 1, "\u9723"], [195062, 1, "\u{29145}"], [195063, 1, "\u{2921A}"], [195064, 1, "\u4A6E"], [195065, 1, "\u4A76"], [195066, 1, "\u97E0"], [195067, 1, "\u{2940A}"], [195068, 1, "\u4AB2"], [195069, 1, "\u{29496}"], [[195070, 195071], 1, "\u980B"], [195072, 1, "\u9829"], [195073, 1, "\u{295B6}"], [195074, 1, "\u98E2"], [195075, 1, "\u4B33"], [195076, 1, "\u9929"], [195077, 1, "\u99A7"], [195078, 1, "\u99C2"], [195079, 1, "\u99FE"], [195080, 1, "\u4BCE"], [195081, 1, "\u{29B30}"], [195082, 1, "\u9B12"], [195083, 1, "\u9C40"], [195084, 1, "\u9CFD"], [195085, 1, "\u4CCE"], [195086, 1, "\u4CED"], [195087, 1, "\u9D67"], [195088, 1, "\u{2A0CE}"], [195089, 1, "\u4CF8"], [195090, 1, "\u{2A105}"], [195091, 1, "\u{2A20E}"], [195092, 1, "\u{2A291}"], [195093, 1, "\u9EBB"], [195094, 1, "\u4D56"], [195095, 1, "\u9EF9"], [195096, 1, "\u9EFE"], [195097, 1, "\u9F05"], [195098, 1, "\u9F0F"], [195099, 1, "\u9F16"], [195100, 1, "\u9F3B"], [195101, 1, "\u{2A600}"], [[195102, 196605], 3], [[196606, 196607], 3], [[196608, 201546], 2], [[201547, 201551], 3], [[201552, 205743], 2], [[205744, 262141], 3], [[262142, 262143], 3], [[262144, 327677], 3], [[327678, 327679], 3], [[327680, 393213], 3], [[393214, 393215], 3], [[393216, 458749], 3], [[458750, 458751], 3], [[458752, 524285], 3], [[524286, 524287], 3], [[524288, 589821], 3], [[589822, 589823], 3], [[589824, 655357], 3], [[655358, 655359], 3], [[655360, 720893], 3], [[720894, 720895], 3], [[720896, 786429], 3], [[786430, 786431], 3], [[786432, 851965], 3], [[851966, 851967], 3], [[851968, 917501], 3], [[917502, 917503], 3], [917504, 3], [917505, 3], [[917506, 917535], 3], [[917536, 917631], 3], [[917632, 917759], 3], [[917760, 917999], 7], [[918e3, 983037], 3], [[983038, 983039], 3], [[983040, 1048573], 3], [[1048574, 1048575], 3], [[1048576, 1114109], 3], [[1114110, 1114111], 3]];
    }
  });

  // ../../node_modules/.pnpm/tr46@5.0.0/node_modules/tr46/lib/statusMapping.js
  var require_statusMapping = __commonJS({
    "../../node_modules/.pnpm/tr46@5.0.0/node_modules/tr46/lib/statusMapping.js"(exports, module) {
      "use strict";
      module.exports.STATUS_MAPPING = {
        mapped: 1,
        valid: 2,
        disallowed: 3,
        disallowed_STD3_valid: 4,
        disallowed_STD3_mapped: 5,
        deviation: 6,
        ignored: 7
      };
    }
  });

  // ../../node_modules/.pnpm/tr46@5.0.0/node_modules/tr46/index.js
  var require_tr46 = __commonJS({
    "../../node_modules/.pnpm/tr46@5.0.0/node_modules/tr46/index.js"(exports, module) {
      "use strict";
      var punycode2 = (init_punycode_es6(), __toCommonJS(punycode_es6_exports));
      var regexes = require_regexes();
      var mappingTable = require_mappingTable();
      var { STATUS_MAPPING } = require_statusMapping();
      function containsNonASCII(str) {
        return /[^\x00-\x7F]/u.test(str);
      }
      function findStatus(val, { useSTD3ASCIIRules }) {
        let start = 0;
        let end = mappingTable.length - 1;
        while (start <= end) {
          const mid = Math.floor((start + end) / 2);
          const target = mappingTable[mid];
          const min = Array.isArray(target[0]) ? target[0][0] : target[0];
          const max2 = Array.isArray(target[0]) ? target[0][1] : target[0];
          if (min <= val && max2 >= val) {
            if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {
              return [STATUS_MAPPING.disallowed, ...target.slice(2)];
            } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {
              return [STATUS_MAPPING.valid, ...target.slice(2)];
            } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {
              return [STATUS_MAPPING.mapped, ...target.slice(2)];
            }
            return target.slice(1);
          } else if (min > val) {
            end = mid - 1;
          } else {
            start = mid + 1;
          }
        }
        return null;
      }
      function mapChars(domainName, { useSTD3ASCIIRules, transitionalProcessing }) {
        let processed = "";
        for (const ch of domainName) {
          const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
          switch (status) {
            case STATUS_MAPPING.disallowed:
              processed += ch;
              break;
            case STATUS_MAPPING.ignored:
              break;
            case STATUS_MAPPING.mapped:
              if (transitionalProcessing && ch === "\u1E9E") {
                processed += "ss";
              } else {
                processed += mapping;
              }
              break;
            case STATUS_MAPPING.deviation:
              if (transitionalProcessing) {
                processed += mapping;
              } else {
                processed += ch;
              }
              break;
            case STATUS_MAPPING.valid:
              processed += ch;
              break;
          }
        }
        return processed;
      }
      function validateLabel(label, {
        checkHyphens,
        checkBidi,
        checkJoiners,
        transitionalProcessing,
        useSTD3ASCIIRules,
        isBidi
      }) {
        if (label.length === 0) {
          return true;
        }
        if (label.normalize("NFC") !== label) {
          return false;
        }
        const codePoints = Array.from(label);
        if (checkHyphens) {
          if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
            return false;
          }
        }
        if (label.includes(".")) {
          return false;
        }
        if (regexes.combiningMarks.test(codePoints[0])) {
          return false;
        }
        for (const ch of codePoints) {
          const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
          if (transitionalProcessing) {
            if (status !== STATUS_MAPPING.valid) {
              return false;
            }
          } else if (status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
            return false;
          }
        }
        if (checkJoiners) {
          let last = 0;
          for (const [i, ch] of codePoints.entries()) {
            if (ch === "\u200C" || ch === "\u200D") {
              if (i > 0) {
                if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
                  continue;
                }
                if (ch === "\u200C") {
                  const next = codePoints.indexOf("\u200C", i + 1);
                  const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
                  if (regexes.validZWNJ.test(test.join(""))) {
                    last = i + 1;
                    continue;
                  }
                }
              }
              return false;
            }
          }
        }
        if (checkBidi && isBidi) {
          let rtl;
          if (regexes.bidiS1LTR.test(codePoints[0])) {
            rtl = false;
          } else if (regexes.bidiS1RTL.test(codePoints[0])) {
            rtl = true;
          } else {
            return false;
          }
          if (rtl) {
            if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
              return false;
            }
          } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
            return false;
          }
        }
        return true;
      }
      function isBidiDomain(labels) {
        const domain = labels.map((label) => {
          if (label.startsWith("xn--")) {
            try {
              return punycode2.decode(label.substring(4));
            } catch (err2) {
              return "";
            }
          }
          return label;
        }).join(".");
        return regexes.bidiDomain.test(domain);
      }
      function processing(domainName, options) {
        let string2 = mapChars(domainName, options);
        string2 = string2.normalize("NFC");
        const labels = string2.split(".");
        const isBidi = isBidiDomain(labels);
        let error3 = false;
        for (const [i, origLabel] of labels.entries()) {
          let label = origLabel;
          let transitionalProcessingForThisLabel = options.transitionalProcessing;
          if (label.startsWith("xn--")) {
            if (containsNonASCII(label)) {
              error3 = true;
              continue;
            }
            try {
              label = punycode2.decode(label.substring(4));
            } catch {
              if (!options.ignoreInvalidPunycode) {
                error3 = true;
                continue;
              }
            }
            labels[i] = label;
            transitionalProcessingForThisLabel = false;
          }
          if (error3) {
            continue;
          }
          const validation = validateLabel(label, {
            ...options,
            transitionalProcessing: transitionalProcessingForThisLabel,
            isBidi
          });
          if (!validation) {
            error3 = true;
          }
        }
        return {
          string: labels.join("."),
          error: error3
        };
      }
      function toASCII2(domainName, {
        checkHyphens = false,
        checkBidi = false,
        checkJoiners = false,
        useSTD3ASCIIRules = false,
        verifyDNSLength = false,
        transitionalProcessing = false,
        ignoreInvalidPunycode = false
      } = {}) {
        const result = processing(domainName, {
          checkHyphens,
          checkBidi,
          checkJoiners,
          useSTD3ASCIIRules,
          transitionalProcessing,
          ignoreInvalidPunycode
        });
        let labels = result.string.split(".");
        labels = labels.map((l) => {
          if (containsNonASCII(l)) {
            try {
              return `xn--${punycode2.encode(l)}`;
            } catch (e) {
              result.error = true;
            }
          }
          return l;
        });
        if (verifyDNSLength) {
          const total = labels.join(".").length;
          if (total > 253 || total === 0) {
            result.error = true;
          }
          for (let i = 0; i < labels.length; ++i) {
            if (labels[i].length > 63 || labels[i].length === 0) {
              result.error = true;
              break;
            }
          }
        }
        if (result.error) {
          return null;
        }
        return labels.join(".");
      }
      function toUnicode2(domainName, {
        checkHyphens = false,
        checkBidi = false,
        checkJoiners = false,
        useSTD3ASCIIRules = false,
        transitionalProcessing = false,
        ignoreInvalidPunycode = false
      } = {}) {
        const result = processing(domainName, {
          checkHyphens,
          checkBidi,
          checkJoiners,
          useSTD3ASCIIRules,
          transitionalProcessing,
          ignoreInvalidPunycode
        });
        return {
          domain: result.string,
          error: result.error
        };
      }
      module.exports = {
        toASCII: toASCII2,
        toUnicode: toUnicode2
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/infra.js
  var require_infra = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/infra.js"(exports, module) {
      "use strict";
      function isASCIIDigit(c) {
        return c >= 48 && c <= 57;
      }
      function isASCIIAlpha(c) {
        return c >= 65 && c <= 90 || c >= 97 && c <= 122;
      }
      function isASCIIAlphanumeric(c) {
        return isASCIIAlpha(c) || isASCIIDigit(c);
      }
      function isASCIIHex(c) {
        return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
      }
      module.exports = {
        isASCIIDigit,
        isASCIIAlpha,
        isASCIIAlphanumeric,
        isASCIIHex
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/encoding.js
  var require_encoding = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/encoding.js"(exports, module) {
      "use strict";
      var utf8Encoder = new TextEncoder();
      var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
      function utf8Encode(string2) {
        return utf8Encoder.encode(string2);
      }
      function utf8DecodeWithoutBOM(bytes2) {
        return utf8Decoder.decode(bytes2);
      }
      module.exports = {
        utf8Encode,
        utf8DecodeWithoutBOM
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/percent-encoding.js
  var require_percent_encoding = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/percent-encoding.js"(exports, module) {
      "use strict";
      var { isASCIIHex } = require_infra();
      var { utf8Encode } = require_encoding();
      function p(char) {
        return char.codePointAt(0);
      }
      function percentEncode(c) {
        let hex = c.toString(16).toUpperCase();
        if (hex.length === 1) {
          hex = `0${hex}`;
        }
        return `%${hex}`;
      }
      function percentDecodeBytes(input) {
        const output2 = new Uint8Array(input.byteLength);
        let outputIndex = 0;
        for (let i = 0; i < input.byteLength; ++i) {
          const byte = input[i];
          if (byte !== 37) {
            output2[outputIndex++] = byte;
          } else if (byte === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
            output2[outputIndex++] = byte;
          } else {
            const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
            output2[outputIndex++] = bytePoint;
            i += 2;
          }
        }
        return output2.slice(0, outputIndex);
      }
      function percentDecodeString(input) {
        const bytes2 = utf8Encode(input);
        return percentDecodeBytes(bytes2);
      }
      function isC0ControlPercentEncode(c) {
        return c <= 31 || c > 126;
      }
      var extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("<"), p(">"), p("`")]);
      function isFragmentPercentEncode(c) {
        return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
      }
      var extraQueryPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("#"), p("<"), p(">")]);
      function isQueryPercentEncode(c) {
        return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
      }
      function isSpecialQueryPercentEncode(c) {
        return isQueryPercentEncode(c) || c === p("'");
      }
      var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([p("?"), p("`"), p("{"), p("}")]);
      function isPathPercentEncode(c) {
        return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
      }
      var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("^"), p("|")]);
      function isUserinfoPercentEncode(c) {
        return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
      }
      var extraComponentPercentEncodeSet = /* @__PURE__ */ new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
      function isComponentPercentEncode(c) {
        return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
      }
      var extraURLEncodedPercentEncodeSet = /* @__PURE__ */ new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
      function isURLEncodedPercentEncode(c) {
        return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
      }
      function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
        const bytes2 = utf8Encode(codePoint);
        let output2 = "";
        for (const byte of bytes2) {
          if (!percentEncodePredicate(byte)) {
            output2 += String.fromCharCode(byte);
          } else {
            output2 += percentEncode(byte);
          }
        }
        return output2;
      }
      function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
        return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
      }
      function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
        let output2 = "";
        for (const codePoint of input) {
          if (spaceAsPlus && codePoint === " ") {
            output2 += "+";
          } else {
            output2 += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
          }
        }
        return output2;
      }
      module.exports = {
        isC0ControlPercentEncode,
        isFragmentPercentEncode,
        isQueryPercentEncode,
        isSpecialQueryPercentEncode,
        isPathPercentEncode,
        isUserinfoPercentEncode,
        isURLEncodedPercentEncode,
        percentDecodeString,
        percentDecodeBytes,
        utf8PercentEncodeString,
        utf8PercentEncodeCodePoint
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/url-state-machine.js
  var require_url_state_machine = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
      "use strict";
      var tr46 = require_tr46();
      var infra = require_infra();
      var { utf8DecodeWithoutBOM } = require_encoding();
      var {
        percentDecodeString,
        utf8PercentEncodeCodePoint,
        utf8PercentEncodeString,
        isC0ControlPercentEncode,
        isFragmentPercentEncode,
        isQueryPercentEncode,
        isSpecialQueryPercentEncode,
        isPathPercentEncode,
        isUserinfoPercentEncode
      } = require_percent_encoding();
      function p(char) {
        return char.codePointAt(0);
      }
      var specialSchemes = {
        ftp: 21,
        file: null,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var failure = Symbol("failure");
      function countSymbols(str) {
        return [...str].length;
      }
      function at(input, idx) {
        const c = input[idx];
        return isNaN(c) ? void 0 : String.fromCodePoint(c);
      }
      function isSingleDot(buffer) {
        return buffer === "." || buffer.toLowerCase() === "%2e";
      }
      function isDoubleDot(buffer) {
        buffer = buffer.toLowerCase();
        return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
      }
      function isWindowsDriveLetterCodePoints(cp1, cp2) {
        return infra.isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
      }
      function isWindowsDriveLetterString(string2) {
        return string2.length === 2 && infra.isASCIIAlpha(string2.codePointAt(0)) && (string2[1] === ":" || string2[1] === "|");
      }
      function isNormalizedWindowsDriveLetterString(string2) {
        return string2.length === 2 && infra.isASCIIAlpha(string2.codePointAt(0)) && string2[1] === ":";
      }
      function containsForbiddenHostCodePoint(string2) {
        return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
      }
      function containsForbiddenDomainCodePoint(string2) {
        return containsForbiddenHostCodePoint(string2) || string2.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
      }
      function isSpecialScheme(scheme) {
        return specialSchemes[scheme] !== void 0;
      }
      function isSpecial(url) {
        return isSpecialScheme(url.scheme);
      }
      function isNotSpecial(url) {
        return !isSpecialScheme(url.scheme);
      }
      function defaultPort(scheme) {
        return specialSchemes[scheme];
      }
      function parseIPv4Number(input) {
        if (input === "") {
          return failure;
        }
        let R = 10;
        if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
          input = input.substring(2);
          R = 16;
        } else if (input.length >= 2 && input.charAt(0) === "0") {
          input = input.substring(1);
          R = 8;
        }
        if (input === "") {
          return 0;
        }
        let regex = /[^0-7]/u;
        if (R === 10) {
          regex = /[^0-9]/u;
        }
        if (R === 16) {
          regex = /[^0-9A-Fa-f]/u;
        }
        if (regex.test(input)) {
          return failure;
        }
        return parseInt(input, R);
      }
      function parseIPv4(input) {
        const parts = input.split(".");
        if (parts[parts.length - 1] === "") {
          if (parts.length > 1) {
            parts.pop();
          }
        }
        if (parts.length > 4) {
          return failure;
        }
        const numbers = [];
        for (const part of parts) {
          const n = parseIPv4Number(part);
          if (n === failure) {
            return failure;
          }
          numbers.push(n);
        }
        for (let i = 0; i < numbers.length - 1; ++i) {
          if (numbers[i] > 255) {
            return failure;
          }
        }
        if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
          return failure;
        }
        let ipv4 = numbers.pop();
        let counter = 0;
        for (const n of numbers) {
          ipv4 += n * 256 ** (3 - counter);
          ++counter;
        }
        return ipv4;
      }
      function serializeIPv4(address) {
        let output2 = "";
        let n = address;
        for (let i = 1; i <= 4; ++i) {
          output2 = String(n % 256) + output2;
          if (i !== 4) {
            output2 = `.${output2}`;
          }
          n = Math.floor(n / 256);
        }
        return output2;
      }
      function parseIPv6(input) {
        const address = [0, 0, 0, 0, 0, 0, 0, 0];
        let pieceIndex = 0;
        let compress = null;
        let pointer = 0;
        input = Array.from(input, (c) => c.codePointAt(0));
        if (input[pointer] === p(":")) {
          if (input[pointer + 1] !== p(":")) {
            return failure;
          }
          pointer += 2;
          ++pieceIndex;
          compress = pieceIndex;
        }
        while (pointer < input.length) {
          if (pieceIndex === 8) {
            return failure;
          }
          if (input[pointer] === p(":")) {
            if (compress !== null) {
              return failure;
            }
            ++pointer;
            ++pieceIndex;
            compress = pieceIndex;
            continue;
          }
          let value = 0;
          let length = 0;
          while (length < 4 && infra.isASCIIHex(input[pointer])) {
            value = value * 16 + parseInt(at(input, pointer), 16);
            ++pointer;
            ++length;
          }
          if (input[pointer] === p(".")) {
            if (length === 0) {
              return failure;
            }
            pointer -= length;
            if (pieceIndex > 6) {
              return failure;
            }
            let numbersSeen = 0;
            while (input[pointer] !== void 0) {
              let ipv4Piece = null;
              if (numbersSeen > 0) {
                if (input[pointer] === p(".") && numbersSeen < 4) {
                  ++pointer;
                } else {
                  return failure;
                }
              }
              if (!infra.isASCIIDigit(input[pointer])) {
                return failure;
              }
              while (infra.isASCIIDigit(input[pointer])) {
                const number3 = parseInt(at(input, pointer));
                if (ipv4Piece === null) {
                  ipv4Piece = number3;
                } else if (ipv4Piece === 0) {
                  return failure;
                } else {
                  ipv4Piece = ipv4Piece * 10 + number3;
                }
                if (ipv4Piece > 255) {
                  return failure;
                }
                ++pointer;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              ++numbersSeen;
              if (numbersSeen === 2 || numbersSeen === 4) {
                ++pieceIndex;
              }
            }
            if (numbersSeen !== 4) {
              return failure;
            }
            break;
          } else if (input[pointer] === p(":")) {
            ++pointer;
            if (input[pointer] === void 0) {
              return failure;
            }
          } else if (input[pointer] !== void 0) {
            return failure;
          }
          address[pieceIndex] = value;
          ++pieceIndex;
        }
        if (compress !== null) {
          let swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex !== 0 && swaps > 0) {
            const temp = address[compress + swaps - 1];
            address[compress + swaps - 1] = address[pieceIndex];
            address[pieceIndex] = temp;
            --pieceIndex;
            --swaps;
          }
        } else if (compress === null && pieceIndex !== 8) {
          return failure;
        }
        return address;
      }
      function serializeIPv6(address) {
        let output2 = "";
        const compress = findTheIPv6AddressCompressedPieceIndex(address);
        let ignore0 = false;
        for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
          if (ignore0 && address[pieceIndex] === 0) {
            continue;
          } else if (ignore0) {
            ignore0 = false;
          }
          if (compress === pieceIndex) {
            const separator = pieceIndex === 0 ? "::" : ":";
            output2 += separator;
            ignore0 = true;
            continue;
          }
          output2 += address[pieceIndex].toString(16);
          if (pieceIndex !== 7) {
            output2 += ":";
          }
        }
        return output2;
      }
      function parseHost(input, isOpaque = false) {
        if (input[0] === "[") {
          if (input[input.length - 1] !== "]") {
            return failure;
          }
          return parseIPv6(input.substring(1, input.length - 1));
        }
        if (isOpaque) {
          return parseOpaqueHost(input);
        }
        const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
        const asciiDomain = domainToASCII(domain);
        if (asciiDomain === failure) {
          return failure;
        }
        if (containsForbiddenDomainCodePoint(asciiDomain)) {
          return failure;
        }
        if (endsInANumber(asciiDomain)) {
          return parseIPv4(asciiDomain);
        }
        return asciiDomain;
      }
      function endsInANumber(input) {
        const parts = input.split(".");
        if (parts[parts.length - 1] === "") {
          if (parts.length === 1) {
            return false;
          }
          parts.pop();
        }
        const last = parts[parts.length - 1];
        if (parseIPv4Number(last) !== failure) {
          return true;
        }
        if (/^[0-9]+$/u.test(last)) {
          return true;
        }
        return false;
      }
      function parseOpaqueHost(input) {
        if (containsForbiddenHostCodePoint(input)) {
          return failure;
        }
        return utf8PercentEncodeString(input, isC0ControlPercentEncode);
      }
      function findTheIPv6AddressCompressedPieceIndex(address) {
        let longestIndex = null;
        let longestSize = 1;
        let foundIndex = null;
        let foundSize = 0;
        for (let pieceIndex = 0; pieceIndex < address.length; ++pieceIndex) {
          if (address[pieceIndex] !== 0) {
            if (foundSize > longestSize) {
              longestIndex = foundIndex;
              longestSize = foundSize;
            }
            foundIndex = null;
            foundSize = 0;
          } else {
            if (foundIndex === null) {
              foundIndex = pieceIndex;
            }
            ++foundSize;
          }
        }
        if (foundSize > longestSize) {
          return foundIndex;
        }
        return longestIndex;
      }
      function serializeHost(host) {
        if (typeof host === "number") {
          return serializeIPv4(host);
        }
        if (host instanceof Array) {
          return `[${serializeIPv6(host)}]`;
        }
        return host;
      }
      function domainToASCII(domain, beStrict = false) {
        const result = tr46.toASCII(domain, {
          checkBidi: true,
          checkHyphens: false,
          checkJoiners: true,
          useSTD3ASCIIRules: beStrict,
          verifyDNSLength: beStrict
        });
        if (result === null || result === "") {
          return failure;
        }
        return result;
      }
      function trimControlChars(url) {
        return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/ug, "");
      }
      function trimTabAndNewline(url) {
        return url.replace(/\u0009|\u000A|\u000D/ug, "");
      }
      function shortenPath(url) {
        const { path: path6 } = url;
        if (path6.length === 0) {
          return;
        }
        if (url.scheme === "file" && path6.length === 1 && isNormalizedWindowsDriveLetter(path6[0])) {
          return;
        }
        path6.pop();
      }
      function includesCredentials(url) {
        return url.username !== "" || url.password !== "";
      }
      function cannotHaveAUsernamePasswordPort(url) {
        return url.host === null || url.host === "" || url.scheme === "file";
      }
      function hasAnOpaquePath(url) {
        return typeof url.path === "string";
      }
      function isNormalizedWindowsDriveLetter(string2) {
        return /^[A-Za-z]:$/u.test(string2);
      }
      function URLStateMachine(input, base2, encodingOverride, url, stateOverride) {
        this.pointer = 0;
        this.input = input;
        this.base = base2 || null;
        this.encodingOverride = encodingOverride || "utf-8";
        this.stateOverride = stateOverride;
        this.url = url;
        this.failure = false;
        this.parseError = false;
        if (!this.url) {
          this.url = {
            scheme: "",
            username: "",
            password: "",
            host: null,
            port: null,
            path: [],
            query: null,
            fragment: null
          };
          const res2 = trimControlChars(this.input);
          if (res2 !== this.input) {
            this.parseError = true;
          }
          this.input = res2;
        }
        const res = trimTabAndNewline(this.input);
        if (res !== this.input) {
          this.parseError = true;
        }
        this.input = res;
        this.state = stateOverride || "scheme start";
        this.buffer = "";
        this.atFlag = false;
        this.arrFlag = false;
        this.passwordTokenSeenFlag = false;
        this.input = Array.from(this.input, (c) => c.codePointAt(0));
        for (; this.pointer <= this.input.length; ++this.pointer) {
          const c = this.input[this.pointer];
          const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
          const ret4 = this[`parse ${this.state}`](c, cStr);
          if (!ret4) {
            break;
          } else if (ret4 === failure) {
            this.failure = true;
            break;
          }
        }
      }
      URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
        if (infra.isASCIIAlpha(c)) {
          this.buffer += cStr.toLowerCase();
          this.state = "scheme";
        } else if (!this.stateOverride) {
          this.state = "no scheme";
          --this.pointer;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
        if (infra.isASCIIAlphanumeric(c) || c === p("+") || c === p("-") || c === p(".")) {
          this.buffer += cStr.toLowerCase();
        } else if (c === p(":")) {
          if (this.stateOverride) {
            if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
              return false;
            }
            if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
              return false;
            }
            if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
              return false;
            }
            if (this.url.scheme === "file" && this.url.host === "") {
              return false;
            }
          }
          this.url.scheme = this.buffer;
          if (this.stateOverride) {
            if (this.url.port === defaultPort(this.url.scheme)) {
              this.url.port = null;
            }
            return false;
          }
          this.buffer = "";
          if (this.url.scheme === "file") {
            if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
              this.parseError = true;
            }
            this.state = "file";
          } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
            this.state = "special relative or authority";
          } else if (isSpecial(this.url)) {
            this.state = "special authority slashes";
          } else if (this.input[this.pointer + 1] === p("/")) {
            this.state = "path or authority";
            ++this.pointer;
          } else {
            this.url.path = "";
            this.state = "opaque path";
          }
        } else if (!this.stateOverride) {
          this.buffer = "";
          this.state = "no scheme";
          this.pointer = -1;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
        if (this.base === null || hasAnOpaquePath(this.base) && c !== p("#")) {
          return failure;
        } else if (hasAnOpaquePath(this.base) && c === p("#")) {
          this.url.scheme = this.base.scheme;
          this.url.path = this.base.path;
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else if (this.base.scheme === "file") {
          this.state = "file";
          --this.pointer;
        } else {
          this.state = "relative";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
        if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "relative";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
        if (c === p("/")) {
          this.state = "authority";
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
        this.url.scheme = this.base.scheme;
        if (c === p("/")) {
          this.state = "relative slash";
        } else if (isSpecial(this.url) && c === p("\\")) {
          this.parseError = true;
          this.state = "relative slash";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          if (c === p("?")) {
            this.url.query = "";
            this.state = "query";
          } else if (c === p("#")) {
            this.url.fragment = "";
            this.state = "fragment";
          } else if (!isNaN(c)) {
            this.url.query = null;
            this.url.path.pop();
            this.state = "path";
            --this.pointer;
          }
        }
        return true;
      };
      URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
        if (isSpecial(this.url) && (c === p("/") || c === p("\\"))) {
          if (c === p("\\")) {
            this.parseError = true;
          }
          this.state = "special authority ignore slashes";
        } else if (c === p("/")) {
          this.state = "authority";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
        if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "special authority ignore slashes";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
        if (c !== p("/") && c !== p("\\")) {
          this.state = "authority";
          --this.pointer;
        } else {
          this.parseError = true;
        }
        return true;
      };
      URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
        if (c === p("@")) {
          this.parseError = true;
          if (this.atFlag) {
            this.buffer = `%40${this.buffer}`;
          }
          this.atFlag = true;
          const len = countSymbols(this.buffer);
          for (let pointer = 0; pointer < len; ++pointer) {
            const codePoint = this.buffer.codePointAt(pointer);
            if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
              this.passwordTokenSeenFlag = true;
              continue;
            }
            const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
            if (this.passwordTokenSeenFlag) {
              this.url.password += encodedCodePoints;
            } else {
              this.url.username += encodedCodePoints;
            }
          }
          this.buffer = "";
        } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
          if (this.atFlag && this.buffer === "") {
            this.parseError = true;
            return failure;
          }
          this.pointer -= countSymbols(this.buffer) + 1;
          this.buffer = "";
          this.state = "host";
        } else {
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
        if (this.stateOverride && this.url.scheme === "file") {
          --this.pointer;
          this.state = "file host";
        } else if (c === p(":") && !this.arrFlag) {
          if (this.buffer === "") {
            this.parseError = true;
            return failure;
          }
          if (this.stateOverride === "hostname") {
            return false;
          }
          const host = parseHost(this.buffer, isNotSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          this.url.host = host;
          this.buffer = "";
          this.state = "port";
        } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
          --this.pointer;
          if (isSpecial(this.url) && this.buffer === "") {
            this.parseError = true;
            return failure;
          } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
            this.parseError = true;
            return false;
          }
          const host = parseHost(this.buffer, isNotSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          this.url.host = host;
          this.buffer = "";
          this.state = "path start";
          if (this.stateOverride) {
            return false;
          }
        } else {
          if (c === p("[")) {
            this.arrFlag = true;
          } else if (c === p("]")) {
            this.arrFlag = false;
          }
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
        if (infra.isASCIIDigit(c)) {
          this.buffer += cStr;
        } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\") || this.stateOverride) {
          if (this.buffer !== "") {
            const port = parseInt(this.buffer);
            if (port > 2 ** 16 - 1) {
              this.parseError = true;
              return failure;
            }
            this.url.port = port === defaultPort(this.url.scheme) ? null : port;
            this.buffer = "";
          }
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
          --this.pointer;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([p("/"), p("\\"), p("?"), p("#")]);
      function startsWithWindowsDriveLetter(input, pointer) {
        const length = input.length - pointer;
        return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
      }
      URLStateMachine.prototype["parse file"] = function parseFile(c) {
        this.url.scheme = "file";
        this.url.host = "";
        if (c === p("/") || c === p("\\")) {
          if (c === p("\\")) {
            this.parseError = true;
          }
          this.state = "file slash";
        } else if (this.base !== null && this.base.scheme === "file") {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          if (c === p("?")) {
            this.url.query = "";
            this.state = "query";
          } else if (c === p("#")) {
            this.url.fragment = "";
            this.state = "fragment";
          } else if (!isNaN(c)) {
            this.url.query = null;
            if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
              shortenPath(this.url);
            } else {
              this.parseError = true;
              this.url.path = [];
            }
            this.state = "path";
            --this.pointer;
          }
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
        if (c === p("/") || c === p("\\")) {
          if (c === p("\\")) {
            this.parseError = true;
          }
          this.state = "file host";
        } else {
          if (this.base !== null && this.base.scheme === "file") {
            if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
              this.url.path.push(this.base.path[0]);
            }
            this.url.host = this.base.host;
          }
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
        if (isNaN(c) || c === p("/") || c === p("\\") || c === p("?") || c === p("#")) {
          --this.pointer;
          if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
            this.parseError = true;
            this.state = "path";
          } else if (this.buffer === "") {
            this.url.host = "";
            if (this.stateOverride) {
              return false;
            }
            this.state = "path start";
          } else {
            let host = parseHost(this.buffer, isNotSpecial(this.url));
            if (host === failure) {
              return failure;
            }
            if (host === "localhost") {
              host = "";
            }
            this.url.host = host;
            if (this.stateOverride) {
              return false;
            }
            this.buffer = "";
            this.state = "path start";
          }
        } else {
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
        if (isSpecial(this.url)) {
          if (c === p("\\")) {
            this.parseError = true;
          }
          this.state = "path";
          if (c !== p("/") && c !== p("\\")) {
            --this.pointer;
          }
        } else if (!this.stateOverride && c === p("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (!this.stateOverride && c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (c !== void 0) {
          this.state = "path";
          if (c !== p("/")) {
            --this.pointer;
          }
        } else if (this.stateOverride && this.url.host === null) {
          this.url.path.push("");
        }
        return true;
      };
      URLStateMachine.prototype["parse path"] = function parsePath3(c) {
        if (isNaN(c) || c === p("/") || isSpecial(this.url) && c === p("\\") || !this.stateOverride && (c === p("?") || c === p("#"))) {
          if (isSpecial(this.url) && c === p("\\")) {
            this.parseError = true;
          }
          if (isDoubleDot(this.buffer)) {
            shortenPath(this.url);
            if (c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
              this.url.path.push("");
            }
          } else if (isSingleDot(this.buffer) && c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
            this.url.path.push("");
          } else if (!isSingleDot(this.buffer)) {
            if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
              this.buffer = `${this.buffer[0]}:`;
            }
            this.url.path.push(this.buffer);
          }
          this.buffer = "";
          if (c === p("?")) {
            this.url.query = "";
            this.state = "query";
          }
          if (c === p("#")) {
            this.url.fragment = "";
            this.state = "fragment";
          }
        } else {
          if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
        }
        return true;
      };
      URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (!isNaN(c) && c !== p("%")) {
            this.parseError = true;
          }
          if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          if (!isNaN(c)) {
            this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
          }
        }
        return true;
      };
      URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        if (!this.stateOverride && c === p("#") || isNaN(c)) {
          const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
          this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
          this.buffer = "";
          if (c === p("#")) {
            this.url.fragment = "";
            this.state = "fragment";
          }
        } else if (!isNaN(c)) {
          if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
        if (!isNaN(c)) {
          if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
        }
        return true;
      };
      function serializeURL(url, excludeFragment) {
        let output2 = `${url.scheme}:`;
        if (url.host !== null) {
          output2 += "//";
          if (url.username !== "" || url.password !== "") {
            output2 += url.username;
            if (url.password !== "") {
              output2 += `:${url.password}`;
            }
            output2 += "@";
          }
          output2 += serializeHost(url.host);
          if (url.port !== null) {
            output2 += `:${url.port}`;
          }
        }
        if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
          output2 += "/.";
        }
        output2 += serializePath(url);
        if (url.query !== null) {
          output2 += `?${url.query}`;
        }
        if (!excludeFragment && url.fragment !== null) {
          output2 += `#${url.fragment}`;
        }
        return output2;
      }
      function serializeOrigin(tuple2) {
        let result = `${tuple2.scheme}://`;
        result += serializeHost(tuple2.host);
        if (tuple2.port !== null) {
          result += `:${tuple2.port}`;
        }
        return result;
      }
      function serializePath(url) {
        if (hasAnOpaquePath(url)) {
          return url.path;
        }
        let output2 = "";
        for (const segment of url.path) {
          output2 += `/${segment}`;
        }
        return output2;
      }
      module.exports.serializeURL = serializeURL;
      module.exports.serializePath = serializePath;
      module.exports.serializeURLOrigin = function(url) {
        switch (url.scheme) {
          case "blob": {
            const pathURL = module.exports.parseURL(serializePath(url));
            if (pathURL === null) {
              return "null";
            }
            if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
              return "null";
            }
            return module.exports.serializeURLOrigin(pathURL);
          }
          case "ftp":
          case "http":
          case "https":
          case "ws":
          case "wss":
            return serializeOrigin({
              scheme: url.scheme,
              host: url.host,
              port: url.port
            });
          case "file":
            return "null";
          default:
            return "null";
        }
      };
      module.exports.basicURLParse = function(input, options) {
        if (options === void 0) {
          options = {};
        }
        const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
        if (usm.failure) {
          return null;
        }
        return usm.url;
      };
      module.exports.setTheUsername = function(url, username) {
        url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
      };
      module.exports.setThePassword = function(url, password) {
        url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
      };
      module.exports.serializeHost = serializeHost;
      module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
      module.exports.hasAnOpaquePath = hasAnOpaquePath;
      module.exports.serializeInteger = function(integer) {
        return String(integer);
      };
      module.exports.parseURL = function(input, options) {
        if (options === void 0) {
          options = {};
        }
        return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/urlencoded.js
  var require_urlencoded = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/urlencoded.js"(exports, module) {
      "use strict";
      var { utf8Encode, utf8DecodeWithoutBOM } = require_encoding();
      var { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require_percent_encoding();
      function p(char) {
        return char.codePointAt(0);
      }
      function parseUrlencoded(input) {
        const sequences = strictlySplitByteSequence(input, p("&"));
        const output2 = [];
        for (const bytes2 of sequences) {
          if (bytes2.length === 0) {
            continue;
          }
          let name, value;
          const indexOfEqual = bytes2.indexOf(p("="));
          if (indexOfEqual >= 0) {
            name = bytes2.slice(0, indexOfEqual);
            value = bytes2.slice(indexOfEqual + 1);
          } else {
            name = bytes2;
            value = new Uint8Array(0);
          }
          name = replaceByteInByteSequence(name, 43, 32);
          value = replaceByteInByteSequence(value, 43, 32);
          const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
          const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
          output2.push([nameString, valueString]);
        }
        return output2;
      }
      function parseUrlencodedString(input) {
        return parseUrlencoded(utf8Encode(input));
      }
      function serializeUrlencoded(tuples, encodingOverride = void 0) {
        let encoding = "utf-8";
        if (encodingOverride !== void 0) {
          encoding = encodingOverride;
        }
        let output2 = "";
        for (const [i, tuple2] of tuples.entries()) {
          const name = utf8PercentEncodeString(tuple2[0], isURLEncodedPercentEncode, true);
          let value = tuple2[1];
          if (tuple2.length > 2 && tuple2[2] !== void 0) {
            if (tuple2[2] === "hidden" && name === "_charset_") {
              value = encoding;
            } else if (tuple2[2] === "file") {
              value = value.name;
            }
          }
          value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);
          if (i !== 0) {
            output2 += "&";
          }
          output2 += `${name}=${value}`;
        }
        return output2;
      }
      function strictlySplitByteSequence(buf, cp) {
        const list = [];
        let last = 0;
        let i = buf.indexOf(cp);
        while (i >= 0) {
          list.push(buf.slice(last, i));
          last = i + 1;
          i = buf.indexOf(cp, last);
        }
        if (last !== buf.length) {
          list.push(buf.slice(last));
        }
        return list;
      }
      function replaceByteInByteSequence(buf, from, to) {
        let i = buf.indexOf(from);
        while (i >= 0) {
          buf[i] = to;
          i = buf.indexOf(from, i + 1);
        }
        return buf;
      }
      module.exports = {
        parseUrlencodedString,
        serializeUrlencoded
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/Function.js
  var require_Function = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/Function.js"(exports) {
      "use strict";
      var conversions = require_lib3();
      var utils = require_utils3();
      exports.convert = (globalObject, value, { context: context2 = "The provided value" } = {}) => {
        if (typeof value !== "function") {
          throw new globalObject.TypeError(context2 + " is not a function");
        }
        function invokeTheCallbackFunction(...args) {
          const thisArg = utils.tryWrapperForImpl(this);
          let callResult;
          for (let i = 0; i < args.length; i++) {
            args[i] = utils.tryWrapperForImpl(args[i]);
          }
          callResult = Reflect.apply(value, thisArg, args);
          callResult = conversions["any"](callResult, { context: context2, globals: globalObject });
          return callResult;
        }
        invokeTheCallbackFunction.construct = (...args) => {
          for (let i = 0; i < args.length; i++) {
            args[i] = utils.tryWrapperForImpl(args[i]);
          }
          let callResult = Reflect.construct(value, args);
          callResult = conversions["any"](callResult, { context: context2, globals: globalObject });
          return callResult;
        };
        invokeTheCallbackFunction[utils.wrapperSymbol] = value;
        invokeTheCallbackFunction.objectReference = value;
        return invokeTheCallbackFunction;
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/URLSearchParams-impl.js
  var require_URLSearchParams_impl = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/URLSearchParams-impl.js"(exports) {
      "use strict";
      var urlencoded = require_urlencoded();
      exports.implementation = class URLSearchParamsImpl {
        constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
          let init2 = constructorArgs[0];
          this._list = [];
          this._url = null;
          if (!doNotStripQMark && typeof init2 === "string" && init2[0] === "?") {
            init2 = init2.slice(1);
          }
          if (Array.isArray(init2)) {
            for (const pair of init2) {
              if (pair.length !== 2) {
                throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
              }
              this._list.push([pair[0], pair[1]]);
            }
          } else if (typeof init2 === "object" && Object.getPrototypeOf(init2) === null) {
            for (const name of Object.keys(init2)) {
              const value = init2[name];
              this._list.push([name, value]);
            }
          } else {
            this._list = urlencoded.parseUrlencodedString(init2);
          }
        }
        _updateSteps() {
          if (this._url !== null) {
            let serializedQuery = urlencoded.serializeUrlencoded(this._list);
            if (serializedQuery === "") {
              serializedQuery = null;
            }
            this._url._url.query = serializedQuery;
            if (serializedQuery === null) {
              this._url._potentiallyStripTrailingSpacesFromAnOpaquePath();
            }
          }
        }
        get size() {
          return this._list.length;
        }
        append(name, value) {
          this._list.push([name, value]);
          this._updateSteps();
        }
        delete(name, value) {
          let i = 0;
          while (i < this._list.length) {
            if (this._list[i][0] === name && (value === void 0 || this._list[i][1] === value)) {
              this._list.splice(i, 1);
            } else {
              i++;
            }
          }
          this._updateSteps();
        }
        get(name) {
          for (const tuple2 of this._list) {
            if (tuple2[0] === name) {
              return tuple2[1];
            }
          }
          return null;
        }
        getAll(name) {
          const output2 = [];
          for (const tuple2 of this._list) {
            if (tuple2[0] === name) {
              output2.push(tuple2[1]);
            }
          }
          return output2;
        }
        has(name, value) {
          for (const tuple2 of this._list) {
            if (tuple2[0] === name && (value === void 0 || tuple2[1] === value)) {
              return true;
            }
          }
          return false;
        }
        set(name, value) {
          let found = false;
          let i = 0;
          while (i < this._list.length) {
            if (this._list[i][0] === name) {
              if (found) {
                this._list.splice(i, 1);
              } else {
                found = true;
                this._list[i][1] = value;
                i++;
              }
            } else {
              i++;
            }
          }
          if (!found) {
            this._list.push([name, value]);
          }
          this._updateSteps();
        }
        sort() {
          this._list.sort((a, b) => {
            if (a[0] < b[0]) {
              return -1;
            }
            if (a[0] > b[0]) {
              return 1;
            }
            return 0;
          });
          this._updateSteps();
        }
        [Symbol.iterator]() {
          return this._list[Symbol.iterator]();
        }
        toString() {
          return urlencoded.serializeUrlencoded(this._list);
        }
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/URLSearchParams.js
  var require_URLSearchParams = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/URLSearchParams.js"(exports) {
      "use strict";
      var conversions = require_lib3();
      var utils = require_utils3();
      var Function4 = require_Function();
      var newObjectInRealm = utils.newObjectInRealm;
      var implSymbol = utils.implSymbol;
      var ctorRegistrySymbol = utils.ctorRegistrySymbol;
      var interfaceName = "URLSearchParams";
      exports.is = (value) => {
        return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
      };
      exports.isImpl = (value) => {
        return utils.isObject(value) && value instanceof Impl.implementation;
      };
      exports.convert = (globalObject, value, { context: context2 = "The provided value" } = {}) => {
        if (exports.is(value)) {
          return utils.implForWrapper(value);
        }
        throw new globalObject.TypeError(`${context2} is not of type 'URLSearchParams'.`);
      };
      exports.createDefaultIterator = (globalObject, target, kind) => {
        const ctorRegistry = globalObject[ctorRegistrySymbol];
        const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
        const iterator = Object.create(iteratorPrototype);
        Object.defineProperty(iterator, utils.iterInternalSymbol, {
          value: { target, kind, index: 0 },
          configurable: true
        });
        return iterator;
      };
      function makeWrapper(globalObject, newTarget) {
        let proto;
        if (newTarget !== void 0) {
          proto = newTarget.prototype;
        }
        if (!utils.isObject(proto)) {
          proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
        }
        return Object.create(proto);
      }
      exports.create = (globalObject, constructorArgs, privateData) => {
        const wrapper = makeWrapper(globalObject);
        return exports.setup(wrapper, globalObject, constructorArgs, privateData);
      };
      exports.createImpl = (globalObject, constructorArgs, privateData) => {
        const wrapper = exports.create(globalObject, constructorArgs, privateData);
        return utils.implForWrapper(wrapper);
      };
      exports._internalSetup = (wrapper, globalObject) => {
      };
      exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
        privateData.wrapper = wrapper;
        exports._internalSetup(wrapper, globalObject);
        Object.defineProperty(wrapper, implSymbol, {
          value: new Impl.implementation(globalObject, constructorArgs, privateData),
          configurable: true
        });
        wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
        if (Impl.init) {
          Impl.init(wrapper[implSymbol]);
        }
        return wrapper;
      };
      exports.new = (globalObject, newTarget) => {
        const wrapper = makeWrapper(globalObject, newTarget);
        exports._internalSetup(wrapper, globalObject);
        Object.defineProperty(wrapper, implSymbol, {
          value: Object.create(Impl.implementation.prototype),
          configurable: true
        });
        wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
        if (Impl.init) {
          Impl.init(wrapper[implSymbol]);
        }
        return wrapper[implSymbol];
      };
      var exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
      exports.install = (globalObject, globalNames) => {
        if (!globalNames.some((globalName) => exposed.has(globalName))) {
          return;
        }
        const ctorRegistry = utils.initCtorRegistry(globalObject);
        class URLSearchParams {
          constructor() {
            const args = [];
            {
              let curArg = arguments[0];
              if (curArg !== void 0) {
                if (utils.isObject(curArg)) {
                  if (curArg[Symbol.iterator] !== void 0) {
                    if (!utils.isObject(curArg)) {
                      throw new globalObject.TypeError(
                        "Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object."
                      );
                    } else {
                      const V = [];
                      const tmp = curArg;
                      for (let nextItem of tmp) {
                        if (!utils.isObject(nextItem)) {
                          throw new globalObject.TypeError(
                            "Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object."
                          );
                        } else {
                          const V2 = [];
                          const tmp2 = nextItem;
                          for (let nextItem2 of tmp2) {
                            nextItem2 = conversions["USVString"](nextItem2, {
                              context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element",
                              globals: globalObject
                            });
                            V2.push(nextItem2);
                          }
                          nextItem = V2;
                        }
                        V.push(nextItem);
                      }
                      curArg = V;
                    }
                  } else {
                    if (!utils.isObject(curArg)) {
                      throw new globalObject.TypeError(
                        "Failed to construct 'URLSearchParams': parameter 1 record is not an object."
                      );
                    } else {
                      const result = /* @__PURE__ */ Object.create(null);
                      for (const key of Reflect.ownKeys(curArg)) {
                        const desc = Object.getOwnPropertyDescriptor(curArg, key);
                        if (desc && desc.enumerable) {
                          let typedKey = key;
                          typedKey = conversions["USVString"](typedKey, {
                            context: "Failed to construct 'URLSearchParams': parameter 1 record's key",
                            globals: globalObject
                          });
                          let typedValue = curArg[key];
                          typedValue = conversions["USVString"](typedValue, {
                            context: "Failed to construct 'URLSearchParams': parameter 1 record's value",
                            globals: globalObject
                          });
                          result[typedKey] = typedValue;
                        }
                      }
                      curArg = result;
                    }
                  }
                } else {
                  curArg = conversions["USVString"](curArg, {
                    context: "Failed to construct 'URLSearchParams': parameter 1",
                    globals: globalObject
                  });
                }
              } else {
                curArg = "";
              }
              args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
          }
          append(name, value) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError(
                "'append' called on an object that is not a valid instance of URLSearchParams."
              );
            }
            if (arguments.length < 2) {
              throw new globalObject.TypeError(
                `Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            {
              let curArg = arguments[1];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
                globals: globalObject
              });
              args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
          }
          delete(name) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError(
                "'delete' called on an object that is not a valid instance of URLSearchParams."
              );
            }
            if (arguments.length < 1) {
              throw new globalObject.TypeError(
                `Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            {
              let curArg = arguments[1];
              if (curArg !== void 0) {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
                  globals: globalObject
                });
              }
              args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
          }
          get(name) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
            }
            if (arguments.length < 1) {
              throw new globalObject.TypeError(
                `Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            return esValue[implSymbol].get(...args);
          }
          getAll(name) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError(
                "'getAll' called on an object that is not a valid instance of URLSearchParams."
              );
            }
            if (arguments.length < 1) {
              throw new globalObject.TypeError(
                `Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
          }
          has(name) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
            }
            if (arguments.length < 1) {
              throw new globalObject.TypeError(
                `Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            {
              let curArg = arguments[1];
              if (curArg !== void 0) {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
                  globals: globalObject
                });
              }
              args.push(curArg);
            }
            return esValue[implSymbol].has(...args);
          }
          set(name, value) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
            }
            if (arguments.length < 2) {
              throw new globalObject.TypeError(
                `Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            {
              let curArg = arguments[1];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
                globals: globalObject
              });
              args.push(curArg);
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
          }
          sort() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
            }
            return utils.tryWrapperForImpl(esValue[implSymbol].sort());
          }
          toString() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError(
                "'toString' called on an object that is not a valid instance of URLSearchParams."
              );
            }
            return esValue[implSymbol].toString();
          }
          keys() {
            if (!exports.is(this)) {
              throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
            }
            return exports.createDefaultIterator(globalObject, this, "key");
          }
          values() {
            if (!exports.is(this)) {
              throw new globalObject.TypeError(
                "'values' called on an object that is not a valid instance of URLSearchParams."
              );
            }
            return exports.createDefaultIterator(globalObject, this, "value");
          }
          entries() {
            if (!exports.is(this)) {
              throw new globalObject.TypeError(
                "'entries' called on an object that is not a valid instance of URLSearchParams."
              );
            }
            return exports.createDefaultIterator(globalObject, this, "key+value");
          }
          forEach(callback) {
            if (!exports.is(this)) {
              throw new globalObject.TypeError(
                "'forEach' called on an object that is not a valid instance of URLSearchParams."
              );
            }
            if (arguments.length < 1) {
              throw new globalObject.TypeError(
                "Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present."
              );
            }
            callback = Function4.convert(globalObject, callback, {
              context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
            });
            const thisArg = arguments[1];
            let pairs = Array.from(this[implSymbol]);
            let i = 0;
            while (i < pairs.length) {
              const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
              callback.call(thisArg, value, key, this);
              pairs = Array.from(this[implSymbol]);
              i++;
            }
          }
          get size() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError(
                "'get size' called on an object that is not a valid instance of URLSearchParams."
              );
            }
            return esValue[implSymbol]["size"];
          }
        }
        Object.defineProperties(URLSearchParams.prototype, {
          append: { enumerable: true },
          delete: { enumerable: true },
          get: { enumerable: true },
          getAll: { enumerable: true },
          has: { enumerable: true },
          set: { enumerable: true },
          sort: { enumerable: true },
          toString: { enumerable: true },
          keys: { enumerable: true },
          values: { enumerable: true },
          entries: { enumerable: true },
          forEach: { enumerable: true },
          size: { enumerable: true },
          [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
          [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
        });
        ctorRegistry[interfaceName] = URLSearchParams;
        ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
          [Symbol.toStringTag]: {
            configurable: true,
            value: "URLSearchParams Iterator"
          }
        });
        utils.define(ctorRegistry["URLSearchParams Iterator"], {
          next() {
            const internal = this && this[utils.iterInternalSymbol];
            if (!internal) {
              throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
            }
            const { target, kind, index } = internal;
            const values = Array.from(target[implSymbol]);
            const len = values.length;
            if (index >= len) {
              return newObjectInRealm(globalObject, { value: void 0, done: true });
            }
            const pair = values[index];
            internal.index = index + 1;
            return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
          }
        });
        Object.defineProperty(globalObject, interfaceName, {
          configurable: true,
          writable: true,
          value: URLSearchParams
        });
      };
      var Impl = require_URLSearchParams_impl();
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/URL-impl.js
  var require_URL_impl = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
      "use strict";
      var usm = require_url_state_machine();
      var urlencoded = require_urlencoded();
      var URLSearchParams = require_URLSearchParams();
      exports.implementation = class URLImpl {
        // Unlike the spec, we duplicate some code between the constructor and canParse, because we want to give useful error
        // messages in the constructor that distinguish between the different causes of failure.
        constructor(globalObject, [url, base2]) {
          let parsedBase = null;
          if (base2 !== void 0) {
            parsedBase = usm.basicURLParse(base2);
            if (parsedBase === null) {
              throw new TypeError(`Invalid base URL: ${base2}`);
            }
          }
          const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
          if (parsedURL === null) {
            throw new TypeError(`Invalid URL: ${url}`);
          }
          const query = parsedURL.query !== null ? parsedURL.query : "";
          this._url = parsedURL;
          this._query = URLSearchParams.createImpl(globalObject, [query], { doNotStripQMark: true });
          this._query._url = this;
        }
        static parse(globalObject, input, base2) {
          try {
            return new URLImpl(globalObject, [input, base2]);
          } catch {
            return null;
          }
        }
        static canParse(url, base2) {
          let parsedBase = null;
          if (base2 !== void 0) {
            parsedBase = usm.basicURLParse(base2);
            if (parsedBase === null) {
              return false;
            }
          }
          const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
          if (parsedURL === null) {
            return false;
          }
          return true;
        }
        get href() {
          return usm.serializeURL(this._url);
        }
        set href(v) {
          const parsedURL = usm.basicURLParse(v);
          if (parsedURL === null) {
            throw new TypeError(`Invalid URL: ${v}`);
          }
          this._url = parsedURL;
          this._query._list.splice(0);
          const { query } = parsedURL;
          if (query !== null) {
            this._query._list = urlencoded.parseUrlencodedString(query);
          }
        }
        get origin() {
          return usm.serializeURLOrigin(this._url);
        }
        get protocol() {
          return `${this._url.scheme}:`;
        }
        set protocol(v) {
          usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
        }
        get username() {
          return this._url.username;
        }
        set username(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          usm.setTheUsername(this._url, v);
        }
        get password() {
          return this._url.password;
        }
        set password(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          usm.setThePassword(this._url, v);
        }
        get host() {
          const url = this._url;
          if (url.host === null) {
            return "";
          }
          if (url.port === null) {
            return usm.serializeHost(url.host);
          }
          return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
        }
        set host(v) {
          if (usm.hasAnOpaquePath(this._url)) {
            return;
          }
          usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
        }
        get hostname() {
          if (this._url.host === null) {
            return "";
          }
          return usm.serializeHost(this._url.host);
        }
        set hostname(v) {
          if (usm.hasAnOpaquePath(this._url)) {
            return;
          }
          usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
        }
        get port() {
          if (this._url.port === null) {
            return "";
          }
          return usm.serializeInteger(this._url.port);
        }
        set port(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          if (v === "") {
            this._url.port = null;
          } else {
            usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
          }
        }
        get pathname() {
          return usm.serializePath(this._url);
        }
        set pathname(v) {
          if (usm.hasAnOpaquePath(this._url)) {
            return;
          }
          this._url.path = [];
          usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
        }
        get search() {
          if (this._url.query === null || this._url.query === "") {
            return "";
          }
          return `?${this._url.query}`;
        }
        set search(v) {
          const url = this._url;
          if (v === "") {
            url.query = null;
            this._query._list = [];
            this._potentiallyStripTrailingSpacesFromAnOpaquePath();
            return;
          }
          const input = v[0] === "?" ? v.substring(1) : v;
          url.query = "";
          usm.basicURLParse(input, { url, stateOverride: "query" });
          this._query._list = urlencoded.parseUrlencodedString(input);
        }
        get searchParams() {
          return this._query;
        }
        get hash() {
          if (this._url.fragment === null || this._url.fragment === "") {
            return "";
          }
          return `#${this._url.fragment}`;
        }
        set hash(v) {
          if (v === "") {
            this._url.fragment = null;
            this._potentiallyStripTrailingSpacesFromAnOpaquePath();
            return;
          }
          const input = v[0] === "#" ? v.substring(1) : v;
          this._url.fragment = "";
          usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
        }
        toJSON() {
          return this.href;
        }
        _potentiallyStripTrailingSpacesFromAnOpaquePath() {
          if (!usm.hasAnOpaquePath(this._url)) {
            return;
          }
          if (this._url.fragment !== null) {
            return;
          }
          if (this._url.query !== null) {
            return;
          }
          this._url.path = this._url.path.replace(/\u0020+$/u, "");
        }
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/URL.js
  var require_URL = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/lib/URL.js"(exports) {
      "use strict";
      var conversions = require_lib3();
      var utils = require_utils3();
      var implSymbol = utils.implSymbol;
      var ctorRegistrySymbol = utils.ctorRegistrySymbol;
      var interfaceName = "URL";
      exports.is = (value) => {
        return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
      };
      exports.isImpl = (value) => {
        return utils.isObject(value) && value instanceof Impl.implementation;
      };
      exports.convert = (globalObject, value, { context: context2 = "The provided value" } = {}) => {
        if (exports.is(value)) {
          return utils.implForWrapper(value);
        }
        throw new globalObject.TypeError(`${context2} is not of type 'URL'.`);
      };
      function makeWrapper(globalObject, newTarget) {
        let proto;
        if (newTarget !== void 0) {
          proto = newTarget.prototype;
        }
        if (!utils.isObject(proto)) {
          proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
        }
        return Object.create(proto);
      }
      exports.create = (globalObject, constructorArgs, privateData) => {
        const wrapper = makeWrapper(globalObject);
        return exports.setup(wrapper, globalObject, constructorArgs, privateData);
      };
      exports.createImpl = (globalObject, constructorArgs, privateData) => {
        const wrapper = exports.create(globalObject, constructorArgs, privateData);
        return utils.implForWrapper(wrapper);
      };
      exports._internalSetup = (wrapper, globalObject) => {
      };
      exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
        privateData.wrapper = wrapper;
        exports._internalSetup(wrapper, globalObject);
        Object.defineProperty(wrapper, implSymbol, {
          value: new Impl.implementation(globalObject, constructorArgs, privateData),
          configurable: true
        });
        wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
        if (Impl.init) {
          Impl.init(wrapper[implSymbol]);
        }
        return wrapper;
      };
      exports.new = (globalObject, newTarget) => {
        const wrapper = makeWrapper(globalObject, newTarget);
        exports._internalSetup(wrapper, globalObject);
        Object.defineProperty(wrapper, implSymbol, {
          value: Object.create(Impl.implementation.prototype),
          configurable: true
        });
        wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
        if (Impl.init) {
          Impl.init(wrapper[implSymbol]);
        }
        return wrapper[implSymbol];
      };
      var exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
      exports.install = (globalObject, globalNames) => {
        if (!globalNames.some((globalName) => exposed.has(globalName))) {
          return;
        }
        const ctorRegistry = utils.initCtorRegistry(globalObject);
        class URL3 {
          constructor(url) {
            if (arguments.length < 1) {
              throw new globalObject.TypeError(
                `Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URL': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            {
              let curArg = arguments[1];
              if (curArg !== void 0) {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to construct 'URL': parameter 2",
                  globals: globalObject
                });
              }
              args.push(curArg);
            }
            return exports.setup(Object.create(new.target.prototype), globalObject, args);
          }
          toJSON() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol].toJSON();
          }
          get href() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["href"];
          }
          set href(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'href' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["href"] = V;
          }
          toString() {
            const esValue = this;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["href"];
          }
          get origin() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["origin"];
          }
          get protocol() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["protocol"];
          }
          set protocol(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'protocol' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["protocol"] = V;
          }
          get username() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["username"];
          }
          set username(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'username' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["username"] = V;
          }
          get password() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["password"];
          }
          set password(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'password' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["password"] = V;
          }
          get host() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["host"];
          }
          set host(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'host' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["host"] = V;
          }
          get hostname() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["hostname"];
          }
          set hostname(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'hostname' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["hostname"] = V;
          }
          get port() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["port"];
          }
          set port(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'port' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["port"] = V;
          }
          get pathname() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["pathname"];
          }
          set pathname(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'pathname' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["pathname"] = V;
          }
          get search() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["search"];
          }
          set search(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'search' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["search"] = V;
          }
          get searchParams() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
            }
            return utils.getSameObject(this, "searchParams", () => {
              return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
            });
          }
          get hash() {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
            }
            return esValue[implSymbol]["hash"];
          }
          set hash(V) {
            const esValue = this !== null && this !== void 0 ? this : globalObject;
            if (!exports.is(esValue)) {
              throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
            }
            V = conversions["USVString"](V, {
              context: "Failed to set the 'hash' property on 'URL': The provided value",
              globals: globalObject
            });
            esValue[implSymbol]["hash"] = V;
          }
          static parse(url) {
            if (arguments.length < 1) {
              throw new globalObject.TypeError(
                `Failed to execute 'parse' on 'URL': 1 argument required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'parse' on 'URL': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            {
              let curArg = arguments[1];
              if (curArg !== void 0) {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to execute 'parse' on 'URL': parameter 2",
                  globals: globalObject
                });
              }
              args.push(curArg);
            }
            return utils.tryWrapperForImpl(Impl.implementation.parse(globalObject, ...args));
          }
          static canParse(url) {
            if (arguments.length < 1) {
              throw new globalObject.TypeError(
                `Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`
              );
            }
            const args = [];
            {
              let curArg = arguments[0];
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'canParse' on 'URL': parameter 1",
                globals: globalObject
              });
              args.push(curArg);
            }
            {
              let curArg = arguments[1];
              if (curArg !== void 0) {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to execute 'canParse' on 'URL': parameter 2",
                  globals: globalObject
                });
              }
              args.push(curArg);
            }
            return Impl.implementation.canParse(...args);
          }
        }
        Object.defineProperties(URL3.prototype, {
          toJSON: { enumerable: true },
          href: { enumerable: true },
          toString: { enumerable: true },
          origin: { enumerable: true },
          protocol: { enumerable: true },
          username: { enumerable: true },
          password: { enumerable: true },
          host: { enumerable: true },
          hostname: { enumerable: true },
          port: { enumerable: true },
          pathname: { enumerable: true },
          search: { enumerable: true },
          searchParams: { enumerable: true },
          hash: { enumerable: true },
          [Symbol.toStringTag]: { value: "URL", configurable: true }
        });
        Object.defineProperties(URL3, { parse: { enumerable: true }, canParse: { enumerable: true } });
        ctorRegistry[interfaceName] = URL3;
        Object.defineProperty(globalObject, interfaceName, {
          configurable: true,
          writable: true,
          value: URL3
        });
        if (globalNames.includes("Window")) {
          Object.defineProperty(globalObject, "webkitURL", {
            configurable: true,
            writable: true,
            value: URL3
          });
        }
      };
      var Impl = require_URL_impl();
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/webidl2js-wrapper.js
  var require_webidl2js_wrapper = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/webidl2js-wrapper.js"(exports) {
      "use strict";
      var URL3 = require_URL();
      var URLSearchParams = require_URLSearchParams();
      exports.URL = URL3;
      exports.URLSearchParams = URLSearchParams;
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/index.js
  var require_whatwg_url = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@14.1.0/node_modules/whatwg-url/index.js"(exports) {
      "use strict";
      var { URL: URL3, URLSearchParams } = require_webidl2js_wrapper();
      var urlStateMachine = require_url_state_machine();
      var percentEncoding = require_percent_encoding();
      var sharedGlobalObject = { Array, Object, Promise, String, TypeError };
      URL3.install(sharedGlobalObject, ["Window"]);
      URLSearchParams.install(sharedGlobalObject, ["Window"]);
      exports.URL = sharedGlobalObject.URL;
      exports.URLSearchParams = sharedGlobalObject.URLSearchParams;
      exports.parseURL = urlStateMachine.parseURL;
      exports.basicURLParse = urlStateMachine.basicURLParse;
      exports.serializeURL = urlStateMachine.serializeURL;
      exports.serializePath = urlStateMachine.serializePath;
      exports.serializeHost = urlStateMachine.serializeHost;
      exports.serializeInteger = urlStateMachine.serializeInteger;
      exports.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
      exports.setTheUsername = urlStateMachine.setTheUsername;
      exports.setThePassword = urlStateMachine.setThePassword;
      exports.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
      exports.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;
      exports.percentDecodeString = percentEncoding.percentDecodeString;
      exports.percentDecodeBytes = percentEncoding.percentDecodeBytes;
    }
  });

  // ../../node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs
  var lib_exports = {};
  __export(lib_exports, {
    AbortError: () => AbortError,
    FetchError: () => FetchError,
    Headers: () => Headers2,
    Request: () => Request,
    Response: () => Response2,
    default: () => lib_default
  });
  function FetchError(message, type3, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type3;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream.default)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof import_stream.default) {
      body.on("error", function(err2) {
        const error3 = err2.name === "AbortError" ? err2 : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err2.message}`, "system", err2);
        _this[INTERNALS].error = error3;
      });
    }
  }
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof import_stream.default)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve10, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err2) {
        if (err2.name === "AbortError") {
          abort = true;
          reject(err2);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err2.message}`, "system", err2));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve10(Buffer.concat(accum, accumBytes));
        } catch (err2) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err2.message}`, "system", err2));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone3(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof import_stream.default) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
      body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map2, name) {
    name = name.toLowerCase();
    for (const key in map2) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys4 = Object.keys(headers[MAP]).sort();
    return keys4.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers2();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  function parseURL(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  }
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers2(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  function fetch2(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve10, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort2() {
        let error3 = new AbortError("The user aborted a request.");
        reject(error3);
        if (request.body && request.body instanceof import_stream.default.Readable) {
          destroyStream(request.body, error3);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error3);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize2() {
        abort();
        finalize();
      };
      const req2 = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req2.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req2.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req2.on("error", function(err2) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err2.message}`, "system", err2));
        if (response && response.body) {
          destroyStream(response.body, err2);
        }
        finalize();
      });
      fixResponseChunkedTransferBadEnding(req2, function(err2) {
        if (signal && signal.aborted) {
          return;
        }
        if (response && response.body) {
          destroyStream(response.body, err2);
        }
      });
      if (parseInt(process.version.substring(1)) < 14) {
        req2.on("socket", function(s) {
          s.addListener("close", function(hadError) {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err2 = new Error("Premature close");
              err2.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", err2);
            }
          });
        });
      }
      req2.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err2) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err2) {
                  reject(err2);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers2(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve10(fetch2(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response2(body, response_options);
          resolve10(response);
          return;
        }
        const zlibOptions = {
          flush: import_zlib.default.Z_SYNC_FLUSH,
          finishFlush: import_zlib.default.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
          response = new Response2(body, response_options);
          resolve10(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(import_zlib.default.createInflate());
            } else {
              body = body.pipe(import_zlib.default.createInflateRaw());
            }
            response = new Response2(body, response_options);
            resolve10(response);
          });
          raw.on("end", function() {
            if (!response) {
              response = new Response2(body, response_options);
              resolve10(response);
            }
          });
          return;
        }
        if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
          body = body.pipe(import_zlib.default.createBrotliDecompress());
          response = new Response2(body, response_options);
          resolve10(response);
          return;
        }
        response = new Response2(body, response_options);
        resolve10(response);
      });
      writeToStream(req2, request);
    });
  }
  function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on("socket", function(s) {
      socket = s;
    });
    request.on("response", function(response) {
      const headers = response.headers;
      if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
        response.once("close", function(hadError) {
          const hasDataListener = socket && socket.listenerCount("data") > 0;
          if (hasDataListener && !hadError) {
            const err2 = new Error("Premature close");
            err2.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(err2);
          }
        });
      }
    });
  }
  function destroyStream(stream2, err2) {
    if (stream2.destroy) {
      stream2.destroy(err2);
    } else {
      stream2.emit("error", err2);
      stream2.end();
    }
  }
  var import_stream, import_http, import_url, import_whatwg_url, import_https, import_zlib, Readable, BUFFER2, TYPE2, Blob, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers2, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response2, INTERNALS$2, URL2, parse_url, format_url, streamDestructionSupported, Request, URL$1, PassThrough$1, isDomainOrSubdomain, isSameProtocol, lib_default;
  var init_lib = __esm({
    "../../node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs"() {
      import_stream = __toESM(__require2("stream"), 1);
      import_http = __toESM(__require2("http"), 1);
      import_url = __toESM(__require2("url"), 1);
      import_whatwg_url = __toESM(require_whatwg_url(), 1);
      import_https = __toESM(__require2("https"), 1);
      import_zlib = __toESM(__require2("zlib"), 1);
      Readable = import_stream.default.Readable;
      BUFFER2 = Symbol("buffer");
      TYPE2 = Symbol("type");
      Blob = class {
        constructor() {
          this[TYPE2] = "";
          const blobParts = arguments[0];
          const options = arguments[1];
          const buffers = [];
          let size = 0;
          if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for (let i = 0; i < length; i++) {
              const element = a[i];
              let buffer;
              if (element instanceof Buffer) {
                buffer = element;
              } else if (ArrayBuffer.isView(element)) {
                buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
              } else if (element instanceof ArrayBuffer) {
                buffer = Buffer.from(element);
              } else if (element instanceof Blob) {
                buffer = element[BUFFER2];
              } else {
                buffer = Buffer.from(typeof element === "string" ? element : String(element));
              }
              size += buffer.length;
              buffers.push(buffer);
            }
          }
          this[BUFFER2] = Buffer.concat(buffers);
          let type3 = options && options.type !== void 0 && String(options.type).toLowerCase();
          if (type3 && !/[^\u0020-\u007E]/.test(type3)) {
            this[TYPE2] = type3;
          }
        }
        get size() {
          return this[BUFFER2].length;
        }
        get type() {
          return this[TYPE2];
        }
        text() {
          return Promise.resolve(this[BUFFER2].toString());
        }
        arrayBuffer() {
          const buf = this[BUFFER2];
          const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          return Promise.resolve(ab);
        }
        stream() {
          const readable = new Readable();
          readable._read = function() {
          };
          readable.push(this[BUFFER2]);
          readable.push(null);
          return readable;
        }
        toString() {
          return "[object Blob]";
        }
        slice() {
          const size = this.size;
          const start = arguments[0];
          const end = arguments[1];
          let relativeStart, relativeEnd;
          if (start === void 0) {
            relativeStart = 0;
          } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
          } else {
            relativeStart = Math.min(start, size);
          }
          if (end === void 0) {
            relativeEnd = size;
          } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
          } else {
            relativeEnd = Math.min(end, size);
          }
          const span = Math.max(relativeEnd - relativeStart, 0);
          const buffer = this[BUFFER2];
          const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
          const blob = new Blob([], { type: arguments[2] });
          blob[BUFFER2] = slicedBuffer;
          return blob;
        }
      };
      Object.defineProperties(Blob.prototype, {
        size: { enumerable: true },
        type: { enumerable: true },
        slice: { enumerable: true }
      });
      Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
        value: "Blob",
        writable: false,
        enumerable: false,
        configurable: true
      });
      FetchError.prototype = Object.create(Error.prototype);
      FetchError.prototype.constructor = FetchError;
      FetchError.prototype.name = "FetchError";
      try {
        convert = __require2("encoding").convert;
      } catch (e) {
      }
      INTERNALS = Symbol("Body internals");
      PassThrough = import_stream.default.PassThrough;
      Body.prototype = {
        get body() {
          return this[INTERNALS].body;
        },
        get bodyUsed() {
          return this[INTERNALS].disturbed;
        },
        /**
         * Decode response as ArrayBuffer
         *
         * @return  Promise
         */
        arrayBuffer() {
          return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          });
        },
        /**
         * Return raw response as Blob
         *
         * @return Promise
         */
        blob() {
          let ct = this.headers && this.headers.get("content-type") || "";
          return consumeBody.call(this).then(function(buf) {
            return Object.assign(
              // Prevent copying
              new Blob([], {
                type: ct.toLowerCase()
              }),
              {
                [BUFFER2]: buf
              }
            );
          });
        },
        /**
         * Decode response as json
         *
         * @return  Promise
         */
        json() {
          var _this2 = this;
          return consumeBody.call(this).then(function(buffer) {
            try {
              return JSON.parse(buffer.toString());
            } catch (err2) {
              return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err2.message}`, "invalid-json"));
            }
          });
        },
        /**
         * Decode response as text
         *
         * @return  Promise
         */
        text() {
          return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
          });
        },
        /**
         * Decode response as buffer (non-spec api)
         *
         * @return  Promise
         */
        buffer() {
          return consumeBody.call(this);
        },
        /**
         * Decode response as text, while automatically detecting the encoding and
         * trying to decode to UTF-8 (non-spec api)
         *
         * @return  Promise
         */
        textConverted() {
          var _this3 = this;
          return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
          });
        }
      };
      Object.defineProperties(Body.prototype, {
        body: { enumerable: true },
        bodyUsed: { enumerable: true },
        arrayBuffer: { enumerable: true },
        blob: { enumerable: true },
        json: { enumerable: true },
        text: { enumerable: true }
      });
      Body.mixIn = function(proto) {
        for (const name of Object.getOwnPropertyNames(Body.prototype)) {
          if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
          }
        }
      };
      Body.Promise = global.Promise;
      invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
      invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
      MAP = Symbol("map");
      Headers2 = class {
        /**
         * Headers class
         *
         * @param   Object  headers  Response headers
         * @return  Void
         */
        constructor() {
          let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          this[MAP] = /* @__PURE__ */ Object.create(null);
          if (init2 instanceof Headers2) {
            const rawHeaders = init2.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames) {
              for (const value of rawHeaders[headerName]) {
                this.append(headerName, value);
              }
            }
            return;
          }
          if (init2 == null)
            ;
          else if (typeof init2 === "object") {
            const method = init2[Symbol.iterator];
            if (method != null) {
              if (typeof method !== "function") {
                throw new TypeError("Header pairs must be iterable");
              }
              const pairs = [];
              for (const pair of init2) {
                if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                  throw new TypeError("Each header pair must be iterable");
                }
                pairs.push(Array.from(pair));
              }
              for (const pair of pairs) {
                if (pair.length !== 2) {
                  throw new TypeError("Each header pair must be a name/value tuple");
                }
                this.append(pair[0], pair[1]);
              }
            } else {
              for (const key of Object.keys(init2)) {
                const value = init2[key];
                this.append(key, value);
              }
            }
          } else {
            throw new TypeError("Provided initializer must be an object");
          }
        }
        /**
         * Return combined header value given name
         *
         * @param   String  name  Header name
         * @return  Mixed
         */
        get(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key === void 0) {
            return null;
          }
          return this[MAP][key].join(", ");
        }
        /**
         * Iterate over all headers
         *
         * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
         * @param   Boolean   thisArg   `this` context for callback function
         * @return  Void
         */
        forEach(callback) {
          let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
          let pairs = getHeaders(this);
          let i = 0;
          while (i < pairs.length) {
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
          }
        }
        /**
         * Overwrite header values given name
         *
         * @param   String  name   Header name
         * @param   String  value  Header value
         * @return  Void
         */
        set(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          this[MAP][key !== void 0 ? key : name] = [value];
        }
        /**
         * Append a value onto existing header
         *
         * @param   String  name   Header name
         * @param   String  value  Header value
         * @return  Void
         */
        append(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          if (key !== void 0) {
            this[MAP][key].push(value);
          } else {
            this[MAP][name] = [value];
          }
        }
        /**
         * Check for header name existence
         *
         * @param   String   name  Header name
         * @return  Boolean
         */
        has(name) {
          name = `${name}`;
          validateName(name);
          return find(this[MAP], name) !== void 0;
        }
        /**
         * Delete all header values given name
         *
         * @param   String  name  Header name
         * @return  Void
         */
        delete(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key !== void 0) {
            delete this[MAP][key];
          }
        }
        /**
         * Return raw headers (non-spec api)
         *
         * @return  Object
         */
        raw() {
          return this[MAP];
        }
        /**
         * Get an iterator on keys.
         *
         * @return  Iterator
         */
        keys() {
          return createHeadersIterator(this, "key");
        }
        /**
         * Get an iterator on values.
         *
         * @return  Iterator
         */
        values() {
          return createHeadersIterator(this, "value");
        }
        /**
         * Get an iterator on entries.
         *
         * This is the default iterator of the Headers object.
         *
         * @return  Iterator
         */
        [Symbol.iterator]() {
          return createHeadersIterator(this, "key+value");
        }
      };
      Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
      Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
        value: "Headers",
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperties(Headers2.prototype, {
        get: { enumerable: true },
        forEach: { enumerable: true },
        set: { enumerable: true },
        append: { enumerable: true },
        has: { enumerable: true },
        delete: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true }
      });
      INTERNAL = Symbol("internal");
      HeadersIteratorPrototype = Object.setPrototypeOf({
        next() {
          if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError("Value of `this` is not a HeadersIterator");
          }
          var _INTERNAL = this[INTERNAL];
          const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
          const values = getHeaders(target, kind);
          const len = values.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true
            };
          }
          this[INTERNAL].index = index + 1;
          return {
            value: values[index],
            done: false
          };
        }
      }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
      Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
        value: "HeadersIterator",
        writable: false,
        enumerable: false,
        configurable: true
      });
      INTERNALS$1 = Symbol("Response internals");
      STATUS_CODES = import_http.default.STATUS_CODES;
      Response2 = class {
        constructor() {
          let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          Body.call(this, body, opts);
          const status = opts.status || 200;
          const headers = new Headers2(opts.headers);
          if (body != null && !headers.has("Content-Type")) {
            const contentType = extractContentType(body);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          this[INTERNALS$1] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter
          };
        }
        get url() {
          return this[INTERNALS$1].url || "";
        }
        get status() {
          return this[INTERNALS$1].status;
        }
        /**
         * Convenience property representing if the request ended normally
         */
        get ok() {
          return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
        }
        get redirected() {
          return this[INTERNALS$1].counter > 0;
        }
        get statusText() {
          return this[INTERNALS$1].statusText;
        }
        get headers() {
          return this[INTERNALS$1].headers;
        }
        /**
         * Clone this response
         *
         * @return  Response
         */
        clone() {
          return new Response2(clone3(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
          });
        }
      };
      Body.mixIn(Response2.prototype);
      Object.defineProperties(Response2.prototype, {
        url: { enumerable: true },
        status: { enumerable: true },
        ok: { enumerable: true },
        redirected: { enumerable: true },
        statusText: { enumerable: true },
        headers: { enumerable: true },
        clone: { enumerable: true }
      });
      Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
        value: "Response",
        writable: false,
        enumerable: false,
        configurable: true
      });
      INTERNALS$2 = Symbol("Request internals");
      URL2 = import_url.default.URL || import_whatwg_url.default.URL;
      parse_url = import_url.default.parse;
      format_url = import_url.default.format;
      streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
      Request = class {
        constructor(input) {
          let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          let parsedURL;
          if (!isRequest(input)) {
            if (input && input.href) {
              parsedURL = parseURL(input.href);
            } else {
              parsedURL = parseURL(`${input}`);
            }
            input = {};
          } else {
            parsedURL = parseURL(input.url);
          }
          let method = init2.method || input.method || "GET";
          method = method.toUpperCase();
          if ((init2.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
            throw new TypeError("Request with GET/HEAD method cannot have body");
          }
          let inputBody = init2.body != null ? init2.body : isRequest(input) && input.body !== null ? clone3(input) : null;
          Body.call(this, inputBody, {
            timeout: init2.timeout || input.timeout || 0,
            size: init2.size || input.size || 0
          });
          const headers = new Headers2(init2.headers || input.headers || {});
          if (inputBody != null && !headers.has("Content-Type")) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          let signal = isRequest(input) ? input.signal : null;
          if ("signal" in init2)
            signal = init2.signal;
          if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError("Expected signal to be an instanceof AbortSignal");
          }
          this[INTERNALS$2] = {
            method,
            redirect: init2.redirect || input.redirect || "follow",
            headers,
            parsedURL,
            signal
          };
          this.follow = init2.follow !== void 0 ? init2.follow : input.follow !== void 0 ? input.follow : 20;
          this.compress = init2.compress !== void 0 ? init2.compress : input.compress !== void 0 ? input.compress : true;
          this.counter = init2.counter || input.counter || 0;
          this.agent = init2.agent || input.agent;
        }
        get method() {
          return this[INTERNALS$2].method;
        }
        get url() {
          return format_url(this[INTERNALS$2].parsedURL);
        }
        get headers() {
          return this[INTERNALS$2].headers;
        }
        get redirect() {
          return this[INTERNALS$2].redirect;
        }
        get signal() {
          return this[INTERNALS$2].signal;
        }
        /**
         * Clone this request
         *
         * @return  Request
         */
        clone() {
          return new Request(this);
        }
      };
      Body.mixIn(Request.prototype);
      Object.defineProperty(Request.prototype, Symbol.toStringTag, {
        value: "Request",
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperties(Request.prototype, {
        method: { enumerable: true },
        url: { enumerable: true },
        headers: { enumerable: true },
        redirect: { enumerable: true },
        clone: { enumerable: true },
        signal: { enumerable: true }
      });
      AbortError.prototype = Object.create(Error.prototype);
      AbortError.prototype.constructor = AbortError;
      AbortError.prototype.name = "AbortError";
      URL$1 = import_url.default.URL || import_whatwg_url.default.URL;
      PassThrough$1 = import_stream.default.PassThrough;
      isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
        const orig = new URL$1(original).hostname;
        const dest = new URL$1(destination).hostname;
        return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
      };
      isSameProtocol = function isSameProtocol2(destination, original) {
        const orig = new URL$1(original).protocol;
        const dest = new URL$1(destination).protocol;
        return orig === dest;
      };
      fetch2.isRedirect = function(code) {
        return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
      };
      fetch2.Promise = global.Promise;
      lib_default = fetch2;
    }
  });

  // ../../node_modules/.pnpm/cross-fetch@4.0.0/node_modules/cross-fetch/dist/node-ponyfill.js
  var require_node_ponyfill = __commonJS({
    "../../node_modules/.pnpm/cross-fetch@4.0.0/node_modules/cross-fetch/dist/node-ponyfill.js"(exports, module) {
      var nodeFetch = (init_lib(), __toCommonJS(lib_exports));
      var realFetch = nodeFetch.default || nodeFetch;
      var fetch3 = function(url, options) {
        if (/^\/\//.test(url)) {
          url = "https:" + url;
        }
        return realFetch.call(this, url, options);
      };
      fetch3.ponyfill = true;
      module.exports = exports = fetch3;
      exports.fetch = fetch3;
      exports.Headers = nodeFetch.Headers;
      exports.Request = nodeFetch.Request;
      exports.Response = nodeFetch.Response;
      exports.default = fetch3;
    }
  });

  // ../../node_modules/.pnpm/@fuels+vm-asm@0.58.2/node_modules/@fuels/vm-asm/dist/node/index.cjs
  var require_node = __commonJS({
    "../../node_modules/.pnpm/@fuels+vm-asm@0.58.2/node_modules/@fuels/vm-asm/dist/node/index.cjs"(exports) {
      "use strict";
      var wasm$1;
      var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
        throw Error("TextDecoder not available");
      } };
      if (typeof TextDecoder !== "undefined") {
        cachedTextDecoder.decode();
      }
      var cachedUint8ArrayMemory0 = null;
      function getUint8ArrayMemory0() {
        if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
          cachedUint8ArrayMemory0 = new Uint8Array(wasm$1.memory.buffer);
        }
        return cachedUint8ArrayMemory0;
      }
      function getStringFromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
      }
      function _assertClass(instance, klass) {
        if (!(instance instanceof klass)) {
          throw new Error(`expected instance of ${klass.name}`);
        }
        return instance.ptr;
      }
      function gm_args(ra, args) {
        const ret5 = wasm$1.gm_args(ra, args);
        return Instruction2.__wrap(ret5);
      }
      function gtf_args(ra, rb, args) {
        const ret5 = wasm$1.gtf_args(ra, rb, args);
        return Instruction2.__wrap(ret5);
      }
      function wdcm_args(ra, rb, rc, args) {
        _assertClass(args, CompareArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wdcm_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wqcm_args(ra, rb, rc, args) {
        _assertClass(args, CompareArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wqcm_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wdop_args(ra, rb, rc, args) {
        _assertClass(args, MathArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wdop_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wqop_args(ra, rb, rc, args) {
        _assertClass(args, MathArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wqop_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wdml_args(ra, rb, rc, args) {
        _assertClass(args, MulArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wdml_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wqml_args(ra, rb, rc, args) {
        _assertClass(args, MulArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wqml_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wddv_args(ra, rb, rc, args) {
        _assertClass(args, DivArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wddv_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function wqdv_args(ra, rb, rc, args) {
        _assertClass(args, DivArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret5 = wasm$1.wqdv_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret5);
      }
      function add(dst, lhs, rhs) {
        const ret5 = wasm$1.add(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function and(dst, lhs, rhs) {
        const ret5 = wasm$1.and(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function div(dst, lhs, rhs) {
        const ret5 = wasm$1.div(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function eq3(dst, lhs, rhs) {
        const ret5 = wasm$1.eq(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function exp(dst, lhs, rhs) {
        const ret5 = wasm$1.exp(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function gt3(dst, lhs, rhs) {
        const ret5 = wasm$1.gt(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function lt(dst, lhs, rhs) {
        const ret5 = wasm$1.lt(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function mlog(dst, lhs, rhs) {
        const ret5 = wasm$1.mlog(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function mroo(dst, lhs, rhs) {
        const ret5 = wasm$1.mroo(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function mod_(dst, lhs, rhs) {
        const ret5 = wasm$1.mod_(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function move_3(dst, src) {
        const ret5 = wasm$1.move_(dst, src);
        return Instruction2.__wrap(ret5);
      }
      function mul(dst, lhs, rhs) {
        const ret5 = wasm$1.mul(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function not(dst, arg) {
        const ret5 = wasm$1.not(dst, arg);
        return Instruction2.__wrap(ret5);
      }
      function or(dst, lhs, rhs) {
        const ret5 = wasm$1.or(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function sll(dst, lhs, rhs) {
        const ret5 = wasm$1.sll(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function srl(dst, lhs, rhs) {
        const ret5 = wasm$1.srl(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function sub3(dst, lhs, rhs) {
        const ret5 = wasm$1.sub(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function xor(dst, lhs, rhs) {
        const ret5 = wasm$1.xor(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function mldv(dst, mul_lhs, mul_rhs, divisor) {
        const ret5 = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret5);
      }
      function ret4(value) {
        const ret5 = wasm$1.ret(value);
        return Instruction2.__wrap(ret5);
      }
      function retd(addr, len) {
        const ret5 = wasm$1.retd(addr, len);
        return Instruction2.__wrap(ret5);
      }
      function aloc(bytes2) {
        const ret5 = wasm$1.aloc(bytes2);
        return Instruction2.__wrap(ret5);
      }
      function mcl(dst_addr, len) {
        const ret5 = wasm$1.mcl(dst_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function mcp(dst_addr, src_addr, len) {
        const ret5 = wasm$1.mcp(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function meq(result, lhs_addr, rhs_addr, len) {
        const ret5 = wasm$1.meq(result, lhs_addr, rhs_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function bhsh(dst, heigth) {
        const ret5 = wasm$1.bhsh(dst, heigth);
        return Instruction2.__wrap(ret5);
      }
      function bhei(dst) {
        const ret5 = wasm$1.bhei(dst);
        return Instruction2.__wrap(ret5);
      }
      function burn(amount, sub_id_addr) {
        const ret5 = wasm$1.burn(amount, sub_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function call2(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        const ret5 = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
        return Instruction2.__wrap(ret5);
      }
      function ccp(dst_addr, contract_id_addr, offset, len) {
        const ret5 = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
        return Instruction2.__wrap(ret5);
      }
      function croo(dst_addr, contract_id_addr) {
        const ret5 = wasm$1.croo(dst_addr, contract_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function csiz(dst, contract_id_addr) {
        const ret5 = wasm$1.csiz(dst, contract_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function cb(dst) {
        const ret5 = wasm$1.cb(dst);
        return Instruction2.__wrap(ret5);
      }
      function ldc3(src_addr, offset, len, mode) {
        const ret5 = wasm$1.ldc(src_addr, offset, len, mode);
        return Instruction2.__wrap(ret5);
      }
      function log4(a, b, c, d) {
        const ret5 = wasm$1.log(a, b, c, d);
        return Instruction2.__wrap(ret5);
      }
      function logd(a, b, addr, len) {
        const ret5 = wasm$1.logd(a, b, addr, len);
        return Instruction2.__wrap(ret5);
      }
      function mint(amount, sub_id_addr) {
        const ret5 = wasm$1.mint(amount, sub_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function rvrt(value) {
        const ret5 = wasm$1.rvrt(value);
        return Instruction2.__wrap(ret5);
      }
      function scwq(key_addr, status, lenq) {
        const ret5 = wasm$1.scwq(key_addr, status, lenq);
        return Instruction2.__wrap(ret5);
      }
      function srw(dst, status, key_addr) {
        const ret5 = wasm$1.srw(dst, status, key_addr);
        return Instruction2.__wrap(ret5);
      }
      function srwq(dst_addr, status, key_addr, lenq) {
        const ret5 = wasm$1.srwq(dst_addr, status, key_addr, lenq);
        return Instruction2.__wrap(ret5);
      }
      function sww(key_addr, status, value) {
        const ret5 = wasm$1.sww(key_addr, status, value);
        return Instruction2.__wrap(ret5);
      }
      function swwq(key_addr, status, src_addr, lenq) {
        const ret5 = wasm$1.swwq(key_addr, status, src_addr, lenq);
        return Instruction2.__wrap(ret5);
      }
      function tr3(contract_id_addr, amount, asset_id_addr) {
        const ret5 = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function tro(contract_id_addr, output_index, amount, asset_id_addr) {
        const ret5 = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function eck1(dst_addr, sig_addr, msg_hash_addr) {
        const ret5 = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
        return Instruction2.__wrap(ret5);
      }
      function ecr1(dst_addr, sig_addr, msg_hash_addr) {
        const ret5 = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
        return Instruction2.__wrap(ret5);
      }
      function ed19(pub_key_addr, sig_addr, msg_addr, msg_len) {
        const ret5 = wasm$1.ed19(pub_key_addr, sig_addr, msg_addr, msg_len);
        return Instruction2.__wrap(ret5);
      }
      function k256(dst_addr, src_addr, len) {
        const ret5 = wasm$1.k256(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function s256(dst_addr, src_addr, len) {
        const ret5 = wasm$1.s256(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function time(dst, heigth) {
        const ret5 = wasm$1.time(dst, heigth);
        return Instruction2.__wrap(ret5);
      }
      function noop() {
        const ret5 = wasm$1.noop();
        return Instruction2.__wrap(ret5);
      }
      function flag(value) {
        const ret5 = wasm$1.flag(value);
        return Instruction2.__wrap(ret5);
      }
      function bal(dst, asset_id_addr, contract_id_addr) {
        const ret5 = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
        return Instruction2.__wrap(ret5);
      }
      function jmp3(abs_target) {
        const ret5 = wasm$1.jmp(abs_target);
        return Instruction2.__wrap(ret5);
      }
      function jne(abs_target, lhs, rhs) {
        const ret5 = wasm$1.jne(abs_target, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function smo(recipient_addr, data_addr, data_len, coins) {
        const ret5 = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
        return Instruction2.__wrap(ret5);
      }
      function addi5(dst, lhs, rhs) {
        const ret5 = wasm$1.addi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function andi(dst, lhs, rhs) {
        const ret5 = wasm$1.andi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function divi3(dst, lhs, rhs) {
        const ret5 = wasm$1.divi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function expi(dst, lhs, rhs) {
        const ret5 = wasm$1.expi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function modi(dst, lhs, rhs) {
        const ret5 = wasm$1.modi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function muli(dst, lhs, rhs) {
        const ret5 = wasm$1.muli(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function ori(dst, lhs, rhs) {
        const ret5 = wasm$1.ori(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function slli(dst, lhs, rhs) {
        const ret5 = wasm$1.slli(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function srli(dst, lhs, rhs) {
        const ret5 = wasm$1.srli(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function subi2(dst, lhs, rhs) {
        const ret5 = wasm$1.subi(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function xori(dst, lhs, rhs) {
        const ret5 = wasm$1.xori(dst, lhs, rhs);
        return Instruction2.__wrap(ret5);
      }
      function jnei(cond_lhs, cond_rhs, abs_target) {
        const ret5 = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
        return Instruction2.__wrap(ret5);
      }
      function lb(dst, addr, offset) {
        const ret5 = wasm$1.lb(dst, addr, offset);
        return Instruction2.__wrap(ret5);
      }
      function lw5(dst, addr, offset) {
        const ret5 = wasm$1.lw(dst, addr, offset);
        return Instruction2.__wrap(ret5);
      }
      function sb(addr, value, offset) {
        const ret5 = wasm$1.sb(addr, value, offset);
        return Instruction2.__wrap(ret5);
      }
      function sw(addr, value, offset) {
        const ret5 = wasm$1.sw(addr, value, offset);
        return Instruction2.__wrap(ret5);
      }
      function mcpi(dst_addr, src_addr, len) {
        const ret5 = wasm$1.mcpi(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret5);
      }
      function gtf3(dst, arg, selector) {
        const ret5 = wasm$1.gtf(dst, arg, selector);
        return Instruction2.__wrap(ret5);
      }
      function mcli(addr, count) {
        const ret5 = wasm$1.mcli(addr, count);
        return Instruction2.__wrap(ret5);
      }
      function gm(dst, selector) {
        const ret5 = wasm$1.gm(dst, selector);
        return Instruction2.__wrap(ret5);
      }
      function movi3(dst, val) {
        const ret5 = wasm$1.movi(dst, val);
        return Instruction2.__wrap(ret5);
      }
      function jnzi(cond_nz, abs_target) {
        const ret5 = wasm$1.jnzi(cond_nz, abs_target);
        return Instruction2.__wrap(ret5);
      }
      function jmpf(dynamic, fixed) {
        const ret5 = wasm$1.jmpf(dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jmpb(dynamic, fixed) {
        const ret5 = wasm$1.jmpb(dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jnzf(cond_nz, dynamic, fixed) {
        const ret5 = wasm$1.jnzf(cond_nz, dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jnzb2(cond_nz, dynamic, fixed) {
        const ret5 = wasm$1.jnzb(cond_nz, dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
        const ret5 = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
        const ret5 = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
        return Instruction2.__wrap(ret5);
      }
      function ji(abs_target) {
        const ret5 = wasm$1.ji(abs_target);
        return Instruction2.__wrap(ret5);
      }
      function cfei(amount) {
        const ret5 = wasm$1.cfei(amount);
        return Instruction2.__wrap(ret5);
      }
      function cfsi(amount) {
        const ret5 = wasm$1.cfsi(amount);
        return Instruction2.__wrap(ret5);
      }
      function cfe(amount) {
        const ret5 = wasm$1.cfe(amount);
        return Instruction2.__wrap(ret5);
      }
      function cfs(amount) {
        const ret5 = wasm$1.cfs(amount);
        return Instruction2.__wrap(ret5);
      }
      function pshl(bitmask) {
        const ret5 = wasm$1.pshl(bitmask);
        return Instruction2.__wrap(ret5);
      }
      function pshh(bitmask) {
        const ret5 = wasm$1.pshh(bitmask);
        return Instruction2.__wrap(ret5);
      }
      function popl(bitmask) {
        const ret5 = wasm$1.popl(bitmask);
        return Instruction2.__wrap(ret5);
      }
      function poph(bitmask) {
        const ret5 = wasm$1.poph(bitmask);
        return Instruction2.__wrap(ret5);
      }
      function wdcm(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wdcm(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wqcm(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wqcm(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wdop(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wdop(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wqop(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wqop(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wdml(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wdml(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wqml(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wqml(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wddv(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wddv(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wqdv(dst, lhs, rhs, flags) {
        const ret5 = wasm$1.wqdv(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret5);
      }
      function wdmd(dst, mul_lhs, mul_rhs, divisor) {
        const ret5 = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret5);
      }
      function wqmd(dst, mul_lhs, mul_rhs, divisor) {
        const ret5 = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret5);
      }
      function wdam(dst, add_lhs, add_rhs, modulo) {
        const ret5 = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
        return Instruction2.__wrap(ret5);
      }
      function wqam(dst, add_lhs, add_rhs, modulo) {
        const ret5 = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
        return Instruction2.__wrap(ret5);
      }
      function wdmm(dst, mul_lhs, mul_rhs, modulo) {
        const ret5 = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
        return Instruction2.__wrap(ret5);
      }
      function wqmm(dst, mul_lhs, mul_rhs, modulo) {
        const ret5 = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
        return Instruction2.__wrap(ret5);
      }
      function ecal(a, b, c, d) {
        const ret5 = wasm$1.ecal(a, b, c, d);
        return Instruction2.__wrap(ret5);
      }
      function bsiz3(dst, blob_id_ptr) {
        const ret5 = wasm$1.bsiz(dst, blob_id_ptr);
        return Instruction2.__wrap(ret5);
      }
      function bldd(dst_ptr, blob_id_ptr, offset, len) {
        const ret5 = wasm$1.bldd(dst_ptr, blob_id_ptr, offset, len);
        return Instruction2.__wrap(ret5);
      }
      var cachedDataViewMemory0 = null;
      function getDataViewMemory0() {
        if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm$1.memory.buffer) {
          cachedDataViewMemory0 = new DataView(wasm$1.memory.buffer);
        }
        return cachedDataViewMemory0;
      }
      function getArrayU8FromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
      }
      var GTFArgs3 = Object.freeze({
        /**
        *r" Set `$rA` to `tx.type`
        */
        Type: 1,
        "1": "Type",
        /**
        *r" Set `$rA` to `tx.scriptGasLimit`
        */
        ScriptGasLimit: 2,
        "2": "ScriptGasLimit",
        /**
        *r" Set `$rA` to `tx.scriptLength`
        */
        ScriptLength: 3,
        "3": "ScriptLength",
        /**
        *r" Set `$rA` to `tx.scriptDataLength`
        */
        ScriptDataLength: 4,
        "4": "ScriptDataLength",
        /**
        *r" Set `$rA` to `tx.inputsCount`
        */
        ScriptInputsCount: 5,
        "5": "ScriptInputsCount",
        /**
        *r" Set `$rA` to `tx.outputsCount`
        */
        ScriptOutputsCount: 6,
        "6": "ScriptOutputsCount",
        /**
        *r" Set `$rA` to `tx.witnessesCount`
        */
        ScriptWitnessesCount: 7,
        "7": "ScriptWitnessesCount",
        /**
        *r" Set `$rA` to `Memory address of tx.script`
        */
        Script: 9,
        "9": "Script",
        /**
        *r" Set `$rA` to `Memory address of tx.scriptData`
        */
        ScriptData: 10,
        "10": "ScriptData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB]`
        */
        ScriptInputAtIndex: 11,
        "11": "ScriptInputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of t.outputs[$rB]`
        */
        ScriptOutputAtIndex: 12,
        "12": "ScriptOutputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
        */
        ScriptWitnessAtIndex: 13,
        "13": "ScriptWitnessAtIndex",
        /**
        *r" Set `$rA` to size of the transaction in memory, in bytes
        */
        TxLength: 14,
        "14": "TxLength",
        /**
        *r" Set `$rA` to `tx.bytecodeWitnessIndex`
        */
        CreateBytecodeWitnessIndex: 257,
        "257": "CreateBytecodeWitnessIndex",
        /**
        *r" Set `$rA` to `tx.storageSlotsCount`
        */
        CreateStorageSlotsCount: 258,
        "258": "CreateStorageSlotsCount",
        /**
        *r" Set `$rA` to `tx.inputsCount`
        */
        CreateInputsCount: 259,
        "259": "CreateInputsCount",
        /**
        *r" Set `$rA` to `tx.outputsCount`
        */
        CreateOutputsCount: 260,
        "260": "CreateOutputsCount",
        /**
        *r" Set `$rA` to `tx.witnessesCount`
        */
        CreateWitnessesCount: 261,
        "261": "CreateWitnessesCount",
        /**
        *r" Set `$rA` to `Memory address of tx.salt`
        */
        CreateSalt: 262,
        "262": "CreateSalt",
        /**
        *r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
        */
        CreateStorageSlotAtIndex: 263,
        "263": "CreateStorageSlotAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB]`
        */
        CreateInputAtIndex: 264,
        "264": "CreateInputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of t.outputs[$rB]`
        */
        CreateOutputAtIndex: 265,
        "265": "CreateOutputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
        */
        CreateWitnessAtIndex: 266,
        "266": "CreateWitnessAtIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].type`
        */
        InputType: 512,
        "512": "InputType",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
        */
        InputCoinTxId: 513,
        "513": "InputCoinTxId",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].outputIndex`
        */
        InputCoinOutputIndex: 514,
        "514": "InputCoinOutputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
        */
        InputCoinOwner: 515,
        "515": "InputCoinOwner",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].amount`
        */
        InputCoinAmount: 516,
        "516": "InputCoinAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
        */
        InputCoinAssetId: 517,
        "517": "InputCoinAssetId",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
        */
        InputCoinTxPointer: 518,
        "518": "InputCoinTxPointer",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
        */
        InputCoinWitnessIndex: 519,
        "519": "InputCoinWitnessIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateLength`
        */
        InputCoinPredicateLength: 521,
        "521": "InputCoinPredicateLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
        */
        InputCoinPredicateDataLength: 522,
        "522": "InputCoinPredicateDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
        */
        InputCoinPredicate: 523,
        "523": "InputCoinPredicate",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
        */
        InputCoinPredicateData: 524,
        "524": "InputCoinPredicateData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
        */
        InputCoinPredicateGasUsed: 525,
        "525": "InputCoinPredicateGasUsed",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
        */
        InputContractTxId: 544,
        "544": "InputContractTxId",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].outputIndex`
        */
        InputContractOutputIndex: 545,
        "545": "InputContractOutputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
        */
        InputContractId: 549,
        "549": "InputContractId",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
        */
        InputMessageSender: 576,
        "576": "InputMessageSender",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
        */
        InputMessageRecipient: 577,
        "577": "InputMessageRecipient",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].amount`
        */
        InputMessageAmount: 578,
        "578": "InputMessageAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
        */
        InputMessageNonce: 579,
        "579": "InputMessageNonce",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
        */
        InputMessageWitnessIndex: 580,
        "580": "InputMessageWitnessIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].dataLength`
        */
        InputMessageDataLength: 581,
        "581": "InputMessageDataLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateLength`
        */
        InputMessagePredicateLength: 582,
        "582": "InputMessagePredicateLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
        */
        InputMessagePredicateDataLength: 583,
        "583": "InputMessagePredicateDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
        */
        InputMessageData: 584,
        "584": "InputMessageData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
        */
        InputMessagePredicate: 585,
        "585": "InputMessagePredicate",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
        */
        InputMessagePredicateData: 586,
        "586": "InputMessagePredicateData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
        */
        InputMessagePredicateGasUsed: 587,
        "587": "InputMessagePredicateGasUsed",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].type`
        */
        OutputType: 768,
        "768": "OutputType",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
        */
        OutputCoinTo: 769,
        "769": "OutputCoinTo",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].amount`
        */
        OutputCoinAmount: 770,
        "770": "OutputCoinAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
        */
        OutputCoinAssetId: 771,
        "771": "OutputCoinAssetId",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].inputIndex`
        */
        OutputContractInputIndex: 772,
        "772": "OutputContractInputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
        */
        OutputContractCreatedContractId: 775,
        "775": "OutputContractCreatedContractId",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
        */
        OutputContractCreatedStateRoot: 776,
        "776": "OutputContractCreatedStateRoot",
        /**
        *r" Set `$rA` to `tx.witnesses[$rB].dataLength`
        */
        WitnessDataLength: 1024,
        "1024": "WitnessDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
        */
        WitnessData: 1025,
        "1025": "WitnessData",
        /**
        *r" Set `$rA` to `tx.policyTypes`
        */
        PolicyTypes: 1280,
        "1280": "PolicyTypes",
        /**
        *r" Set `$rA` to `tx.policies[0x00].gasPrice`
        */
        PolicyTip: 1281,
        "1281": "PolicyTip",
        /**
        *r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
        */
        PolicyWitnessLimit: 1282,
        "1282": "PolicyWitnessLimit",
        /**
        *r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
        */
        PolicyMaturity: 1283,
        "1283": "PolicyMaturity",
        /**
        *r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
        */
        PolicyMaxFee: 1284,
        "1284": "PolicyMaxFee"
      });
      var CompareMode = Object.freeze({
        /**
        * Equality (`==`)
        */
        EQ: 0,
        "0": "EQ",
        /**
        * Inequality (`!=`)
        */
        NE: 1,
        "1": "NE",
        /**
        * Less than (`<`)
        */
        LT: 2,
        "2": "LT",
        /**
        * Greater than (`>`)
        */
        GT: 3,
        "3": "GT",
        /**
        * Less than or equals (`>=`)
        */
        LTE: 4,
        "4": "LTE",
        /**
        * Greater than or equals (`>=`)
        */
        GTE: 5,
        "5": "GTE",
        /**
        * Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
        */
        LZC: 6,
        "6": "LZC"
      });
      var PanicReason = Object.freeze({
        /**
        *r" The byte can't be mapped to any known `PanicReason`.
        */
        UnknownPanicReason: 0,
        "0": "UnknownPanicReason",
        /**
        *r" Found `RVRT` instruction.
        */
        Revert: 1,
        "1": "Revert",
        /**
        *r" Execution ran out of gas.
        */
        OutOfGas: 2,
        "2": "OutOfGas",
        /**
        *r" The transaction validity is violated.
        */
        TransactionValidity: 3,
        "3": "TransactionValidity",
        /**
        *r" Attempt to write outside interpreter memory boundaries.
        */
        MemoryOverflow: 4,
        "4": "MemoryOverflow",
        /**
        *r" Overflow while executing arithmetic operation.
        *r" These errors are ignored using the WRAPPING flag.
        */
        ArithmeticOverflow: 5,
        "5": "ArithmeticOverflow",
        /**
        *r" Designed contract was not found in the storage.
        */
        ContractNotFound: 6,
        "6": "ContractNotFound",
        /**
        *r" Memory ownership rules are violated.
        */
        MemoryOwnership: 7,
        "7": "MemoryOwnership",
        /**
        *r" The asset ID balance isn't enough for the instruction.
        */
        NotEnoughBalance: 8,
        "8": "NotEnoughBalance",
        /**
        *r" The interpreter is expected to be in internal context.
        */
        ExpectedInternalContext: 9,
        "9": "ExpectedInternalContext",
        /**
        *r" The queried asset ID was not found in the state.
        */
        AssetIdNotFound: 10,
        "10": "AssetIdNotFound",
        /**
        *r" The provided input is not found in the transaction.
        */
        InputNotFound: 11,
        "11": "InputNotFound",
        /**
        *r" The provided output is not found in the transaction.
        */
        OutputNotFound: 12,
        "12": "OutputNotFound",
        /**
        *r" The provided witness is not found in the transaction.
        */
        WitnessNotFound: 13,
        "13": "WitnessNotFound",
        /**
        *r" The transaction maturity is not valid for this request.
        */
        TransactionMaturity: 14,
        "14": "TransactionMaturity",
        /**
        *r" The metadata identifier is invalid.
        */
        InvalidMetadataIdentifier: 15,
        "15": "InvalidMetadataIdentifier",
        /**
        *r" The call structure is not valid.
        */
        MalformedCallStructure: 16,
        "16": "MalformedCallStructure",
        /**
        *r" The provided register does not allow write operations.
        */
        ReservedRegisterNotWritable: 17,
        "17": "ReservedRegisterNotWritable",
        /**
        *r" The execution resulted in an erroneous state of the interpreter.
        */
        InvalidFlags: 18,
        "18": "InvalidFlags",
        /**
        *r" The provided immediate value is not valid for this instruction.
        */
        InvalidImmediateValue: 19,
        "19": "InvalidImmediateValue",
        /**
        *r" The provided transaction input is not of type `Coin`.
        */
        ExpectedCoinInput: 20,
        "20": "ExpectedCoinInput",
        /**
        *r" `ECAL` instruction failed.
        */
        EcalError: 21,
        "21": "EcalError",
        /**
        *r" Two segments of the interpreter memory should not intersect for write operations.
        */
        MemoryWriteOverlap: 22,
        "22": "MemoryWriteOverlap",
        /**
        *r" The requested contract is not listed in the transaction inputs.
        */
        ContractNotInInputs: 23,
        "23": "ContractNotInInputs",
        /**
        *r" The internal asset ID balance overflowed with the provided instruction.
        */
        InternalBalanceOverflow: 24,
        "24": "InternalBalanceOverflow",
        /**
        *r" The maximum allowed contract size is violated.
        */
        ContractMaxSize: 25,
        "25": "ContractMaxSize",
        /**
        *r" This instruction expects the stack area to be unallocated for this call.
        */
        ExpectedUnallocatedStack: 26,
        "26": "ExpectedUnallocatedStack",
        /**
        *r" The maximum allowed number of static contracts was reached for this transaction.
        */
        MaxStaticContractsReached: 27,
        "27": "MaxStaticContractsReached",
        /**
        *r" The requested transfer amount cannot be zero.
        */
        TransferAmountCannotBeZero: 28,
        "28": "TransferAmountCannotBeZero",
        /**
        *r" The provided transaction output should be of type `Variable`.
        */
        ExpectedOutputVariable: 29,
        "29": "ExpectedOutputVariable",
        /**
        *r" The expected context of the stack parent is internal.
        */
        ExpectedParentInternalContext: 30,
        "30": "ExpectedParentInternalContext",
        /**
        *r" The predicate returned non `1`. The `1` means successful verification
        *r" of the predicate, all other values means unsuccessful.
        */
        PredicateReturnedNonOne: 31,
        "31": "PredicateReturnedNonOne",
        /**
        *r" The contract ID is already deployed and can't be overwritten.
        */
        ContractIdAlreadyDeployed: 32,
        "32": "ContractIdAlreadyDeployed",
        /**
        *r" The loaded contract mismatch expectations.
        */
        ContractMismatch: 33,
        "33": "ContractMismatch",
        /**
        *r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
        */
        MessageDataTooLong: 34,
        "34": "MessageDataTooLong",
        /**
        *r" Mathematically invalid arguments where given to an arithmetic instruction.
        *r" For instance, division by zero produces this.
        *r" These errors are ignored using the UNSAFEMATH flag.
        */
        ArithmeticError: 35,
        "35": "ArithmeticError",
        /**
        *r" The contract instruction is not allowed in predicates.
        */
        ContractInstructionNotAllowed: 36,
        "36": "ContractInstructionNotAllowed",
        /**
        *r" Transfer of zero coins is not allowed.
        */
        TransferZeroCoins: 37,
        "37": "TransferZeroCoins",
        /**
        *r" Attempted to execute an invalid instruction
        */
        InvalidInstruction: 38,
        "38": "InvalidInstruction",
        /**
        *r" Memory outside $is..$ssp range is not executable
        */
        MemoryNotExecutable: 39,
        "39": "MemoryNotExecutable",
        /**
        *r" The policy is not set.
        */
        PolicyIsNotSet: 40,
        "40": "PolicyIsNotSet",
        /**
        *r" The policy is not found across policies.
        */
        PolicyNotFound: 41,
        "41": "PolicyNotFound",
        /**
        *r" Receipt context is full
        */
        TooManyReceipts: 42,
        "42": "TooManyReceipts",
        /**
        *r" Balance of a contract overflowed
        */
        BalanceOverflow: 43,
        "43": "BalanceOverflow",
        /**
        *r" Block height value is invalid, typically because it is too large
        */
        InvalidBlockHeight: 44,
        "44": "InvalidBlockHeight",
        /**
        *r" Attempt to use sequential memory instructions with too large slot count,
        *r" typically because it cannot fit into usize
        */
        TooManySlots: 45,
        "45": "TooManySlots",
        /**
        *r" Caller of this internal context is also expected to be internal,
        *r" i.e. $fp->$fp must be non-zero.
        */
        ExpectedNestedCaller: 46,
        "46": "ExpectedNestedCaller",
        /**
        *r" During memory growth, the stack overlapped with the heap
        */
        MemoryGrowthOverlap: 47,
        "47": "MemoryGrowthOverlap",
        /**
        *r" Attempting to read or write uninitialized memory.
        *r" Also occurs when boundary crosses from stack to heap.
        */
        UninitalizedMemoryAccess: 48,
        "48": "UninitalizedMemoryAccess",
        /**
        *r" Overriding consensus parameters is not allowed.
        */
        OverridingConsensusParameters: 49,
        "49": "OverridingConsensusParameters",
        /**
        *r" The storage doesn't know about the hash of the state transition bytecode.
        */
        UnknownStateTransactionBytecodeRoot: 50,
        "50": "UnknownStateTransactionBytecodeRoot",
        /**
        *r" Overriding the state transition bytecode is not allowed.
        */
        OverridingStateTransactionBytecode: 51,
        "51": "OverridingStateTransactionBytecode",
        /**
        *r" The bytecode is already uploaded and cannot be uploaded again.
        */
        BytecodeAlreadyUploaded: 52,
        "52": "BytecodeAlreadyUploaded",
        /**
        *r" The part of the bytecode is not sequentially connected to the previous parts.
        */
        ThePartIsNotSequentiallyConnected: 53,
        "53": "ThePartIsNotSequentiallyConnected",
        /**
        *r" The requested blob is not found.
        */
        BlobNotFound: 54,
        "54": "BlobNotFound",
        /**
        *r" The blob was already
        */
        BlobIdAlreadyUploaded: 55,
        "55": "BlobIdAlreadyUploaded",
        /**
        *r" Active gas costs do not define the cost for this instruction.
        */
        GasCostNotDefined: 56,
        "56": "GasCostNotDefined"
      });
      var MathOp = Object.freeze({
        /**
        * Add
        */
        ADD: 0,
        "0": "ADD",
        /**
        * Subtract
        */
        SUB: 1,
        "1": "SUB",
        /**
        * Invert bits (discards rhs)
        */
        NOT: 2,
        "2": "NOT",
        /**
        * Bitwise or
        */
        OR: 3,
        "3": "OR",
        /**
        * Bitwise exclusive or
        */
        XOR: 4,
        "4": "XOR",
        /**
        * Bitwise and
        */
        AND: 5,
        "5": "AND",
        /**
        * Shift left
        */
        SHL: 6,
        "6": "SHL",
        /**
        * Shift right
        */
        SHR: 7,
        "7": "SHR"
      });
      var GMArgs = Object.freeze({
        /**
        *r" Get if caller is external.
        */
        IsCallerExternal: 1,
        "1": "IsCallerExternal",
        /**
        *r" Get caller's contract ID.
        */
        GetCaller: 2,
        "2": "GetCaller",
        /**
        *r" Get index of current predicate.
        */
        GetVerifyingPredicate: 3,
        "3": "GetVerifyingPredicate",
        /**
        *r" Get the Chain ID this VM is operating within
        */
        GetChainId: 4,
        "4": "GetChainId",
        /**
        *r" Get memory address where the transaction is located
        */
        TxStart: 5,
        "5": "TxStart",
        /**
        *r" Get memory address of base asset ID
        */
        BaseAssetId: 6,
        "6": "BaseAssetId"
      });
      var ADDFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_add_free(ptr >>> 0, 1));
      var ADD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ADDFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_add_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          ADDFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ADDIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_addi_free(ptr >>> 0, 1));
      var ADDI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ADDIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_addi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          ADDIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var ALOCFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_aloc_free(ptr >>> 0, 1));
      var ALOC = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ALOCFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_aloc_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} bytes
        */
        constructor(bytes2) {
          _assertClass(bytes2, RegId2);
          var ptr0 = bytes2.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          ALOCFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ANDFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_and_free(ptr >>> 0, 1));
      var AND = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ANDFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_and_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          ANDFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ANDIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_andi_free(ptr >>> 0, 1));
      var ANDI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ANDIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_andi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          ANDIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var BALFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_bal_free(ptr >>> 0, 1));
      var BAL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          BALFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bal_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} asset_id_addr
        * @param {RegId} contract_id_addr
        */
        constructor(dst, asset_id_addr, contract_id_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr1 = asset_id_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr2 = contract_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          BALFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var BHEIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_bhei_free(ptr >>> 0, 1));
      var BHEI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          BHEIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bhei_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        */
        constructor(dst) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          BHEIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var BHSHFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_bhsh_free(ptr >>> 0, 1));
      var BHSH = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          BHSHFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bhsh_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} heigth
        */
        constructor(dst, heigth) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(heigth, RegId2);
          var ptr1 = heigth.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          BHSHFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var BLDDFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_bldd_free(ptr >>> 0, 1));
      var BLDD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          BLDDFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bldd_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_ptr
        * @param {RegId} blob_id_ptr
        * @param {RegId} offset
        * @param {RegId} len
        */
        constructor(dst_ptr, blob_id_ptr, offset, len) {
          _assertClass(dst_ptr, RegId2);
          var ptr0 = dst_ptr.__destroy_into_raw();
          _assertClass(blob_id_ptr, RegId2);
          var ptr1 = blob_id_ptr.__destroy_into_raw();
          _assertClass(offset, RegId2);
          var ptr2 = offset.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          BLDDFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var BSIZFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_bsiz_free(ptr >>> 0, 1));
      var BSIZ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          BSIZFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bsiz_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} blob_id_ptr
        */
        constructor(dst, blob_id_ptr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(blob_id_ptr, RegId2);
          var ptr1 = blob_id_ptr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          BSIZFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var BURNFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_burn_free(ptr >>> 0, 1));
      var BURN = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          BURNFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_burn_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        * @param {RegId} sub_id_addr
        */
        constructor(amount, sub_id_addr) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          _assertClass(sub_id_addr, RegId2);
          var ptr1 = sub_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          BURNFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CALLFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_call_free(ptr >>> 0, 1));
      var CALL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CALLFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_call_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} target_struct
        * @param {RegId} fwd_coins
        * @param {RegId} asset_id_addr
        * @param {RegId} fwd_gas
        */
        constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
          _assertClass(target_struct, RegId2);
          var ptr0 = target_struct.__destroy_into_raw();
          _assertClass(fwd_coins, RegId2);
          var ptr1 = fwd_coins.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr2 = asset_id_addr.__destroy_into_raw();
          _assertClass(fwd_gas, RegId2);
          var ptr3 = fwd_gas.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          CALLFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CBFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cb_free(ptr >>> 0, 1));
      var CB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CBFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cb_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        */
        constructor(dst) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          CBFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CCPFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ccp_free(ptr >>> 0, 1));
      var CCP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CCPFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ccp_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} contract_id_addr
        * @param {RegId} offset
        * @param {RegId} len
        */
        constructor(dst_addr, contract_id_addr, offset, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          _assertClass(offset, RegId2);
          var ptr2 = offset.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          CCPFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CFEFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cfe_free(ptr >>> 0, 1));
      var CFE = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CFEFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfe_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        */
        constructor(amount) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          CFEFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CFEIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cfei_free(ptr >>> 0, 1));
      var CFEI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CFEIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfei_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} amount
        */
        constructor(amount) {
          _assertClass(amount, Imm24);
          var ptr0 = amount.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          CFEIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var CFSFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cfs_free(ptr >>> 0, 1));
      var CFS = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CFSFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfs_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        */
        constructor(amount) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          CFSFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CFSIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_cfsi_free(ptr >>> 0, 1));
      var CFSI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CFSIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfsi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} amount
        */
        constructor(amount) {
          _assertClass(amount, Imm24);
          var ptr0 = amount.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          CFSIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var CROOFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_croo_free(ptr >>> 0, 1));
      var CROO = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CROOFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_croo_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} contract_id_addr
        */
        constructor(dst_addr, contract_id_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          CROOFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CSIZFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_csiz_free(ptr >>> 0, 1));
      var CSIZ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CSIZFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_csiz_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} contract_id_addr
        */
        constructor(dst, contract_id_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          CSIZFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var CompareArgsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_compareargs_free(ptr >>> 0, 1));
      var CompareArgs = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CompareArgs.prototype);
          obj.__wbg_ptr = ptr;
          CompareArgsFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          CompareArgsFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_compareargs_free(ptr, 0);
        }
        /**
        * Comparison mode
        * @returns {CompareMode}
        */
        get mode() {
          const ret5 = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
          return ret5;
        }
        /**
        * Comparison mode
        * @param {CompareMode} arg0
        */
        set mode(arg0) {
          wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret5 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
        /**
        * Convert to immediate value.
        * @returns {Imm06}
        */
        to_imm() {
          const ptr = this.__destroy_into_raw();
          const ret5 = wasm$1.compareargs_to_imm(ptr);
          return Imm06.__wrap(ret5);
        }
        /**
        * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
        * @param {Imm06} bits
        * @returns {CompareArgs | undefined}
        */
        static from_imm(bits2) {
          _assertClass(bits2, Imm06);
          var ptr0 = bits2.__destroy_into_raw();
          const ret5 = wasm$1.compareargs_from_imm(ptr0);
          return ret5 === 0 ? void 0 : CompareArgs.__wrap(ret5);
        }
      };
      var DIVFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_div_free(ptr >>> 0, 1));
      var DIV = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          DIVFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_div_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          DIVFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var DIVIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_divi_free(ptr >>> 0, 1));
      var DIVI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          DIVIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_divi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          DIVIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var DivArgsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_divargs_free(ptr >>> 0, 1));
      var DivArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          DivArgsFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_divargs_free(ptr, 0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret5 = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var ECALFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ecal_free(ptr >>> 0, 1));
      var ECAL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ECALFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ecal_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} a
        * @param {RegId} b
        * @param {RegId} c
        * @param {RegId} d
        */
        constructor(a, b, c, d) {
          _assertClass(a, RegId2);
          var ptr0 = a.__destroy_into_raw();
          _assertClass(b, RegId2);
          var ptr1 = b.__destroy_into_raw();
          _assertClass(c, RegId2);
          var ptr2 = c.__destroy_into_raw();
          _assertClass(d, RegId2);
          var ptr3 = d.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          ECALFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ECK1Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_eck1_free(ptr >>> 0, 1));
      var ECK1 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ECK1Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_eck1_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_hash_addr
        */
        constructor(dst_addr, sig_addr, msg_hash_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_hash_addr, RegId2);
          var ptr2 = msg_hash_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          ECK1Finalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ECR1Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ecr1_free(ptr >>> 0, 1));
      var ECR1 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ECR1Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ecr1_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_hash_addr
        */
        constructor(dst_addr, sig_addr, msg_hash_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_hash_addr, RegId2);
          var ptr2 = msg_hash_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          ECR1Finalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ED19Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ed19_free(ptr >>> 0, 1));
      var ED19 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ED19Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ed19_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} pub_key_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_addr
        * @param {RegId} msg_len
        */
        constructor(pub_key_addr, sig_addr, msg_addr, msg_len) {
          _assertClass(pub_key_addr, RegId2);
          var ptr0 = pub_key_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_addr, RegId2);
          var ptr2 = msg_addr.__destroy_into_raw();
          _assertClass(msg_len, RegId2);
          var ptr3 = msg_len.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          ED19Finalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var EQFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_eq_free(ptr >>> 0, 1));
      var EQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          EQFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_eq_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          EQFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var EXPFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_exp_free(ptr >>> 0, 1));
      var EXP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          EXPFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_exp_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          EXPFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var EXPIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_expi_free(ptr >>> 0, 1));
      var EXPI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          EXPIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_expi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          EXPIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var FLAGFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_flag_free(ptr >>> 0, 1));
      var FLAG = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          FLAGFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_flag_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          FLAGFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var GMFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_gm_free(ptr >>> 0, 1));
      var GM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(GM.prototype);
          obj.__wbg_ptr = ptr;
          GMFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          GMFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gm_free(ptr, 0);
        }
        /**
        * Construct a `GM` instruction from its arguments.
        * @param {RegId} ra
        * @param {GMArgs} args
        * @returns {GM}
        */
        static from_args(ra, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          const ret5 = wasm$1.gm_from_args(ptr0, args);
          return GM.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {Imm18} selector
        */
        constructor(dst, selector) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(selector, Imm18);
          var ptr1 = selector.__destroy_into_raw();
          const ret5 = wasm$1.gm_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          GMFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var GTFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_gt_free(ptr >>> 0, 1));
      var GT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          GTFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gt_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          GTFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var GTFFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_gtf_free(ptr >>> 0, 1));
      var GTF = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(GTF.prototype);
          obj.__wbg_ptr = ptr;
          GTFFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          GTFFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gtf_free(ptr, 0);
        }
        /**
        * Construct a `GTF` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {GTFArgs} args
        * @returns {GTF}
        */
        static from_args(ra, rb, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          const ret5 = wasm$1.gtf_from_args(ptr0, ptr1, args);
          return GTF.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} arg
        * @param {Imm12} selector
        */
        constructor(dst, arg, selector) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(arg, RegId2);
          var ptr1 = arg.__destroy_into_raw();
          _assertClass(selector, Imm12);
          var ptr2 = selector.__destroy_into_raw();
          const ret5 = wasm$1.gtf_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          GTFFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var Imm06Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_imm06_free(ptr >>> 0, 1));
      var Imm06 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm06.prototype);
          obj.__wbg_ptr = ptr;
          Imm06Finalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          Imm06Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm06_free(ptr, 0);
        }
      };
      var Imm12Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_imm12_free(ptr >>> 0, 1));
      var Imm12 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm12.prototype);
          obj.__wbg_ptr = ptr;
          Imm12Finalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          Imm12Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm12_free(ptr, 0);
        }
      };
      var Imm18Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_imm18_free(ptr >>> 0, 1));
      var Imm18 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm18.prototype);
          obj.__wbg_ptr = ptr;
          Imm18Finalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          Imm18Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm18_free(ptr, 0);
        }
      };
      var Imm24Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_imm24_free(ptr >>> 0, 1));
      var Imm24 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm24.prototype);
          obj.__wbg_ptr = ptr;
          Imm24Finalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          Imm24Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm24_free(ptr, 0);
        }
      };
      var InstructionFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_instruction_free(ptr >>> 0, 1));
      var Instruction2 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Instruction2.prototype);
          obj.__wbg_ptr = ptr;
          InstructionFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          InstructionFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_instruction_free(ptr, 0);
        }
        /**
        * Convenience method for converting to bytes
        * @returns {Uint8Array}
        */
        to_bytes() {
          try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_export_0(r0, r1 * 1, 1);
            return v1;
          } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
          }
        }
        /**
        * Size of an instruction in bytes
        * @returns {number}
        */
        static size() {
          const ret5 = wasm$1.instruction_size();
          return ret5 >>> 0;
        }
      };
      var JIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ji_free(ptr >>> 0, 1));
      var JI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ji_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} abs_target
        */
        constructor(abs_target) {
          _assertClass(abs_target, Imm24);
          var ptr0 = abs_target.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          JIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var JMPFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jmp_free(ptr >>> 0, 1));
      var JMP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JMPFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmp_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} abs_target
        */
        constructor(abs_target) {
          _assertClass(abs_target, RegId2);
          var ptr0 = abs_target.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          JMPFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var JMPBFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jmpb_free(ptr >>> 0, 1));
      var JMPB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JMPBFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmpb_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dynamic
        * @param {Imm18} fixed
        */
        constructor(dynamic, fixed) {
          _assertClass(dynamic, RegId2);
          var ptr0 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm18);
          var ptr1 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.jmpb_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          JMPBFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var JMPFFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jmpf_free(ptr >>> 0, 1));
      var JMPF = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JMPFFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmpf_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dynamic
        * @param {Imm18} fixed
        */
        constructor(dynamic, fixed) {
          _assertClass(dynamic, RegId2);
          var ptr0 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm18);
          var ptr1 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.jmpb_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          JMPFFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var JNEFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jne_free(ptr >>> 0, 1));
      var JNE = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JNEFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jne_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} abs_target
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(abs_target, lhs, rhs) {
          _assertClass(abs_target, RegId2);
          var ptr0 = abs_target.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          JNEFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var JNEBFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jneb_free(ptr >>> 0, 1));
      var JNEB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JNEBFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jneb_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {RegId} dynamic
        * @param {Imm06} fixed
        */
        constructor(cond_lhs, cond_rhs, dynamic, fixed) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr2 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm06);
          var ptr3 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          JNEBFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var JNEFFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnef_free(ptr >>> 0, 1));
      var JNEF = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JNEFFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnef_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {RegId} dynamic
        * @param {Imm06} fixed
        */
        constructor(cond_lhs, cond_rhs, dynamic, fixed) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr2 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm06);
          var ptr3 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          JNEFFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var JNEIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnei_free(ptr >>> 0, 1));
      var JNEI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JNEIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnei_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {Imm12} abs_target
        */
        constructor(cond_lhs, cond_rhs, abs_target) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(abs_target, Imm12);
          var ptr2 = abs_target.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          JNEIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var JNZBFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnzb_free(ptr >>> 0, 1));
      var JNZB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JNZBFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzb_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {RegId} dynamic
        * @param {Imm12} fixed
        */
        constructor(cond_nz, dynamic, fixed) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr1 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm12);
          var ptr2 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          JNZBFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var JNZFFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnzf_free(ptr >>> 0, 1));
      var JNZF = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JNZFFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzf_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {RegId} dynamic
        * @param {Imm12} fixed
        */
        constructor(cond_nz, dynamic, fixed) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr1 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm12);
          var ptr2 = fixed.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          JNZFFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var JNZIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_jnzi_free(ptr >>> 0, 1));
      var JNZI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          JNZIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {Imm18} abs_target
        */
        constructor(cond_nz, abs_target) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(abs_target, Imm18);
          var ptr1 = abs_target.__destroy_into_raw();
          const ret5 = wasm$1.jmpb_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          JNZIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var K256Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_k256_free(ptr >>> 0, 1));
      var K256 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          K256Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_k256_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          K256Finalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LBFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_lb_free(ptr >>> 0, 1));
      var LB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          LBFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lb_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} addr
        * @param {Imm12} offset
        */
        constructor(dst, addr, offset) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr1 = addr.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          LBFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var LDCFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ldc_free(ptr >>> 0, 1));
      var LDC = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          LDCFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ldc_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} src_addr
        * @param {RegId} offset
        * @param {RegId} len
        * @param {Imm06} mode
        */
        constructor(src_addr, offset, len, mode) {
          _assertClass(src_addr, RegId2);
          var ptr0 = src_addr.__destroy_into_raw();
          _assertClass(offset, RegId2);
          var ptr1 = offset.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          _assertClass(mode, Imm06);
          var ptr3 = mode.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          LDCFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var LOGFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_log_free(ptr >>> 0, 1));
      var LOG = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          LOGFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_log_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} a
        * @param {RegId} b
        * @param {RegId} c
        * @param {RegId} d
        */
        constructor(a, b, c, d) {
          _assertClass(a, RegId2);
          var ptr0 = a.__destroy_into_raw();
          _assertClass(b, RegId2);
          var ptr1 = b.__destroy_into_raw();
          _assertClass(c, RegId2);
          var ptr2 = c.__destroy_into_raw();
          _assertClass(d, RegId2);
          var ptr3 = d.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          LOGFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LOGDFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_logd_free(ptr >>> 0, 1));
      var LOGD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          LOGDFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_logd_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} a
        * @param {RegId} b
        * @param {RegId} addr
        * @param {RegId} len
        */
        constructor(a, b, addr, len) {
          _assertClass(a, RegId2);
          var ptr0 = a.__destroy_into_raw();
          _assertClass(b, RegId2);
          var ptr1 = b.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr2 = addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          LOGDFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LTFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_lt_free(ptr >>> 0, 1));
      var LT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          LTFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lt_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          LTFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var LWFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_lw_free(ptr >>> 0, 1));
      var LW = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          LWFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lw_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} addr
        * @param {Imm12} offset
        */
        constructor(dst, addr, offset) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr1 = addr.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          LWFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var MCLFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mcl_free(ptr >>> 0, 1));
      var MCL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MCLFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcl_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} len
        */
        constructor(dst_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr1 = len.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          MCLFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MCLIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mcli_free(ptr >>> 0, 1));
      var MCLI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MCLIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcli_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {Imm18} count
        */
        constructor(addr, count) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(count, Imm18);
          var ptr1 = count.__destroy_into_raw();
          const ret5 = wasm$1.jmpb_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          MCLIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var MCPFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mcp_free(ptr >>> 0, 1));
      var MCP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MCPFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcp_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          MCPFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MCPIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mcpi_free(ptr >>> 0, 1));
      var MCPI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MCPIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcpi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {Imm12} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, Imm12);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          MCPIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var MEQFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_meq_free(ptr >>> 0, 1));
      var MEQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MEQFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_meq_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} result
        * @param {RegId} lhs_addr
        * @param {RegId} rhs_addr
        * @param {RegId} len
        */
        constructor(result, lhs_addr, rhs_addr, len) {
          _assertClass(result, RegId2);
          var ptr0 = result.__destroy_into_raw();
          _assertClass(lhs_addr, RegId2);
          var ptr1 = lhs_addr.__destroy_into_raw();
          _assertClass(rhs_addr, RegId2);
          var ptr2 = rhs_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          MEQFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MINTFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mint_free(ptr >>> 0, 1));
      var MINT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MINTFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mint_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        * @param {RegId} sub_id_addr
        */
        constructor(amount, sub_id_addr) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          _assertClass(sub_id_addr, RegId2);
          var ptr1 = sub_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          MINTFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MLDVFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mldv_free(ptr >>> 0, 1));
      var MLDV = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MLDVFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mldv_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          MLDVFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MLOGFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mlog_free(ptr >>> 0, 1));
      var MLOG = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MLOGFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mlog_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          MLOGFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MODFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mod_free(ptr >>> 0, 1));
      var MOD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MODFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mod_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          MODFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MODIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_modi_free(ptr >>> 0, 1));
      var MODI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MODIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_modi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          MODIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var MOVEFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_move_free(ptr >>> 0, 1));
      var MOVE = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MOVEFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_move_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} src
        */
        constructor(dst, src) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(src, RegId2);
          var ptr1 = src.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          MOVEFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MOVIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_movi_free(ptr >>> 0, 1));
      var MOVI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MOVIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_movi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {Imm18} val
        */
        constructor(dst, val) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(val, Imm18);
          var ptr1 = val.__destroy_into_raw();
          const ret5 = wasm$1.jmpb_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          MOVIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret5 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret5);
        }
      };
      var MROOFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mroo_free(ptr >>> 0, 1));
      var MROO = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MROOFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mroo_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          MROOFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MULFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mul_free(ptr >>> 0, 1));
      var MUL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MULFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mul_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          MULFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var MULIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_muli_free(ptr >>> 0, 1));
      var MULI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MULIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_muli_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          MULIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var MathArgsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mathargs_free(ptr >>> 0, 1));
      var MathArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MathArgsFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mathargs_free(ptr, 0);
        }
        /**
        * The operation to perform
        * @returns {MathOp}
        */
        get op() {
          const ret5 = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
          return ret5;
        }
        /**
        * The operation to perform
        * @param {MathOp} arg0
        */
        set op(arg0) {
          wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret5 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var MulArgsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_mulargs_free(ptr >>> 0, 1));
      var MulArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          MulArgsFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mulargs_free(ptr, 0);
        }
        /**
        * Load LHSS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_lhs() {
          const ret5 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load LHSS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_lhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret5 = wasm$1.__wbg_get_mulargs_indirect_rhs(this.__wbg_ptr);
          return ret5 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_mulargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var NOOPFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_noop_free(ptr >>> 0, 1));
      var NOOP = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          NOOPFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_noop_free(ptr, 0);
        }
        /**
        * Construct the instruction.
        */
        constructor() {
          const ret5 = wasm$1.noop_new_typescript();
          this.__wbg_ptr = ret5 >>> 0;
          NOOPFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
      };
      var NOTFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_not_free(ptr >>> 0, 1));
      var NOT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          NOTFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_not_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} arg
        */
        constructor(dst, arg) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(arg, RegId2);
          var ptr1 = arg.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          NOTFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ORFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_or_free(ptr >>> 0, 1));
      var OR = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ORFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_or_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          ORFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var ORIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ori_free(ptr >>> 0, 1));
      var ORI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          ORIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ori_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          ORIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var POPHFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_poph_free(ptr >>> 0, 1));
      var POPH = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          POPHFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_poph_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          POPHFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var POPLFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_popl_free(ptr >>> 0, 1));
      var POPL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          POPLFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_popl_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          POPLFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var PSHHFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_pshh_free(ptr >>> 0, 1));
      var PSHH = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          PSHHFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_pshh_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          PSHHFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var PSHLFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_pshl_free(ptr >>> 0, 1));
      var PSHL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          PSHLFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_pshl_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret5 = wasm$1.cfei_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          PSHLFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret5 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret5);
        }
      };
      var PanicInstructionFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_panicinstruction_free(ptr >>> 0, 1));
      var PanicInstruction = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          PanicInstructionFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_panicinstruction_free(ptr, 0);
        }
        /**
        * Represents an error described by a reason and an instruction.
        * @param {PanicReason} reason
        * @param {number} instruction
        */
        constructor(reason, instruction) {
          const ret5 = wasm$1.panicinstruction_error_typescript(reason, instruction);
          this.__wbg_ptr = ret5 >>> 0;
          PanicInstructionFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Underlying panic reason
        * @returns {PanicReason}
        */
        reason() {
          const ret5 = wasm$1.panicinstruction_reason(this.__wbg_ptr);
          return ret5;
        }
        /**
        * Underlying instruction
        * @returns {number}
        */
        instruction() {
          const ret5 = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
          return ret5 >>> 0;
        }
      };
      var RETFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_ret_free(ptr >>> 0, 1));
      var RET = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          RETFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ret_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          RETFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var RETDFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_retd_free(ptr >>> 0, 1));
      var RETD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          RETDFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_retd_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} len
        */
        constructor(addr, len) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr1 = len.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          RETDFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var RVRTFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_rvrt_free(ptr >>> 0, 1));
      var RVRT = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          RVRTFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_rvrt_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret5 = wasm$1.aloc_new_typescript(ptr0);
          this.__wbg_ptr = ret5 >>> 0;
          RVRTFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.aloc_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var RegIdFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_regid_free(ptr >>> 0, 1));
      var RegId2 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(RegId2.prototype);
          obj.__wbg_ptr = ptr;
          RegIdFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          RegIdFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_regid_free(ptr, 0);
        }
        /**
        * Construct a register ID from the given value.
        *
        * Returns `None` if the value is outside the 6-bit value range.
        * @param {number} u
        * @returns {RegId | undefined}
        */
        static new_checked(u) {
          const ret5 = wasm$1.regid_new_checked(u);
          return ret5 === 0 ? void 0 : RegId2.__wrap(ret5);
        }
        /**
        * Received balance for this context.
        * @returns {RegId}
        */
        static bal() {
          const ret5 = wasm$1.regid_bal();
          return RegId2.__wrap(ret5);
        }
        /**
        * Remaining gas in the context.
        * @returns {RegId}
        */
        static cgas() {
          const ret5 = wasm$1.regid_cgas();
          return RegId2.__wrap(ret5);
        }
        /**
        * Error codes for particular operations.
        * @returns {RegId}
        */
        static err() {
          const ret5 = wasm$1.regid_err();
          return RegId2.__wrap(ret5);
        }
        /**
        * Flags register.
        * @returns {RegId}
        */
        static flag() {
          const ret5 = wasm$1.regid_flag();
          return RegId2.__wrap(ret5);
        }
        /**
        * Frame pointer. Memory address of beginning of current call frame.
        * @returns {RegId}
        */
        static fp() {
          const ret5 = wasm$1.regid_fp();
          return RegId2.__wrap(ret5);
        }
        /**
        * Remaining gas globally.
        * @returns {RegId}
        */
        static ggas() {
          const ret5 = wasm$1.regid_ggas();
          return RegId2.__wrap(ret5);
        }
        /**
        * Heap pointer. Memory address below the current bottom of the heap (points to free
        * memory).
        * @returns {RegId}
        */
        static hp() {
          const ret5 = wasm$1.regid_hp();
          return RegId2.__wrap(ret5);
        }
        /**
        * Instructions start. Pointer to the start of the currently-executing code.
        * @returns {RegId}
        */
        static is() {
          const ret5 = wasm$1.regid_is();
          return RegId2.__wrap(ret5);
        }
        /**
        * Contains overflow/underflow of addition, subtraction, and multiplication.
        * @returns {RegId}
        */
        static of() {
          const ret5 = wasm$1.regid_of();
          return RegId2.__wrap(ret5);
        }
        /**
        * Contains one (1), for convenience.
        * @returns {RegId}
        */
        static one() {
          const ret5 = wasm$1.regid_one();
          return RegId2.__wrap(ret5);
        }
        /**
        * The program counter. Memory address of the current instruction.
        * @returns {RegId}
        */
        static pc() {
          const ret5 = wasm$1.regid_pc();
          return RegId2.__wrap(ret5);
        }
        /**
        * Return value or pointer.
        * @returns {RegId}
        */
        static ret() {
          const ret5 = wasm$1.regid_ret();
          return RegId2.__wrap(ret5);
        }
        /**
        * Return value length in bytes.
        * @returns {RegId}
        */
        static retl() {
          const ret5 = wasm$1.regid_retl();
          return RegId2.__wrap(ret5);
        }
        /**
        * Stack pointer. Memory address on top of current writable stack area (points to
        * free memory).
        * @returns {RegId}
        */
        static sp() {
          const ret5 = wasm$1.regid_sp();
          return RegId2.__wrap(ret5);
        }
        /**
        * Stack start pointer. Memory address of bottom of current writable stack area.
        * @returns {RegId}
        */
        static spp() {
          const ret5 = wasm$1.regid_spp();
          return RegId2.__wrap(ret5);
        }
        /**
        * Smallest writable register.
        * @returns {RegId}
        */
        static writable() {
          const ret5 = wasm$1.regid_writable();
          return RegId2.__wrap(ret5);
        }
        /**
        * Contains zero (0), for convenience.
        * @returns {RegId}
        */
        static zero() {
          const ret5 = wasm$1.regid_zero();
          return RegId2.__wrap(ret5);
        }
        /**
        * Construct a register ID from the given value.
        *
        * The given value will be masked to 6 bits.
        * @param {number} u
        */
        constructor(u) {
          const ret5 = wasm$1.regid_new_typescript(u);
          this.__wbg_ptr = ret5 >>> 0;
          RegIdFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * A const alternative to the `Into<u8>` implementation.
        * @returns {number}
        */
        to_u8() {
          const ptr = this.__destroy_into_raw();
          const ret5 = wasm$1.regid_to_u8(ptr);
          return ret5;
        }
      };
      var S256Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_s256_free(ptr >>> 0, 1));
      var S256 = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          S256Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_s256_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          S256Finalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SBFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sb_free(ptr >>> 0, 1));
      var SB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SBFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sb_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} value
        * @param {Imm12} offset
        */
        constructor(addr, value, offset) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr1 = value.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SBFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SCWQFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_scwq_free(ptr >>> 0, 1));
      var SCWQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SCWQFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_scwq_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} lenq
        */
        constructor(key_addr, status, lenq) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr2 = lenq.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SCWQFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SLLFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sll_free(ptr >>> 0, 1));
      var SLL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SLLFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sll_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SLLFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SLLIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_slli_free(ptr >>> 0, 1));
      var SLLI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SLLIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_slli_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SLLIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SMOFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_smo_free(ptr >>> 0, 1));
      var SMO = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SMOFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_smo_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} recipient_addr
        * @param {RegId} data_addr
        * @param {RegId} data_len
        * @param {RegId} coins
        */
        constructor(recipient_addr, data_addr, data_len, coins) {
          _assertClass(recipient_addr, RegId2);
          var ptr0 = recipient_addr.__destroy_into_raw();
          _assertClass(data_addr, RegId2);
          var ptr1 = data_addr.__destroy_into_raw();
          _assertClass(data_len, RegId2);
          var ptr2 = data_len.__destroy_into_raw();
          _assertClass(coins, RegId2);
          var ptr3 = coins.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          SMOFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SRLFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_srl_free(ptr >>> 0, 1));
      var SRL = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SRLFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srl_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SRLFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SRLIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_srli_free(ptr >>> 0, 1));
      var SRLI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SRLIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srli_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SRLIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SRWFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_srw_free(ptr >>> 0, 1));
      var SRW = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SRWFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srw_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} status
        * @param {RegId} key_addr
        */
        constructor(dst, status, key_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(key_addr, RegId2);
          var ptr2 = key_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SRWFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SRWQFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_srwq_free(ptr >>> 0, 1));
      var SRWQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SRWQFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srwq_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} status
        * @param {RegId} key_addr
        * @param {RegId} lenq
        */
        constructor(dst_addr, status, key_addr, lenq) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(key_addr, RegId2);
          var ptr2 = key_addr.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr3 = lenq.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          SRWQFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SUBFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sub_free(ptr >>> 0, 1));
      var SUB = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SUBFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sub_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SUBFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SUBIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_subi_free(ptr >>> 0, 1));
      var SUBI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SUBIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_subi_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SUBIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SWFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sw_free(ptr >>> 0, 1));
      var SW = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SWFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sw_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} value
        * @param {Imm12} offset
        */
        constructor(addr, value, offset) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr1 = value.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SWFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      var SWWFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_sww_free(ptr >>> 0, 1));
      var SWW = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SWWFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sww_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} value
        */
        constructor(key_addr, status, value) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr2 = value.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          SWWFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var SWWQFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_swwq_free(ptr >>> 0, 1));
      var SWWQ = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          SWWQFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_swwq_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} src_addr
        * @param {RegId} lenq
        */
        constructor(key_addr, status, src_addr, lenq) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr2 = src_addr.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr3 = lenq.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          SWWQFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var TIMEFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_time_free(ptr >>> 0, 1));
      var TIME = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          TIMEFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_time_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} heigth
        */
        constructor(dst, heigth) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(heigth, RegId2);
          var ptr1 = heigth.__destroy_into_raw();
          const ret5 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          this.__wbg_ptr = ret5 >>> 0;
          TIMEFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var TRFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_tr_free(ptr >>> 0, 1));
      var TR = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          TRFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_tr_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} contract_id_addr
        * @param {RegId} amount
        * @param {RegId} asset_id_addr
        */
        constructor(contract_id_addr, amount, asset_id_addr) {
          _assertClass(contract_id_addr, RegId2);
          var ptr0 = contract_id_addr.__destroy_into_raw();
          _assertClass(amount, RegId2);
          var ptr1 = amount.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr2 = asset_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          TRFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var TROFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_tro_free(ptr >>> 0, 1));
      var TRO = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          TROFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_tro_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} contract_id_addr
        * @param {RegId} output_index
        * @param {RegId} amount
        * @param {RegId} asset_id_addr
        */
        constructor(contract_id_addr, output_index, amount, asset_id_addr) {
          _assertClass(contract_id_addr, RegId2);
          var ptr0 = contract_id_addr.__destroy_into_raw();
          _assertClass(output_index, RegId2);
          var ptr1 = output_index.__destroy_into_raw();
          _assertClass(amount, RegId2);
          var ptr2 = amount.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr3 = asset_id_addr.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          TROFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WDAMFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdam_free(ptr >>> 0, 1));
      var WDAM = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WDAMFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdam_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} add_lhs
        * @param {RegId} add_rhs
        * @param {RegId} modulo
        */
        constructor(dst, add_lhs, add_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(add_lhs, RegId2);
          var ptr1 = add_lhs.__destroy_into_raw();
          _assertClass(add_rhs, RegId2);
          var ptr2 = add_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WDAMFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WDCMFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdcm_free(ptr >>> 0, 1));
      var WDCM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDCM.prototype);
          obj.__wbg_ptr = ptr;
          WDCMFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WDCMFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdcm_free(ptr, 0);
        }
        /**
        * Construct a `WDCM` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {CompareArgs} args
        * @returns {WDCM}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, CompareArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDCM.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WDCMFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var WDDVFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wddv_free(ptr >>> 0, 1));
      var WDDV = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDDV.prototype);
          obj.__wbg_ptr = ptr;
          WDDVFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WDDVFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wddv_free(ptr, 0);
        }
        /**
        * Construct a `WDDV` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {DivArgs} args
        * @returns {WDDV}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, DivArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDDV.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WDDVFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var WDMDFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdmd_free(ptr >>> 0, 1));
      var WDMD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WDMDFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdmd_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WDMDFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WDMLFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdml_free(ptr >>> 0, 1));
      var WDML = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDML.prototype);
          obj.__wbg_ptr = ptr;
          WDMLFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WDMLFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdml_free(ptr, 0);
        }
        /**
        * Construct a `WDML` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MulArgs} args
        * @returns {WDML}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MulArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDML.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WDMLFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var WDMMFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdmm_free(ptr >>> 0, 1));
      var WDMM = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WDMMFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdmm_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} modulo
        */
        constructor(dst, mul_lhs, mul_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WDMMFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WDOPFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wdop_free(ptr >>> 0, 1));
      var WDOP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDOP.prototype);
          obj.__wbg_ptr = ptr;
          WDOPFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WDOPFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdop_free(ptr, 0);
        }
        /**
        * Construct a `WDOP` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MathArgs} args
        * @returns {WDOP}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MathArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDOP.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WDOPFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var WQAMFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqam_free(ptr >>> 0, 1));
      var WQAM = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WQAMFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqam_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} add_lhs
        * @param {RegId} add_rhs
        * @param {RegId} modulo
        */
        constructor(dst, add_lhs, add_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(add_lhs, RegId2);
          var ptr1 = add_lhs.__destroy_into_raw();
          _assertClass(add_rhs, RegId2);
          var ptr2 = add_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WQAMFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WQCMFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqcm_free(ptr >>> 0, 1));
      var WQCM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQCM.prototype);
          obj.__wbg_ptr = ptr;
          WQCMFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WQCMFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqcm_free(ptr, 0);
        }
        /**
        * Construct a `WQCM` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {CompareArgs} args
        * @returns {WQCM}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, CompareArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQCM.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WQCMFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var WQDVFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqdv_free(ptr >>> 0, 1));
      var WQDV = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQDV.prototype);
          obj.__wbg_ptr = ptr;
          WQDVFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WQDVFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqdv_free(ptr, 0);
        }
        /**
        * Construct a `WQDV` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {DivArgs} args
        * @returns {WQDV}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, DivArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQDV.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WQDVFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var WQMDFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqmd_free(ptr >>> 0, 1));
      var WQMD = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WQMDFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqmd_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WQMDFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WQMLFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqml_free(ptr >>> 0, 1));
      var WQML = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQML.prototype);
          obj.__wbg_ptr = ptr;
          WQMLFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WQMLFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqml_free(ptr, 0);
        }
        /**
        * Construct a `WQML` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MulArgs} args
        * @returns {WQML}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MulArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQML.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WQMLFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var WQMMFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqmm_free(ptr >>> 0, 1));
      var WQMM = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WQMMFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqmm_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} modulo
        */
        constructor(dst, mul_lhs, mul_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret5 = wasm$1.bldd_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WQMMFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret5 = wasm$1.bldd_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var WQOPFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_wqop_free(ptr >>> 0, 1));
      var WQOP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQOP.prototype);
          obj.__wbg_ptr = ptr;
          WQOPFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          WQOPFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqop_free(ptr, 0);
        }
        /**
        * Construct a `WQOP` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MathArgs} args
        * @returns {WQOP}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MathArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret5 = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQOP.__wrap(ret5);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret5 = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
          this.__wbg_ptr = ret5 >>> 0;
          WQOPFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret5 = wasm$1.jneb_imm06(this.__wbg_ptr);
          return Imm06.__wrap(ret5);
        }
      };
      var XORFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_xor_free(ptr >>> 0, 1));
      var XOR = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          XORFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_xor_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          XORFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret5 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
      };
      var XORIFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm$1.__wbg_xori_free(ptr >>> 0, 1));
      var XORI = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          XORIFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_xori_free(ptr, 0);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret5 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          this.__wbg_ptr = ret5 >>> 0;
          XORIFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret5 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret5 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret5);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret5 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret5);
        }
      };
      async function __wbg_load(module2, imports) {
        if (typeof Response === "function" && module2 instanceof Response) {
          if (typeof WebAssembly.instantiateStreaming === "function") {
            try {
              return await WebAssembly.instantiateStreaming(module2, imports);
            } catch (e) {
              if (module2.headers.get("Content-Type") != "application/wasm") {
                console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
              } else {
                throw e;
              }
            }
          }
          const bytes2 = await module2.arrayBuffer();
          return await WebAssembly.instantiate(bytes2, imports);
        } else {
          const instance = await WebAssembly.instantiate(module2, imports);
          if (instance instanceof WebAssembly.Instance) {
            return { instance, module: module2 };
          } else {
            return instance;
          }
        }
      }
      function __wbg_get_imports() {
        const imports = {};
        imports.wbg = {};
        imports.wbg.__wbindgen_throw = function(arg0, arg1) {
          throw new Error(getStringFromWasm0(arg0, arg1));
        };
        return imports;
      }
      function __wbg_finalize_init(instance, module2) {
        wasm$1 = instance.exports;
        __wbg_init.__wbindgen_wasm_module = module2;
        cachedDataViewMemory0 = null;
        cachedUint8ArrayMemory0 = null;
        return wasm$1;
      }
      function initSync(module2) {
        if (wasm$1 !== void 0)
          return wasm$1;
        if (typeof module2 !== "undefined" && Object.getPrototypeOf(module2) === Object.prototype)
          ({ module: module2 } = module2);
        else
          console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
        const imports = __wbg_get_imports();
        if (!(module2 instanceof WebAssembly.Module)) {
          module2 = new WebAssembly.Module(module2);
        }
        const instance = new WebAssembly.Instance(module2, imports);
        return __wbg_finalize_init(instance, module2);
      }
      async function __wbg_init(module_or_path) {
        if (wasm$1 !== void 0)
          return wasm$1;
        if (typeof module_or_path !== "undefined" && Object.getPrototypeOf(module_or_path) === Object.prototype)
          ({ module_or_path } = module_or_path);
        else
          console.warn("using deprecated parameters for the initialization function; pass a single object instead");
        const imports = __wbg_get_imports();
        const { instance, module: module2 } = await __wbg_load(await module_or_path, imports);
        return __wbg_finalize_init(instance, module2);
      }
      function _loadWasmModule(sync2, filepath, src, imports) {
        function _instantiateOrCompile(source, imports2, stream2) {
          var instantiateFunc = stream2 ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
          var compileFunc = stream2 ? WebAssembly.compileStreaming : WebAssembly.compile;
          if (imports2) {
            return instantiateFunc(source, imports2);
          } else {
            return compileFunc(source);
          }
        }
        var buf = null;
        var isNode2 = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
        if (isNode2) {
          buf = Buffer.from(src, "base64");
        } else {
          var raw = globalThis.atob(src);
          var rawLength = raw.length;
          buf = new Uint8Array(new ArrayBuffer(rawLength));
          for (var i = 0; i < rawLength; i++) {
            buf[i] = raw.charCodeAt(i);
          }
        }
        if (sync2) {
          var mod2 = new WebAssembly.Module(buf);
          return imports ? new WebAssembly.Instance(mod2, imports) : mod2;
        } else {
          return _instantiateOrCompile(buf, imports, false);
        }
      }
      function wasm(imports) {
        return _loadWasmModule(1, null, "AGFzbQEAAAABOgpgA39/fwF/YAF/AX9gBH9/f38Bf2ACf38AYAJ/fwF/YAABf2AFf39/f38Bf2ABfwBgA39/fwBgAAACGAEDd2JnEF9fd2JpbmRnZW5fdGhyb3cAAwP/Af0BAQEDAwMDAwMBAQMDAQEBAwMBAQEEAQMDAwEBAwEBAQQCAQMCAgICAgIDAwMEBAQEBAQEBAEBAQMDAAICBAQEBAQEBAQEBAABAQgDAwQBAQEBAQEBAgcDAQAAAQEDBwcBAwEDAgIBAQEAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQUBAQEBBAAEAQYCAgMDAAIABwEIBAEEAQkDAQEHAQUFBQUFBQUFBQUFBQUFBQUFBQUDBgYCAgQCBgYAAAgABAUDAQARBgkBfwFBgIDAAAsHjUzPBQZtZW1vcnkCABZfX3diZ19jb21wYXJlYXJnc19mcmVlABAaX193YmdfZ2V0X2NvbXBhcmVhcmdzX21vZGUASBpfX3diZ19zZXRfY29tcGFyZWFyZ3NfbW9kZQA4Il9fd2JnX2dldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMASSJfX3diZ19zZXRfY29tcGFyZWFyZ3NfaW5kaXJlY3RfcmhzAEsSY29tcGFyZWFyZ3NfdG9faW1tAFgUY29tcGFyZWFyZ3NfZnJvbV9pbW0AHxVfX3diZ19nZXRfbWF0aGFyZ3Nfb3AASBVfX3diZ19zZXRfbWF0aGFyZ3Nfb3AAORJfX3diZ19tdWxhcmdzX2ZyZWUAER5fX3diZ19nZXRfbXVsYXJnc19pbmRpcmVjdF9yaHMASB5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9yaHMATBJfX3diZ19kaXZhcmdzX2ZyZWUAIx5fX3diZ19nZXRfZGl2YXJnc19pbmRpcmVjdF9yaHMAuQEeX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAGMbX193YmdfcGFuaWNpbnN0cnVjdGlvbl9mcmVlABchcGFuaWNpbnN0cnVjdGlvbl9lcnJvcl90eXBlc2NyaXB0AE0XcGFuaWNpbnN0cnVjdGlvbl9yZWFzb24AWxxwYW5pY2luc3RydWN0aW9uX2luc3RydWN0aW9uAFwMZ21fZnJvbV9hcmdzANUBDWd0Zl9mcm9tX2FyZ3MAzQEHZ21fYXJncwCIAQhndGZfYXJncwBpDndkY21fZnJvbV9hcmdzADsOd2RvcF9mcm9tX2FyZ3MAOw53ZG1sX2Zyb21fYXJncwA8DndkZHZfZnJvbV9hcmdzAMkBCXdkY21fYXJncwAkCXdxY21fYXJncwAlCXdkb3BfYXJncwAmCXdxb3BfYXJncwAnCXdkbWxfYXJncwAoCXdxbWxfYXJncwApCXdkZHZfYXJncwBkCXdxZHZfYXJncwBlEF9fd2JnX2ltbTA2X2ZyZWUAKhBfX3diZ19pbW0xMl9mcmVlACsQX193YmdfaW1tMThfZnJlZQAsDl9fd2JnX2FkZF9mcmVlABgPX193Ymdfbm9vcF9mcmVlAAcSYWRkX25ld190eXBlc2NyaXB0AFkGYWRkX3JhADUGYWRkX3JiABIGYWRkX3JjABoDYWRkAMUBA2FuZACKAQNkaXYAiwECZXEAjAEDZXhwAI0BAmd0AI4BAmx0AI8BBG1sb2cAkAEEbXJvbwCRAQRtb2RfAJIBBW1vdmVfAD0DbXVsAJMBA25vdAA+Am9yAJQBA3NsbACVAQNzcmwAlgEDc3ViAJcBA3hvcgCYAQRtbGR2AGoDcmV0ALoBBHJldGQAPxNhbG9jX25ld190eXBlc2NyaXB0AGAHYWxvY19yYQAiBGFsb2MAuwEDbWNsAEADbWNwAJkBA21lcQBrE2Joc2hfbmV3X3R5cGVzY3JpcHQAIARiaHNoAC0EYmhlaQC8AQRidXJuAEEEY2FsbABsA2NjcABtBGNyb28AQgRjc2l6AEMCY2IAvQEDbGRjAG4DbG9nAG8EbG9nZABwBG1pbnQARARydnJ0AL4BBHNjd3EAmgEDc3J3AJsBBHNyd3EAcQNzd3cAnAEEc3d3cQByAnRyAJ0BA3RybwBzBGVjazEAngEEZWNyMQCfAQRlZDE5AHQEazI1NgCgAQRzMjU2AKEBBHRpbWUARRNub29wX25ld190eXBlc2NyaXB0AL8BBG5vb3AA3QEEZmxhZwDAAQNiYWwAogEDam1wAMEBA2puZQCjAQNzbW8AdRNhZGRpX25ld190eXBlc2NyaXB0AFoKYWRkaV9pbW0xMgAJBGFkZGkApAEEYW5kaQClAQRkaXZpAKYBBGV4cGkApwEEbW9kaQCoAQRtdWxpAKkBA29yaQCqAQRzbGxpAKsBBHNybGkArAEEc3ViaQCtAQR4b3JpAK4BBGpuZWkArwECbGIAsAECbHcAsQECc2IAsgECc3cAswEEbWNwaQC0ARJndGZfbmV3X3R5cGVzY3JpcHQAzwEDZ3RmALUBBG1jbGkALhFnbV9uZXdfdHlwZXNjcmlwdABGCGdtX2ltbTE4AA0CZ20ALwRtb3ZpADAEam56aQAxBGptcGYAMhNqbXBiX25ld190eXBlc2NyaXB0ABUEam1wYgAzBGpuemYAtgEEam56YgC3AQRqbmVmAHYKam5lYl9pbW0wNgA2BGpuZWIAdwJqaQBOE2NmZWlfbmV3X3R5cGVzY3JpcHQANwpjZmVpX2ltbTI0AAoEY2ZlaQBPBGNmc2kAUANjZmUAwgEDY2ZzAMMBBHBzaGwAUQRwc2hoAFIEcG9wbABTBHBvcGgAVBN3ZGNtX25ld190eXBlc2NyaXB0AMoBBHdkY20AeAR3cWNtAHkEd2RvcAB6BHdxb3AAewR3ZG1sAHwEd3FtbAB9BHdkZHYAfgR3cWR2AH8Ed2RtZACAAQR3cW1kAIEBBHdkYW0AggEEd3FhbQCDAQR3ZG1tAIQBBHdxbW0AhQEEZWNhbACGAQRic2l6ADQTYmxkZF9uZXdfdHlwZXNjcmlwdABVB2JsZGRfcmQANgRibGRkAIcBFl9fd2JnX2luc3RydWN0aW9uX2ZyZWUADBRpbnN0cnVjdGlvbl90b19ieXRlcwAGEGluc3RydWN0aW9uX3NpemUA7wERcmVnaWRfbmV3X2NoZWNrZWQAuAEJcmVnaWRfYmFsAN4BCnJlZ2lkX2NnYXMA3wEJcmVnaWRfZXJyAOABCnJlZ2lkX2ZsYWcA4QEIcmVnaWRfZnAA4gEKcmVnaWRfZ2dhcwDjAQhyZWdpZF9ocADkAQhyZWdpZF9pcwDlAQhyZWdpZF9vZgDmAQlyZWdpZF9vbmUA5wEIcmVnaWRfcGMA6AEJcmVnaWRfcmV0AOkBCnJlZ2lkX3JldGwA6gEIcmVnaWRfc3AA6wEJcmVnaWRfc3BwAOwBDnJlZ2lkX3dyaXRhYmxlAO0BCnJlZ2lkX3plcm8A7gEUcmVnaWRfbmV3X3R5cGVzY3JpcHQA2QELcmVnaWRfdG9fdTgA2gESYW5kX25ld190eXBlc2NyaXB0AFkSZGl2X25ld190eXBlc2NyaXB0AFkRZXFfbmV3X3R5cGVzY3JpcHQAWRJleHBfbmV3X3R5cGVzY3JpcHQAWRFndF9uZXdfdHlwZXNjcmlwdABZEWx0X25ld190eXBlc2NyaXB0AFkTbWxvZ19uZXdfdHlwZXNjcmlwdABZE21yb29fbmV3X3R5cGVzY3JpcHQAWRJtb2RfbmV3X3R5cGVzY3JpcHQAWRJtdWxfbmV3X3R5cGVzY3JpcHQAWRFvcl9uZXdfdHlwZXNjcmlwdABZEnNsbF9uZXdfdHlwZXNjcmlwdABZEnNybF9uZXdfdHlwZXNjcmlwdABZEnN1Yl9uZXdfdHlwZXNjcmlwdABZEnhvcl9uZXdfdHlwZXNjcmlwdABZEm1jcF9uZXdfdHlwZXNjcmlwdABZE3Njd3FfbmV3X3R5cGVzY3JpcHQAWRJzcndfbmV3X3R5cGVzY3JpcHQAWRJzd3dfbmV3X3R5cGVzY3JpcHQAWRF0cl9uZXdfdHlwZXNjcmlwdABZE2VjazFfbmV3X3R5cGVzY3JpcHQAWRNlY3IxX25ld190eXBlc2NyaXB0AFkTazI1Nl9uZXdfdHlwZXNjcmlwdABZE3MyNTZfbmV3X3R5cGVzY3JpcHQAWRJiYWxfbmV3X3R5cGVzY3JpcHQAWRJqbmVfbmV3X3R5cGVzY3JpcHQAWRNhbmRpX25ld190eXBlc2NyaXB0AFoTZGl2aV9uZXdfdHlwZXNjcmlwdABaE2V4cGlfbmV3X3R5cGVzY3JpcHQAWhNtb2RpX25ld190eXBlc2NyaXB0AFoTbXVsaV9uZXdfdHlwZXNjcmlwdABaEm9yaV9uZXdfdHlwZXNjcmlwdABaE3NsbGlfbmV3X3R5cGVzY3JpcHQAWhNzcmxpX25ld190eXBlc2NyaXB0AFoTc3ViaV9uZXdfdHlwZXNjcmlwdABaE3hvcmlfbmV3X3R5cGVzY3JpcHQAWhNqbmVpX25ld190eXBlc2NyaXB0AFoRbGJfbmV3X3R5cGVzY3JpcHQAWhFsd19uZXdfdHlwZXNjcmlwdABaEXNiX25ld190eXBlc2NyaXB0AFoRc3dfbmV3X3R5cGVzY3JpcHQAWhNtY3BpX25ld190eXBlc2NyaXB0AFoTam56Zl9uZXdfdHlwZXNjcmlwdABaE2puemJfbmV3X3R5cGVzY3JpcHQAWhFqaV9uZXdfdHlwZXNjcmlwdAA3E2Nmc2lfbmV3X3R5cGVzY3JpcHQANxNwc2hsX25ld190eXBlc2NyaXB0ADcTcHNoaF9uZXdfdHlwZXNjcmlwdAA3E3BvcGxfbmV3X3R5cGVzY3JpcHQANxNwb3BoX25ld190eXBlc2NyaXB0ADcTbW92aV9uZXdfdHlwZXNjcmlwdAAVE21jbGlfbmV3X3R5cGVzY3JpcHQAFRNqbnppX25ld190eXBlc2NyaXB0ABUTam1wZl9uZXdfdHlwZXNjcmlwdAAVEm5vdF9uZXdfdHlwZXNjcmlwdAAgE3JldGRfbmV3X3R5cGVzY3JpcHQAIBNtb3ZlX25ld190eXBlc2NyaXB0ACASbWNsX25ld190eXBlc2NyaXB0ACATYnVybl9uZXdfdHlwZXNjcmlwdAAgE2Nyb29fbmV3X3R5cGVzY3JpcHQAIBNjc2l6X25ld190eXBlc2NyaXB0ACATbWludF9uZXdfdHlwZXNjcmlwdAAgE3RpbWVfbmV3X3R5cGVzY3JpcHQAIBNic2l6X25ld190eXBlc2NyaXB0ACAGcmV0X3JhACIHYmhlaV9yYQAiBWNiX3JhACIHcnZydF9yYQAiB2ZsYWdfcmEAIgZqbXBfcmEAIghqaV9pbW0yNAAKCmNmc2lfaW1tMjQACgZjZmVfcmEAIgZjZnNfcmEAIgpwc2hsX2ltbTI0AAoKcHNoaF9pbW0yNAAKCnBvcGxfaW1tMjQACgpwb3BoX2ltbTI0AAoTbWxkdl9uZXdfdHlwZXNjcmlwdABVEm1lcV9uZXdfdHlwZXNjcmlwdABVEmNjcF9uZXdfdHlwZXNjcmlwdABVEmxvZ19uZXdfdHlwZXNjcmlwdABVE2xvZ2RfbmV3X3R5cGVzY3JpcHQAVRNzcndxX25ld190eXBlc2NyaXB0AFUTc3d3cV9uZXdfdHlwZXNjcmlwdABVEnRyb19uZXdfdHlwZXNjcmlwdABVE2VkMTlfbmV3X3R5cGVzY3JpcHQAVRJzbW9fbmV3X3R5cGVzY3JpcHQAVRJsZGNfbmV3X3R5cGVzY3JpcHQAVRNqbmVmX25ld190eXBlc2NyaXB0AFUTd2RtZF9uZXdfdHlwZXNjcmlwdABVE3dxbWRfbmV3X3R5cGVzY3JpcHQAVRN3ZGFtX25ld190eXBlc2NyaXB0AFUTd3FhbV9uZXdfdHlwZXNjcmlwdABVE3dkbW1fbmV3X3R5cGVzY3JpcHQAVRN3cW1tX25ld190eXBlc2NyaXB0AFUTZWNhbF9uZXdfdHlwZXNjcmlwdABVE2NhbGxfbmV3X3R5cGVzY3JpcHQAVRNfX3diZ19tYXRoYXJnc19mcmVlABAfX193Ymdfc2V0X21hdGhhcmdzX2luZGlyZWN0X3JocwBLHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X2xocwBLH19fd2JnX2dldF9tYXRoYXJnc19pbmRpcmVjdF9yaHMASR5fX3diZ19nZXRfbXVsYXJnc19pbmRpcmVjdF9saHMASRJyZXRfbmV3X3R5cGVzY3JpcHQAYBNiaGVpX25ld190eXBlc2NyaXB0AGARY2JfbmV3X3R5cGVzY3JpcHQAYBNydnJ0X25ld190eXBlc2NyaXB0AGATZmxhZ19uZXdfdHlwZXNjcmlwdABgEmptcF9uZXdfdHlwZXNjcmlwdABgEmNmZV9uZXdfdHlwZXNjcmlwdABgEmNmc19uZXdfdHlwZXNjcmlwdABgD19fd2JnX3dkb3BfZnJlZQAYDl9fd2JnX21vZF9mcmVlABgPX193Ymdfd3Fkdl9mcmVlABgNX193Ymdfc2JfZnJlZQAYDl9fd2JnX3Ntb19mcmVlABgPX193YmdfcHNobF9mcmVlABgOX193YmdfbG9nX2ZyZWUAGA9fX3diZ193cWFtX2ZyZWUAGA9fX3diZ193cW1sX2ZyZWUAGA5fX3diZ19ub3RfZnJlZQAYD19fd2JnX2puemlfZnJlZQAYD19fd2JnX2puZWlfZnJlZQAYD19fd2JnX3N1YmlfZnJlZQAYD19fd2JnX2ZsYWdfZnJlZQAYD19fd2JnX2NzaXpfZnJlZQAYD19fd2JnX3Nyd3FfZnJlZQAYD19fd2JnX3NsbGlfZnJlZQAYD19fd2JnX2ptcGJfZnJlZQAYD19fd2JnX3dkbWxfZnJlZQAYD19fd2JnX3MyNTZfZnJlZQAYDl9fd2JnX3hvcl9mcmVlABgOX193YmdfY2ZlX2ZyZWUAGA1fX3diZ19ndF9mcmVlABgPX193YmdfcHNoaF9mcmVlABgPX193YmdfbWNsaV9mcmVlABgNX193YmdfbHRfZnJlZQAYD19fd2JnX2puZWZfZnJlZQAYDV9fd2JnX3N3X2ZyZWUAGA9fX3diZ19zcmxpX2ZyZWUAGA9fX3diZ19idXJuX2ZyZWUAGA9fX3diZ19ic2l6X2ZyZWUAGA9fX3diZ19ydnJ0X2ZyZWUAGA9fX3diZ194b3JpX2ZyZWUAGA9fX3diZ19tdWxpX2ZyZWUAGA1fX3diZ19sYl9mcmVlABgNX193YmdfZ21fZnJlZQAYD19fd2JnX2Joc2hfZnJlZQAYDV9fd2JnX2VxX2ZyZWUAGA5fX3diZ19zbGxfZnJlZQAYDl9fd2JnX29yaV9mcmVlABgPX193YmdfZWQxOV9mcmVlABgPX193YmdfY2ZlaV9mcmVlABgPX193YmdfY2ZzaV9mcmVlABgPX193Ymdfam56Yl9mcmVlABgPX193YmdfYWxvY19mcmVlABgOX193Ymdfc3JsX2ZyZWUAGA9fX3diZ19tcm9vX2ZyZWUAGA5fX3diZ19jZnNfZnJlZQAYDl9fd2JnX2ptcF9mcmVlABgPX193YmdfYmhlaV9mcmVlABgPX193YmdfbG9nZF9mcmVlABgPX193Ymdfam5lYl9mcmVlABgPX193Ymdfd3FtbV9mcmVlABgPX193YmdfcG9waF9mcmVlABgPX193Ymdfd2RjbV9mcmVlABgPX193YmdfZXhwaV9mcmVlABgPX193YmdfYWRkaV9mcmVlABgPX193YmdfYmxkZF9mcmVlABgOX193YmdfbGRjX2ZyZWUAGA5fX3diZ19kaXZfZnJlZQAYD19fd2JnX3dkZHZfZnJlZQAYD19fd2JnX21sZHZfZnJlZQAYDl9fd2JnX21jbF9mcmVlABgOX193YmdfbXVsX2ZyZWUAGA9fX3diZ193ZGFtX2ZyZWUAGA9fX3diZ19jYWxsX2ZyZWUAGA1fX3diZ19sd19mcmVlABgPX193YmdfZWNhbF9mcmVlABgPX193YmdfbWxvZ19mcmVlABgPX193YmdfcmV0ZF9mcmVlABgPX193YmdfdGltZV9mcmVlABgOX193YmdfZ3RmX2ZyZWUAGA5fX3diZ19qbmVfZnJlZQAYDV9fd2JnX29yX2ZyZWUAGA9fX3diZ19kaXZpX2ZyZWUAGA9fX3diZ19qbnpmX2ZyZWUAGA5fX3diZ190cm9fZnJlZQAYDl9fd2JnX21jcF9mcmVlABgPX193YmdfbWludF9mcmVlABgOX193Ymdfc3ViX2ZyZWUAGA1fX3diZ19jYl9mcmVlABgPX193Ymdfd3FvcF9mcmVlABgOX193Ymdfc3J3X2ZyZWUAGA9fX3diZ19lY3IxX2ZyZWUAGA9fX3diZ19qbXBmX2ZyZWUAGA9fX3diZ19rMjU2X2ZyZWUAGA5fX3diZ19yZXRfZnJlZQAYD19fd2JnX3Njd3FfZnJlZQAYDl9fd2JnX21lcV9mcmVlABgPX193Ymdfc3d3cV9mcmVlABgOX193YmdfYmFsX2ZyZWUAGA9fX3diZ19tb3ZpX2ZyZWUAGA9fX3diZ193ZG1kX2ZyZWUAGA9fX3diZ19wb3BsX2ZyZWUAGA9fX3diZ193ZG1tX2ZyZWUAGA5fX3diZ19leHBfZnJlZQAYDV9fd2JnX2ppX2ZyZWUAGA9fX3diZ193cWNtX2ZyZWUAGA9fX3diZ19tY3BpX2ZyZWUAGA9fX3diZ19tb2RpX2ZyZWUAGA1fX3diZ190cl9mcmVlABgPX193YmdfYW5kaV9mcmVlABgOX193YmdfY2NwX2ZyZWUAGA5fX3diZ19zd3dfZnJlZQAYD19fd2JnX2Nyb29fZnJlZQAYD19fd2JnX3dxbWRfZnJlZQAYD19fd2JnX21vdmVfZnJlZQAYD19fd2JnX2VjazFfZnJlZQAYDl9fd2JnX2FuZF9mcmVlABgTd3Fkdl9uZXdfdHlwZXNjcmlwdADKARN3cW1sX25ld190eXBlc2NyaXB0AMoBE3dkbWxfbmV3X3R5cGVzY3JpcHQAygETd3FvcF9uZXdfdHlwZXNjcmlwdADKARN3ZG9wX25ld190eXBlc2NyaXB0AMoBE3dxY21fbmV3X3R5cGVzY3JpcHQAygETd2Rkdl9uZXdfdHlwZXNjcmlwdADKAQ53cWNtX2Zyb21fYXJncwA7CndxZHZfaW1tMDYANgp3cW1sX2ltbTA2ADYKd2RtbF9pbW0wNgA2Cndxb3BfaW1tMDYANgp3ZG9wX2ltbTA2ADYKd3FjbV9pbW0wNgA2CndkZHZfaW1tMDYANgp3ZGNtX2ltbTA2ADYKam5lZl9pbW0wNgA2CWxkY19pbW0wNgA2DndxbWxfZnJvbV9hcmdzADwOd3FvcF9mcm9tX2FyZ3MAOwVnbV9yYQA1BWd0X3JjABoFZ3RfcmIAEgVndF9yYQA1BWxiX3JiABIFbGJfcmEANQVsdF9yYwAaBWx0X3JiABIFbHRfcmEANQhsd19pbW0xMgAJBWx3X3JiABIFbHdfcmEANQVvcl9yYwAaBW9yX3JiABIFb3JfcmEANQhzYl9pbW0xMgAJBXNiX3JiABIFc2JfcmEANQhzd19pbW0xMgAJBXN3X3JiABIFc3dfcmEANQV0cl9yYwAaBXRyX3JiABIFdHJfcmEANQVlcV9yYwAaBWVxX3JiABIFZXFfcmEANQZhbmRfcmMAGgZhbmRfcmIAEgZhbmRfcmEANQZiYWxfcmMAGgZiYWxfcmIAEgZiYWxfcmEANQZjY3BfcmMAGgZjY3BfcmIAEgZjY3BfcmEANQZkaXZfcmMAGgZkaXZfcmIAEgZkaXZfcmEANQZleHBfcmMAGgZleHBfcmIAEgZleHBfcmEANQhsYl9pbW0xMgAJBmd0Zl9yYgASBmd0Zl9yYQA1BmpuZV9yYwAaBmpuZV9yYgASBmpuZV9yYQA1BmxkY19yYwAaBmxkY19yYgASBmxkY19yYQA1BmxvZ19yZAA2BmxvZ19yYwAaBmxvZ19yYgASBmxvZ19yYQA1Bm1jbF9yYgASBm1jbF9yYQA1Bm1jcF9yYwAaBm1jcF9yYgASBm1jcF9yYQA1Bm1lcV9yZAA2Bm1lcV9yYwAaBm1lcV9yYgASBm1lcV9yYQA1Bm1vZF9yYwAaBm1vZF9yYgASBm1vZF9yYQA1Bm11bF9yYwAaBm11bF9yYgASBm11bF9yYQA1Bm5vdF9yYgASBm5vdF9yYQA1CW9yaV9pbW0xMgAJBm9yaV9yYgASBm9yaV9yYQA1BnNsbF9yYwAaBnNsbF9yYgASBnNsbF9yYQA1BnNtb19yZAA2BnNtb19yYwAaBnNtb19yYgASBnNtb19yYQA1BnNybF9yYwAaBnNybF9yYgASBnNybF9yYQA1BnNyd19yYwAaBnNyd19yYgASBnNyd19yYQA1BnN1Yl9yYwAaBnN1Yl9yYgASBnN1Yl9yYQA1BnN3d19yYwAaBnN3d19yYgASBnN3d19yYQA1BnRyb19yZAA2BnRyb19yYwAaBnRyb19yYgASBnRyb19yYQA1Bnhvcl9yYwAaBnhvcl9yYgASBnhvcl9yYQA1CWd0Zl9pbW0xMgAJB2FkZGlfcmIAEgdhZGRpX3JhADUKYW5kaV9pbW0xMgAJB2FuZGlfcmIAEgdhbmRpX3JhADUHYmhzaF9yYgASB2Joc2hfcmEANQZjY3BfcmQANgdibGRkX3JjABoHYmxkZF9yYgASB2JsZGRfcmEANQdic2l6X3JiABIHYnNpel9yYQA1B2J1cm5fcmIAEgdidXJuX3JhADUHY2FsbF9yZAA2B2NhbGxfcmMAGgdjYWxsX3JiABIHY2FsbF9yYQA1B2Nyb29fcmIAEgdjcm9vX3JhADUHY3Npel9yYgASB2NzaXpfcmEANQpkaXZpX2ltbTEyAAkHZGl2aV9yYgASB2RpdmlfcmEANQdlY2FsX3JkADYHZWNhbF9yYwAaB2VjYWxfcmIAEgdlY2FsX3JhADUHZWNrMV9yYwAaB2VjazFfcmIAEgdlY2sxX3JhADUHZWNyMV9yYwAaB2VjcjFfcmIAEgdlY3IxX3JhADUHZWQxOV9yZAA2B2VkMTlfcmMAGgdlZDE5X3JiABIHZWQxOV9yYQA1CmV4cGlfaW1tMTIACQdleHBpX3JiABIHZXhwaV9yYQA1CmptcGJfaW1tMTgADQdqbXBiX3JhADUKam1wZl9pbW0xOAANB2ptcGZfcmEANQdqbmViX3JjABoHam5lYl9yYgASB2puZWJfcmEANQdqbmVmX3JjABoHam5lZl9yYgASB2puZWZfcmEANQpqbmVpX2ltbTEyAAkHam5laV9yYgASB2puZWlfcmEANQpqbnpiX2ltbTEyAAkHam56Yl9yYgASB2puemJfcmEANQpqbnpmX2ltbTEyAAkHam56Zl9yYgASB2puemZfcmEANQpqbnppX2ltbTE4AA0Ham56aV9yYQA1B2syNTZfcmMAGgdrMjU2X3JiABIHazI1Nl9yYQA1B2xvZ2RfcmQANgdsb2dkX3JjABoHbG9nZF9yYgASB2xvZ2RfcmEANQptY2xpX2ltbTE4AA0HbWNsaV9yYQA1Cm1jcGlfaW1tMTIACQdtY3BpX3JiABIHbWNwaV9yYQA1B21pbnRfcmIAEgdtaW50X3JhADUHbWxkdl9yZAA2B21sZHZfcmMAGgdtbGR2X3JiABIHbWxkdl9yYQA1B21sb2dfcmMAGgdtbG9nX3JiABIHbWxvZ19yYQA1Cm1vZGlfaW1tMTIACQdtb2RpX3JiABIHbW9kaV9yYQA1B21vdmVfcmIAEgdtb3ZlX3JhADUKbW92aV9pbW0xOAANB21vdmlfcmEANQdtcm9vX3JjABoHbXJvb19yYgASB21yb29fcmEANQptdWxpX2ltbTEyAAkHbXVsaV9yYgASB211bGlfcmEANQdyZXRkX3JiABIHcmV0ZF9yYQA1B3MyNTZfcmMAGgdzMjU2X3JiABIHczI1Nl9yYQA1B3Njd3FfcmMAGgdzY3dxX3JiABIHc2N3cV9yYQA1CnNsbGlfaW1tMTIACQdzbGxpX3JiABIHc2xsaV9yYQA1CnNybGlfaW1tMTIACQdzcmxpX3JiABIHc3JsaV9yYQA1B3Nyd3FfcmQANgdzcndxX3JjABoHc3J3cV9yYgASB3Nyd3FfcmEANQpzdWJpX2ltbTEyAAkHc3ViaV9yYgASB3N1YmlfcmEANQdzd3dxX3JkADYHc3d3cV9yYwAaB3N3d3FfcmIAEgdzd3dxX3JhADUHdGltZV9yYgASB3RpbWVfcmEANQd3ZGFtX3JkADYHd2RhbV9yYwAaB3dkYW1fcmIAEgd3ZGFtX3JhADUHd2RjbV9yYwAaB3dkY21fcmIAEgd3ZGNtX3JhADUHd2Rkdl9yYwAaB3dkZHZfcmIAEgd3ZGR2X3JhADUHd2RtZF9yZAA2B3dkbWRfcmMAGgd3ZG1kX3JiABIHd2RtZF9yYQA1B3dkbWxfcmMAGgd3ZG1sX3JiABIHd2RtbF9yYQA1B3dkbW1fcmQANgd3ZG1tX3JjABoHd2RtbV9yYgASB3dkbW1fcmEANQd3ZG9wX3JjABoHd2RvcF9yYgASB3dkb3BfcmEANQd3cWFtX3JkADYHd3FhbV9yYwAaB3dxYW1fcmIAEgd3cWFtX3JhADUHd3FjbV9yYwAaB3dxY21fcmIAEgd3cWNtX3JhADUHd3Fkdl9yYwAaB3dxZHZfcmIAEgd3cWR2X3JhADUHd3FtZF9yZAA2B3dxbWRfcmMAGgd3cW1kX3JiABIHd3FtZF9yYQA1B3dxbWxfcmMAGgd3cW1sX3JiABIHd3FtbF9yYQA1B3dxbW1fcmQANgd3cW1tX3JjABoHd3FtbV9yYgASB3dxbW1fcmEANQd3cW9wX3JjABoHd3FvcF9yYgASB3dxb3BfcmEANQp4b3JpX2ltbTEyAAkHeG9yaV9yYgASB3hvcmlfcmEANRNqbmViX25ld190eXBlc2NyaXB0AFUQX193YmdfcmVnaWRfZnJlZQAqDndxZHZfZnJvbV9hcmdzAMkBEF9fd2JnX2ltbTI0X2ZyZWUALB9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyANYBE19fd2JpbmRnZW5fZXhwb3J0XzAA0gEKgXv9Ae0iAgh/AX4CQAJAAkACQAJAAkACQAJAIABB9QFPBEAgAEHN/3tPDQUgAEELaiIAQXhxIQVB5I7AACgCACIIRQ0EQQAgBWshBAJ/QQAgBUGAAkkNABpBHyAFQf///wdLDQAaIAVBBiAAQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgdBAnRByIvAAGooAgAiAkUEQEEAIQAMAgtBACEAIAVBGSAHQQF2a0EAIAdBH0cbdCEDA0ACQCACKAIEQXhxIgYgBUkNACAGIAVrIgYgBE8NACACIQEgBiIEDQBBACEEIAEhAAwECyACKAIUIgYgACAGIAIgA0EddkEEcWpBEGooAgAiAkcbIAAgBhshACADQQF0IQMgAg0ACwwBC0HgjsAAKAIAIgJBECAAQQtqQfgDcSAAQQtJGyIFQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiAUEDdCIAQdiMwABqIgMgAEHgjMAAaigCACIAKAIIIgRHBEAgBCADNgIMIAMgBDYCCAwBC0HgjsAAIAJBfiABd3E2AgALIAAgAUEDdCIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAgLIAVB6I7AACgCAE0NAwJAAkAgAUUEQEHkjsAAKAIAIgBFDQYgAGhBAnRByIvAAGooAgAiASgCBEF4cSAFayEEIAEhAgNAAkAgASgCECIADQAgASgCFCIADQAgAigCGCEHAkACQCACIAIoAgwiAEYEQCACQRRBECACKAIUIgAbaigCACIBDQFBACEADAILIAIoAggiASAANgIMIAAgATYCCAwBCyACQRRqIAJBEGogABshAwNAIAMhBiABIgBBFGogAEEQaiAAKAIUIgEbIQMgAEEUQRAgARtqKAIAIgENAAsgBkEANgIACyAHRQ0EIAIgAigCHEECdEHIi8AAaiIBKAIARwRAIAdBEEEUIAcoAhAgAkYbaiAANgIAIABFDQUMBAsgASAANgIAIAANA0HkjsAAQeSOwAAoAgBBfiACKAIcd3E2AgAMBAsgACgCBEF4cSAFayIBIAQgASAESSIBGyEEIAAgAiABGyECIAAhAQwACwALAkBBAiAAdCIDQQAgA2tyIAEgAHRxaCIAQQN0IgFB2IzAAGoiAyABQeCMwABqKAIAIgEoAggiBEcEQCAEIAM2AgwgAyAENgIIDAELQeCOwAAgAkF+IAB3cTYCAAsgASAFQQNyNgIEIAEgBWoiBiAAQQN0IgAgBWsiBEEBcjYCBCAAIAFqIAQ2AgBB6I7AACgCACICBEAgAkF4cUHYjMAAaiEAQfCOwAAoAgAhAwJ/QeCOwAAoAgAiBUEBIAJBA3Z0IgJxRQRAQeCOwAAgAiAFcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIC0HwjsAAIAY2AgBB6I7AACAENgIAIAFBCGoPCyAAIAc2AhggAigCECIBBEAgACABNgIQIAEgADYCGAsgAigCFCIBRQ0AIAAgATYCFCABIAA2AhgLAkACQCAEQRBPBEAgAiAFQQNyNgIEIAIgBWoiBSAEQQFyNgIEIAQgBWogBDYCAEHojsAAKAIAIgNFDQEgA0F4cUHYjMAAaiEAQfCOwAAoAgAhAQJ/QeCOwAAoAgAiBkEBIANBA3Z0IgNxRQRAQeCOwAAgAyAGcjYCACAADAELIAAoAggLIQMgACABNgIIIAMgATYCDCABIAA2AgwgASADNgIIDAELIAIgBCAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELQfCOwAAgBTYCAEHojsAAIAQ2AgALIAJBCGoPCyAAIAFyRQRAQQAhAUECIAd0IgBBACAAa3IgCHEiAEUNAyAAaEECdEHIi8AAaigCACEACyAARQ0BCwNAIAAgASAAKAIEQXhxIgMgBWsiBiAESSIHGyEIIAAoAhAiAkUEQCAAKAIUIQILIAEgCCADIAVJIgAbIQEgBCAGIAQgBxsgABshBCACIgANAAsLIAFFDQAgBUHojsAAKAIAIgBNIAQgACAFa09xDQAgASgCGCEHAkACQCABIAEoAgwiAEYEQCABQRRBECABKAIUIgAbaigCACICDQFBACEADAILIAEoAggiAiAANgIMIAAgAjYCCAwBCyABQRRqIAFBEGogABshAwNAIAMhBiACIgBBFGogAEEQaiAAKAIUIgIbIQMgAEEUQRAgAhtqKAIAIgINAAsgBkEANgIACyAHRQ0DIAEgASgCHEECdEHIi8AAaiICKAIARwRAIAdBEEEUIAcoAhAgAUYbaiAANgIAIABFDQQMAwsgAiAANgIAIAANAkHkjsAAQeSOwAAoAgBBfiABKAIcd3E2AgAMAwsCQAJAAkACQAJAIAVB6I7AACgCACIBSwRAIAVB7I7AACgCACIATwRAQQAhBCAFQa+ABGoiAEEQdkAAIgFBf0YiAw0HIAFBEHQiAkUNB0H4jsAAQQAgAEGAgHxxIAMbIgRB+I7AACgCAGoiADYCAEH8jsAAQfyOwAAoAgAiASAAIAAgAUkbNgIAAkACQEH0jsAAKAIAIgMEQEHIjMAAIQADQCAAKAIAIgEgACgCBCIGaiACRg0CIAAoAggiAA0ACwwCC0GEj8AAKAIAIgBBACAAIAJNG0UEQEGEj8AAIAI2AgALQYiPwABB/x82AgBBzIzAACAENgIAQciMwAAgAjYCAEHkjMAAQdiMwAA2AgBB7IzAAEHgjMAANgIAQeCMwABB2IzAADYCAEH0jMAAQeiMwAA2AgBB6IzAAEHgjMAANgIAQfyMwABB8IzAADYCAEHwjMAAQeiMwAA2AgBBhI3AAEH4jMAANgIAQfiMwABB8IzAADYCAEGMjcAAQYCNwAA2AgBBgI3AAEH4jMAANgIAQZSNwABBiI3AADYCAEGIjcAAQYCNwAA2AgBBnI3AAEGQjcAANgIAQZCNwABBiI3AADYCAEHUjMAAQQA2AgBBpI3AAEGYjcAANgIAQZiNwABBkI3AADYCAEGgjcAAQZiNwAA2AgBBrI3AAEGgjcAANgIAQaiNwABBoI3AADYCAEG0jcAAQaiNwAA2AgBBsI3AAEGojcAANgIAQbyNwABBsI3AADYCAEG4jcAAQbCNwAA2AgBBxI3AAEG4jcAANgIAQcCNwABBuI3AADYCAEHMjcAAQcCNwAA2AgBByI3AAEHAjcAANgIAQdSNwABByI3AADYCAEHQjcAAQciNwAA2AgBB3I3AAEHQjcAANgIAQdiNwABB0I3AADYCAEHkjcAAQdiNwAA2AgBB7I3AAEHgjcAANgIAQeCNwABB2I3AADYCAEH0jcAAQeiNwAA2AgBB6I3AAEHgjcAANgIAQfyNwABB8I3AADYCAEHwjcAAQeiNwAA2AgBBhI7AAEH4jcAANgIAQfiNwABB8I3AADYCAEGMjsAAQYCOwAA2AgBBgI7AAEH4jcAANgIAQZSOwABBiI7AADYCAEGIjsAAQYCOwAA2AgBBnI7AAEGQjsAANgIAQZCOwABBiI7AADYCAEGkjsAAQZiOwAA2AgBBmI7AAEGQjsAANgIAQayOwABBoI7AADYCAEGgjsAAQZiOwAA2AgBBtI7AAEGojsAANgIAQaiOwABBoI7AADYCAEG8jsAAQbCOwAA2AgBBsI7AAEGojsAANgIAQcSOwABBuI7AADYCAEG4jsAAQbCOwAA2AgBBzI7AAEHAjsAANgIAQcCOwABBuI7AADYCAEHUjsAAQciOwAA2AgBByI7AAEHAjsAANgIAQdyOwABB0I7AADYCAEHQjsAAQciOwAA2AgBB9I7AACACNgIAQdiOwABB0I7AADYCAEHsjsAAIARBKGsiADYCACACIABBAXI2AgQgACACakEoNgIEQYCPwABBgICAATYCAAwICyACIANNIAEgA0tyDQAgACgCDEUNAwtBhI/AAEGEj8AAKAIAIgAgAiAAIAJJGzYCACACIARqIQFByIzAACEAAkACQANAIAEgACgCAEcEQCAAKAIIIgANAQwCCwsgACgCDEUNAQtByIzAACEAA0ACQCADIAAoAgAiAU8EQCABIAAoAgRqIgYgA0sNAQsgACgCCCEADAELC0H0jsAAIAI2AgBB7I7AACAEQShrIgA2AgAgAiAAQQFyNgIEIAAgAmpBKDYCBEGAj8AAQYCAgAE2AgAgAyAGQSBrQXhxQQhrIgAgACADQRBqSRsiAUEbNgIEQciMwAApAgAhCSABQRBqQdCMwAApAgA3AgAgASAJNwIIQcyMwAAgBDYCAEHIjMAAIAI2AgBB0IzAACABQQhqNgIAQdSMwABBADYCACABQRxqIQADQCAAQQc2AgAgAEEEaiIAIAZJDQALIAEgA0YNByABIAEoAgRBfnE2AgQgAyABIANrIgBBAXI2AgQgASAANgIAIABBgAJPBEAgAyAAEAUMCAsgAEF4cUHYjMAAaiEBAn9B4I7AACgCACICQQEgAEEDdnQiAHFFBEBB4I7AACAAIAJyNgIAIAEMAQsgASgCCAshACABIAM2AgggACADNgIMIAMgATYCDCADIAA2AggMBwsgACACNgIAIAAgACgCBCAEajYCBCACIAVBA3I2AgQgASACIAVqIgNrIQUgAUH0jsAAKAIARg0DIAFB8I7AACgCAEYNBCABKAIEIgRBA3FBAUYEQCABIARBeHEiABAEIAAgBWohBSAAIAFqIgEoAgQhBAsgASAEQX5xNgIEIAMgBUEBcjYCBCADIAVqIAU2AgAgBUGAAk8EQCADIAUQBQwGCyAFQXhxQdiMwABqIQACf0HgjsAAKAIAIgFBASAFQQN2dCIEcUUEQEHgjsAAIAEgBHI2AgAgAAwBCyAAKAIICyEFIAAgAzYCCCAFIAM2AgwgAyAANgIMIAMgBTYCCAwFC0HsjsAAIAAgBWsiATYCAEH0jsAAQfSOwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEEDAYLQfCOwAAoAgAhAAJAIAEgBWsiAkEPTQRAQfCOwABBADYCAEHojsAAQQA2AgAgACABQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELQeiOwAAgAjYCAEHwjsAAIAAgBWoiAzYCACADIAJBAXI2AgQgACABaiACNgIAIAAgBUEDcjYCBAsMCAsgACAEIAZqNgIEQfSOwABB9I7AACgCACIAQQ9qQXhxIgFBCGsiAjYCAEHsjsAAQeyOwAAoAgAgBGoiAyAAIAFrakEIaiIBNgIAIAIgAUEBcjYCBCAAIANqQSg2AgRBgI/AAEGAgIABNgIADAMLQfSOwAAgAzYCAEHsjsAAQeyOwAAoAgAgBWoiADYCACADIABBAXI2AgQMAQtB8I7AACADNgIAQeiOwABB6I7AACgCACAFaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgALIAJBCGoPC0EAIQRB7I7AACgCACIAIAVNDQBB7I7AACAAIAVrIgE2AgBB9I7AAEH0jsAAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEDAMLIAQPCyAAIAc2AhggASgCECICBEAgACACNgIQIAIgADYCGAsgASgCFCICRQ0AIAAgAjYCFCACIAA2AhgLAkAgBEEQTwRAIAEgBUEDcjYCBCABIAVqIgIgBEEBcjYCBCACIARqIAQ2AgAgBEGAAk8EQCACIAQQBQwCCyAEQXhxQdiMwABqIQACf0HgjsAAKAIAIgNBASAEQQN2dCIEcUUEQEHgjsAAIAMgBHI2AgAgAAwBCyAAKAIICyEEIAAgAjYCCCAEIAI2AgwgAiAANgIMIAIgBDYCCAwBCyABIAQgBWoiAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsgAUEIag8LIABBCGoL+wQBAX8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEGABGsOJgECAwQFBgcILAkKCwwNLCwsLCwsLCwsLCwsLCwsLCwsDg8sLCwQAAtBASEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQQFrDg5BAQIDBAUGQgcICQoLDAALAkAgAEHABGsODCcoKSorLC0uLzAxMgALAkAgAEGBAmsOCg0ODxAREhMUFRYACwJAIABBgAZrDgkzNDU2N0JCODkACwJAIABBgAprDgU8PT4/QAALIABBgAhrDgI5OkELQQIPC0EDDwtBBA8LQQUPC0EGDwtBBw8LQQkPC0EKDwtBCw8LQQwPC0ENDwtBDg8LQYECDwtBggIPC0GDAg8LQYQCDwtBhQIPC0GGAg8LQYcCDwtBiAIPC0GJAg8LQYoCDwtBgAQPC0GBBA8LQYIEDwtBgwQPC0GEBA8LQYUEDwtBhgQPC0GHBA8LQYkEDwtBigQPC0GLBA8LQYwEDwtBjQQPC0GgBA8LQaEEDwtBpQQPC0HABA8LQcEEDwtBwgQPC0HDBA8LQcQEDwtBxQQPC0HGBA8LQccEDwtByAQPC0HJBA8LQcoEDwtBywQPC0GABg8LQYEGDwtBggYPC0GDBg8LQYQGDwtBhwYPC0GIBg8LQYAIDwtBgQgPC0GACg8LQYEKDwtBggoPC0GDCg8LQYQKIQELIAEPC0HggsAAQRkQ2AEAC/gDAQJ/IAAgAWohAgJAAkAgACgCBCIDQQFxDQAgA0ECcUUNASAAKAIAIgMgAWohASAAIANrIgBB8I7AACgCAEYEQCACKAIEQQNxQQNHDQFB6I7AACABNgIAIAIgAigCBEF+cTYCBCAAIAFBAXI2AgQgAiABNgIADAILIAAgAxAECwJAAkACQCACKAIEIgNBAnFFBEAgAkH0jsAAKAIARg0CIAJB8I7AACgCAEYNAyACIANBeHEiAhAEIAAgASACaiIBQQFyNgIEIAAgAWogATYCACAAQfCOwAAoAgBHDQFB6I7AACABNgIADwsgAiADQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgALIAFBgAJPBEAgACABEAUPCyABQXhxQdiMwABqIQICf0HgjsAAKAIAIgNBASABQQN2dCIBcUUEQEHgjsAAIAEgA3I2AgAgAgwBCyACKAIICyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCA8LQfSOwAAgADYCAEHsjsAAQeyOwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEHwjsAAKAIARw0BQeiOwABBADYCAEHwjsAAQQA2AgAPC0HwjsAAIAA2AgBB6I7AAEHojsAAKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsL8QIBBH8gACgCDCECAkACQCABQYACTwRAIAAoAhghAwJAAkAgACACRgRAIABBFEEQIAAoAhQiAhtqKAIAIgENAUEAIQIMAgsgACgCCCIBIAI2AgwgAiABNgIIDAELIABBFGogAEEQaiACGyEEA0AgBCEFIAEiAkEUaiACQRBqIAIoAhQiARshBCACQRRBECABG2ooAgAiAQ0ACyAFQQA2AgALIANFDQIgACAAKAIcQQJ0QciLwABqIgEoAgBHBEAgA0EQQRQgAygCECAARhtqIAI2AgAgAkUNAwwCCyABIAI2AgAgAg0BQeSOwABB5I7AACgCAEF+IAAoAhx3cTYCAAwCCyAAKAIIIgAgAkcEQCAAIAI2AgwgAiAANgIIDwtB4I7AAEHgjsAAKAIAQX4gAUEDdndxNgIADwsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIAAoAhQiAEUNACACIAA2AhQgACACNgIYCwu6AgEEf0EfIQIgAEIANwIQIAFB////B00EQCABQQYgAUEIdmciA2t2QQFxIANBAXRrQT5qIQILIAAgAjYCHCACQQJ0QciLwABqIQRBASACdCIDQeSOwAAoAgBxRQRAIAQgADYCACAAIAQ2AhggACAANgIMIAAgADYCCEHkjsAAQeSOwAAoAgAgA3I2AgAPCwJAAkAgASAEKAIAIgMoAgRBeHFGBEAgAyECDAELIAFBGSACQQF2a0EAIAJBH0cbdCEFA0AgAyAFQR12QQRxakEQaiIEKAIAIgJFDQIgBUEBdCEFIAIhAyACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAE2AggPCyAEIAA2AgAgACADNgIYIAAgADYCDCAAIAA2AggLlAEBBH8gARDQASABQQhrIgMgAygCAEEBaiICNgIAAkACQCACBEAgASgCACICQX9GDQEgASACQQFqNgIAIAEoAgQoAAAiBMBBAnRBuIPAAGooAgAhBUEBQQQQ0wEiAg0CCwALENcBAAsgAiAFIARBgH5xcjYAACABIAEoAgBBAWs2AgAgAxBWIABBBDYCBCAAIAI2AgALiwEBAn8gABDQASAAQQhrIgIoAgAhAwJAAkAgAUUEQCADQQFGBEAgAkEANgIAIAJBf0YNAyAAQQRrIgAgACgCAEEBayIANgIAIABFDQIMAwtB+YLAAEE/ENgBAAsgAiADQQFrIgE2AgAgAQ0BIABBBGsiACAAKAIAQQFrIgA2AgAgAA0BCyACQRAQGQsLdQIBfwF+IAEQ0AEgAUEIayICKAIAQQFGBEAgATUCBCEDIAJBADYCAAJAIAJBf0YNACABQQRrIgEgASgCAEEBayIBNgIAIAENACACQRAQGQsgACADQgGDPAAAIAAgA6dBCHZBAXE6AAEPC0H5gsAAQT8Q2AEAC3cBAn8jAEEQayIBJAAgAUEEaiAAEBwgASgCBCIALwAAIABBAmotAABBEHRyENwBIQIgASgCCCABKAIMEMsBQRBBBBDGASIAIAJBCHZBgB5xIAJBGHZyOwEMIABBADYCCCAAQoGAgIAQNwIAIAFBEGokACAAQQhqC2wBAn8gABDQASAAQQhrIgEgASgCAEEBaiICNgIAAkAgAgRAIAAoAgBBf0YNASAALwAEIABBBmotAABBEHRyENwBIQAgARBeIABBCHZBgP4DcSAAQRh2ciAAQYD+A3FBCHRyEGgPCwALENcBAAtvAQJ/IAEQ0AEgAUEIayICKAIAQQFGBEAgASgCBCEDIAJBADYCAAJAIAJBf0YNACABQQRrIgEgASgCAEEBayIBNgIAIAENACACQRAQGQsgACADQQh2OgABIAAgA0EBcToAAA8LQfmCwABBPxDYAQALawEBfyAAENABIABBCGshAgJAIAFFBEAgAigCAEEBRw0BIAAoAgQgAkEANgIAAkAgAkF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAJBEBAZCxDbAQ8LIAIQVg8LQfmCwABBPxDYAQALYQEBfyMAQRBrIgEkACABQQRqIAAQHCABKAIEIgAvAAAgAEECai0AAEEQdHIQ3AEhACABKAIIIAEoAgwQywEgAEEIdkGA/gNxIABBGHZyIABBgAZxQQh0chBoIAFBEGokAAtqAQF/IwBBMGsiASQAIAEgADoADyAAQf8BcUHAAE8EQCABQQI2AhQgAUH0gMAANgIQIAFCATcCHCABQQE2AiwgASABQShqNgIYIAEgAUEPajYCKCABQRBqQYSBwAAQVwALIAFBMGokACAAC2sBAX8jAEEwayIBJAAgASAAOwEOIABB//8DcUGAIE8EQCABQQI2AhQgAUG4gcAANgIQIAFCATcCHCABQQI2AiwgASABQShqNgIYIAEgAUEOajYCKCABQRBqQciBwAAQVwALIAFBMGokACAAC2MBAn8jAEEQayICJAACQCABRQRAIAJBCGogABALDAELIAAQ0AEgAEEIayIBIAEoAgBBAWsiAzYCACADDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEQEBkLIAJBEGokAAtjAQJ/IwBBEGsiAiQAAkAgAUUEQCACQQhqIAAQCAwBCyAAENABIABBCGsiASABKAIAQQFrIgM2AgAgAw0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBAZCyACQRBqJAALXgEBfyMAQRBrIgEkACABQQRqIAAQHCABKAIEIgAvAAAgAEECai0AAEEQdHIQ3AEhACABKAIIIAEoAgwQywEgAEEIdkGA4ANxIABBgAZxQQh0ckEMdhBnIAFBEGokAAsVACAAQYyCwABB/IHAAEGAgBAQ9gELFgAgAEHQgsAAQcCCwABBgICACBD2AQtgAQF/IAAQGyECIAEQHiEAQRBBBBDGASIBQoGAgIAQNwIAIAEgAEEQdEGAgPwHcSAAIAJB/wFxQRJ0ciIAQYD+A3FBCHQgAEEIdkGA/gNxckEIdnKtQiCGNwIIIAFBCGoLXAECfyAAENABIABBCGsiASgCAEEBRgRAIAAtAAQgAUEANgIAAkAgAUF/Rg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBAZC0EBcQ8LQfmCwABBPxDYAQALYAEBfyAAENABIABBCGshAgJAIAFFBEAgAigCAEEBRgRAIAJBADYCACACQX9GDQIgAEEEayIAIAAoAgBBAWsiADYCACAADQIgAkEUEBkPC0H5gsAAQT8Q2AEACyACEF8LC2ABAX8gABDQASAAQQhrIQICQCABRQRAIAIoAgBBAUYEQCACQQA2AgAgAkF/Rg0CIABBBGsiACAAKAIAQQFrIgA2AgAgAA0CIAJBEBAZDwtB+YLAAEE/ENgBAAsgAhBeCwvQBgEEfwJAIABBBGsoAgAiBCICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgAEEIayIBIAQiA0F4cSIAaiECAkACQCADQQFxDQAgA0ECcUUNASABKAIAIgMgAGohACABIANrIgFB8I7AACgCAEYEQCACKAIEQQNxQQNHDQFB6I7AACAANgIAIAIgAigCBEF+cTYCBCABIABBAXI2AgQgAiAANgIADAILIAEgAxAECwJAAkACQAJAIAIoAgQiA0ECcUUEQCACQfSOwAAoAgBGDQIgAkHwjsAAKAIARg0EIAIgA0F4cSICEAQgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFB8I7AACgCAEcNAUHojsAAIAA2AgAMBQsgAiADQX5xNgIEIAEgAEEBcjYCBCAAIAFqIAA2AgALIABBgAJJDQEgASAAEAVBACEBQYiPwABBiI/AACgCAEEBayIANgIAIAANA0HQjMAAKAIAIgAEQANAIAFBAWohASAAKAIIIgANAAsLQYiPwABB/x8gASABQf8fTRs2AgAMAwtB9I7AACABNgIAQeyOwABB7I7AACgCACAAaiIANgIAIAEgAEEBcjYCBEHwjsAAKAIAIAFGBEBB6I7AAEEANgIAQfCOwABBADYCAAsgAEGAj8AAKAIAIgNNDQJB9I7AACgCACICRQ0CQQAhAQJAQeyOwAAoAgAiBEEpSQ0AQciMwAAhAANAIAIgACgCACIFTwRAIAUgACgCBGogAksNAgsgACgCCCIADQALC0HQjMAAKAIAIgAEQANAIAFBAWohASAAKAIIIgANAAsLQYiPwABB/x8gASABQf8fTRs2AgAgAyAETw0CQYCPwABBfzYCAAwCCyAAQXhxQdiMwABqIQICf0HgjsAAKAIAIgNBASAAQQN2dCIAcUUEQEHgjsAAIAAgA3I2AgAgAgwBCyACKAIICyEAIAIgATYCCCAAIAE2AgwgASACNgIMIAEgADYCCAwBC0HwjsAAIAE2AgBB6I7AAEHojsAAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAsPC0GpicAAQS5B2InAABBKAAtB6InAAEEuQZiKwAAQSgALVQEBfyMAQRBrIgEkACABQQRqIAAQHCABKAIEIgAvAAAgAEECai0AAEEQdHIQ3AEhACABKAIIIAEoAgwQywEgAEEOdkE8cSAAQR52chBnIAFBEGokAAtZAQJ/IAAQ0AEgAEEIayIBKAIAQQFGBEAgAC0ABCABQQA2AgACQCABQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEQEBkLDwtB+YLAAEE/ENgBAAtZAQJ/IAEQ0AEgAUEIayIDIAMoAgBBAWoiAjYCAAJAIAIEQCABKAIAIgJBf0YNASAAIAM2AgggACABNgIEIAAgAUEEajYCACABIAJBAWo2AgAPCwALENcBAAtZAQJ/IAAQ0AEgAEEIayIBKAIAQQFGBEAgAC8BBCABQQA2AgACQCABQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEQEBkLDwtB+YLAAEE/ENgBAAtZAQJ/IAAQ0AEgAEEIayIBKAIAQQFGBEAgACgCBCABQQA2AgACQCABQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEQEBkLDwtB+YLAAEE/ENgBAAtRAQJ/AkAgABAbIgBBGHENACAAQQdxIgJBB0YNAEEQQQQQxgEiAUKBgICAEDcCACABIABBBXZBAXGtQiCGIAKtQiiGhDcCCCABQQhqIQELIAELVwEBfyAAEBshAiABEBshAUEQQQQQxgEiAEKBgICAEDcCACAAIAFB/wFxQQx0IAJBEnRyIgFBgOADcUEIdCABQQh2QYD+A3FyQQh2rUIghjcCCCAAQQhqC0wAIANB/wFxIAFB/wFxQQx0IABB/wFxQRJ0ciIAIAJB/wFxQQZ0cnIiAUEQdEGAgPwHcSAAQQh2QYD+A3EgAUGA/gNxQQh0ckEIdnILTwECfyAAENABIABBCGsiASABKAIAQQFqIgI2AgACQCACBEAgACgCAEF/Rg0BIAAvAAQgAEEGai0AAEEQdHIQ1AEgARBeEGcPCwALENcBAAtOAQF/IAFFBEAgABAWGg8LIAAQ0AEgAEEIayIBIAEoAgBBAWsiAjYCAAJAIAINACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQRAQGQsLEAAgACABIAIgA0HeABD3AQsQACAAIAEgAiADQd8AEPcBCxAAIAAgASACIANB4AAQ9wELEAAgACABIAIgA0HhABD3AQsQACAAIAEgAiADQeIAEPgBCxAAIAAgASACIANB4wAQ+AELTgEBfyABRQRAIAAQGxoPCyAAENABIABBCGsiASABKAIAQQFrIgI2AgACQCACDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEQEBkLC04BAX8gAUUEQCAAEB0aDwsgABDQASAAQQhrIgEgASgCAEEBayICNgIAAkAgAg0AIABBBGsiACAAKAIAQQFrIgA2AgAgAA0AIAFBEBAZCwtOAQF/IAFFBEAgABAeGg8LIAAQ0AEgAEEIayIBIAEoAgBBAWsiAjYCAAJAIAINACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQRAQGQsLDwAgACABQYCAgMgBEPkBCwwAIAAgAUHLABD6AQsMACAAIAFBzAAQ+gELDAAgACABQc0AEPoBCwwAIAAgAUHOABD6AQsMACAAIAFBzwAQ+gELDAAgACABQdAAEPoBCw8AIAAgAUGAgIDoBhD5AQtFAQF/IwBBEGsiASQAIAFBBGogABAcIAEoAgQiAC8AACAAQQJqLQAAQRB0chDUASABKAIIIAEoAgwQywEQZyABQRBqJAALSwEBfyMAQRBrIgEkACABQQRqIAAQHCABKAIEIgAvAAAgAEECai0AAEEQdHIQ3AFBGHZBP3EgASgCCCABKAIMEMsBEGcgAUEQaiQAC04BAX8gABAeIQBBEEEEEMYBIgFCgYCAgBA3AgAgASAAQRB0QYCA/AdxIABBCHZBgP4DcSAAQYD+A3FBCHRyQQh2cq1CIIY3AgggAUEIagsLACAAIAFBBxD7AQsLACAAIAFBCBD7AQs/ACACQRZ0QYCAgAZxIAFB/wFxQQx0IgEgAkH8AXFBBnRyQYD+A3FBCHQgASAAQRJ0ckEIdkGA/gNxckEIdnILOAEBfyMAQRBrIgQkACAAEBsgARAbIAIQGyAEQQhqIAMQCyAELQAIIAQtAAkQyAEQYiAEQRBqJAALOAEBfyMAQRBrIgQkACAAEBsgARAbIAIQGyAEQQhqIAMQCCAELQAIIAQtAAkQiQEQYiAEQRBqJAALCwAgACABQQoQ/AELCwAgACABQQwQ/AELCwAgACABQRQQ/AELCwAgACABQRYQ/AELCwAgACABQRsQ/AELCwAgACABQR4Q/AELCwAgACABQR8Q/AELCwAgACABQSQQ/AELCwAgACABQTIQ/AELPgAgABAbIQAgARAeIgFBEHRBgID8B3EgAEH/AXFBEnQgAXIiAEGA/gNxQQh0IABBCHZBgP4DcXJBCHZyEGILOAAgAkEQdEGAgPwHcSABQf8BcUEMdCIBIAJyQYD+A3FBCHQgASAAQRJ0ckEIdkGA/gNxckEIdnILPAECfyMAQRBrIgEkACAAENABIAFBCGogABBdIAEoAggtAAEgASgCDCICIAIoAgBBAWs2AgAgAUEQaiQACzwBAn8jAEEQayIBJAAgABDQASABQQhqIAAQXSABKAIILQAAIAEoAgwiAiACKAIAQQFrNgIAIAFBEGokAAtBAQF/IwBBIGsiAyQAIANBADYCECADQQE2AgQgA0IENwIIIAMgATYCHCADIAA2AhggAyADQRhqNgIAIAMgAhBXAAs5AQF/IwBBEGsiAiQAIAAQ0AEgAkEIaiAAEGEgAigCDCACKAIIIAFBAEc6AABBADYCACACQRBqJAALOQEBfyMAQRBrIgIkACAAENABIAJBCGogABBhIAIoAgwgAigCCCABQQBHOgABQQA2AgAgAkEQaiQAC0MBAX8gAEE5TwRAQeCCwABBGRDYAQALQRRBBBDGASICIAA6ABAgAiABNgIMIAJBADYCCCACQoGAgIAQNwIAIAJBCGoLCgAgAEHVABD9AQsKACAAQdYAEP0BCwoAIABB1wAQ/QELCgAgAEHaABD9AQsKACAAQdsAEP0BCwoAIABB3AAQ/QELCgAgAEHdABD9AQs+ACAAEBsgARAbIAIQGyADEBsQISEBQRBBBBDGASIAQoGAgIAQNwIAIAAgAa1C////B4NCIIY3AgggAEEIags7AQF/IAAgACgCAEEBayIBNgIAAkAgAQ0AIAAoAgwQ2wEgACAAKAIEQQFrIgE2AgQgAQ0AIABBEBAZCwvIAQEBfyMAQSBrIgIkACACQQE7ARwgAiABNgIYIAIgADYCFCACQaiHwAA2AhAgAkEBNgIMIAJBDGoiACgCCCIBRQRAQfyGwABBK0HEisAAEEoACyABKAIMGiABKAIEGiAALQAQIQEgAC0AERpBxIvAAEHEi8AAKAIAIgBBAWo2AgACQCAAQQBIDQBBkI/AAC0AAEEBcQ0AQYyPwABBjI/AACgCAEEBajYCAEHAi8AAKAIAQQBIDQBBkI/AAEEAOgAAIAFFDQAACwALLwEBfyMAQRBrIgEkACABQQhqIAAQCyABLQAJQSBBACABLQAIG3IQZyABQRBqJAALOgAgABAbIAEQGyACEBsQOiEBQRBBBBDGASIAQoGAgIAQNwIAIAAgAa1C////B4NCIIY3AgggAEEIags6ACAAEBsgARAbIAIQHRBHIQFBEEEEEMYBIgBCgYCAgBA3AgAgACABrUL///8Hg0IghjcCCCAAQQhqCzIBAX8jAEEQayIBJAAgAUEEaiAAEBwgASgCBC0ABCABKAIIIAEoAgwQzAEgAUEQaiQACzIBAX8jAEEQayIBJAAgAUEEaiAAEBwgASgCBCgCACABKAIIIAEoAgwQzAEgAUEQaiQACzEBAX8gASgCACICQX9HBEAgASACQQFqNgIAIAAgATYCBCAAIAFBBGo2AgAPCxDXAQALCQAgAEEQEPABCwkAIABBFBDwAQszAQF/IAAQGyEBQRBBBBDGASIAQoGAgIAQNwIAIAAgAUECdEH8AXGtQiCGNwIIIABBCGoLKAAgASgCAEUEQCABQX82AgAgACABNgIEIAAgAUEEajYCAA8LENcBAAssAQF/QRBBBBDGASIBQoGAgIAQNwIAIAEgAK1C////B4NCIIY3AgggAUEIagskACAAENABIAAoAgAEQBDXAQALIABBADYCACAAIAFBAEc6AAQLKAAgAxAWIQMgABDHASABEMcBIAIQxwEgAxDOAUEIdEHkAHIQ0QEQaAsoACADEBYhAyAAEMcBIAEQxwEgAhDHASADEM4BQQh0QeUAchDRARBoCyAAIABBAWsiAEEFTQRAIABBAWoPC0HggsAAQRkQ2AEACykBAX9BEEEEEMYBIgEgADoADCABQQA2AgggAUKBgICAEDcCACABQQhqCykBAX9BEEEEEMYBIgEgADYCDCABQQA2AgggAUKBgICAEDcCACABQQhqCyIAIAIQAiECIAAQxwEgARDHASACEEdBCHRBygByENEBEGgLDwAgACABIAIgA0ESEPEBCw8AIAAgASACIANBGBDxAQsPACAAIAEgAiADQRwQ8QELDwAgACABIAIgA0EdEPEBCw8AIAAgASACIANBIRDyAQsPACAAIAEgAiADQSIQ8QELDwAgACABIAIgA0EjEPEBCw8AIAAgASACIANBKBDxAQsPACAAIAEgAiADQSoQ8QELDwAgACABIAIgA0EsEPEBCw8AIAAgASACIANBLxDxAQsPACAAIAEgAiADQTgQ8QELEAAgACABIAIgA0HTABDyAQsQACAAIAEgAiADQdQAEPIBCxAAIAAgASACIANB3gAQ8gELEAAgACABIAIgA0HfABDyAQsQACAAIAEgAiADQeAAEPIBCxAAIAAgASACIANB4QAQ8gELEAAgACABIAIgA0HiABDyAQsQACAAIAEgAiADQeMAEPIBCxAAIAAgASACIANB5AAQ8gELEAAgACABIAIgA0HlABDyAQsQACAAIAEgAiADQeYAEPEBCxAAIAAgASACIANB5wAQ8QELEAAgACABIAIgA0HoABDxAQsQACAAIAEgAiADQekAEPEBCxAAIAAgASACIANB6gAQ8QELEAAgACABIAIgA0HrABDxAQsQACAAIAEgAiADQewAEPEBCxAAIAAgASACIANB7gAQ8QELHgAgARBmIQEgABDHASABEMQBQQh0QcwAchDRARBoCxkAIAAgASACQSBBACAEG0EQQQAgAxtyECELDQAgACABIAJBARDzAQsNACAAIAEgAkECEPMBCw0AIAAgASACQQMQ8wELDQAgACABIAJBBBDzAQsNACAAIAEgAkEFEPMBCw0AIAAgASACQQYQ8wELDQAgACABIAJBBxDzAQsNACAAIAEgAkEIEPMBCw0AIAAgASACQQkQ8wELDQAgACABIAJBCxDzAQsNACAAIAEgAkENEPMBCw0AIAAgASACQQ4Q8wELDQAgACABIAJBDxDzAQsNACAAIAEgAkEQEPMBCw0AIAAgASACQREQ8wELDQAgACABIAJBFxDzAQsNACAAIAEgAkEmEPMBCw0AIAAgASACQScQ8wELDQAgACABIAJBKRDzAQsNACAAIAEgAkErEPMBCw0AIAAgASACQS0Q8wELDQAgACABIAJBLhDzAQsNACAAIAEgAkEwEPMBCw0AIAAgASACQTEQ8wELDQAgACABIAJBNRDzAQsNACAAIAEgAkE3EPMBCw0AIAAgASACQTkQ9AELDQAgACABIAJBOhD0AQsNACAAIAEgAkE7EPQBCw0AIAAgASACQTwQ9AELDQAgACABIAJBPRD0AQsNACAAIAEgAkE+EPQBCw0AIAAgASACQT8Q9AELDgAgACABIAJBwAAQ9AELDgAgACABIAJBwQAQ9AELDgAgACABIAJBwgAQ9AELDgAgACABIAJBwwAQ9AELDgAgACABIAJBxAAQ9AELDgAgACABIAJBxQAQ9AELDgAgACABIAJBxgAQ9AELDgAgACABIAJBxwAQ9AELDgAgACABIAJByAAQ9AELDgAgACABIAJByQAQ9AELDgAgACABIAJBygAQ9AELDgAgACABIAJB0QAQ9AELDgAgACABIAJB0gAQ9AELFwEBfyAAQf8BcUE/TQR/IAAQZwVBAAsLGwAgABDQASAAKAIAQX9GBEAQ1wEACyAALQAECwkAIABBExD1AQsJACAAQRUQ9QELCQAgAEEaEPUBCwkAIABBIBD1AQsJACAAQSUQ9QELIgEBf0EQQQQQxgEiAEIANwIIIABCgYCAgBA3AgAgAEEIagsJACAAQTQQ9QELCQAgAEE2EPUBCwoAIABB2AAQ9QELCgAgAEHZABD1AQsXACABQRB0QYCA/ANxIABBAnRB/AFxcgsbACAAEMcBIAEQxwEgAhDHARA6QQh0ENEBEGgLEgAgASAAENMBIgAEQCAADwsAC3UBAX8gAEH/AXFBwABPBEAjAEEQayIBJAAgAUEiNgIMIAFBgIDAADYCCCMAQSBrIgAkACAAQQE2AgQgAEH0hsAANgIAIABCATcCDCAAIAFBCGqtQoCAgIDAAIQ3AxggACAAQRhqNgIIIABBuIDAABBXAAsgAAsUACAAIAEgAkEgQQAgAxsgBHIQIQsXACAAEBsgARAbIAIQGyADEBYQzgEQYgsWACAAEBsgARAbIAIQGyADEBsQIRBiCxMAIAAgACgCAEEBazYCACABEF4LEwAgACAAKAIAQQFrNgIAIAEQXwsSACAAEBsgARAbIAIQAhBHEGILEQAgACABIAJBIEEAIAMbECELEgAgABAbIAEQGyACEB0QRxBiCxMAIAAEQA8LQdSKwABBGxDYAQALFAEBf0EEQQEQxgEiASAANgAAIAELDQAgAQRAIAAgARAZCwuBAwEFf0GRj8AALQAAGgJ/IABBCU8EQAJAQc3/e0EQIAAgAEEQTRsiAGsgAU0NACAAQRAgAUELakF4cSABQQtJGyIEakEMahABIgJFDQAgAkEIayEBAkAgAEEBayIDIAJxRQRAIAEhAAwBCyACQQRrIgUoAgAiBkF4cSACIANqQQAgAGtxQQhrIgIgAEEAIAIgAWtBEE0baiIAIAFrIgJrIQMgBkEDcQRAIAAgAyAAKAIEQQFxckECcjYCBCAAIANqIgMgAygCBEEBcjYCBCAFIAIgBSgCAEEBcXJBAnI2AgAgASACaiIDIAMoAgRBAXI2AgQgASACEAMMAQsgASgCACEBIAAgAzYCBCAAIAEgAmo2AgALAkAgACgCBCIBQQNxRQ0AIAFBeHEiAiAEQRBqTQ0AIAAgBCABQQFxckECcjYCBCAAIARqIgEgAiAEayIEQQNyNgIEIAAgAmoiAiACKAIEQQFyNgIEIAEgBBADCyAAQQhqIQMLIAMMAQsgARABCwsNACAAENwBQQp2QT9xCw8AIAAQGyABEGYQxAEQYgsLACAAIwBqJAAjAAsOAEHvisAAQc8AENgBAAsJACAAIAEQAAALCQAgAEE/cRBnCwoAIAAQG0H/AXELCAAgAEEEEBkLBwAgAEEIdAsJAEEzENEBEGgLBgBBCxBnCwYAQQoQZwsGAEEIEGcLBgBBDxBnCwYAQQYQZwsGAEEJEGcLBgBBBxBnCwYAQQwQZwsGAEECEGcLBgBBARBnCwYAQQMQZwsGAEENEGcLBgBBDhBnCwYAQQUQZwsGAEEEEGcLBgBBEBBnCwYAQQAQZwsEAEEECzMBAX8gACAAKAIAQQFrIgI2AgACQCACDQAgACAAKAIEQQFrIgI2AgQgAg0AIAAgARAZCwsjACAAEMcBIAEQxwEgAhDHASADEMcBECFBCHQgBHIQ0QEQaAsiACAAEMcBIAEQxwEgAhDHASADEA4QIUEIdCAEchDRARBoCx4AIAAQxwEgARDHASACEMcBEDpBCHQgA3IQ0QEQaAsdACAAEMcBIAEQxwEgAhAPEEdBCHQgA3IQ0QEQaAsaACAAEMcBGiAAQQp0QYD4A3EgAXIQ0QEQaAtfAQF/IwBBMGsiBCQAIAQgADYCDCAAIANPBEAgBEECNgIUIAQgAjYCECAEQgE3AhwgBEEDNgIsIAQgBEEoajYCGCAEIARBDGo2AiggBEEQaiABEFcACyAEQTBqJAAgAAtMAQJ/IwBBEGsiBSQAIAVBCGogAxALIAUtAAkhAyAFLQAIIQYgABDHASABEMcBIAIQxwEgBiADEMgBQQh0IARyENEBEGggBUEQaiQAC0wBAn8jAEEQayIFJAAgBUEIaiADEAggBS0ACSEDIAUtAAghBiAAEMcBIAEQxwEgAhDHASAGIAMQiQFBCHQgBHIQ0QEQaCAFQRBqJAALSQAgABDHARogARDHARogAEESdEGAgPAXcSIAIAFBDHRBgOA/cXIiAUGA4ANxQQh0IAFBCHZBgP4DcSAAIAJyQRh2cnIQ0QEQaAtJACAAEMcBGiABEBMiAUEQdEGAgPwHcSAAQRJ0QYCA8B9xIAFyIgBBgP4DcUEIdCAAQQh2QYD+A3FyQQh2ckEIdCACchDRARBoC0kBAX8jAEEQayIDJAAgABDQASABIAJPBEBB4ILAAEEZENgBAAsgA0EIaiAAEGEgAygCDCADKAIIIAE6AAFBADYCACADQRBqJAALQQAgABDHARogARDHARogAEESdEGAgPAHcSABQQx0QYDgP3FyIgBBCHZBgP4DcSAAQYDgA3FBCHRyIAJyENEBEGgLNQAgABAUIgBBEHRBgID8B3EgAEEIdkGA/gNxIABBgP4DcUEIdHJBCHZyQQh0IAFyENEBEGgLC8gLAQBBgIDAAAu+C0NoZWNrUmVnSWQgd2FzIGdpdmVuIGludmFsaWQgUmVnSWRmdWVsLWFzbS9zcmMvbGliLnJzAAAAIgAQABMAAABuAAAAIgAAAFZhbHVlIGBgIG91dCBvZiByYW5nZSBmb3IgNi1iaXQgaW1tZWRpYXRlAAAASAAQAAcAAABPABAAIgAAACIAEAATAAAAsAMAABwAAABgIG91dCBvZiByYW5nZSBmb3IgMTItYml0IGltbWVkaWF0ZQBIABAABwAAAJQAEAAjAAAAIgAQABMAAAC1AwAAHAAAAGAgb3V0IG9mIHJhbmdlIGZvciAxOC1iaXQgaW1tZWRpYXRlAEgAEAAHAAAA2AAQACMAAAAiABAAEwAAALoDAAAcAAAAYCBvdXQgb2YgcmFuZ2UgZm9yIDI0LWJpdCBpbW1lZGlhdGUASAAQAAcAAAAcARAAIwAAACIAEAATAAAAvwMAABwAAABpbnZhbGlkIGVudW0gdmFsdWUgcGFzc2VkYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAQQAAAEIAAABDAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAAUAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAFoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAABhAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAJAAAACRAAAAkgAAAJMAAACUAAAAlQAAAJYAAACXAAAAmAAAAKAAAAChAAAAogAAAKMAAACkAAAApQAAAKYAAACnAAAAqAAAAKkAAACqAAAAqwAAAKwAAACtAAAAsAAAALoAAAC7AAAAAQAAAAAAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAAUAAAAAAAAAAQAAAAYAAAAwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OS9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZACABBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAgAQQACkAAACuBAAADQAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnMoBRAAHAAAAIsCAAAeAAAAbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAA7CXByb2R1Y2VycwEMcHJvY2Vzc2VkLWJ5AgZ3YWxydXMGMC4yMS4zDHdhc20tYmluZGdlbgYwLjIuOTM=", imports);
      }
      async function initWasm4() {
        return await __wbg_init(wasm());
      }
      initWasm4();
      exports.ADD = ADD;
      exports.ADDI = ADDI;
      exports.ALOC = ALOC;
      exports.AND = AND;
      exports.ANDI = ANDI;
      exports.BAL = BAL;
      exports.BHEI = BHEI;
      exports.BHSH = BHSH;
      exports.BLDD = BLDD;
      exports.BSIZ = BSIZ;
      exports.BURN = BURN;
      exports.CALL = CALL;
      exports.CB = CB;
      exports.CCP = CCP;
      exports.CFE = CFE;
      exports.CFEI = CFEI;
      exports.CFS = CFS;
      exports.CFSI = CFSI;
      exports.CROO = CROO;
      exports.CSIZ = CSIZ;
      exports.CompareArgs = CompareArgs;
      exports.CompareMode = CompareMode;
      exports.DIV = DIV;
      exports.DIVI = DIVI;
      exports.DivArgs = DivArgs;
      exports.ECAL = ECAL;
      exports.ECK1 = ECK1;
      exports.ECR1 = ECR1;
      exports.ED19 = ED19;
      exports.EQ = EQ;
      exports.EXP = EXP;
      exports.EXPI = EXPI;
      exports.FLAG = FLAG;
      exports.GM = GM;
      exports.GMArgs = GMArgs;
      exports.GT = GT;
      exports.GTF = GTF;
      exports.GTFArgs = GTFArgs3;
      exports.Imm06 = Imm06;
      exports.Imm12 = Imm12;
      exports.Imm18 = Imm18;
      exports.Imm24 = Imm24;
      exports.Instruction = Instruction2;
      exports.JI = JI;
      exports.JMP = JMP;
      exports.JMPB = JMPB;
      exports.JMPF = JMPF;
      exports.JNE = JNE;
      exports.JNEB = JNEB;
      exports.JNEF = JNEF;
      exports.JNEI = JNEI;
      exports.JNZB = JNZB;
      exports.JNZF = JNZF;
      exports.JNZI = JNZI;
      exports.K256 = K256;
      exports.LB = LB;
      exports.LDC = LDC;
      exports.LOG = LOG;
      exports.LOGD = LOGD;
      exports.LT = LT;
      exports.LW = LW;
      exports.MCL = MCL;
      exports.MCLI = MCLI;
      exports.MCP = MCP;
      exports.MCPI = MCPI;
      exports.MEQ = MEQ;
      exports.MINT = MINT;
      exports.MLDV = MLDV;
      exports.MLOG = MLOG;
      exports.MOD = MOD;
      exports.MODI = MODI;
      exports.MOVE = MOVE;
      exports.MOVI = MOVI;
      exports.MROO = MROO;
      exports.MUL = MUL;
      exports.MULI = MULI;
      exports.MathArgs = MathArgs;
      exports.MathOp = MathOp;
      exports.MulArgs = MulArgs;
      exports.NOOP = NOOP;
      exports.NOT = NOT;
      exports.OR = OR;
      exports.ORI = ORI;
      exports.POPH = POPH;
      exports.POPL = POPL;
      exports.PSHH = PSHH;
      exports.PSHL = PSHL;
      exports.PanicInstruction = PanicInstruction;
      exports.PanicReason = PanicReason;
      exports.RET = RET;
      exports.RETD = RETD;
      exports.RVRT = RVRT;
      exports.RegId = RegId2;
      exports.S256 = S256;
      exports.SB = SB;
      exports.SCWQ = SCWQ;
      exports.SLL = SLL;
      exports.SLLI = SLLI;
      exports.SMO = SMO;
      exports.SRL = SRL;
      exports.SRLI = SRLI;
      exports.SRW = SRW;
      exports.SRWQ = SRWQ;
      exports.SUB = SUB;
      exports.SUBI = SUBI;
      exports.SW = SW;
      exports.SWW = SWW;
      exports.SWWQ = SWWQ;
      exports.TIME = TIME;
      exports.TR = TR;
      exports.TRO = TRO;
      exports.WDAM = WDAM;
      exports.WDCM = WDCM;
      exports.WDDV = WDDV;
      exports.WDMD = WDMD;
      exports.WDML = WDML;
      exports.WDMM = WDMM;
      exports.WDOP = WDOP;
      exports.WQAM = WQAM;
      exports.WQCM = WQCM;
      exports.WQDV = WQDV;
      exports.WQMD = WQMD;
      exports.WQML = WQML;
      exports.WQMM = WQMM;
      exports.WQOP = WQOP;
      exports.XOR = XOR;
      exports.XORI = XORI;
      exports.add = add;
      exports.addi = addi5;
      exports.aloc = aloc;
      exports.and = and;
      exports.andi = andi;
      exports.bal = bal;
      exports.bhei = bhei;
      exports.bhsh = bhsh;
      exports.bldd = bldd;
      exports.bsiz = bsiz3;
      exports.burn = burn;
      exports.call = call2;
      exports.cb = cb;
      exports.ccp = ccp;
      exports.cfe = cfe;
      exports.cfei = cfei;
      exports.cfs = cfs;
      exports.cfsi = cfsi;
      exports.croo = croo;
      exports.csiz = csiz;
      exports.div = div;
      exports.divi = divi3;
      exports.ecal = ecal;
      exports.eck1 = eck1;
      exports.ecr1 = ecr1;
      exports.ed19 = ed19;
      exports.eq = eq3;
      exports.exp = exp;
      exports.expi = expi;
      exports.flag = flag;
      exports.gm = gm;
      exports.gm_args = gm_args;
      exports.gt = gt3;
      exports.gtf = gtf3;
      exports.gtf_args = gtf_args;
      exports.initSync = initSync;
      exports.initWasm = initWasm4;
      exports.ji = ji;
      exports.jmp = jmp3;
      exports.jmpb = jmpb;
      exports.jmpf = jmpf;
      exports.jne = jne;
      exports.jneb = jneb;
      exports.jnef = jnef;
      exports.jnei = jnei;
      exports.jnzb = jnzb2;
      exports.jnzf = jnzf;
      exports.jnzi = jnzi;
      exports.k256 = k256;
      exports.lb = lb;
      exports.ldc = ldc3;
      exports.log = log4;
      exports.logd = logd;
      exports.lt = lt;
      exports.lw = lw5;
      exports.mcl = mcl;
      exports.mcli = mcli;
      exports.mcp = mcp;
      exports.mcpi = mcpi;
      exports.meq = meq;
      exports.mint = mint;
      exports.mldv = mldv;
      exports.mlog = mlog;
      exports.mod_ = mod_;
      exports.modi = modi;
      exports.move_ = move_3;
      exports.movi = movi3;
      exports.mroo = mroo;
      exports.mul = mul;
      exports.muli = muli;
      exports.noop = noop;
      exports.not = not;
      exports.or = or;
      exports.ori = ori;
      exports.poph = poph;
      exports.popl = popl;
      exports.pshh = pshh;
      exports.pshl = pshl;
      exports.ret = ret4;
      exports.retd = retd;
      exports.rvrt = rvrt;
      exports.s256 = s256;
      exports.sb = sb;
      exports.scwq = scwq;
      exports.sll = sll;
      exports.slli = slli;
      exports.smo = smo;
      exports.srl = srl;
      exports.srli = srli;
      exports.srw = srw;
      exports.srwq = srwq;
      exports.sub = sub3;
      exports.subi = subi2;
      exports.sw = sw;
      exports.sww = sww;
      exports.swwq = swwq;
      exports.time = time;
      exports.tr = tr3;
      exports.tro = tro;
      exports.wdam = wdam;
      exports.wdcm = wdcm;
      exports.wdcm_args = wdcm_args;
      exports.wddv = wddv;
      exports.wddv_args = wddv_args;
      exports.wdmd = wdmd;
      exports.wdml = wdml;
      exports.wdml_args = wdml_args;
      exports.wdmm = wdmm;
      exports.wdop = wdop;
      exports.wdop_args = wdop_args;
      exports.wqam = wqam;
      exports.wqcm = wqcm;
      exports.wqcm_args = wqcm_args;
      exports.wqdv = wqdv;
      exports.wqdv_args = wqdv_args;
      exports.wqmd = wqmd;
      exports.wqml = wqml;
      exports.wqml_args = wqml_args;
      exports.wqmm = wqmm;
      exports.wqop = wqop;
      exports.wqop_args = wqop_args;
      exports.xor = xor;
      exports.xori = xori;
    }
  });

  // ../../node_modules/.pnpm/async@2.6.4/node_modules/async/dist/async.js
  var require_async = __commonJS({
    "../../node_modules/.pnpm/async@2.6.4/node_modules/async/dist/async.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = global2.async || {});
      })(exports, function(exports2) {
        "use strict";
        function slice(arrayLike, start) {
          start = start | 0;
          var newLen = Math.max(arrayLike.length - start, 0);
          var newArr = Array(newLen);
          for (var idx = 0; idx < newLen; idx++) {
            newArr[idx] = arrayLike[start + idx];
          }
          return newArr;
        }
        var apply = function(fn) {
          var args = slice(arguments, 1);
          return function() {
            var callArgs = slice(arguments);
            return fn.apply(null, args.concat(callArgs));
          };
        };
        var initialParams = function(fn) {
          return function() {
            var args = slice(arguments);
            var callback = args.pop();
            fn.call(this, args, callback);
          };
        };
        function isObject2(value) {
          var type3 = typeof value;
          return value != null && (type3 == "object" || type3 == "function");
        }
        var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
        var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
        function fallback(fn) {
          setTimeout(fn, 0);
        }
        function wrap3(defer2) {
          return function(fn) {
            var args = slice(arguments, 1);
            defer2(function() {
              fn.apply(null, args);
            });
          };
        }
        var _defer;
        if (hasSetImmediate) {
          _defer = setImmediate;
        } else if (hasNextTick) {
          _defer = process.nextTick;
        } else {
          _defer = fallback;
        }
        var setImmediate$1 = wrap3(_defer);
        function asyncify(func) {
          return initialParams(function(args, callback) {
            var result;
            try {
              result = func.apply(this, args);
            } catch (e) {
              return callback(e);
            }
            if (isObject2(result) && typeof result.then === "function") {
              result.then(function(value) {
                invokeCallback(callback, null, value);
              }, function(err2) {
                invokeCallback(callback, err2.message ? err2 : new Error(err2));
              });
            } else {
              callback(null, result);
            }
          });
        }
        function invokeCallback(callback, error3, value) {
          try {
            callback(error3, value);
          } catch (e) {
            setImmediate$1(rethrow, e);
          }
        }
        function rethrow(error3) {
          throw error3;
        }
        var supportsSymbol = typeof Symbol === "function";
        function isAsync(fn) {
          return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
        }
        function wrapAsync(asyncFn) {
          return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
        }
        function applyEach$1(eachfn) {
          return function(fns) {
            var args = slice(arguments, 1);
            var go = initialParams(function(args2, callback) {
              var that = this;
              return eachfn(fns, function(fn, cb) {
                wrapAsync(fn).apply(that, args2.concat(cb));
              }, callback);
            });
            if (args.length) {
              return go.apply(this, args);
            } else {
              return go;
            }
          };
        }
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var Symbol$1 = root.Symbol;
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
          try {
            value[symToStringTag$1] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag$1] = tag;
            } else {
              delete value[symToStringTag$1];
            }
          }
          return result;
        }
        var objectProto$1 = Object.prototype;
        var nativeObjectToString$1 = objectProto$1.toString;
        function objectToString(value) {
          return nativeObjectToString$1.call(value);
        }
        var nullTag = "[object Null]";
        var undefinedTag = "[object Undefined]";
        var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        var asyncTag = "[object AsyncFunction]";
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var proxyTag = "[object Proxy]";
        function isFunction(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        var MAX_SAFE_INTEGER = 9007199254740991;
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        var breakLoop = {};
        function noop() {
        }
        function once(fn) {
          return function() {
            if (fn === null)
              return;
            var callFn = fn;
            fn = null;
            callFn.apply(this, arguments);
          };
        }
        var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
        var getIterator = function(coll) {
          return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
        };
        function baseTimes(n, iteratee) {
          var index2 = -1, result = Array(n);
          while (++index2 < n) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function isObjectLike2(value) {
          return value != null && typeof value == "object";
        }
        var argsTag = "[object Arguments]";
        function baseIsArguments(value) {
          return isObjectLike2(value) && baseGetTag(value) == argsTag;
        }
        var objectProto$3 = Object.prototype;
        var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
        var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike2(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array.isArray;
        function stubFalse() {
          return false;
        }
        var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer2 = moduleExports ? root.Buffer : void 0;
        var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
        var isBuffer = nativeIsBuffer || stubFalse;
        var MAX_SAFE_INTEGER$1 = 9007199254740991;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        function isIndex(value, length) {
          var type3 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER$1 : length;
          return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        var argsTag$1 = "[object Arguments]";
        var arrayTag = "[object Array]";
        var boolTag = "[object Boolean]";
        var dateTag = "[object Date]";
        var errorTag = "[object Error]";
        var funcTag$1 = "[object Function]";
        var mapTag = "[object Map]";
        var numberTag = "[object Number]";
        var objectTag = "[object Object]";
        var regexpTag = "[object RegExp]";
        var setTag = "[object Set]";
        var stringTag = "[object String]";
        var weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]";
        var dataViewTag = "[object DataView]";
        var float32Tag = "[object Float32Array]";
        var float64Tag = "[object Float64Array]";
        var int8Tag = "[object Int8Array]";
        var int16Tag = "[object Int16Array]";
        var int32Tag = "[object Int32Array]";
        var uint8Tag = "[object Uint8Array]";
        var uint8ClampedTag = "[object Uint8ClampedArray]";
        var uint16Tag = "[object Uint16Array]";
        var uint32Tag = "[object Uint32Array]";
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        function baseIsTypedArray(value) {
          return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        var freeExports$1 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
        var freeProcess = moduleExports$1 && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        var objectProto$2 = Object.prototype;
        var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        var objectProto$5 = Object.prototype;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
          return value === proto;
        }
        function overArg(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        var nativeKeys = overArg(Object.keys, Object);
        var objectProto$4 = Object.prototype;
        var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result = [];
          for (var key in Object(object2)) {
            if (hasOwnProperty$3.call(object2, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function keys4(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function createArrayIterator(coll) {
          var i = -1;
          var len = coll.length;
          return function next() {
            return ++i < len ? { value: coll[i], key: i } : null;
          };
        }
        function createES2015Iterator(iterator2) {
          var i = -1;
          return function next() {
            var item = iterator2.next();
            if (item.done)
              return null;
            i++;
            return { value: item.value, key: i };
          };
        }
        function createObjectIterator(obj) {
          var okeys = keys4(obj);
          var i = -1;
          var len = okeys.length;
          return function next() {
            var key = okeys[++i];
            if (key === "__proto__") {
              return next();
            }
            return i < len ? { value: obj[key], key } : null;
          };
        }
        function iterator(coll) {
          if (isArrayLike(coll)) {
            return createArrayIterator(coll);
          }
          var iterator2 = getIterator(coll);
          return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
        }
        function onlyOnce(fn) {
          return function() {
            if (fn === null)
              throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null;
            callFn.apply(this, arguments);
          };
        }
        function _eachOfLimit(limit) {
          return function(obj, iteratee, callback) {
            callback = once(callback || noop);
            if (limit <= 0 || !obj) {
              return callback(null);
            }
            var nextElem = iterator(obj);
            var done = false;
            var running = 0;
            var looping = false;
            function iterateeCallback(err2, value) {
              running -= 1;
              if (err2) {
                done = true;
                callback(err2);
              } else if (value === breakLoop || done && running <= 0) {
                done = true;
                return callback(null);
              } else if (!looping) {
                replenish();
              }
            }
            function replenish() {
              looping = true;
              while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                  done = true;
                  if (running <= 0) {
                    callback(null);
                  }
                  return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
              }
              looping = false;
            }
            replenish();
          };
        }
        function eachOfLimit(coll, limit, iteratee, callback) {
          _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
        }
        function doLimit(fn, limit) {
          return function(iterable, iteratee, callback) {
            return fn(iterable, limit, iteratee, callback);
          };
        }
        function eachOfArrayLike(coll, iteratee, callback) {
          callback = once(callback || noop);
          var index2 = 0, completed = 0, length = coll.length;
          if (length === 0) {
            callback(null);
          }
          function iteratorCallback(err2, value) {
            if (err2) {
              callback(err2);
            } else if (++completed === length || value === breakLoop) {
              callback(null);
            }
          }
          for (; index2 < length; index2++) {
            iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
          }
        }
        var eachOfGeneric = doLimit(eachOfLimit, Infinity);
        var eachOf = function(coll, iteratee, callback) {
          var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
          eachOfImplementation(coll, wrapAsync(iteratee), callback);
        };
        function doParallel(fn) {
          return function(obj, iteratee, callback) {
            return fn(eachOf, obj, wrapAsync(iteratee), callback);
          };
        }
        function _asyncMap(eachfn, arr, iteratee, callback) {
          callback = callback || noop;
          arr = arr || [];
          var results = [];
          var counter = 0;
          var _iteratee = wrapAsync(iteratee);
          eachfn(arr, function(value, _, callback2) {
            var index2 = counter++;
            _iteratee(value, function(err2, v) {
              results[index2] = v;
              callback2(err2);
            });
          }, function(err2) {
            callback(err2, results);
          });
        }
        var map2 = doParallel(_asyncMap);
        var applyEach = applyEach$1(map2);
        function doParallelLimit(fn) {
          return function(obj, limit, iteratee, callback) {
            return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
          };
        }
        var mapLimit = doParallelLimit(_asyncMap);
        var mapSeries = doLimit(mapLimit, 1);
        var applyEachSeries = applyEach$1(mapSeries);
        function arrayEach(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (iteratee(array2[index2], index2, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee, keysFunc) {
            var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        var baseFor = createBaseFor();
        function baseForOwn(object2, iteratee) {
          return object2 && baseFor(object2, iteratee, keys4);
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        var auto = function(tasks, concurrency, callback) {
          if (typeof concurrency === "function") {
            callback = concurrency;
            concurrency = null;
          }
          callback = once(callback || noop);
          var keys$$1 = keys4(tasks);
          var numTasks = keys$$1.length;
          if (!numTasks) {
            return callback(null);
          }
          if (!concurrency) {
            concurrency = numTasks;
          }
          var results = {};
          var runningTasks = 0;
          var hasError = false;
          var listeners = /* @__PURE__ */ Object.create(null);
          var readyTasks = [];
          var readyToCheck = [];
          var uncheckedDependencies = {};
          baseForOwn(tasks, function(task, key) {
            if (!isArray(task)) {
              enqueueTask(key, [task]);
              readyToCheck.push(key);
              return;
            }
            var dependencies = task.slice(0, task.length - 1);
            var remainingDependencies = dependencies.length;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
              readyToCheck.push(key);
              return;
            }
            uncheckedDependencies[key] = remainingDependencies;
            arrayEach(dependencies, function(dependencyName) {
              if (!tasks[dependencyName]) {
                throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
              }
              addListener(dependencyName, function() {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                  enqueueTask(key, task);
                }
              });
            });
          });
          checkForDeadlocks();
          processQueue();
          function enqueueTask(key, task) {
            readyTasks.push(function() {
              runTask(key, task);
            });
          }
          function processQueue() {
            if (readyTasks.length === 0 && runningTasks === 0) {
              return callback(null, results);
            }
            while (readyTasks.length && runningTasks < concurrency) {
              var run2 = readyTasks.shift();
              run2();
            }
          }
          function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            if (!taskListeners) {
              taskListeners = listeners[taskName] = [];
            }
            taskListeners.push(fn);
          }
          function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            arrayEach(taskListeners, function(fn) {
              fn();
            });
            processQueue();
          }
          function runTask(key, task) {
            if (hasError)
              return;
            var taskCallback = onlyOnce(function(err2, result) {
              runningTasks--;
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              }
              if (err2) {
                var safeResults = {};
                baseForOwn(results, function(val, rkey) {
                  safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = /* @__PURE__ */ Object.create(null);
                callback(err2, safeResults);
              } else {
                results[key] = result;
                taskComplete(key);
              }
            });
            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            if (task.length > 1) {
              taskFn(results, taskCallback);
            } else {
              taskFn(taskCallback);
            }
          }
          function checkForDeadlocks() {
            var currentTask;
            var counter = 0;
            while (readyToCheck.length) {
              currentTask = readyToCheck.pop();
              counter++;
              arrayEach(getDependents(currentTask), function(dependent) {
                if (--uncheckedDependencies[dependent] === 0) {
                  readyToCheck.push(dependent);
                }
              });
            }
            if (counter !== numTasks) {
              throw new Error(
                "async.auto cannot execute tasks due to a recursive dependency"
              );
            }
          }
          function getDependents(taskName) {
            var result = [];
            baseForOwn(tasks, function(task, key) {
              if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
                result.push(key);
              }
            });
            return result;
          }
        };
        function arrayMap(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array2[index2], index2, array2);
          }
          return result;
        }
        var symbolTag = "[object Symbol]";
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
        }
        var INFINITY = 1 / 0;
        var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
        var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString2 ? symbolToString2.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function baseSlice(array2, start, end) {
          var index2 = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index2 < length) {
            result[index2] = array2[index2 + start];
          }
          return result;
        }
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === void 0 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function asciiToArray(string2) {
          return string2.split("");
        }
        var rsAstralRange = "\\ud800-\\udfff";
        var rsComboMarksRange = "\\u0300-\\u036f";
        var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange = "\\u20d0-\\u20ff";
        var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
        var rsVarRange = "\\ufe0e\\ufe0f";
        var rsZWJ = "\\u200d";
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        var rsAstralRange$1 = "\\ud800-\\udfff";
        var rsComboMarksRange$1 = "\\u0300-\\u036f";
        var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
        var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
        var rsVarRange$1 = "\\ufe0e\\ufe0f";
        var rsAstral = "[" + rsAstralRange$1 + "]";
        var rsCombo = "[" + rsComboRange$1 + "]";
        var rsFitz = "\\ud83c[\\udffb-\\udfff]";
        var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
        var rsNonAstral = "[^" + rsAstralRange$1 + "]";
        var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
        var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
        var rsZWJ$1 = "\\u200d";
        var reOptMod = rsModifier + "?";
        var rsOptVar = "[" + rsVarRange$1 + "]?";
        var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
        var rsSeq = rsOptVar + reOptMod + rsOptJoin;
        var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        function toString3(value) {
          return value == null ? "" : baseToString(value);
        }
        var reTrim = /^\s+|\s+$/g;
        function trim(string2, chars, guard) {
          string2 = toString3(string2);
          if (string2 && (guard || chars === void 0)) {
            return string2.replace(reTrim, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
        var FN_ARG_SPLIT = /,/;
        var FN_ARG = /(=.+)?(\s*)$/;
        var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
        function parseParams(func) {
          func = func.toString().replace(STRIP_COMMENTS, "");
          func = func.match(FN_ARGS)[2].replace(" ", "");
          func = func ? func.split(FN_ARG_SPLIT) : [];
          func = func.map(function(arg) {
            return trim(arg.replace(FN_ARG, ""));
          });
          return func;
        }
        function autoInject(tasks, callback) {
          var newTasks = {};
          baseForOwn(tasks, function(taskFn, key) {
            var params;
            var fnIsAsync = isAsync(taskFn);
            var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
            if (isArray(taskFn)) {
              params = taskFn.slice(0, -1);
              taskFn = taskFn[taskFn.length - 1];
              newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
            } else if (hasNoDeps) {
              newTasks[key] = taskFn;
            } else {
              params = parseParams(taskFn);
              if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
              }
              if (!fnIsAsync)
                params.pop();
              newTasks[key] = params.concat(newTask);
            }
            function newTask(results, taskCb) {
              var newArgs = arrayMap(params, function(name) {
                return results[name];
              });
              newArgs.push(taskCb);
              wrapAsync(taskFn).apply(null, newArgs);
            }
          });
          auto(newTasks, callback);
        }
        function DLL() {
          this.head = this.tail = null;
          this.length = 0;
        }
        function setInitial(dll, node2) {
          dll.length = 1;
          dll.head = dll.tail = node2;
        }
        DLL.prototype.removeLink = function(node2) {
          if (node2.prev)
            node2.prev.next = node2.next;
          else
            this.head = node2.next;
          if (node2.next)
            node2.next.prev = node2.prev;
          else
            this.tail = node2.prev;
          node2.prev = node2.next = null;
          this.length -= 1;
          return node2;
        };
        DLL.prototype.empty = function() {
          while (this.head)
            this.shift();
          return this;
        };
        DLL.prototype.insertAfter = function(node2, newNode) {
          newNode.prev = node2;
          newNode.next = node2.next;
          if (node2.next)
            node2.next.prev = newNode;
          else
            this.tail = newNode;
          node2.next = newNode;
          this.length += 1;
        };
        DLL.prototype.insertBefore = function(node2, newNode) {
          newNode.prev = node2.prev;
          newNode.next = node2;
          if (node2.prev)
            node2.prev.next = newNode;
          else
            this.head = newNode;
          node2.prev = newNode;
          this.length += 1;
        };
        DLL.prototype.unshift = function(node2) {
          if (this.head)
            this.insertBefore(this.head, node2);
          else
            setInitial(this, node2);
        };
        DLL.prototype.push = function(node2) {
          if (this.tail)
            this.insertAfter(this.tail, node2);
          else
            setInitial(this, node2);
        };
        DLL.prototype.shift = function() {
          return this.head && this.removeLink(this.head);
        };
        DLL.prototype.pop = function() {
          return this.tail && this.removeLink(this.tail);
        };
        DLL.prototype.toArray = function() {
          var arr = Array(this.length);
          var curr = this.head;
          for (var idx = 0; idx < this.length; idx++) {
            arr[idx] = curr.data;
            curr = curr.next;
          }
          return arr;
        };
        DLL.prototype.remove = function(testFn) {
          var curr = this.head;
          while (!!curr) {
            var next = curr.next;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        };
        function queue(worker, concurrency, payload) {
          if (concurrency == null) {
            concurrency = 1;
          } else if (concurrency === 0) {
            throw new Error("Concurrency must not be zero");
          }
          var _worker = wrapAsync(worker);
          var numRunning = 0;
          var workersList = [];
          var processingScheduled = false;
          function _insert(data, insertAtFront, callback) {
            if (callback != null && typeof callback !== "function") {
              throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!isArray(data)) {
              data = [data];
            }
            if (data.length === 0 && q.idle()) {
              return setImmediate$1(function() {
                q.drain();
              });
            }
            for (var i = 0, l = data.length; i < l; i++) {
              var item = {
                data: data[i],
                callback: callback || noop
              };
              if (insertAtFront) {
                q._tasks.unshift(item);
              } else {
                q._tasks.push(item);
              }
            }
            if (!processingScheduled) {
              processingScheduled = true;
              setImmediate$1(function() {
                processingScheduled = false;
                q.process();
              });
            }
          }
          function _next(tasks) {
            return function(err2) {
              numRunning -= 1;
              for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];
                var index2 = baseIndexOf(workersList, task, 0);
                if (index2 === 0) {
                  workersList.shift();
                } else if (index2 > 0) {
                  workersList.splice(index2, 1);
                }
                task.callback.apply(task, arguments);
                if (err2 != null) {
                  q.error(err2, task.data);
                }
              }
              if (numRunning <= q.concurrency - q.buffer) {
                q.unsaturated();
              }
              if (q.idle()) {
                q.drain();
              }
              q.process();
            };
          }
          var isProcessing = false;
          var q = {
            _tasks: new DLL(),
            concurrency,
            payload,
            saturated: noop,
            unsaturated: noop,
            buffer: concurrency / 4,
            empty: noop,
            drain: noop,
            error: noop,
            started: false,
            paused: false,
            push: function(data, callback) {
              _insert(data, false, callback);
            },
            kill: function() {
              q.drain = noop;
              q._tasks.empty();
            },
            unshift: function(data, callback) {
              _insert(data, true, callback);
            },
            remove: function(testFn) {
              q._tasks.remove(testFn);
            },
            process: function() {
              if (isProcessing) {
                return;
              }
              isProcessing = true;
              while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload)
                  l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                  var node2 = q._tasks.shift();
                  tasks.push(node2);
                  workersList.push(node2);
                  data.push(node2.data);
                }
                numRunning += 1;
                if (q._tasks.length === 0) {
                  q.empty();
                }
                if (numRunning === q.concurrency) {
                  q.saturated();
                }
                var cb = onlyOnce(_next(tasks));
                _worker(data, cb);
              }
              isProcessing = false;
            },
            length: function() {
              return q._tasks.length;
            },
            running: function() {
              return numRunning;
            },
            workersList: function() {
              return workersList;
            },
            idle: function() {
              return q._tasks.length + numRunning === 0;
            },
            pause: function() {
              q.paused = true;
            },
            resume: function() {
              if (q.paused === false) {
                return;
              }
              q.paused = false;
              setImmediate$1(q.process);
            }
          };
          return q;
        }
        function cargo(worker, payload) {
          return queue(worker, 1, payload);
        }
        var eachOfSeries = doLimit(eachOfLimit, 1);
        function reduce(coll, memo, iteratee, callback) {
          callback = once(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          eachOfSeries(coll, function(x, i, callback2) {
            _iteratee(memo, x, function(err2, v) {
              memo = v;
              callback2(err2);
            });
          }, function(err2) {
            callback(err2, memo);
          });
        }
        function seq() {
          var _functions = arrayMap(arguments, wrapAsync);
          return function() {
            var args = slice(arguments);
            var that = this;
            var cb = args[args.length - 1];
            if (typeof cb == "function") {
              args.pop();
            } else {
              cb = noop;
            }
            reduce(
              _functions,
              args,
              function(newargs, fn, cb2) {
                fn.apply(that, newargs.concat(function(err2) {
                  var nextargs = slice(arguments, 1);
                  cb2(err2, nextargs);
                }));
              },
              function(err2, results) {
                cb.apply(that, [err2].concat(results));
              }
            );
          };
        }
        var compose = function() {
          return seq.apply(null, slice(arguments).reverse());
        };
        var _concat = Array.prototype.concat;
        var concatLimit = function(coll, limit, iteratee, callback) {
          callback = callback || noop;
          var _iteratee = wrapAsync(iteratee);
          mapLimit(coll, limit, function(val, callback2) {
            _iteratee(val, function(err2) {
              if (err2)
                return callback2(err2);
              return callback2(null, slice(arguments, 1));
            });
          }, function(err2, mapResults) {
            var result = [];
            for (var i = 0; i < mapResults.length; i++) {
              if (mapResults[i]) {
                result = _concat.apply(result, mapResults[i]);
              }
            }
            return callback(err2, result);
          });
        };
        var concat2 = doLimit(concatLimit, Infinity);
        var concatSeries = doLimit(concatLimit, 1);
        var constant = function() {
          var values = slice(arguments);
          var args = [null].concat(values);
          return function() {
            var callback = arguments[arguments.length - 1];
            return callback.apply(this, args);
          };
        };
        function identity2(value) {
          return value;
        }
        function _createTester(check, getResult2) {
          return function(eachfn, arr, iteratee, cb) {
            cb = cb || noop;
            var testPassed = false;
            var testResult;
            eachfn(arr, function(value, _, callback) {
              iteratee(value, function(err2, result) {
                if (err2) {
                  callback(err2);
                } else if (check(result) && !testResult) {
                  testPassed = true;
                  testResult = getResult2(true, value);
                  callback(null, breakLoop);
                } else {
                  callback();
                }
              });
            }, function(err2) {
              if (err2) {
                cb(err2);
              } else {
                cb(null, testPassed ? testResult : getResult2(false));
              }
            });
          };
        }
        function _findGetResult(v, x) {
          return x;
        }
        var detect = doParallel(_createTester(identity2, _findGetResult));
        var detectLimit = doParallelLimit(_createTester(identity2, _findGetResult));
        var detectSeries = doLimit(detectLimit, 1);
        function consoleFunc(name) {
          return function(fn) {
            var args = slice(arguments, 1);
            args.push(function(err2) {
              var args2 = slice(arguments, 1);
              if (typeof console === "object") {
                if (err2) {
                  if (console.error) {
                    console.error(err2);
                  }
                } else if (console[name]) {
                  arrayEach(args2, function(x) {
                    console[name](x);
                  });
                }
              }
            });
            wrapAsync(fn).apply(null, args);
          };
        }
        var dir = consoleFunc("dir");
        function doDuring(fn, test, callback) {
          callback = onlyOnce(callback || noop);
          var _fn = wrapAsync(fn);
          var _test = wrapAsync(test);
          function next(err2) {
            if (err2)
              return callback(err2);
            var args = slice(arguments, 1);
            args.push(check);
            _test.apply(this, args);
          }
          function check(err2, truth) {
            if (err2)
              return callback(err2);
            if (!truth)
              return callback(null);
            _fn(next);
          }
          check(null, true);
        }
        function doWhilst(iteratee, test, callback) {
          callback = onlyOnce(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          var next = function(err2) {
            if (err2)
              return callback(err2);
            var args = slice(arguments, 1);
            if (test.apply(this, args))
              return _iteratee(next);
            callback.apply(null, [null].concat(args));
          };
          _iteratee(next);
        }
        function doUntil(iteratee, test, callback) {
          doWhilst(iteratee, function() {
            return !test.apply(this, arguments);
          }, callback);
        }
        function during(test, fn, callback) {
          callback = onlyOnce(callback || noop);
          var _fn = wrapAsync(fn);
          var _test = wrapAsync(test);
          function next(err2) {
            if (err2)
              return callback(err2);
            _test(check);
          }
          function check(err2, truth) {
            if (err2)
              return callback(err2);
            if (!truth)
              return callback(null);
            _fn(next);
          }
          _test(check);
        }
        function _withoutIndex(iteratee) {
          return function(value, index2, callback) {
            return iteratee(value, callback);
          };
        }
        function eachLimit(coll, iteratee, callback) {
          eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
        }
        function eachLimit$1(coll, limit, iteratee, callback) {
          _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
        }
        var eachSeries = doLimit(eachLimit$1, 1);
        function ensureAsync(fn) {
          if (isAsync(fn))
            return fn;
          return initialParams(function(args, callback) {
            var sync2 = true;
            args.push(function() {
              var innerArgs = arguments;
              if (sync2) {
                setImmediate$1(function() {
                  callback.apply(null, innerArgs);
                });
              } else {
                callback.apply(null, innerArgs);
              }
            });
            fn.apply(this, args);
            sync2 = false;
          });
        }
        function notId(v) {
          return !v;
        }
        var every = doParallel(_createTester(notId, notId));
        var everyLimit = doParallelLimit(_createTester(notId, notId));
        var everySeries = doLimit(everyLimit, 1);
        function baseProperty(key) {
          return function(object2) {
            return object2 == null ? void 0 : object2[key];
          };
        }
        function filterArray(eachfn, arr, iteratee, callback) {
          var truthValues = new Array(arr.length);
          eachfn(arr, function(x, index2, callback2) {
            iteratee(x, function(err2, v) {
              truthValues[index2] = !!v;
              callback2(err2);
            });
          }, function(err2) {
            if (err2)
              return callback(err2);
            var results = [];
            for (var i = 0; i < arr.length; i++) {
              if (truthValues[i])
                results.push(arr[i]);
            }
            callback(null, results);
          });
        }
        function filterGeneric(eachfn, coll, iteratee, callback) {
          var results = [];
          eachfn(coll, function(x, index2, callback2) {
            iteratee(x, function(err2, v) {
              if (err2) {
                callback2(err2);
              } else {
                if (v) {
                  results.push({ index: index2, value: x });
                }
                callback2();
              }
            });
          }, function(err2) {
            if (err2) {
              callback(err2);
            } else {
              callback(null, arrayMap(results.sort(function(a, b) {
                return a.index - b.index;
              }), baseProperty("value")));
            }
          });
        }
        function _filter(eachfn, coll, iteratee, callback) {
          var filter3 = isArrayLike(coll) ? filterArray : filterGeneric;
          filter3(eachfn, coll, wrapAsync(iteratee), callback || noop);
        }
        var filter2 = doParallel(_filter);
        var filterLimit = doParallelLimit(_filter);
        var filterSeries = doLimit(filterLimit, 1);
        function forever(fn, errback) {
          var done = onlyOnce(errback || noop);
          var task = wrapAsync(ensureAsync(fn));
          function next(err2) {
            if (err2)
              return done(err2);
            task(next);
          }
          next();
        }
        var groupByLimit = function(coll, limit, iteratee, callback) {
          callback = callback || noop;
          var _iteratee = wrapAsync(iteratee);
          mapLimit(coll, limit, function(val, callback2) {
            _iteratee(val, function(err2, key) {
              if (err2)
                return callback2(err2);
              return callback2(null, { key, val });
            });
          }, function(err2, mapResults) {
            var result = {};
            var hasOwnProperty2 = Object.prototype.hasOwnProperty;
            for (var i = 0; i < mapResults.length; i++) {
              if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;
                if (hasOwnProperty2.call(result, key)) {
                  result[key].push(val);
                } else {
                  result[key] = [val];
                }
              }
            }
            return callback(err2, result);
          });
        };
        var groupBy = doLimit(groupByLimit, Infinity);
        var groupBySeries = doLimit(groupByLimit, 1);
        var log4 = consoleFunc("log");
        function mapValuesLimit(obj, limit, iteratee, callback) {
          callback = once(callback || noop);
          var newObj = {};
          var _iteratee = wrapAsync(iteratee);
          eachOfLimit(obj, limit, function(val, key, next) {
            _iteratee(val, key, function(err2, result) {
              if (err2)
                return next(err2);
              newObj[key] = result;
              next();
            });
          }, function(err2) {
            callback(err2, newObj);
          });
        }
        var mapValues = doLimit(mapValuesLimit, Infinity);
        var mapValuesSeries = doLimit(mapValuesLimit, 1);
        function has(obj, key) {
          return key in obj;
        }
        function memoize(fn, hasher) {
          var memo = /* @__PURE__ */ Object.create(null);
          var queues = /* @__PURE__ */ Object.create(null);
          hasher = hasher || identity2;
          var _fn = wrapAsync(fn);
          var memoized2 = initialParams(function memoized3(args, callback) {
            var key = hasher.apply(null, args);
            if (has(memo, key)) {
              setImmediate$1(function() {
                callback.apply(null, memo[key]);
              });
            } else if (has(queues, key)) {
              queues[key].push(callback);
            } else {
              queues[key] = [callback];
              _fn.apply(null, args.concat(function() {
                var args2 = slice(arguments);
                memo[key] = args2;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                  q[i].apply(null, args2);
                }
              }));
            }
          });
          memoized2.memo = memo;
          memoized2.unmemoized = fn;
          return memoized2;
        }
        var _defer$1;
        if (hasNextTick) {
          _defer$1 = process.nextTick;
        } else if (hasSetImmediate) {
          _defer$1 = setImmediate;
        } else {
          _defer$1 = fallback;
        }
        var nextTick = wrap3(_defer$1);
        function _parallel(eachfn, tasks, callback) {
          callback = callback || noop;
          var results = isArrayLike(tasks) ? [] : {};
          eachfn(tasks, function(task, key, callback2) {
            wrapAsync(task)(function(err2, result) {
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              }
              results[key] = result;
              callback2(err2);
            });
          }, function(err2) {
            callback(err2, results);
          });
        }
        function parallelLimit(tasks, callback) {
          _parallel(eachOf, tasks, callback);
        }
        function parallelLimit$1(tasks, limit, callback) {
          _parallel(_eachOfLimit(limit), tasks, callback);
        }
        var queue$1 = function(worker, concurrency) {
          var _worker = wrapAsync(worker);
          return queue(function(items, cb) {
            _worker(items[0], cb);
          }, concurrency, 1);
        };
        var priorityQueue = function(worker, concurrency) {
          var q = queue$1(worker, concurrency);
          q.push = function(data, priority, callback) {
            if (callback == null)
              callback = noop;
            if (typeof callback !== "function") {
              throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!isArray(data)) {
              data = [data];
            }
            if (data.length === 0) {
              return setImmediate$1(function() {
                q.drain();
              });
            }
            priority = priority || 0;
            var nextNode = q._tasks.head;
            while (nextNode && priority >= nextNode.priority) {
              nextNode = nextNode.next;
            }
            for (var i = 0, l = data.length; i < l; i++) {
              var item = {
                data: data[i],
                priority,
                callback
              };
              if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
              } else {
                q._tasks.push(item);
              }
            }
            setImmediate$1(q.process);
          };
          delete q.unshift;
          return q;
        };
        function race(tasks, callback) {
          callback = once(callback || noop);
          if (!isArray(tasks))
            return callback(new TypeError("First argument to race must be an array of functions"));
          if (!tasks.length)
            return callback();
          for (var i = 0, l = tasks.length; i < l; i++) {
            wrapAsync(tasks[i])(callback);
          }
        }
        function reduceRight(array2, memo, iteratee, callback) {
          var reversed = slice(array2).reverse();
          reduce(reversed, memo, iteratee, callback);
        }
        function reflect(fn) {
          var _fn = wrapAsync(fn);
          return initialParams(function reflectOn(args, reflectCallback) {
            args.push(function callback(error3, cbArg) {
              if (error3) {
                reflectCallback(null, { error: error3 });
              } else {
                var value;
                if (arguments.length <= 2) {
                  value = cbArg;
                } else {
                  value = slice(arguments, 1);
                }
                reflectCallback(null, { value });
              }
            });
            return _fn.apply(this, args);
          });
        }
        function reflectAll(tasks) {
          var results;
          if (isArray(tasks)) {
            results = arrayMap(tasks, reflect);
          } else {
            results = {};
            baseForOwn(tasks, function(task, key) {
              results[key] = reflect.call(this, task);
            });
          }
          return results;
        }
        function reject$1(eachfn, arr, iteratee, callback) {
          _filter(eachfn, arr, function(value, cb) {
            iteratee(value, function(err2, v) {
              cb(err2, !v);
            });
          }, callback);
        }
        var reject = doParallel(reject$1);
        var rejectLimit = doParallelLimit(reject$1);
        var rejectSeries = doLimit(rejectLimit, 1);
        function constant$1(value) {
          return function() {
            return value;
          };
        }
        function retry(opts, task, callback) {
          var DEFAULT_TIMES = 5;
          var DEFAULT_INTERVAL = 0;
          var options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
          };
          function parseTimes(acc, t) {
            if (typeof t === "object") {
              acc.times = +t.times || DEFAULT_TIMES;
              acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
              acc.errorFilter = t.errorFilter;
            } else if (typeof t === "number" || typeof t === "string") {
              acc.times = +t || DEFAULT_TIMES;
            } else {
              throw new Error("Invalid arguments for async.retry");
            }
          }
          if (arguments.length < 3 && typeof opts === "function") {
            callback = task || noop;
            task = opts;
          } else {
            parseTimes(options, opts);
            callback = callback || noop;
          }
          if (typeof task !== "function") {
            throw new Error("Invalid arguments for async.retry");
          }
          var _task = wrapAsync(task);
          var attempt = 1;
          function retryAttempt() {
            _task(function(err2) {
              if (err2 && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err2))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
              } else {
                callback.apply(null, arguments);
              }
            });
          }
          retryAttempt();
        }
        var retryable = function(opts, task) {
          if (!task) {
            task = opts;
            opts = null;
          }
          var _task = wrapAsync(task);
          return initialParams(function(args, callback) {
            function taskFn(cb) {
              _task.apply(null, args.concat(cb));
            }
            if (opts)
              retry(opts, taskFn, callback);
            else
              retry(taskFn, callback);
          });
        };
        function series(tasks, callback) {
          _parallel(eachOfSeries, tasks, callback);
        }
        var some = doParallel(_createTester(Boolean, identity2));
        var someLimit = doParallelLimit(_createTester(Boolean, identity2));
        var someSeries = doLimit(someLimit, 1);
        function sortBy(coll, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          map2(coll, function(x, callback2) {
            _iteratee(x, function(err2, criteria) {
              if (err2)
                return callback2(err2);
              callback2(null, { value: x, criteria });
            });
          }, function(err2, results) {
            if (err2)
              return callback(err2);
            callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
          });
          function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
          }
        }
        function timeout(asyncFn, milliseconds, info) {
          var fn = wrapAsync(asyncFn);
          return initialParams(function(args, callback) {
            var timedOut = false;
            var timer;
            function timeoutCallback() {
              var name = asyncFn.name || "anonymous";
              var error3 = new Error('Callback function "' + name + '" timed out.');
              error3.code = "ETIMEDOUT";
              if (info) {
                error3.info = info;
              }
              timedOut = true;
              callback(error3);
            }
            args.push(function() {
              if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
              }
            });
            timer = setTimeout(timeoutCallback, milliseconds);
            fn.apply(null, args);
          });
        }
        var nativeCeil = Math.ceil;
        var nativeMax = Math.max;
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
          while (length--) {
            result[fromRight ? length : ++index2] = start;
            start += step;
          }
          return result;
        }
        function timeLimit(count, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
        }
        var times = doLimit(timeLimit, Infinity);
        var timesSeries = doLimit(timeLimit, 1);
        function transform(coll, accumulator, iteratee, callback) {
          if (arguments.length <= 3) {
            callback = iteratee;
            iteratee = accumulator;
            accumulator = isArray(coll) ? [] : {};
          }
          callback = once(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          eachOf(coll, function(v, k, cb) {
            _iteratee(accumulator, v, k, cb);
          }, function(err2) {
            callback(err2, accumulator);
          });
        }
        function tryEach(tasks, callback) {
          var error3 = null;
          var result;
          callback = callback || noop;
          eachSeries(tasks, function(task, callback2) {
            wrapAsync(task)(function(err2, res) {
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              } else {
                result = res;
              }
              error3 = err2;
              callback2(!err2);
            });
          }, function() {
            callback(error3, result);
          });
        }
        function unmemoize(fn) {
          return function() {
            return (fn.unmemoized || fn).apply(null, arguments);
          };
        }
        function whilst(test, iteratee, callback) {
          callback = onlyOnce(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          if (!test())
            return callback(null);
          var next = function(err2) {
            if (err2)
              return callback(err2);
            if (test())
              return _iteratee(next);
            var args = slice(arguments, 1);
            callback.apply(null, [null].concat(args));
          };
          _iteratee(next);
        }
        function until(test, iteratee, callback) {
          whilst(function() {
            return !test.apply(this, arguments);
          }, iteratee, callback);
        }
        var waterfall = function(tasks, callback) {
          callback = once(callback || noop);
          if (!isArray(tasks))
            return callback(new Error("First argument to waterfall must be an array of functions"));
          if (!tasks.length)
            return callback();
          var taskIndex = 0;
          function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            args.push(onlyOnce(next));
            task.apply(null, args);
          }
          function next(err2) {
            if (err2 || taskIndex === tasks.length) {
              return callback.apply(null, arguments);
            }
            nextTask(slice(arguments, 1));
          }
          nextTask([]);
        };
        var index = {
          apply,
          applyEach,
          applyEachSeries,
          asyncify,
          auto,
          autoInject,
          cargo,
          compose,
          concat: concat2,
          concatLimit,
          concatSeries,
          constant,
          detect,
          detectLimit,
          detectSeries,
          dir,
          doDuring,
          doUntil,
          doWhilst,
          during,
          each: eachLimit,
          eachLimit: eachLimit$1,
          eachOf,
          eachOfLimit,
          eachOfSeries,
          eachSeries,
          ensureAsync,
          every,
          everyLimit,
          everySeries,
          filter: filter2,
          filterLimit,
          filterSeries,
          forever,
          groupBy,
          groupByLimit,
          groupBySeries,
          log: log4,
          map: map2,
          mapLimit,
          mapSeries,
          mapValues,
          mapValuesLimit,
          mapValuesSeries,
          memoize,
          nextTick,
          parallel: parallelLimit,
          parallelLimit: parallelLimit$1,
          priorityQueue,
          queue: queue$1,
          race,
          reduce,
          reduceRight,
          reflect,
          reflectAll,
          reject,
          rejectLimit,
          rejectSeries,
          retry,
          retryable,
          seq,
          series,
          setImmediate: setImmediate$1,
          some,
          someLimit,
          someSeries,
          sortBy,
          timeout,
          times,
          timesLimit: timeLimit,
          timesSeries,
          transform,
          tryEach,
          unmemoize,
          until,
          waterfall,
          whilst,
          // aliases
          all: every,
          allLimit: everyLimit,
          allSeries: everySeries,
          any: some,
          anyLimit: someLimit,
          anySeries: someSeries,
          find: detect,
          findLimit: detectLimit,
          findSeries: detectSeries,
          forEach: eachLimit,
          forEachSeries: eachSeries,
          forEachLimit: eachLimit$1,
          forEachOf: eachOf,
          forEachOfSeries: eachOfSeries,
          forEachOfLimit: eachOfLimit,
          inject: reduce,
          foldl: reduce,
          foldr: reduceRight,
          select: filter2,
          selectLimit: filterLimit,
          selectSeries: filterSeries,
          wrapSync: asyncify
        };
        exports2["default"] = index;
        exports2.apply = apply;
        exports2.applyEach = applyEach;
        exports2.applyEachSeries = applyEachSeries;
        exports2.asyncify = asyncify;
        exports2.auto = auto;
        exports2.autoInject = autoInject;
        exports2.cargo = cargo;
        exports2.compose = compose;
        exports2.concat = concat2;
        exports2.concatLimit = concatLimit;
        exports2.concatSeries = concatSeries;
        exports2.constant = constant;
        exports2.detect = detect;
        exports2.detectLimit = detectLimit;
        exports2.detectSeries = detectSeries;
        exports2.dir = dir;
        exports2.doDuring = doDuring;
        exports2.doUntil = doUntil;
        exports2.doWhilst = doWhilst;
        exports2.during = during;
        exports2.each = eachLimit;
        exports2.eachLimit = eachLimit$1;
        exports2.eachOf = eachOf;
        exports2.eachOfLimit = eachOfLimit;
        exports2.eachOfSeries = eachOfSeries;
        exports2.eachSeries = eachSeries;
        exports2.ensureAsync = ensureAsync;
        exports2.every = every;
        exports2.everyLimit = everyLimit;
        exports2.everySeries = everySeries;
        exports2.filter = filter2;
        exports2.filterLimit = filterLimit;
        exports2.filterSeries = filterSeries;
        exports2.forever = forever;
        exports2.groupBy = groupBy;
        exports2.groupByLimit = groupByLimit;
        exports2.groupBySeries = groupBySeries;
        exports2.log = log4;
        exports2.map = map2;
        exports2.mapLimit = mapLimit;
        exports2.mapSeries = mapSeries;
        exports2.mapValues = mapValues;
        exports2.mapValuesLimit = mapValuesLimit;
        exports2.mapValuesSeries = mapValuesSeries;
        exports2.memoize = memoize;
        exports2.nextTick = nextTick;
        exports2.parallel = parallelLimit;
        exports2.parallelLimit = parallelLimit$1;
        exports2.priorityQueue = priorityQueue;
        exports2.queue = queue$1;
        exports2.race = race;
        exports2.reduce = reduce;
        exports2.reduceRight = reduceRight;
        exports2.reflect = reflect;
        exports2.reflectAll = reflectAll;
        exports2.reject = reject;
        exports2.rejectLimit = rejectLimit;
        exports2.rejectSeries = rejectSeries;
        exports2.retry = retry;
        exports2.retryable = retryable;
        exports2.seq = seq;
        exports2.series = series;
        exports2.setImmediate = setImmediate$1;
        exports2.some = some;
        exports2.someLimit = someLimit;
        exports2.someSeries = someSeries;
        exports2.sortBy = sortBy;
        exports2.timeout = timeout;
        exports2.times = times;
        exports2.timesLimit = timeLimit;
        exports2.timesSeries = timesSeries;
        exports2.transform = transform;
        exports2.tryEach = tryEach;
        exports2.unmemoize = unmemoize;
        exports2.until = until;
        exports2.waterfall = waterfall;
        exports2.whilst = whilst;
        exports2.all = every;
        exports2.allLimit = everyLimit;
        exports2.allSeries = everySeries;
        exports2.any = some;
        exports2.anyLimit = someLimit;
        exports2.anySeries = someSeries;
        exports2.find = detect;
        exports2.findLimit = detectLimit;
        exports2.findSeries = detectSeries;
        exports2.forEach = eachLimit;
        exports2.forEachSeries = eachSeries;
        exports2.forEachLimit = eachLimit$1;
        exports2.forEachOf = eachOf;
        exports2.forEachOfSeries = eachOfSeries;
        exports2.forEachOfLimit = eachOfLimit;
        exports2.inject = reduce;
        exports2.foldl = reduce;
        exports2.foldr = reduceRight;
        exports2.select = filter2;
        exports2.selectLimit = filterLimit;
        exports2.selectSeries = filterSeries;
        exports2.wrapSync = asyncify;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type3 = typeof val;
        if (type3 === "string" && val.length > 0) {
          return parse9(val);
        } else if (type3 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse9(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match3) {
          return;
        }
        var n = parseFloat(match3[1]);
        var type3 = (match3[2] || "ms").toLowerCase();
        switch (type3) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/common.js"(exports, module) {
      "use strict";
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        Object.keys(env).forEach(function(key) {
          createDebug[key] = env[key];
        });
        createDebug.instances = [];
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          var hash3 = 0;
          for (var i = 0; i < namespace.length; i++) {
            hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i);
            hash3 |= 0;
          }
          return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          var prevTime;
          function debug4() {
            if (!debug4.enabled) {
              return;
            }
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var self2 = debug4;
            var curr = Number(/* @__PURE__ */ new Date());
            var ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match3, format) {
              if (match3 === "%%") {
                return match3;
              }
              index++;
              var formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                var val = args[index];
                match3 = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match3;
            });
            createDebug.formatArgs.call(self2, args);
            var logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug4.namespace = namespace;
          debug4.enabled = createDebug.enabled(namespace);
          debug4.useColors = createDebug.useColors();
          debug4.color = selectColor(namespace);
          debug4.destroy = destroy;
          debug4.extend = extend;
          if (typeof createDebug.init === "function") {
            createDebug.init(debug4);
          }
          createDebug.instances.push(debug4);
          return debug4;
        }
        function destroy() {
          var index = createDebug.instances.indexOf(this);
          if (index !== -1) {
            createDebug.instances.splice(index, 1);
            return true;
          }
          return false;
        }
        function extend(namespace, delimiter2) {
          return createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.names = [];
          createDebug.skips = [];
          var i;
          var split3 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          var len = split3.length;
          for (i = 0; i < len; i++) {
            if (!split3[i]) {
              continue;
            }
            namespaces = split3[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
          for (i = 0; i < createDebug.instances.length; i++) {
            var instance = createDebug.instances[i];
            instance.enabled = createDebug.enabled(instance.namespace);
          }
        }
        function disable() {
          createDebug.enable("");
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          var i;
          var len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/browser.js"(exports, module) {
      "use strict";
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      exports.log = log4;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        var c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match3) {
          if (match3 === "%%") {
            return;
          }
          index++;
          if (match3 === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      function log4() {
        var _console;
        return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
      }
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error3) {
        }
      }
      function load() {
        var r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error3) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error3) {
        }
      }
      module.exports = require_common()(exports);
      var formatters = module.exports.formatters;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error3) {
          return "[UnexpectedJSONParseError]: " + error3.message;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/node.js
  var require_node2 = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/node.js"(exports, module) {
      "use strict";
      var tty = __require2("tty");
      var util = __require2("util");
      exports.init = init2;
      exports.log = log4;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.colors = [6, 2, 3, 4, 5, 1];
      try {
        supportsColor = require_supports_color();
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
        }
      } catch (error3) {
      }
      var supportsColor;
      exports.inspectOpts = Object.keys(process.env).filter(function(key) {
        return /^debug_/i.test(key);
      }).reduce(function(obj, key) {
        var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
          return k.toUpperCase();
        });
        var val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        var name = this.namespace, useColors2 = this.useColors;
        if (useColors2) {
          var c = this.color;
          var colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
          var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return "";
        }
        return (/* @__PURE__ */ new Date()).toISOString() + " ";
      }
      function log4() {
        return process.stderr.write(util.format.apply(util, arguments) + "\n");
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load() {
        return process.env.DEBUG;
      }
      function init2(debug4) {
        debug4.inspectOpts = {};
        var keys4 = Object.keys(exports.inspectOpts);
        for (var i = 0; i < keys4.length; i++) {
          debug4.inspectOpts[keys4[i]] = exports.inspectOpts[keys4[i]];
        }
      }
      module.exports = require_common()(exports);
      var formatters = module.exports.formatters;
      formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
          return str.trim();
        }).join(" ");
      };
      formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/index.js
  var require_src = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7/node_modules/debug/src/index.js"(exports, module) {
      "use strict";
      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module.exports = require_browser();
      } else {
        module.exports = require_node2();
      }
    }
  });

  // ../../node_modules/.pnpm/mkdirp@0.5.6/node_modules/mkdirp/index.js
  var require_mkdirp = __commonJS({
    "../../node_modules/.pnpm/mkdirp@0.5.6/node_modules/mkdirp/index.js"(exports, module) {
      var path6 = __require2("path");
      var fs5 = __require2("fs");
      var _0777 = parseInt("0777", 8);
      module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
      function mkdirP(p, opts, f2, made) {
        if (typeof opts === "function") {
          f2 = opts;
          opts = {};
        } else if (!opts || typeof opts !== "object") {
          opts = { mode: opts };
        }
        var mode = opts.mode;
        var xfs = opts.fs || fs5;
        if (mode === void 0) {
          mode = _0777;
        }
        if (!made)
          made = null;
        var cb = f2 || /* istanbul ignore next */
        function() {
        };
        p = path6.resolve(p);
        xfs.mkdir(p, mode, function(er) {
          if (!er) {
            made = made || p;
            return cb(null, made);
          }
          switch (er.code) {
            case "ENOENT":
              if (path6.dirname(p) === p)
                return cb(er);
              mkdirP(path6.dirname(p), opts, function(er2, made2) {
                if (er2)
                  cb(er2, made2);
                else
                  mkdirP(p, opts, cb, made2);
              });
              break;
            default:
              xfs.stat(p, function(er2, stat4) {
                if (er2 || !stat4.isDirectory())
                  cb(er, made);
                else
                  cb(null, made);
              });
              break;
          }
        });
      }
      mkdirP.sync = function sync2(p, opts, made) {
        if (!opts || typeof opts !== "object") {
          opts = { mode: opts };
        }
        var mode = opts.mode;
        var xfs = opts.fs || fs5;
        if (mode === void 0) {
          mode = _0777;
        }
        if (!made)
          made = null;
        p = path6.resolve(p);
        try {
          xfs.mkdirSync(p, mode);
          made = made || p;
        } catch (err0) {
          switch (err0.code) {
            case "ENOENT":
              made = sync2(path6.dirname(p), opts, made);
              sync2(p, opts, made);
              break;
            default:
              var stat4;
              try {
                stat4 = xfs.statSync(p);
              } catch (err1) {
                throw err0;
              }
              if (!stat4.isDirectory())
                throw err0;
              break;
          }
        }
        return made;
      };
    }
  });

  // ../../node_modules/.pnpm/portfinder@1.0.32/node_modules/portfinder/lib/portfinder.js
  var require_portfinder = __commonJS({
    "../../node_modules/.pnpm/portfinder@1.0.32/node_modules/portfinder/lib/portfinder.js"(exports) {
      "use strict";
      var fs5 = __require2("fs");
      var os2 = __require2("os");
      var net = __require2("net");
      var path6 = __require2("path");
      var _async = require_async();
      var debug4 = require_src();
      var mkdirp2 = require_mkdirp().mkdirp;
      var debugTestPort = debug4("portfinder:testPort");
      var debugGetPort = debug4("portfinder:getPort");
      var debugDefaultHosts = debug4("portfinder:defaultHosts");
      var internals = {};
      internals.testPort = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.server = options.server || net.createServer(function() {
        });
        debugTestPort("entered testPort(): trying", options.host, "port", options.port);
        function onListen() {
          debugTestPort("done w/ testPort(): OK", options.host, "port", options.port);
          options.server.removeListener("error", onError2);
          options.server.close();
          callback(null, options.port);
        }
        function onError2(err2) {
          debugTestPort("done w/ testPort(): failed", options.host, "w/ port", options.port, "with error", err2.code);
          options.server.removeListener("listening", onListen);
          if (!(err2.code == "EADDRINUSE" || err2.code == "EACCES")) {
            return callback(err2);
          }
          var nextPort = exports.nextPort(options.port);
          if (nextPort > exports.highestPort) {
            return callback(new Error("No open ports available"));
          }
          internals.testPort({
            port: nextPort,
            host: options.host,
            server: options.server
          }, callback);
        }
        options.server.once("error", onError2);
        options.server.once("listening", onListen);
        if (options.host) {
          options.server.listen(options.port, options.host);
        } else {
          options.server.listen(options.port);
        }
      };
      exports.basePort = 8e3;
      exports.setBasePort = function(port) {
        exports.basePort = port;
      };
      exports.highestPort = 65535;
      exports.setHighestPort = function(port) {
        exports.highestPort = port;
      };
      exports.basePath = "/tmp/portfinder";
      exports.getPort = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.port = Number(options.port) || Number(exports.basePort);
        options.host = options.host || null;
        options.stopPort = Number(options.stopPort) || Number(exports.highestPort);
        if (!options.startPort) {
          options.startPort = Number(options.port);
          if (options.startPort < 0) {
            throw Error("Provided options.startPort(" + options.startPort + ") is less than 0, which are cannot be bound.");
          }
          if (options.stopPort < options.startPort) {
            throw Error("Provided options.stopPort(" + options.stopPort + "is less than options.startPort (" + options.startPort + ")");
          }
        }
        if (options.host) {
          if (exports._defaultHosts.indexOf(options.host) !== -1) {
            exports._defaultHosts.push(options.host);
          }
        }
        var openPorts = [], currentHost;
        return _async.eachSeries(exports._defaultHosts, function(host, next) {
          debugGetPort("in eachSeries() iteration callback: host is", host);
          return internals.testPort({ host, port: options.port }, function(err2, port) {
            if (err2) {
              debugGetPort("in eachSeries() iteration callback testPort() callback", "with an err:", err2.code);
              currentHost = host;
              return next(err2);
            } else {
              debugGetPort(
                "in eachSeries() iteration callback testPort() callback",
                "with a success for port",
                port
              );
              openPorts.push(port);
              return next();
            }
          });
        }, function(err2) {
          if (err2) {
            debugGetPort("in eachSeries() result callback: err is", err2);
            if (err2.code === "EADDRNOTAVAIL" || err2.code === "EINVAL") {
              if (options.host === currentHost) {
                var msg = "Provided host " + options.host + " could NOT be bound. Please provide a different host address or hostname";
                return callback(Error(msg));
              } else {
                var idx = exports._defaultHosts.indexOf(currentHost);
                exports._defaultHosts.splice(idx, 1);
                return exports.getPort(options, callback);
              }
            } else {
              return callback(err2);
            }
          }
          openPorts.sort(function(a, b) {
            return a - b;
          });
          debugGetPort("in eachSeries() result callback: openPorts is", openPorts);
          if (openPorts[0] === openPorts[openPorts.length - 1]) {
            if (openPorts[0] <= options.stopPort) {
              return callback(null, openPorts[0]);
            } else {
              var msg = "No open ports found in between " + options.startPort + " and " + options.stopPort;
              return callback(Error(msg));
            }
          } else {
            return exports.getPort({ port: openPorts.pop(), host: options.host, startPort: options.startPort, stopPort: options.stopPort }, callback);
          }
        });
      };
      exports.getPortPromise = function(options) {
        if (typeof Promise !== "function") {
          throw Error("Native promise support is not available in this version of node.Please install a polyfill and assign Promise to global.Promise before calling this method");
        }
        if (!options) {
          options = {};
        }
        return new Promise(function(resolve10, reject) {
          exports.getPort(options, function(err2, port) {
            if (err2) {
              return reject(err2);
            }
            resolve10(port);
          });
        });
      };
      exports.getPorts = function(count, options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        var lastPort = null;
        _async.timesSeries(count, function(index, asyncCallback) {
          if (lastPort) {
            options.port = exports.nextPort(lastPort);
          }
          exports.getPort(options, function(err2, port) {
            if (err2) {
              asyncCallback(err2);
            } else {
              lastPort = port;
              asyncCallback(null, port);
            }
          });
        }, callback);
      };
      exports.getSocket = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.mod = options.mod || parseInt(755, 8);
        options.path = options.path || exports.basePath + ".sock";
        function testSocket() {
          fs5.stat(options.path, function(err2) {
            if (err2) {
              if (err2.code == "ENOENT") {
                callback(null, options.path);
              } else {
                callback(err2);
              }
            } else {
              options.path = exports.nextSocket(options.path);
              exports.getSocket(options, callback);
            }
          });
        }
        function createAndTestSocket(dir) {
          mkdirp2(dir, options.mod, function(err2) {
            if (err2) {
              return callback(err2);
            }
            options.exists = true;
            testSocket();
          });
        }
        function checkAndTestSocket() {
          var dir = path6.dirname(options.path);
          fs5.stat(dir, function(err2, stats) {
            if (err2 || !stats.isDirectory()) {
              return createAndTestSocket(dir);
            }
            options.exists = true;
            testSocket();
          });
        }
        return options.exists ? testSocket() : checkAndTestSocket();
      };
      exports.nextPort = function(port) {
        return port + 1;
      };
      exports.nextSocket = function(socketPath) {
        var dir = path6.dirname(socketPath), name = path6.basename(socketPath, ".sock"), match3 = name.match(/^([a-zA-z]+)(\d*)$/i), index = parseInt(match3[2]), base2 = match3[1];
        if (isNaN(index)) {
          index = 0;
        }
        index += 1;
        return path6.join(dir, base2 + index + ".sock");
      };
      exports._defaultHosts = function() {
        var interfaces = {};
        try {
          interfaces = os2.networkInterfaces();
        } catch (e) {
          if (e.syscall === "uv_interface_addresses") {
          } else {
            throw e;
          }
        }
        var interfaceNames = Object.keys(interfaces), hiddenButImportantHost = "0.0.0.0", results = [hiddenButImportantHost];
        for (var i = 0; i < interfaceNames.length; i++) {
          var _interface = interfaces[interfaceNames[i]];
          for (var j = 0; j < _interface.length; j++) {
            var curr = _interface[j];
            results.push(curr.address);
          }
        }
        results.push(null);
        debugDefaultHosts("exports._defaultHosts is: %o", results);
        return results;
      }();
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
  var require_constants = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports, module) {
      "use strict";
      var path6 = __require2("path");
      var WIN_SLASH = "\\\\/";
      var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
      var DOT_LITERAL = "\\.";
      var PLUS_LITERAL = "\\+";
      var QMARK_LITERAL = "\\?";
      var SLASH_LITERAL = "\\/";
      var ONE_CHAR = "(?=.)";
      var QMARK = "[^/]";
      var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
      var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
      var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
      var NO_DOT = `(?!${DOT_LITERAL})`;
      var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
      var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
      var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
      var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
      var STAR = `${QMARK}*?`;
      var POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      };
      var WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
      };
      var POSIX_REGEX_SOURCE = {
        alnum: "a-zA-Z0-9",
        alpha: "a-zA-Z",
        ascii: "\\x00-\\x7F",
        blank: " \\t",
        cntrl: "\\x00-\\x1F\\x7F",
        digit: "0-9",
        graph: "\\x21-\\x7E",
        lower: "a-z",
        print: "\\x20-\\x7E ",
        punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
        space: " \\t\\r\\n\\v\\f",
        upper: "A-Z",
        word: "A-Za-z0-9_",
        xdigit: "A-Fa-f0-9"
      };
      module.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        // regular expressions
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        // Replace globs with equivalent patterns to reduce parsing time.
        REPLACEMENTS: {
          "***": "*",
          "**/**": "**",
          "**/**/**": "**"
        },
        // Digits
        CHAR_0: 48,
        /* 0 */
        CHAR_9: 57,
        /* 9 */
        // Alphabet chars.
        CHAR_UPPERCASE_A: 65,
        /* A */
        CHAR_LOWERCASE_A: 97,
        /* a */
        CHAR_UPPERCASE_Z: 90,
        /* Z */
        CHAR_LOWERCASE_Z: 122,
        /* z */
        CHAR_LEFT_PARENTHESES: 40,
        /* ( */
        CHAR_RIGHT_PARENTHESES: 41,
        /* ) */
        CHAR_ASTERISK: 42,
        /* * */
        // Non-alphabetic chars.
        CHAR_AMPERSAND: 38,
        /* & */
        CHAR_AT: 64,
        /* @ */
        CHAR_BACKWARD_SLASH: 92,
        /* \ */
        CHAR_CARRIAGE_RETURN: 13,
        /* \r */
        CHAR_CIRCUMFLEX_ACCENT: 94,
        /* ^ */
        CHAR_COLON: 58,
        /* : */
        CHAR_COMMA: 44,
        /* , */
        CHAR_DOT: 46,
        /* . */
        CHAR_DOUBLE_QUOTE: 34,
        /* " */
        CHAR_EQUAL: 61,
        /* = */
        CHAR_EXCLAMATION_MARK: 33,
        /* ! */
        CHAR_FORM_FEED: 12,
        /* \f */
        CHAR_FORWARD_SLASH: 47,
        /* / */
        CHAR_GRAVE_ACCENT: 96,
        /* ` */
        CHAR_HASH: 35,
        /* # */
        CHAR_HYPHEN_MINUS: 45,
        /* - */
        CHAR_LEFT_ANGLE_BRACKET: 60,
        /* < */
        CHAR_LEFT_CURLY_BRACE: 123,
        /* { */
        CHAR_LEFT_SQUARE_BRACKET: 91,
        /* [ */
        CHAR_LINE_FEED: 10,
        /* \n */
        CHAR_NO_BREAK_SPACE: 160,
        /* \u00A0 */
        CHAR_PERCENT: 37,
        /* % */
        CHAR_PLUS: 43,
        /* + */
        CHAR_QUESTION_MARK: 63,
        /* ? */
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        /* > */
        CHAR_RIGHT_CURLY_BRACE: 125,
        /* } */
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        /* ] */
        CHAR_SEMICOLON: 59,
        /* ; */
        CHAR_SINGLE_QUOTE: 39,
        /* ' */
        CHAR_SPACE: 32,
        /*   */
        CHAR_TAB: 9,
        /* \t */
        CHAR_UNDERSCORE: 95,
        /* _ */
        CHAR_VERTICAL_LINE: 124,
        /* | */
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        /* \uFEFF */
        SEP: path6.sep,
        /**
         * Create EXTGLOB_CHARS
         */
        extglobChars(chars) {
          return {
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" }
          };
        },
        /**
         * Create GLOB_CHARS
         */
        globChars(win322) {
          return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
  var require_utils4 = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports) {
      "use strict";
      var path6 = __require2("path");
      var win322 = process.platform === "win32";
      var {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = require_constants();
      exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
      exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match3) => {
          return match3 === "\\" ? "" : match3;
        });
      };
      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports.isWindows = (options) => {
        if (options && typeof options.windows === "boolean") {
          return options.windows;
        }
        return win322 === true || path6.sep === "\\";
      };
      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports.removePrefix = (input, state = {}) => {
        let output2 = input;
        if (output2.startsWith("./")) {
          output2 = output2.slice(2);
          state.prefix = "./";
        }
        return output2;
      };
      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend = options.contains ? "" : "^";
        const append = options.contains ? "" : "$";
        let output2 = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
          output2 = `(?:^(?!${output2}).*$)`;
        }
        return output2;
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
  var require_scan = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports, module) {
      "use strict";
      var utils = require_utils4();
      var {
        CHAR_ASTERISK,
        /* * */
        CHAR_AT,
        /* @ */
        CHAR_BACKWARD_SLASH,
        /* \ */
        CHAR_COMMA,
        /* , */
        CHAR_DOT,
        /* . */
        CHAR_EXCLAMATION_MARK,
        /* ! */
        CHAR_FORWARD_SLASH,
        /* / */
        CHAR_LEFT_CURLY_BRACE,
        /* { */
        CHAR_LEFT_PARENTHESES,
        /* ( */
        CHAR_LEFT_SQUARE_BRACKET,
        /* [ */
        CHAR_PLUS,
        /* + */
        CHAR_QUESTION_MARK,
        /* ? */
        CHAR_RIGHT_CURLY_BRACE,
        /* } */
        CHAR_RIGHT_PARENTHESES,
        /* ) */
        CHAR_RIGHT_SQUARE_BRACKET
        /* ] */
      } = require_constants();
      var isPathSeparator = (code) => {
        return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
      };
      var depth = (token) => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1;
        }
      };
      var scan = (input, options) => {
        const opts = options || {};
        const length = input.length - 1;
        const scanToEnd = opts.parts === true || opts.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let negatedExtglob = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = { value: "", depth: 0, isGlob: false };
        const eos = () => index >= length;
        const peek = () => str.charCodeAt(index + 1);
        const advance = () => {
          prev = code;
          return str.charCodeAt(++index);
        };
        while (index < length) {
          code = advance();
          let next;
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true;
            }
            continue;
          }
          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                continue;
              }
              if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--;
                if (braces === 0) {
                  braceEscaped = false;
                  isBrace = token.isBrace = true;
                  finished = true;
                  break;
                }
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = { value: "", depth: 0, isGlob: false };
            if (finished === true)
              continue;
            if (prev === CHAR_DOT && index === start + 1) {
              start += 2;
              continue;
            }
            lastIndex = index + 1;
            continue;
          }
          if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true;
              isExtglob = token.isExtglob = true;
              finished = true;
              if (code === CHAR_EXCLAMATION_MARK && index === start) {
                negatedExtglob = true;
              }
              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                  }
                }
                continue;
              }
              break;
            }
          }
          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK)
              isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true;
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
          }
          if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
          if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
        if (opts.noext === true) {
          isExtglob = false;
          isGlob = false;
        }
        let base2 = str;
        let prefix = "";
        let glob2 = "";
        if (start > 0) {
          prefix = str.slice(0, start);
          str = str.slice(start);
          lastIndex -= start;
        }
        if (base2 && isGlob === true && lastIndex > 0) {
          base2 = str.slice(0, lastIndex);
          glob2 = str.slice(lastIndex);
        } else if (isGlob === true) {
          base2 = "";
          glob2 = str;
        } else {
          base2 = str;
        }
        if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
          if (isPathSeparator(base2.charCodeAt(base2.length - 1))) {
            base2 = base2.slice(0, -1);
          }
        }
        if (opts.unescape === true) {
          if (glob2)
            glob2 = utils.removeBackslashes(glob2);
          if (base2 && backslashes === true) {
            base2 = utils.removeBackslashes(base2);
          }
        }
        const state = {
          prefix,
          input,
          start,
          base: base2,
          glob: glob2,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated,
          negatedExtglob
        };
        if (opts.tokens === true) {
          state.maxDepth = 0;
          if (!isPathSeparator(code)) {
            tokens.push(token);
          }
          state.tokens = tokens;
        }
        if (opts.parts === true || opts.tokens === true) {
          let prevIndex;
          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true;
                tokens[idx].value = prefix;
              } else {
                tokens[idx].value = value;
              }
              depth(tokens[idx]);
              state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") {
              parts.push(value);
            }
            prevIndex = i;
          }
          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
              tokens[tokens.length - 1].value = value;
              depth(tokens[tokens.length - 1]);
              state.maxDepth += tokens[tokens.length - 1].depth;
            }
          }
          state.slashes = slashes;
          state.parts = parts;
        }
        return state;
      };
      module.exports = scan;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
  var require_parse = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var utils = require_utils4();
      var {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS
      } = constants;
      var expandRange = (args, options) => {
        if (typeof options.expandRange === "function") {
          return options.expandRange(...args, options);
        }
        args.sort();
        const value = `[${args.join("-")}]`;
        try {
          new RegExp(value);
        } catch (ex) {
          return args.map((v) => utils.escapeRegex(v)).join("..");
        }
        return value;
      };
      var syntaxError2 = (type3, char) => {
        return `Missing ${type3}: "${char}" - use "\\\\${char}" to match literal characters`;
      };
      var parse9 = (input, options) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        input = REPLACEMENTS[input] || input;
        const opts = { ...options };
        const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max2) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
        }
        const bos = { type: "bos", value: "", output: opts.prepend || "" };
        const tokens = [bos];
        const capture = opts.capture ? "" : "?:";
        const win322 = utils.isWindows(options);
        const PLATFORM_CHARS = constants.globChars(win322);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        } = PLATFORM_CHARS;
        const globstar = (opts2) => {
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const nodot = opts.dot ? "" : NO_DOT;
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
        let star3 = opts.bash === true ? globstar(opts) : STAR;
        if (opts.capture) {
          star3 = `(${star3})`;
        }
        if (typeof opts.noext === "boolean") {
          opts.noextglob = opts.noext;
        }
        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts.dot === true,
          consumed: "",
          output: "",
          prefix: "",
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = () => state.index === len - 1;
        const peek = state.peek = (n = 1) => input[state.index + n];
        const advance = state.advance = () => input[++state.index] || "";
        const remaining = () => input.slice(state.index + 1);
        const consume = (value2 = "", num = 0) => {
          state.consumed += value2;
          state.index += num;
        };
        const append = (token) => {
          state.output += token.output != null ? token.output : token.value;
          consume(token.value);
        };
        const negate = () => {
          let count = 1;
          while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
            advance();
            state.start++;
            count++;
          }
          if (count % 2 === 0) {
            return false;
          }
          state.negated = true;
          state.start++;
          return true;
        };
        const increment = (type3) => {
          state[type3]++;
          stack.push(type3);
        };
        const decrement = (type3) => {
          state[type3]--;
          stack.pop();
        };
        const push = (tok) => {
          if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
              state.output = state.output.slice(0, -prev.output.length);
              prev.type = "star";
              prev.value = "*";
              prev.output = star3;
              state.output += prev.output;
            }
          }
          if (extglobs.length && tok.type !== "paren") {
            extglobs[extglobs.length - 1].inner += tok.value;
          }
          if (tok.value || tok.output)
            append(tok);
          if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
          }
          tok.prev = prev;
          tokens.push(tok);
          prev = tok;
        };
        const extglobOpen = (type3, value2) => {
          const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
          token.prev = prev;
          token.parens = state.parens;
          token.output = state.output;
          const output2 = (opts.capture ? "(" : "") + token.open;
          increment("parens");
          push({ type: type3, value: value2, output: state.output ? "" : ONE_CHAR });
          push({ type: "paren", extglob: true, value: advance(), output: output2 });
          extglobs.push(token);
        };
        const extglobClose = (token) => {
          let output2 = token.close + (opts.capture ? ")" : "");
          let rest;
          if (token.type === "negate") {
            let extglobStar = star3;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
              extglobStar = globstar(opts);
            }
            if (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) {
              output2 = token.close = `)$))${extglobStar}`;
            }
            if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
              const expression = parse9(rest, { ...options, fastpaths: false }).output;
              output2 = token.close = `)${expression})${extglobStar})`;
            }
            if (token.prev.type === "bos") {
              state.negatedExtglob = true;
            }
          }
          push({ type: "paren", extglob: true, value, output: output2 });
          decrement("parens");
        };
        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false;
          let output2 = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
            if (first === "\\") {
              backslashes = true;
              return m;
            }
            if (first === "?") {
              if (esc) {
                return esc + first + (rest ? QMARK.repeat(rest.length) : "");
              }
              if (index === 0) {
                return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
              }
              return QMARK.repeat(chars.length);
            }
            if (first === ".") {
              return DOT_LITERAL.repeat(chars.length);
            }
            if (first === "*") {
              if (esc) {
                return esc + first + (rest ? star3 : "");
              }
              return star3;
            }
            return esc ? m : `\\${m}`;
          });
          if (backslashes === true) {
            if (opts.unescape === true) {
              output2 = output2.replace(/\\/g, "");
            } else {
              output2 = output2.replace(/\\+/g, (m) => {
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
              });
            }
          }
          if (output2 === input && opts.contains === true) {
            state.output = input;
            return state;
          }
          state.output = utils.wrapOutput(output2, state, options);
          return state;
        }
        while (!eos()) {
          value = advance();
          if (value === "\0") {
            continue;
          }
          if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) {
              continue;
            }
            if (next === "." || next === ";") {
              continue;
            }
            if (!next) {
              value += "\\";
              push({ type: "text", value });
              continue;
            }
            const match3 = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match3 && match3[0].length > 2) {
              slashes = match3[0].length;
              state.index += slashes;
              if (slashes % 2 !== 0) {
                value += "\\";
              }
            }
            if (opts.unescape === true) {
              value = advance();
            } else {
              value += advance();
            }
            if (state.brackets === 0) {
              push({ type: "text", value });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
              const inner = prev.value.slice(1);
              if (inner.includes("[")) {
                prev.posix = true;
                if (inner.includes(":")) {
                  const idx = prev.value.lastIndexOf("[");
                  const pre = prev.value.slice(0, idx);
                  const rest2 = prev.value.slice(idx + 2);
                  const posix3 = POSIX_REGEX_SOURCE[rest2];
                  if (posix3) {
                    prev.value = pre + posix3;
                    state.backtrack = true;
                    advance();
                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR;
                    }
                    continue;
                  }
                }
              }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
              value = `\\${value}`;
            }
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
              value = `\\${value}`;
            }
            if (opts.posix === true && value === "!" && prev.value === "[") {
              value = "^";
            }
            prev.value += value;
            append({ value });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
              push({ type: "text", value });
            }
            continue;
          }
          if (value === "(") {
            increment("parens");
            push({ type: "paren", value });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("opening", "("));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
            decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
              if (opts.nobracket !== true && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError2("closing", "]"));
              }
              value = `\\${value}`;
            } else {
              increment("brackets");
            }
            push({ type: "bracket", value });
            continue;
          }
          if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            if (state.brackets === 0) {
              if (opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError2("opening", "["));
              }
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
              value = `/${value}`;
            }
            prev.value += value;
            append({ value });
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
              continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            if (opts.literalBrackets === true) {
              state.output += escaped;
              prev.value = escaped;
              continue;
            }
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
          }
          if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
          }
          if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
              push({ type: "text", value, output: value });
              continue;
            }
            let output2 = ")";
            if (brace.dots === true) {
              const arr = tokens.slice();
              const range = [];
              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop();
                if (arr[i].type === "brace") {
                  break;
                }
                if (arr[i].type !== "dots") {
                  range.unshift(arr[i].value);
                }
              }
              output2 = expandRange(range, opts);
              state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex);
              const toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{";
              value = output2 = "\\}";
              state.output = out;
              for (const t of toks) {
                state.output += t.output || t.value;
              }
            }
            push({ type: "brace", value, output: output2 });
            decrement("braces");
            braces.pop();
            continue;
          }
          if (value === "|") {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === ",") {
            let output2 = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
              brace.comma = true;
              output2 = "|";
            }
            push({ type: "comma", value, output: output2 });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1;
              state.consumed = "";
              state.output = "";
              tokens.pop();
              prev = bos;
              continue;
            }
            push({ type: "slash", value, output: SLASH_LITERAL });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              if (prev.value === ".")
                prev.output = DOT_LITERAL;
              const brace = braces[braces.length - 1];
              prev.type = "dots";
              prev.output += value;
              prev.value += value;
              brace.dots = true;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({ type: "text", value, output: DOT_LITERAL });
              continue;
            }
            push({ type: "dot", value, output: DOT_LITERAL });
            continue;
          }
          if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              const next = peek();
              let output2 = value;
              if (next === "<" && !utils.supportsLookbehinds()) {
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              }
              if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                output2 = `\\${value}`;
              }
              push({ type: "text", value, output: output2 });
              continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
              push({ type: "qmark", value, output: QMARK_NO_DOT });
              continue;
            }
            push({ type: "qmark", value, output: QMARK });
            continue;
          }
          if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
              if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                extglobOpen("negate", value);
                continue;
              }
            }
            if (opts.nonegate !== true && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
              push({ type: "plus", value, output: PLUS_LITERAL });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({ type: "plus", value });
              continue;
            }
            push({ type: "plus", value: PLUS_LITERAL });
            continue;
          }
          if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              push({ type: "at", extglob: true, value, output: "" });
              continue;
            }
            push({ type: "text", value });
            continue;
          }
          if (value !== "*") {
            if (value === "$" || value === "^") {
              value = `\\${value}`;
            }
            const match3 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match3) {
              value += match3[0];
              state.index += match3[0].length;
            }
            push({ type: "text", value });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star3;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
          }
          let rest = remaining();
          if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts.noglobstar === true) {
              consume(value);
              continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
              push({ type: "star", value, output: "" });
              continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({ type: "star", value, output: "" });
              continue;
            }
            while (rest.slice(0, 3) === "/**") {
              const after = input[state.index + 4];
              if (after && after !== "/") {
                break;
              }
              rest = rest.slice(3);
              consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar";
              prev.value += value;
              prev.output = globstar(opts);
              state.output = prev.output;
              state.globstar = true;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
              prev.value += value;
              state.globstar = true;
              state.output += prior.output + prev.output;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
              const end = rest[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
              prev.value += value;
              state.output += prior.output + prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
              prev.type = "globstar";
              prev.value += value;
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
              state.output = prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          const token = { type: "star", value, output: star3 };
          if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") {
              token.output = nodot + token.output;
            }
            push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
          }
          if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
              state.output += NO_DOT_SLASH;
              prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
              state.output += NO_DOTS_SLASH;
              prev.output += NO_DOTS_SLASH;
            } else {
              state.output += nodot;
              prev.output += nodot;
            }
            if (peek() !== "*") {
              state.output += ONE_CHAR;
              prev.output += ONE_CHAR;
            }
          }
          push(token);
        }
        while (state.brackets > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", "]"));
          state.output = utils.escapeLast(state.output, "[");
          decrement("brackets");
        }
        while (state.parens > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", ")"));
          state.output = utils.escapeLast(state.output, "(");
          decrement("parens");
        }
        while (state.braces > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", "}"));
          state.output = utils.escapeLast(state.output, "{");
          decrement("braces");
        }
        if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
          push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
        }
        if (state.backtrack === true) {
          state.output = "";
          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
              state.output += token.suffix;
            }
          }
        }
        return state;
      };
      parse9.fastpaths = (input, options) => {
        const opts = { ...options };
        const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max2) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
        }
        input = REPLACEMENTS[input] || input;
        const win322 = utils.isWindows(options);
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR
        } = constants.globChars(win322);
        const nodot = opts.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts.capture ? "" : "?:";
        const state = { negated: false, prefix: "" };
        let star3 = opts.bash === true ? ".*?" : STAR;
        if (opts.capture) {
          star3 = `(${star3})`;
        }
        const globstar = (opts2) => {
          if (opts2.noglobstar === true)
            return star3;
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const create = (str) => {
          switch (str) {
            case "*":
              return `${nodot}${ONE_CHAR}${star3}`;
            case ".*":
              return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "*.*":
              return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "*/*":
              return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
            case "**":
              return nodot + globstar(opts);
            case "**/*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
            case "**/*.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "**/.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
            default: {
              const match3 = /^(.*?)\.(\w+)$/.exec(str);
              if (!match3)
                return;
              const source2 = create(match3[1]);
              if (!source2)
                return;
              return source2 + DOT_LITERAL + match3[2];
            }
          }
        };
        const output2 = utils.removePrefix(input, state);
        let source = create(output2);
        if (source && opts.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`;
        }
        return source;
      };
      module.exports = parse9;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
  var require_picomatch = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports, module) {
      "use strict";
      var path6 = __require2("path");
      var scan = require_scan();
      var parse9 = require_parse();
      var utils = require_utils4();
      var constants = require_constants();
      var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
      var picomatch = (glob2, options, returnState = false) => {
        if (Array.isArray(glob2)) {
          const fns = glob2.map((input) => picomatch(input, options, returnState));
          const arrayMatcher = (str) => {
            for (const isMatch of fns) {
              const state2 = isMatch(str);
              if (state2)
                return state2;
            }
            return false;
          };
          return arrayMatcher;
        }
        const isState = isObject2(glob2) && glob2.tokens && glob2.input;
        if (glob2 === "" || typeof glob2 !== "string" && !isState) {
          throw new TypeError("Expected pattern to be a non-empty string");
        }
        const opts = options || {};
        const posix3 = utils.isWindows(options);
        const regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored = () => false;
        if (opts.ignore) {
          const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
          isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
        }
        const matcher = (input, returnObject = false) => {
          const { isMatch, match: match3, output: output2 } = picomatch.test(input, regex, options, { glob: glob2, posix: posix3 });
          const result = { glob: glob2, state, regex, posix: posix3, input, output: output2, match: match3, isMatch };
          if (typeof opts.onResult === "function") {
            opts.onResult(result);
          }
          if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") {
              opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (typeof opts.onMatch === "function") {
            opts.onMatch(result);
          }
          return returnObject ? result : true;
        };
        if (returnState) {
          matcher.state = state;
        }
        return matcher;
      };
      picomatch.test = (input, regex, options, { glob: glob2, posix: posix3 } = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected input to be a string");
        }
        if (input === "") {
          return { isMatch: false, output: "" };
        }
        const opts = options || {};
        const format = opts.format || (posix3 ? utils.toPosixSlashes : null);
        let match3 = input === glob2;
        let output2 = match3 && format ? format(input) : input;
        if (match3 === false) {
          output2 = format ? format(input) : input;
          match3 = output2 === glob2;
        }
        if (match3 === false || opts.capture === true) {
          if (opts.matchBase === true || opts.basename === true) {
            match3 = picomatch.matchBase(input, regex, options, posix3);
          } else {
            match3 = regex.exec(output2);
          }
        }
        return { isMatch: Boolean(match3), match: match3, output: output2 };
      };
      picomatch.matchBase = (input, glob2, options, posix3 = utils.isWindows(options)) => {
        const regex = glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options);
        return regex.test(path6.basename(input));
      };
      picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
      picomatch.parse = (pattern, options) => {
        if (Array.isArray(pattern))
          return pattern.map((p) => picomatch.parse(p, options));
        return parse9(pattern, { ...options, fastpaths: false });
      };
      picomatch.scan = (input, options) => scan(input, options);
      picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
        if (returnOutput === true) {
          return state.output;
        }
        const opts = options || {};
        const prepend = opts.contains ? "" : "^";
        const append = opts.contains ? "" : "$";
        let source = `${prepend}(?:${state.output})${append}`;
        if (state && state.negated === true) {
          source = `^(?!${source}).*$`;
        }
        const regex = picomatch.toRegex(source, options);
        if (returnState === true) {
          regex.state = state;
        }
        return regex;
      };
      picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
        if (!input || typeof input !== "string") {
          throw new TypeError("Expected a non-empty string");
        }
        let parsed = { negated: false, fastpaths: true };
        if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
          parsed.output = parse9.fastpaths(input, options);
        }
        if (!parsed.output) {
          parsed = parse9(input, options);
        }
        return picomatch.compileRe(parsed, options, returnOutput, returnState);
      };
      picomatch.toRegex = (source, options) => {
        try {
          const opts = options || {};
          return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
        } catch (err2) {
          if (options && options.debug === true)
            throw err2;
          return /$^/;
        }
      };
      picomatch.constants = constants;
      module.exports = picomatch;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
  var require_picomatch2 = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports, module) {
      "use strict";
      module.exports = require_picomatch();
    }
  });

  // ../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js
  var require_readdirp = __commonJS({
    "../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js"(exports, module) {
      "use strict";
      var fs5 = __require2("fs");
      var { Readable: Readable2 } = __require2("stream");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var picomatch = require_picomatch2();
      var readdir4 = promisify(fs5.readdir);
      var stat4 = promisify(fs5.stat);
      var lstat6 = promisify(fs5.lstat);
      var realpath2 = promisify(fs5.realpath);
      var BANG = "!";
      var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
      var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
      var FILE_TYPE = "files";
      var DIR_TYPE = "directories";
      var FILE_DIR_TYPE = "files_directories";
      var EVERYTHING_TYPE = "all";
      var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
      var isNormalFlowError = (error3) => NORMAL_FLOW_ERRORS.has(error3.code);
      var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n) => Number.parseInt(n, 10));
      var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
      var normalizeFilter = (filter2) => {
        if (filter2 === void 0)
          return;
        if (typeof filter2 === "function")
          return filter2;
        if (typeof filter2 === "string") {
          const glob2 = picomatch(filter2.trim());
          return (entry) => glob2(entry.basename);
        }
        if (Array.isArray(filter2)) {
          const positive = [];
          const negative = [];
          for (const item of filter2) {
            const trimmed = item.trim();
            if (trimmed.charAt(0) === BANG) {
              negative.push(picomatch(trimmed.slice(1)));
            } else {
              positive.push(picomatch(trimmed));
            }
          }
          if (negative.length > 0) {
            if (positive.length > 0) {
              return (entry) => positive.some((f2) => f2(entry.basename)) && !negative.some((f2) => f2(entry.basename));
            }
            return (entry) => !negative.some((f2) => f2(entry.basename));
          }
          return (entry) => positive.some((f2) => f2(entry.basename));
        }
      };
      var ReaddirpStream = class extends Readable2 {
        static get defaultOptions() {
          return {
            root: ".",
            /* eslint-disable no-unused-vars */
            fileFilter: (path6) => true,
            directoryFilter: (path6) => true,
            /* eslint-enable no-unused-vars */
            type: FILE_TYPE,
            lstat: false,
            depth: 2147483648,
            alwaysStat: false
          };
        }
        constructor(options = {}) {
          super({
            objectMode: true,
            autoDestroy: true,
            highWaterMark: options.highWaterMark || 4096
          });
          const opts = { ...ReaddirpStream.defaultOptions, ...options };
          const { root, type: type3 } = opts;
          this._fileFilter = normalizeFilter(opts.fileFilter);
          this._directoryFilter = normalizeFilter(opts.directoryFilter);
          const statMethod = opts.lstat ? lstat6 : stat4;
          if (wantBigintFsStats) {
            this._stat = (path6) => statMethod(path6, { bigint: true });
          } else {
            this._stat = statMethod;
          }
          this._maxDepth = opts.depth;
          this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type3);
          this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type3);
          this._wantsEverything = type3 === EVERYTHING_TYPE;
          this._root = sysPath.resolve(root);
          this._isDirent = "Dirent" in fs5 && !opts.alwaysStat;
          this._statsProp = this._isDirent ? "dirent" : "stats";
          this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
          this.parents = [this._exploreDir(root, 1)];
          this.reading = false;
          this.parent = void 0;
        }
        async _read(batch) {
          if (this.reading)
            return;
          this.reading = true;
          try {
            while (!this.destroyed && batch > 0) {
              const { path: path6, depth, files = [] } = this.parent || {};
              if (files.length > 0) {
                const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path6));
                for (const entry of await Promise.all(slice)) {
                  if (this.destroyed)
                    return;
                  const entryType = await this._getEntryType(entry);
                  if (entryType === "directory" && this._directoryFilter(entry)) {
                    if (depth <= this._maxDepth) {
                      this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                    }
                    if (this._wantsDir) {
                      this.push(entry);
                      batch--;
                    }
                  } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                    if (this._wantsFile) {
                      this.push(entry);
                      batch--;
                    }
                  }
                }
              } else {
                const parent = this.parents.pop();
                if (!parent) {
                  this.push(null);
                  break;
                }
                this.parent = await parent;
                if (this.destroyed)
                  return;
              }
            }
          } catch (error3) {
            this.destroy(error3);
          } finally {
            this.reading = false;
          }
        }
        async _exploreDir(path6, depth) {
          let files;
          try {
            files = await readdir4(path6, this._rdOptions);
          } catch (error3) {
            this._onError(error3);
          }
          return { files, depth, path: path6 };
        }
        async _formatEntry(dirent, path6) {
          let entry;
          try {
            const basename4 = this._isDirent ? dirent.name : dirent;
            const fullPath = sysPath.resolve(sysPath.join(path6, basename4));
            entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename: basename4 };
            entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
          } catch (err2) {
            this._onError(err2);
          }
          return entry;
        }
        _onError(err2) {
          if (isNormalFlowError(err2) && !this.destroyed) {
            this.emit("warn", err2);
          } else {
            this.destroy(err2);
          }
        }
        async _getEntryType(entry) {
          const stats = entry && entry[this._statsProp];
          if (!stats) {
            return;
          }
          if (stats.isFile()) {
            return "file";
          }
          if (stats.isDirectory()) {
            return "directory";
          }
          if (stats && stats.isSymbolicLink()) {
            const full = entry.fullPath;
            try {
              const entryRealPath = await realpath2(full);
              const entryRealPathStats = await lstat6(entryRealPath);
              if (entryRealPathStats.isFile()) {
                return "file";
              }
              if (entryRealPathStats.isDirectory()) {
                const len = entryRealPath.length;
                if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                  const recursiveError = new Error(
                    `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                  );
                  recursiveError.code = RECURSIVE_ERROR_CODE;
                  return this._onError(recursiveError);
                }
                return "directory";
              }
            } catch (error3) {
              this._onError(error3);
            }
          }
        }
        _includeAsFile(entry) {
          const stats = entry && entry[this._statsProp];
          return stats && this._wantsEverything && !stats.isDirectory();
        }
      };
      var readdirp = (root, options = {}) => {
        let type3 = options.entryType || options.type;
        if (type3 === "both")
          type3 = FILE_DIR_TYPE;
        if (type3)
          options.type = type3;
        if (!root) {
          throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
        } else if (typeof root !== "string") {
          throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
        } else if (type3 && !ALL_TYPES.includes(type3)) {
          throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
        }
        options.root = root;
        return new ReaddirpStream(options);
      };
      var readdirpPromise = (root, options = {}) => {
        return new Promise((resolve10, reject) => {
          const files = [];
          readdirp(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve10(files)).on("error", (error3) => reject(error3));
        });
      };
      readdirp.promise = readdirpPromise;
      readdirp.ReaddirpStream = ReaddirpStream;
      readdirp.default = readdirp;
      module.exports = readdirp;
    }
  });

  // ../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
  var require_normalize_path = __commonJS({
    "../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js"(exports, module) {
      module.exports = function(path6, stripTrailing) {
        if (typeof path6 !== "string") {
          throw new TypeError("expected path to be a string");
        }
        if (path6 === "\\" || path6 === "/")
          return "/";
        var len = path6.length;
        if (len <= 1)
          return path6;
        var prefix = "";
        if (len > 4 && path6[3] === "\\") {
          var ch = path6[2];
          if ((ch === "?" || ch === ".") && path6.slice(0, 2) === "\\\\") {
            path6 = path6.slice(2);
            prefix = "//";
          }
        }
        var segs = path6.split(/[/\\]+/);
        if (stripTrailing !== false && segs[segs.length - 1] === "") {
          segs.pop();
        }
        return prefix + segs.join("/");
      };
    }
  });

  // ../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js
  var require_anymatch = __commonJS({
    "../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var picomatch = require_picomatch2();
      var normalizePath2 = require_normalize_path();
      var BANG = "!";
      var DEFAULT_OPTIONS = { returnIndex: false };
      var arrify = (item) => Array.isArray(item) ? item : [item];
      var createPattern = (matcher, options) => {
        if (typeof matcher === "function") {
          return matcher;
        }
        if (typeof matcher === "string") {
          const glob2 = picomatch(matcher, options);
          return (string2) => matcher === string2 || glob2(string2);
        }
        if (matcher instanceof RegExp) {
          return (string2) => matcher.test(string2);
        }
        return (string2) => false;
      };
      var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
        const isList = Array.isArray(args);
        const _path = isList ? args[0] : args;
        if (!isList && typeof _path !== "string") {
          throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
        }
        const path6 = normalizePath2(_path, false);
        for (let index = 0; index < negPatterns.length; index++) {
          const nglob = negPatterns[index];
          if (nglob(path6)) {
            return returnIndex ? -1 : false;
          }
        }
        const applied = isList && [path6].concat(args.slice(1));
        for (let index = 0; index < patterns.length; index++) {
          const pattern = patterns[index];
          if (isList ? pattern(...applied) : pattern(path6)) {
            return returnIndex ? index : true;
          }
        }
        return returnIndex ? -1 : false;
      };
      var anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
        if (matchers == null) {
          throw new TypeError("anymatch: specify first argument");
        }
        const opts = typeof options === "boolean" ? { returnIndex: options } : options;
        const returnIndex = opts.returnIndex || false;
        const mtchers = arrify(matchers);
        const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
        const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
        if (testString == null) {
          return (testString2, ri = false) => {
            const returnIndex2 = typeof ri === "boolean" ? ri : false;
            return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
          };
        }
        return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
      };
      anymatch.default = anymatch;
      module.exports = anymatch;
    }
  });

  // ../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
  var require_is_extglob = __commonJS({
    "../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js"(exports, module) {
      module.exports = function isExtglob(str) {
        if (typeof str !== "string" || str === "") {
          return false;
        }
        var match3;
        while (match3 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
          if (match3[2])
            return true;
          str = str.slice(match3.index + match3[0].length);
        }
        return false;
      };
    }
  });

  // ../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js
  var require_is_glob = __commonJS({
    "../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js"(exports, module) {
      var isExtglob = require_is_extglob();
      var chars = { "{": "}", "(": ")", "[": "]" };
      var strictCheck = function(str) {
        if (str[0] === "!") {
          return true;
        }
        var index = 0;
        var pipeIndex = -2;
        var closeSquareIndex = -2;
        var closeCurlyIndex = -2;
        var closeParenIndex = -2;
        var backSlashIndex = -2;
        while (index < str.length) {
          if (str[index] === "*") {
            return true;
          }
          if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
            return true;
          }
          if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
            if (closeSquareIndex < index) {
              closeSquareIndex = str.indexOf("]", index);
            }
            if (closeSquareIndex > index) {
              if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                return true;
              }
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                return true;
              }
            }
          }
          if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
            closeCurlyIndex = str.indexOf("}", index);
            if (closeCurlyIndex > index) {
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
                return true;
              }
            }
          }
          if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
            closeParenIndex = str.indexOf(")", index);
            if (closeParenIndex > index) {
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
          if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
            if (pipeIndex < index) {
              pipeIndex = str.indexOf("|", index);
            }
            if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
              closeParenIndex = str.indexOf(")", pipeIndex);
              if (closeParenIndex > pipeIndex) {
                backSlashIndex = str.indexOf("\\", pipeIndex);
                if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                  return true;
                }
              }
            }
          }
          if (str[index] === "\\") {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
              var n = str.indexOf(close, index);
              if (n !== -1) {
                index = n + 1;
              }
            }
            if (str[index] === "!") {
              return true;
            }
          } else {
            index++;
          }
        }
        return false;
      };
      var relaxedCheck = function(str) {
        if (str[0] === "!") {
          return true;
        }
        var index = 0;
        while (index < str.length) {
          if (/[*?{}()[\]]/.test(str[index])) {
            return true;
          }
          if (str[index] === "\\") {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
              var n = str.indexOf(close, index);
              if (n !== -1) {
                index = n + 1;
              }
            }
            if (str[index] === "!") {
              return true;
            }
          } else {
            index++;
          }
        }
        return false;
      };
      module.exports = function isGlob(str, options) {
        if (typeof str !== "string" || str === "") {
          return false;
        }
        if (isExtglob(str)) {
          return true;
        }
        var check = strictCheck;
        if (options && options.strict === false) {
          check = relaxedCheck;
        }
        return check(str);
      };
    }
  });

  // ../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
  var require_glob_parent = __commonJS({
    "../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js"(exports, module) {
      "use strict";
      var isGlob = require_is_glob();
      var pathPosixDirname = __require2("path").posix.dirname;
      var isWin32 = __require2("os").platform() === "win32";
      var slash = "/";
      var backslash = /\\/g;
      var enclosure = /[\{\[].*[\}\]]$/;
      var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
      var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
      module.exports = function globParent(str, opts) {
        var options = Object.assign({ flipBackslashes: true }, opts);
        if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
          str = str.replace(backslash, slash);
        }
        if (enclosure.test(str)) {
          str += slash;
        }
        str += "a";
        do {
          str = pathPosixDirname(str);
        } while (isGlob(str) || globby.test(str));
        return str.replace(escaped, "$1");
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/utils.js
  var require_utils5 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/utils.js"(exports) {
      "use strict";
      exports.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports.find = (node2, type3) => node2.nodes.find((node3) => node3.type === type3);
      exports.exceedsLimit = (min, max2, step = 1, limit) => {
        if (limit === false)
          return false;
        if (!exports.isInteger(min) || !exports.isInteger(max2))
          return false;
        return (Number(max2) - Number(min)) / Number(step) >= limit;
      };
      exports.escapeNode = (block2, n = 0, type3) => {
        const node2 = block2.nodes[n];
        if (!node2)
          return;
        if (type3 && node2.type === type3 || node2.type === "open" || node2.type === "close") {
          if (node2.escaped !== true) {
            node2.value = "\\" + node2.value;
            node2.escaped = true;
          }
        }
      };
      exports.encloseBrace = (node2) => {
        if (node2.type !== "brace")
          return false;
        if (node2.commas >> 0 + node2.ranges >> 0 === 0) {
          node2.invalid = true;
          return true;
        }
        return false;
      };
      exports.isInvalidBrace = (block2) => {
        if (block2.type !== "brace")
          return false;
        if (block2.invalid === true || block2.dollar)
          return true;
        if (block2.commas >> 0 + block2.ranges >> 0 === 0) {
          block2.invalid = true;
          return true;
        }
        if (block2.open !== true || block2.close !== true) {
          block2.invalid = true;
          return true;
        }
        return false;
      };
      exports.isOpenOrClose = (node2) => {
        if (node2.type === "open" || node2.type === "close") {
          return true;
        }
        return node2.open === true || node2.close === true;
      };
      exports.reduce = (nodes) => nodes.reduce((acc, node2) => {
        if (node2.type === "text")
          acc.push(node2.value);
        if (node2.type === "range")
          node2.type = "text";
        return acc;
      }, []);
      exports.flatten = (...args) => {
        const result = [];
        const flat = (arr) => {
          for (let i = 0; i < arr.length; i++) {
            const ele = arr[i];
            if (Array.isArray(ele)) {
              flat(ele);
              continue;
            }
            if (ele !== void 0) {
              result.push(ele);
            }
          }
          return result;
        };
        flat(args);
        return result;
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/stringify.js
  var require_stringify = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/stringify.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      module.exports = (ast, options = {}) => {
        const stringify3 = (node2, parent = {}) => {
          const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
          const invalidNode = node2.invalid === true && options.escapeInvalid === true;
          let output2 = "";
          if (node2.value) {
            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node2)) {
              return "\\" + node2.value;
            }
            return node2.value;
          }
          if (node2.value) {
            return node2.value;
          }
          if (node2.nodes) {
            for (const child of node2.nodes) {
              output2 += stringify3(child);
            }
          }
          return output2;
        };
        return stringify3(ast);
      };
    }
  });

  // ../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
  var require_is_number = __commonJS({
    "../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js"(exports, module) {
      "use strict";
      module.exports = function(num) {
        if (typeof num === "number") {
          return num - num === 0;
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
        }
        return false;
      };
    }
  });

  // ../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
  var require_to_regex_range = __commonJS({
    "../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"(exports, module) {
      "use strict";
      var isNumber = require_is_number();
      var toRegexRange = (min, max2, options) => {
        if (isNumber(min) === false) {
          throw new TypeError("toRegexRange: expected the first argument to be a number");
        }
        if (max2 === void 0 || min === max2) {
          return String(min);
        }
        if (isNumber(max2) === false) {
          throw new TypeError("toRegexRange: expected the second argument to be a number.");
        }
        let opts = { relaxZeros: true, ...options };
        if (typeof opts.strictZeros === "boolean") {
          opts.relaxZeros = opts.strictZeros === false;
        }
        let relax = String(opts.relaxZeros);
        let shorthand = String(opts.shorthand);
        let capture = String(opts.capture);
        let wrap3 = String(opts.wrap);
        let cacheKey = min + ":" + max2 + "=" + relax + shorthand + capture + wrap3;
        if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
          return toRegexRange.cache[cacheKey].result;
        }
        let a = Math.min(min, max2);
        let b = Math.max(min, max2);
        if (Math.abs(a - b) === 1) {
          let result = min + "|" + max2;
          if (opts.capture) {
            return `(${result})`;
          }
          if (opts.wrap === false) {
            return result;
          }
          return `(?:${result})`;
        }
        let isPadded = hasPadding(min) || hasPadding(max2);
        let state = { min, max: max2, a, b };
        let positives = [];
        let negatives = [];
        if (isPadded) {
          state.isPadded = isPadded;
          state.maxLen = String(state.max).length;
        }
        if (a < 0) {
          let newMin = b < 0 ? Math.abs(b) : 1;
          negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
          a = state.a = 0;
        }
        if (b >= 0) {
          positives = splitToPatterns(a, b, state, opts);
        }
        state.negatives = negatives;
        state.positives = positives;
        state.result = collatePatterns(negatives, positives, opts);
        if (opts.capture === true) {
          state.result = `(${state.result})`;
        } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
          state.result = `(?:${state.result})`;
        }
        toRegexRange.cache[cacheKey] = state;
        return state.result;
      };
      function collatePatterns(neg, pos, options) {
        let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
        let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
        let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
        let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
        return subpatterns.join("|");
      }
      function splitToRanges(min, max2) {
        let nines = 1;
        let zeros = 1;
        let stop = countNines(min, nines);
        let stops = /* @__PURE__ */ new Set([max2]);
        while (min <= stop && stop <= max2) {
          stops.add(stop);
          nines += 1;
          stop = countNines(min, nines);
        }
        stop = countZeros(max2 + 1, zeros) - 1;
        while (min < stop && stop <= max2) {
          stops.add(stop);
          zeros += 1;
          stop = countZeros(max2 + 1, zeros) - 1;
        }
        stops = [...stops];
        stops.sort(compare);
        return stops;
      }
      function rangeToPattern(start, stop, options) {
        if (start === stop) {
          return { pattern: start, count: [], digits: 0 };
        }
        let zipped = zip(start, stop);
        let digits = zipped.length;
        let pattern = "";
        let count = 0;
        for (let i = 0; i < digits; i++) {
          let [startDigit, stopDigit] = zipped[i];
          if (startDigit === stopDigit) {
            pattern += startDigit;
          } else if (startDigit !== "0" || stopDigit !== "9") {
            pattern += toCharacterClass(startDigit, stopDigit, options);
          } else {
            count++;
          }
        }
        if (count) {
          pattern += options.shorthand === true ? "\\d" : "[0-9]";
        }
        return { pattern, count: [count], digits };
      }
      function splitToPatterns(min, max2, tok, options) {
        let ranges = splitToRanges(min, max2);
        let tokens = [];
        let start = min;
        let prev;
        for (let i = 0; i < ranges.length; i++) {
          let max3 = ranges[i];
          let obj = rangeToPattern(String(start), String(max3), options);
          let zeros = "";
          if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.count.length > 1) {
              prev.count.pop();
            }
            prev.count.push(obj.count[0]);
            prev.string = prev.pattern + toQuantifier(prev.count);
            start = max3 + 1;
            continue;
          }
          if (tok.isPadded) {
            zeros = padZeros(max3, tok, options);
          }
          obj.string = zeros + obj.pattern + toQuantifier(obj.count);
          tokens.push(obj);
          start = max3 + 1;
          prev = obj;
        }
        return tokens;
      }
      function filterPatterns(arr, comparison, prefix, intersection, options) {
        let result = [];
        for (let ele of arr) {
          let { string: string2 } = ele;
          if (!intersection && !contains3(comparison, "string", string2)) {
            result.push(prefix + string2);
          }
          if (intersection && contains3(comparison, "string", string2)) {
            result.push(prefix + string2);
          }
        }
        return result;
      }
      function zip(a, b) {
        let arr = [];
        for (let i = 0; i < a.length; i++)
          arr.push([a[i], b[i]]);
        return arr;
      }
      function compare(a, b) {
        return a > b ? 1 : b > a ? -1 : 0;
      }
      function contains3(arr, key, val) {
        return arr.some((ele) => ele[key] === val);
      }
      function countNines(min, len) {
        return Number(String(min).slice(0, -len) + "9".repeat(len));
      }
      function countZeros(integer, zeros) {
        return integer - integer % Math.pow(10, zeros);
      }
      function toQuantifier(digits) {
        let [start = 0, stop = ""] = digits;
        if (stop || start > 1) {
          return `{${start + (stop ? "," + stop : "")}}`;
        }
        return "";
      }
      function toCharacterClass(a, b, options) {
        return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
      }
      function hasPadding(str) {
        return /^-?(0+)\d/.test(str);
      }
      function padZeros(value, tok, options) {
        if (!tok.isPadded) {
          return value;
        }
        let diff = Math.abs(tok.maxLen - String(value).length);
        let relax = options.relaxZeros !== false;
        switch (diff) {
          case 0:
            return "";
          case 1:
            return relax ? "0?" : "0";
          case 2:
            return relax ? "0{0,2}" : "00";
          default: {
            return relax ? `0{0,${diff}}` : `0{${diff}}`;
          }
        }
      }
      toRegexRange.cache = {};
      toRegexRange.clearCache = () => toRegexRange.cache = {};
      module.exports = toRegexRange;
    }
  });

  // ../../node_modules/.pnpm/fill-range@7.1.1/node_modules/fill-range/index.js
  var require_fill_range = __commonJS({
    "../../node_modules/.pnpm/fill-range@7.1.1/node_modules/fill-range/index.js"(exports, module) {
      "use strict";
      var util = __require2("util");
      var toRegexRange = require_to_regex_range();
      var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      var transform = (toNumber3) => {
        return (value) => toNumber3 === true ? Number(value) : String(value);
      };
      var isValidValue = (value) => {
        return typeof value === "number" || typeof value === "string" && value !== "";
      };
      var isNumber = (num) => Number.isInteger(+num);
      var zeros = (input) => {
        let value = `${input}`;
        let index = -1;
        if (value[0] === "-")
          value = value.slice(1);
        if (value === "0")
          return false;
        while (value[++index] === "0")
          ;
        return index > 0;
      };
      var stringify3 = (start, end, options) => {
        if (typeof start === "string" || typeof end === "string") {
          return true;
        }
        return options.stringify === true;
      };
      var pad = (input, maxLength, toNumber3) => {
        if (maxLength > 0) {
          let dash = input[0] === "-" ? "-" : "";
          if (dash)
            input = input.slice(1);
          input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
        }
        if (toNumber3 === false) {
          return String(input);
        }
        return input;
      };
      var toMaxLen = (input, maxLength) => {
        let negative = input[0] === "-" ? "-" : "";
        if (negative) {
          input = input.slice(1);
          maxLength--;
        }
        while (input.length < maxLength)
          input = "0" + input;
        return negative ? "-" + input : input;
      };
      var toSequence = (parts, options, maxLen) => {
        parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
        parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
        let prefix = options.capture ? "" : "?:";
        let positives = "";
        let negatives = "";
        let result;
        if (parts.positives.length) {
          positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
        }
        if (parts.negatives.length) {
          negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
        }
        if (positives && negatives) {
          result = `${positives}|${negatives}`;
        } else {
          result = positives || negatives;
        }
        if (options.wrap) {
          return `(${prefix}${result})`;
        }
        return result;
      };
      var toRange = (a, b, isNumbers, options) => {
        if (isNumbers) {
          return toRegexRange(a, b, { wrap: false, ...options });
        }
        let start = String.fromCharCode(a);
        if (a === b)
          return start;
        let stop = String.fromCharCode(b);
        return `[${start}-${stop}]`;
      };
      var toRegex = (start, end, options) => {
        if (Array.isArray(start)) {
          let wrap3 = options.wrap === true;
          let prefix = options.capture ? "" : "?:";
          return wrap3 ? `(${prefix}${start.join("|")})` : start.join("|");
        }
        return toRegexRange(start, end, options);
      };
      var rangeError = (...args) => {
        return new RangeError("Invalid range arguments: " + util.inspect(...args));
      };
      var invalidRange = (start, end, options) => {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      };
      var invalidStep = (step, options) => {
        if (options.strictRanges === true) {
          throw new TypeError(`Expected step "${step}" to be a number`);
        }
        return [];
      };
      var fillNumbers = (start, end, step = 1, options = {}) => {
        let a = Number(start);
        let b = Number(end);
        if (!Number.isInteger(a) || !Number.isInteger(b)) {
          if (options.strictRanges === true)
            throw rangeError([start, end]);
          return [];
        }
        if (a === 0)
          a = 0;
        if (b === 0)
          b = 0;
        let descending = a > b;
        let startString = String(start);
        let endString = String(end);
        let stepString = String(step);
        step = Math.max(Math.abs(step), 1);
        let padded = zeros(startString) || zeros(endString) || zeros(stepString);
        let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
        let toNumber3 = padded === false && stringify3(start, end, options) === false;
        let format = options.transform || transform(toNumber3);
        if (options.toRegex && step === 1) {
          return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
        }
        let parts = { negatives: [], positives: [] };
        let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
        let range = [];
        let index = 0;
        while (descending ? a >= b : a <= b) {
          if (options.toRegex === true && step > 1) {
            push(a);
          } else {
            range.push(pad(format(a, index), maxLen, toNumber3));
          }
          a = descending ? a - step : a + step;
          index++;
        }
        if (options.toRegex === true) {
          return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, { wrap: false, ...options });
        }
        return range;
      };
      var fillLetters = (start, end, step = 1, options = {}) => {
        if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
          return invalidRange(start, end, options);
        }
        let format = options.transform || ((val) => String.fromCharCode(val));
        let a = `${start}`.charCodeAt(0);
        let b = `${end}`.charCodeAt(0);
        let descending = a > b;
        let min = Math.min(a, b);
        let max2 = Math.max(a, b);
        if (options.toRegex && step === 1) {
          return toRange(min, max2, false, options);
        }
        let range = [];
        let index = 0;
        while (descending ? a >= b : a <= b) {
          range.push(format(a, index));
          a = descending ? a - step : a + step;
          index++;
        }
        if (options.toRegex === true) {
          return toRegex(range, null, { wrap: false, options });
        }
        return range;
      };
      var fill = (start, end, step, options = {}) => {
        if (end == null && isValidValue(start)) {
          return [start];
        }
        if (!isValidValue(start) || !isValidValue(end)) {
          return invalidRange(start, end, options);
        }
        if (typeof step === "function") {
          return fill(start, end, 1, { transform: step });
        }
        if (isObject2(step)) {
          return fill(start, end, 0, step);
        }
        let opts = { ...options };
        if (opts.capture === true)
          opts.wrap = true;
        step = step || opts.step || 1;
        if (!isNumber(step)) {
          if (step != null && !isObject2(step))
            return invalidStep(step, opts);
          return fill(start, end, 1, step);
        }
        if (isNumber(start) && isNumber(end)) {
          return fillNumbers(start, end, step, opts);
        }
        return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
      };
      module.exports = fill;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/compile.js
  var require_compile = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/compile.js"(exports, module) {
      "use strict";
      var fill = require_fill_range();
      var utils = require_utils5();
      var compile = (ast, options = {}) => {
        const walk = (node2, parent = {}) => {
          const invalidBlock = utils.isInvalidBrace(parent);
          const invalidNode = node2.invalid === true && options.escapeInvalid === true;
          const invalid = invalidBlock === true || invalidNode === true;
          const prefix = options.escapeInvalid === true ? "\\" : "";
          let output2 = "";
          if (node2.isOpen === true) {
            return prefix + node2.value;
          }
          if (node2.isClose === true) {
            console.log("node.isClose", prefix, node2.value);
            return prefix + node2.value;
          }
          if (node2.type === "open") {
            return invalid ? prefix + node2.value : "(";
          }
          if (node2.type === "close") {
            return invalid ? prefix + node2.value : ")";
          }
          if (node2.type === "comma") {
            return node2.prev.type === "comma" ? "" : invalid ? node2.value : "|";
          }
          if (node2.value) {
            return node2.value;
          }
          if (node2.nodes && node2.ranges > 0) {
            const args = utils.reduce(node2.nodes);
            const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
            if (range.length !== 0) {
              return args.length > 1 && range.length > 1 ? `(${range})` : range;
            }
          }
          if (node2.nodes) {
            for (const child of node2.nodes) {
              output2 += walk(child, node2);
            }
          }
          return output2;
        };
        return walk(ast);
      };
      module.exports = compile;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/expand.js
  var require_expand = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/expand.js"(exports, module) {
      "use strict";
      var fill = require_fill_range();
      var stringify3 = require_stringify();
      var utils = require_utils5();
      var append = (queue = "", stash = "", enclose = false) => {
        const result = [];
        queue = [].concat(queue);
        stash = [].concat(stash);
        if (!stash.length)
          return queue;
        if (!queue.length) {
          return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
        }
        for (const item of queue) {
          if (Array.isArray(item)) {
            for (const value of item) {
              result.push(append(value, stash, enclose));
            }
          } else {
            for (let ele of stash) {
              if (enclose === true && typeof ele === "string")
                ele = `{${ele}}`;
              result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
            }
          }
        }
        return utils.flatten(result);
      };
      var expand2 = (ast, options = {}) => {
        const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
        const walk = (node2, parent = {}) => {
          node2.queue = [];
          let p = parent;
          let q = parent.queue;
          while (p.type !== "brace" && p.type !== "root" && p.parent) {
            p = p.parent;
            q = p.queue;
          }
          if (node2.invalid || node2.dollar) {
            q.push(append(q.pop(), stringify3(node2, options)));
            return;
          }
          if (node2.type === "brace" && node2.invalid !== true && node2.nodes.length === 2) {
            q.push(append(q.pop(), ["{}"]));
            return;
          }
          if (node2.nodes && node2.ranges > 0) {
            const args = utils.reduce(node2.nodes);
            if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
              throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
            }
            let range = fill(...args, options);
            if (range.length === 0) {
              range = stringify3(node2, options);
            }
            q.push(append(q.pop(), range));
            node2.nodes = [];
            return;
          }
          const enclose = utils.encloseBrace(node2);
          let queue = node2.queue;
          let block2 = node2;
          while (block2.type !== "brace" && block2.type !== "root" && block2.parent) {
            block2 = block2.parent;
            queue = block2.queue;
          }
          for (let i = 0; i < node2.nodes.length; i++) {
            const child = node2.nodes[i];
            if (child.type === "comma" && node2.type === "brace") {
              if (i === 1)
                queue.push("");
              queue.push("");
              continue;
            }
            if (child.type === "close") {
              q.push(append(q.pop(), queue, enclose));
              continue;
            }
            if (child.value && child.type !== "open") {
              queue.push(append(queue.pop(), child.value));
              continue;
            }
            if (child.nodes) {
              walk(child, node2);
            }
          }
          return queue;
        };
        return utils.flatten(walk(ast));
      };
      module.exports = expand2;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/constants.js
  var require_constants2 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        MAX_LENGTH: 1e4,
        // Digits
        CHAR_0: "0",
        /* 0 */
        CHAR_9: "9",
        /* 9 */
        // Alphabet chars.
        CHAR_UPPERCASE_A: "A",
        /* A */
        CHAR_LOWERCASE_A: "a",
        /* a */
        CHAR_UPPERCASE_Z: "Z",
        /* Z */
        CHAR_LOWERCASE_Z: "z",
        /* z */
        CHAR_LEFT_PARENTHESES: "(",
        /* ( */
        CHAR_RIGHT_PARENTHESES: ")",
        /* ) */
        CHAR_ASTERISK: "*",
        /* * */
        // Non-alphabetic chars.
        CHAR_AMPERSAND: "&",
        /* & */
        CHAR_AT: "@",
        /* @ */
        CHAR_BACKSLASH: "\\",
        /* \ */
        CHAR_BACKTICK: "`",
        /* ` */
        CHAR_CARRIAGE_RETURN: "\r",
        /* \r */
        CHAR_CIRCUMFLEX_ACCENT: "^",
        /* ^ */
        CHAR_COLON: ":",
        /* : */
        CHAR_COMMA: ",",
        /* , */
        CHAR_DOLLAR: "$",
        /* . */
        CHAR_DOT: ".",
        /* . */
        CHAR_DOUBLE_QUOTE: '"',
        /* " */
        CHAR_EQUAL: "=",
        /* = */
        CHAR_EXCLAMATION_MARK: "!",
        /* ! */
        CHAR_FORM_FEED: "\f",
        /* \f */
        CHAR_FORWARD_SLASH: "/",
        /* / */
        CHAR_HASH: "#",
        /* # */
        CHAR_HYPHEN_MINUS: "-",
        /* - */
        CHAR_LEFT_ANGLE_BRACKET: "<",
        /* < */
        CHAR_LEFT_CURLY_BRACE: "{",
        /* { */
        CHAR_LEFT_SQUARE_BRACKET: "[",
        /* [ */
        CHAR_LINE_FEED: "\n",
        /* \n */
        CHAR_NO_BREAK_SPACE: "\xA0",
        /* \u00A0 */
        CHAR_PERCENT: "%",
        /* % */
        CHAR_PLUS: "+",
        /* + */
        CHAR_QUESTION_MARK: "?",
        /* ? */
        CHAR_RIGHT_ANGLE_BRACKET: ">",
        /* > */
        CHAR_RIGHT_CURLY_BRACE: "}",
        /* } */
        CHAR_RIGHT_SQUARE_BRACKET: "]",
        /* ] */
        CHAR_SEMICOLON: ";",
        /* ; */
        CHAR_SINGLE_QUOTE: "'",
        /* ' */
        CHAR_SPACE: " ",
        /*   */
        CHAR_TAB: "	",
        /* \t */
        CHAR_UNDERSCORE: "_",
        /* _ */
        CHAR_VERTICAL_LINE: "|",
        /* | */
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
        /* \uFEFF */
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/parse.js
  var require_parse2 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/parse.js"(exports, module) {
      "use strict";
      var stringify3 = require_stringify();
      var {
        MAX_LENGTH,
        CHAR_BACKSLASH,
        /* \ */
        CHAR_BACKTICK,
        /* ` */
        CHAR_COMMA,
        /* , */
        CHAR_DOT,
        /* . */
        CHAR_LEFT_PARENTHESES,
        /* ( */
        CHAR_RIGHT_PARENTHESES,
        /* ) */
        CHAR_LEFT_CURLY_BRACE,
        /* { */
        CHAR_RIGHT_CURLY_BRACE,
        /* } */
        CHAR_LEFT_SQUARE_BRACKET,
        /* [ */
        CHAR_RIGHT_SQUARE_BRACKET,
        /* ] */
        CHAR_DOUBLE_QUOTE,
        /* " */
        CHAR_SINGLE_QUOTE,
        /* ' */
        CHAR_NO_BREAK_SPACE,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE
      } = require_constants2();
      var parse9 = (input, options = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        const opts = options || {};
        const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        if (input.length > max2) {
          throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
        }
        const ast = { type: "root", input, nodes: [] };
        const stack = [ast];
        let block2 = ast;
        let prev = ast;
        let brackets = 0;
        const length = input.length;
        let index = 0;
        let depth = 0;
        let value;
        const advance = () => input[index++];
        const push = (node2) => {
          if (node2.type === "text" && prev.type === "dot") {
            prev.type = "text";
          }
          if (prev && prev.type === "text" && node2.type === "text") {
            prev.value += node2.value;
            return;
          }
          block2.nodes.push(node2);
          node2.parent = block2;
          node2.prev = prev;
          prev = node2;
          return node2;
        };
        push({ type: "bos" });
        while (index < length) {
          block2 = stack[stack.length - 1];
          value = advance();
          if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
            continue;
          }
          if (value === CHAR_BACKSLASH) {
            push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
            continue;
          }
          if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({ type: "text", value: "\\" + value });
            continue;
          }
          if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            let next;
            while (index < length && (next = advance())) {
              value += next;
              if (next === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                continue;
              }
              if (next === CHAR_BACKSLASH) {
                value += advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                brackets--;
                if (brackets === 0) {
                  break;
                }
              }
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_PARENTHESES) {
            block2 = push({ type: "paren", nodes: [] });
            stack.push(block2);
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_RIGHT_PARENTHESES) {
            if (block2.type !== "paren") {
              push({ type: "text", value });
              continue;
            }
            block2 = stack.pop();
            push({ type: "text", value });
            block2 = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            const open = value;
            let next;
            if (options.keepQuotes !== true) {
              value = "";
            }
            while (index < length && (next = advance())) {
              if (next === CHAR_BACKSLASH) {
                value += next + advance();
                continue;
              }
              if (next === open) {
                if (options.keepQuotes === true)
                  value += next;
                break;
              }
              value += next;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            const dollar = prev.value && prev.value.slice(-1) === "$" || block2.dollar === true;
            const brace = {
              type: "brace",
              open: true,
              close: false,
              dollar,
              depth,
              commas: 0,
              ranges: 0,
              nodes: []
            };
            block2 = push(brace);
            stack.push(block2);
            push({ type: "open", value });
            continue;
          }
          if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block2.type !== "brace") {
              push({ type: "text", value });
              continue;
            }
            const type3 = "close";
            block2 = stack.pop();
            block2.close = true;
            push({ type: type3, value });
            depth--;
            block2 = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_COMMA && depth > 0) {
            if (block2.ranges > 0) {
              block2.ranges = 0;
              const open = block2.nodes.shift();
              block2.nodes = [open, { type: "text", value: stringify3(block2) }];
            }
            push({ type: "comma", value });
            block2.commas++;
            continue;
          }
          if (value === CHAR_DOT && depth > 0 && block2.commas === 0) {
            const siblings = block2.nodes;
            if (depth === 0 || siblings.length === 0) {
              push({ type: "text", value });
              continue;
            }
            if (prev.type === "dot") {
              block2.range = [];
              prev.value += value;
              prev.type = "range";
              if (block2.nodes.length !== 3 && block2.nodes.length !== 5) {
                block2.invalid = true;
                block2.ranges = 0;
                prev.type = "text";
                continue;
              }
              block2.ranges++;
              block2.args = [];
              continue;
            }
            if (prev.type === "range") {
              siblings.pop();
              const before = siblings[siblings.length - 1];
              before.value += prev.value + value;
              prev = before;
              block2.ranges--;
              continue;
            }
            push({ type: "dot", value });
            continue;
          }
          push({ type: "text", value });
        }
        do {
          block2 = stack.pop();
          if (block2.type !== "root") {
            block2.nodes.forEach((node2) => {
              if (!node2.nodes) {
                if (node2.type === "open")
                  node2.isOpen = true;
                if (node2.type === "close")
                  node2.isClose = true;
                if (!node2.nodes)
                  node2.type = "text";
                node2.invalid = true;
              }
            });
            const parent = stack[stack.length - 1];
            const index2 = parent.nodes.indexOf(block2);
            parent.nodes.splice(index2, 1, ...block2.nodes);
          }
        } while (stack.length > 0);
        push({ type: "eos" });
        return ast;
      };
      module.exports = parse9;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/index.js
  var require_braces = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/index.js"(exports, module) {
      "use strict";
      var stringify3 = require_stringify();
      var compile = require_compile();
      var expand2 = require_expand();
      var parse9 = require_parse2();
      var braces = (input, options = {}) => {
        let output2 = [];
        if (Array.isArray(input)) {
          for (const pattern of input) {
            const result = braces.create(pattern, options);
            if (Array.isArray(result)) {
              output2.push(...result);
            } else {
              output2.push(result);
            }
          }
        } else {
          output2 = [].concat(braces.create(input, options));
        }
        if (options && options.expand === true && options.nodupes === true) {
          output2 = [...new Set(output2)];
        }
        return output2;
      };
      braces.parse = (input, options = {}) => parse9(input, options);
      braces.stringify = (input, options = {}) => {
        if (typeof input === "string") {
          return stringify3(braces.parse(input, options), options);
        }
        return stringify3(input, options);
      };
      braces.compile = (input, options = {}) => {
        if (typeof input === "string") {
          input = braces.parse(input, options);
        }
        return compile(input, options);
      };
      braces.expand = (input, options = {}) => {
        if (typeof input === "string") {
          input = braces.parse(input, options);
        }
        let result = expand2(input, options);
        if (options.noempty === true) {
          result = result.filter(Boolean);
        }
        if (options.nodupes === true) {
          result = [...new Set(result)];
        }
        return result;
      };
      braces.create = (input, options = {}) => {
        if (input === "" || input.length < 3) {
          return [input];
        }
        return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
      };
      module.exports = braces;
    }
  });

  // ../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/binary-extensions.json
  var require_binary_extensions = __commonJS({
    "../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/binary-extensions.json"(exports, module) {
      module.exports = [
        "3dm",
        "3ds",
        "3g2",
        "3gp",
        "7z",
        "a",
        "aac",
        "adp",
        "ai",
        "aif",
        "aiff",
        "alz",
        "ape",
        "apk",
        "appimage",
        "ar",
        "arj",
        "asf",
        "au",
        "avi",
        "bak",
        "baml",
        "bh",
        "bin",
        "bk",
        "bmp",
        "btif",
        "bz2",
        "bzip2",
        "cab",
        "caf",
        "cgm",
        "class",
        "cmx",
        "cpio",
        "cr2",
        "cur",
        "dat",
        "dcm",
        "deb",
        "dex",
        "djvu",
        "dll",
        "dmg",
        "dng",
        "doc",
        "docm",
        "docx",
        "dot",
        "dotm",
        "dra",
        "DS_Store",
        "dsk",
        "dts",
        "dtshd",
        "dvb",
        "dwg",
        "dxf",
        "ecelp4800",
        "ecelp7470",
        "ecelp9600",
        "egg",
        "eol",
        "eot",
        "epub",
        "exe",
        "f4v",
        "fbs",
        "fh",
        "fla",
        "flac",
        "flatpak",
        "fli",
        "flv",
        "fpx",
        "fst",
        "fvt",
        "g3",
        "gh",
        "gif",
        "graffle",
        "gz",
        "gzip",
        "h261",
        "h263",
        "h264",
        "icns",
        "ico",
        "ief",
        "img",
        "ipa",
        "iso",
        "jar",
        "jpeg",
        "jpg",
        "jpgv",
        "jpm",
        "jxr",
        "key",
        "ktx",
        "lha",
        "lib",
        "lvp",
        "lz",
        "lzh",
        "lzma",
        "lzo",
        "m3u",
        "m4a",
        "m4v",
        "mar",
        "mdi",
        "mht",
        "mid",
        "midi",
        "mj2",
        "mka",
        "mkv",
        "mmr",
        "mng",
        "mobi",
        "mov",
        "movie",
        "mp3",
        "mp4",
        "mp4a",
        "mpeg",
        "mpg",
        "mpga",
        "mxu",
        "nef",
        "npx",
        "numbers",
        "nupkg",
        "o",
        "odp",
        "ods",
        "odt",
        "oga",
        "ogg",
        "ogv",
        "otf",
        "ott",
        "pages",
        "pbm",
        "pcx",
        "pdb",
        "pdf",
        "pea",
        "pgm",
        "pic",
        "png",
        "pnm",
        "pot",
        "potm",
        "potx",
        "ppa",
        "ppam",
        "ppm",
        "pps",
        "ppsm",
        "ppsx",
        "ppt",
        "pptm",
        "pptx",
        "psd",
        "pya",
        "pyc",
        "pyo",
        "pyv",
        "qt",
        "rar",
        "ras",
        "raw",
        "resources",
        "rgb",
        "rip",
        "rlc",
        "rmf",
        "rmvb",
        "rpm",
        "rtf",
        "rz",
        "s3m",
        "s7z",
        "scpt",
        "sgi",
        "shar",
        "snap",
        "sil",
        "sketch",
        "slk",
        "smv",
        "snk",
        "so",
        "stl",
        "suo",
        "sub",
        "swf",
        "tar",
        "tbz",
        "tbz2",
        "tga",
        "tgz",
        "thmx",
        "tif",
        "tiff",
        "tlz",
        "ttc",
        "ttf",
        "txz",
        "udf",
        "uvh",
        "uvi",
        "uvm",
        "uvp",
        "uvs",
        "uvu",
        "viv",
        "vob",
        "war",
        "wav",
        "wax",
        "wbmp",
        "wdp",
        "weba",
        "webm",
        "webp",
        "whl",
        "wim",
        "wm",
        "wma",
        "wmv",
        "wmx",
        "woff",
        "woff2",
        "wrm",
        "wvx",
        "xbm",
        "xif",
        "xla",
        "xlam",
        "xls",
        "xlsb",
        "xlsm",
        "xlsx",
        "xlt",
        "xltm",
        "xltx",
        "xm",
        "xmind",
        "xpi",
        "xpm",
        "xwd",
        "xz",
        "z",
        "zip",
        "zipx"
      ];
    }
  });

  // ../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/index.js
  var require_binary_extensions2 = __commonJS({
    "../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/index.js"(exports, module) {
      module.exports = require_binary_extensions();
    }
  });

  // ../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js
  var require_is_binary_path = __commonJS({
    "../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js"(exports, module) {
      "use strict";
      var path6 = __require2("path");
      var binaryExtensions = require_binary_extensions2();
      var extensions = new Set(binaryExtensions);
      module.exports = (filePath) => extensions.has(path6.extname(filePath).slice(1).toLowerCase());
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/constants.js
  var require_constants3 = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/constants.js"(exports) {
      "use strict";
      var { sep: sep2 } = __require2("path");
      var { platform: platform2 } = process;
      var os2 = __require2("os");
      exports.EV_ALL = "all";
      exports.EV_READY = "ready";
      exports.EV_ADD = "add";
      exports.EV_CHANGE = "change";
      exports.EV_ADD_DIR = "addDir";
      exports.EV_UNLINK = "unlink";
      exports.EV_UNLINK_DIR = "unlinkDir";
      exports.EV_RAW = "raw";
      exports.EV_ERROR = "error";
      exports.STR_DATA = "data";
      exports.STR_END = "end";
      exports.STR_CLOSE = "close";
      exports.FSEVENT_CREATED = "created";
      exports.FSEVENT_MODIFIED = "modified";
      exports.FSEVENT_DELETED = "deleted";
      exports.FSEVENT_MOVED = "moved";
      exports.FSEVENT_CLONED = "cloned";
      exports.FSEVENT_UNKNOWN = "unknown";
      exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
      exports.FSEVENT_TYPE_FILE = "file";
      exports.FSEVENT_TYPE_DIRECTORY = "directory";
      exports.FSEVENT_TYPE_SYMLINK = "symlink";
      exports.KEY_LISTENERS = "listeners";
      exports.KEY_ERR = "errHandlers";
      exports.KEY_RAW = "rawEmitters";
      exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
      exports.DOT_SLASH = `.${sep2}`;
      exports.BACK_SLASH_RE = /\\/g;
      exports.DOUBLE_SLASH_RE = /\/\//;
      exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
      exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
      exports.REPLACER_RE = /^\.[/\\]/;
      exports.SLASH = "/";
      exports.SLASH_SLASH = "//";
      exports.BRACE_START = "{";
      exports.BANG = "!";
      exports.ONE_DOT = ".";
      exports.TWO_DOTS = "..";
      exports.STAR = "*";
      exports.GLOBSTAR = "**";
      exports.ROOT_GLOBSTAR = "/**/*";
      exports.SLASH_GLOBSTAR = "/**";
      exports.DIR_SUFFIX = "Dir";
      exports.ANYMATCH_OPTS = { dot: true };
      exports.STRING_TYPE = "string";
      exports.FUNCTION_TYPE = "function";
      exports.EMPTY_STR = "";
      exports.EMPTY_FN = () => {
      };
      exports.IDENTITY_FN = (val) => val;
      exports.isWindows = platform2 === "win32";
      exports.isMacos = platform2 === "darwin";
      exports.isLinux = platform2 === "linux";
      exports.isIBMi = os2.type() === "OS400";
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/nodefs-handler.js
  var require_nodefs_handler = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/nodefs-handler.js"(exports, module) {
      "use strict";
      var fs5 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var isBinaryPath = require_is_binary_path();
      var {
        isWindows,
        isLinux,
        EMPTY_FN,
        EMPTY_STR,
        KEY_LISTENERS,
        KEY_ERR,
        KEY_RAW,
        HANDLER_KEYS,
        EV_CHANGE,
        EV_ADD,
        EV_ADD_DIR,
        EV_ERROR,
        STR_DATA,
        STR_END,
        BRACE_START,
        STAR
      } = require_constants3();
      var THROTTLE_MODE_WATCH = "watch";
      var open = promisify(fs5.open);
      var stat4 = promisify(fs5.stat);
      var lstat6 = promisify(fs5.lstat);
      var close = promisify(fs5.close);
      var fsrealpath = promisify(fs5.realpath);
      var statMethods = { lstat: lstat6, stat: stat4 };
      var foreach = (val, fn) => {
        if (val instanceof Set) {
          val.forEach(fn);
        } else {
          fn(val);
        }
      };
      var addAndConvert = (main, prop, item) => {
        let container = main[prop];
        if (!(container instanceof Set)) {
          main[prop] = container = /* @__PURE__ */ new Set([container]);
        }
        container.add(item);
      };
      var clearItem = (cont) => (key) => {
        const set = cont[key];
        if (set instanceof Set) {
          set.clear();
        } else {
          delete cont[key];
        }
      };
      var delFromSet = (main, prop, item) => {
        const container = main[prop];
        if (container instanceof Set) {
          container.delete(item);
        } else if (container === item) {
          delete main[prop];
        }
      };
      var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
      var FsWatchInstances = /* @__PURE__ */ new Map();
      function createFsWatchInstance(path6, options, listener, errHandler, emitRaw) {
        const handleEvent = (rawEvent, evPath) => {
          listener(path6);
          emitRaw(rawEvent, evPath, { watchedPath: path6 });
          if (evPath && path6 !== evPath) {
            fsWatchBroadcast(
              sysPath.resolve(path6, evPath),
              KEY_LISTENERS,
              sysPath.join(path6, evPath)
            );
          }
        };
        try {
          return fs5.watch(path6, options, handleEvent);
        } catch (error3) {
          errHandler(error3);
        }
      }
      var fsWatchBroadcast = (fullPath, type3, val1, val2, val3) => {
        const cont = FsWatchInstances.get(fullPath);
        if (!cont)
          return;
        foreach(cont[type3], (listener) => {
          listener(val1, val2, val3);
        });
      };
      var setFsWatchListener = (path6, fullPath, options, handlers) => {
        const { listener, errHandler, rawEmitter } = handlers;
        let cont = FsWatchInstances.get(fullPath);
        let watcher;
        if (!options.persistent) {
          watcher = createFsWatchInstance(
            path6,
            options,
            listener,
            errHandler,
            rawEmitter
          );
          return watcher.close.bind(watcher);
        }
        if (cont) {
          addAndConvert(cont, KEY_LISTENERS, listener);
          addAndConvert(cont, KEY_ERR, errHandler);
          addAndConvert(cont, KEY_RAW, rawEmitter);
        } else {
          watcher = createFsWatchInstance(
            path6,
            options,
            fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
            errHandler,
            // no need to use broadcast here
            fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
          );
          if (!watcher)
            return;
          watcher.on(EV_ERROR, async (error3) => {
            const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
            cont.watcherUnusable = true;
            if (isWindows && error3.code === "EPERM") {
              try {
                const fd2 = await open(path6, "r");
                await close(fd2);
                broadcastErr(error3);
              } catch (err2) {
              }
            } else {
              broadcastErr(error3);
            }
          });
          cont = {
            listeners: listener,
            errHandlers: errHandler,
            rawEmitters: rawEmitter,
            watcher
          };
          FsWatchInstances.set(fullPath, cont);
        }
        return () => {
          delFromSet(cont, KEY_LISTENERS, listener);
          delFromSet(cont, KEY_ERR, errHandler);
          delFromSet(cont, KEY_RAW, rawEmitter);
          if (isEmptySet(cont.listeners)) {
            cont.watcher.close();
            FsWatchInstances.delete(fullPath);
            HANDLER_KEYS.forEach(clearItem(cont));
            cont.watcher = void 0;
            Object.freeze(cont);
          }
        };
      };
      var FsWatchFileInstances = /* @__PURE__ */ new Map();
      var setFsWatchFileListener = (path6, fullPath, options, handlers) => {
        const { listener, rawEmitter } = handlers;
        let cont = FsWatchFileInstances.get(fullPath);
        let listeners = /* @__PURE__ */ new Set();
        let rawEmitters = /* @__PURE__ */ new Set();
        const copts = cont && cont.options;
        if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
          listeners = cont.listeners;
          rawEmitters = cont.rawEmitters;
          fs5.unwatchFile(fullPath);
          cont = void 0;
        }
        if (cont) {
          addAndConvert(cont, KEY_LISTENERS, listener);
          addAndConvert(cont, KEY_RAW, rawEmitter);
        } else {
          cont = {
            listeners: listener,
            rawEmitters: rawEmitter,
            options,
            watcher: fs5.watchFile(fullPath, options, (curr, prev) => {
              foreach(cont.rawEmitters, (rawEmitter2) => {
                rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
              });
              const currmtime = curr.mtimeMs;
              if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
                foreach(cont.listeners, (listener2) => listener2(path6, curr));
              }
            })
          };
          FsWatchFileInstances.set(fullPath, cont);
        }
        return () => {
          delFromSet(cont, KEY_LISTENERS, listener);
          delFromSet(cont, KEY_RAW, rawEmitter);
          if (isEmptySet(cont.listeners)) {
            FsWatchFileInstances.delete(fullPath);
            fs5.unwatchFile(fullPath);
            cont.options = cont.watcher = void 0;
            Object.freeze(cont);
          }
        };
      };
      var NodeFsHandler = class {
        /**
         * @param {import("../index").FSWatcher} fsW
         */
        constructor(fsW) {
          this.fsw = fsW;
          this._boundHandleError = (error3) => fsW._handleError(error3);
        }
        /**
         * Watch file for changes with fs_watchFile or fs_watch.
         * @param {String} path to file or dir
         * @param {Function} listener on fs change
         * @returns {Function} closer for the watcher instance
         */
        _watchWithNodeFs(path6, listener) {
          const opts = this.fsw.options;
          const directory = sysPath.dirname(path6);
          const basename4 = sysPath.basename(path6);
          const parent = this.fsw._getWatchedDir(directory);
          parent.add(basename4);
          const absolutePath = sysPath.resolve(path6);
          const options = { persistent: opts.persistent };
          if (!listener)
            listener = EMPTY_FN;
          let closer;
          if (opts.usePolling) {
            options.interval = opts.enableBinaryInterval && isBinaryPath(basename4) ? opts.binaryInterval : opts.interval;
            closer = setFsWatchFileListener(path6, absolutePath, options, {
              listener,
              rawEmitter: this.fsw._emitRaw
            });
          } else {
            closer = setFsWatchListener(path6, absolutePath, options, {
              listener,
              errHandler: this._boundHandleError,
              rawEmitter: this.fsw._emitRaw
            });
          }
          return closer;
        }
        /**
         * Watch a file and emit add event if warranted.
         * @param {Path} file Path
         * @param {fs.Stats} stats result of fs_stat
         * @param {Boolean} initialAdd was the file added at watch instantiation?
         * @returns {Function} closer for the watcher instance
         */
        _handleFile(file, stats, initialAdd) {
          if (this.fsw.closed) {
            return;
          }
          const dirname4 = sysPath.dirname(file);
          const basename4 = sysPath.basename(file);
          const parent = this.fsw._getWatchedDir(dirname4);
          let prevStats = stats;
          if (parent.has(basename4))
            return;
          const listener = async (path6, newStats) => {
            if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
              return;
            if (!newStats || newStats.mtimeMs === 0) {
              try {
                const newStats2 = await stat4(file);
                if (this.fsw.closed)
                  return;
                const at = newStats2.atimeMs;
                const mt = newStats2.mtimeMs;
                if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                  this.fsw._emit(EV_CHANGE, file, newStats2);
                }
                if (isLinux && prevStats.ino !== newStats2.ino) {
                  this.fsw._closeFile(path6);
                  prevStats = newStats2;
                  this.fsw._addPathCloser(path6, this._watchWithNodeFs(file, listener));
                } else {
                  prevStats = newStats2;
                }
              } catch (error3) {
                this.fsw._remove(dirname4, basename4);
              }
            } else if (parent.has(basename4)) {
              const at = newStats.atimeMs;
              const mt = newStats.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats);
              }
              prevStats = newStats;
            }
          };
          const closer = this._watchWithNodeFs(file, listener);
          if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
            if (!this.fsw._throttle(EV_ADD, file, 0))
              return;
            this.fsw._emit(EV_ADD, file, stats);
          }
          return closer;
        }
        /**
         * Handle symlinks encountered while reading a dir.
         * @param {Object} entry returned by readdirp
         * @param {String} directory path of dir being read
         * @param {String} path of this item
         * @param {String} item basename of this item
         * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
         */
        async _handleSymlink(entry, directory, path6, item) {
          if (this.fsw.closed) {
            return;
          }
          const full = entry.fullPath;
          const dir = this.fsw._getWatchedDir(directory);
          if (!this.fsw.options.followSymlinks) {
            this.fsw._incrReadyCount();
            let linkPath;
            try {
              linkPath = await fsrealpath(path6);
            } catch (e) {
              this.fsw._emitReady();
              return true;
            }
            if (this.fsw.closed)
              return;
            if (dir.has(item)) {
              if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                this.fsw._symlinkPaths.set(full, linkPath);
                this.fsw._emit(EV_CHANGE, path6, entry.stats);
              }
            } else {
              dir.add(item);
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_ADD, path6, entry.stats);
            }
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw._symlinkPaths.has(full)) {
            return true;
          }
          this.fsw._symlinkPaths.set(full, true);
        }
        _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
          directory = sysPath.join(directory, EMPTY_STR);
          if (!wh.hasGlob) {
            throttler = this.fsw._throttle("readdir", directory, 1e3);
            if (!throttler)
              return;
          }
          const previous = this.fsw._getWatchedDir(wh.path);
          const current = /* @__PURE__ */ new Set();
          let stream2 = this.fsw._readdirp(directory, {
            fileFilter: (entry) => wh.filterPath(entry),
            directoryFilter: (entry) => wh.filterDir(entry),
            depth: 0
          }).on(STR_DATA, async (entry) => {
            if (this.fsw.closed) {
              stream2 = void 0;
              return;
            }
            const item = entry.path;
            let path6 = sysPath.join(directory, item);
            current.add(item);
            if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path6, item)) {
              return;
            }
            if (this.fsw.closed) {
              stream2 = void 0;
              return;
            }
            if (item === target || !target && !previous.has(item)) {
              this.fsw._incrReadyCount();
              path6 = sysPath.join(dir, sysPath.relative(dir, path6));
              this._addToNodeFs(path6, initialAdd, wh, depth + 1);
            }
          }).on(EV_ERROR, this._boundHandleError);
          return new Promise(
            (resolve10) => stream2.once(STR_END, () => {
              if (this.fsw.closed) {
                stream2 = void 0;
                return;
              }
              const wasThrottled = throttler ? throttler.clear() : false;
              resolve10();
              previous.getChildren().filter((item) => {
                return item !== directory && !current.has(item) && // in case of intersecting globs;
                // a path may have been filtered out of this readdir, but
                // shouldn't be removed because it matches a different glob
                (!wh.hasGlob || wh.filterPath({
                  fullPath: sysPath.resolve(directory, item)
                }));
              }).forEach((item) => {
                this.fsw._remove(directory, item);
              });
              stream2 = void 0;
              if (wasThrottled)
                this._handleRead(directory, false, wh, target, dir, depth, throttler);
            })
          );
        }
        /**
         * Read directory to add / remove files from `@watched` list and re-read it on change.
         * @param {String} dir fs path
         * @param {fs.Stats} stats
         * @param {Boolean} initialAdd
         * @param {Number} depth relative to user-supplied path
         * @param {String} target child path targeted for watch
         * @param {Object} wh Common watch helpers for this path
         * @param {String} realpath
         * @returns {Promise<Function>} closer for the watcher instance.
         */
        async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath2) {
          const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
          const tracked = parentDir.has(sysPath.basename(dir));
          if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
            if (!wh.hasGlob || wh.globFilter(dir))
              this.fsw._emit(EV_ADD_DIR, dir, stats);
          }
          parentDir.add(sysPath.basename(dir));
          this.fsw._getWatchedDir(dir);
          let throttler;
          let closer;
          const oDepth = this.fsw.options.depth;
          if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath2)) {
            if (!target) {
              await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
              if (this.fsw.closed)
                return;
            }
            closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
              if (stats2 && stats2.mtimeMs === 0)
                return;
              this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
            });
          }
          return closer;
        }
        /**
         * Handle added file, directory, or glob pattern.
         * Delegates call to _handleFile / _handleDir after checks.
         * @param {String} path to file or ir
         * @param {Boolean} initialAdd was the file added at watch instantiation?
         * @param {Object} priorWh depth relative to user-supplied path
         * @param {Number} depth Child path actually targeted for watch
         * @param {String=} target Child path actually targeted for watch
         * @returns {Promise}
         */
        async _addToNodeFs(path6, initialAdd, priorWh, depth, target) {
          const ready = this.fsw._emitReady;
          if (this.fsw._isIgnored(path6) || this.fsw.closed) {
            ready();
            return false;
          }
          const wh = this.fsw._getWatchHelpers(path6, depth);
          if (!wh.hasGlob && priorWh) {
            wh.hasGlob = priorWh.hasGlob;
            wh.globFilter = priorWh.globFilter;
            wh.filterPath = (entry) => priorWh.filterPath(entry);
            wh.filterDir = (entry) => priorWh.filterDir(entry);
          }
          try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
              ready();
              return false;
            }
            const follow = this.fsw.options.followSymlinks && !path6.includes(STAR) && !path6.includes(BRACE_START);
            let closer;
            if (stats.isDirectory()) {
              const absPath = sysPath.resolve(path6);
              const targetPath = follow ? await fsrealpath(path6) : path6;
              if (this.fsw.closed)
                return;
              closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
              if (this.fsw.closed)
                return;
              if (absPath !== targetPath && targetPath !== void 0) {
                this.fsw._symlinkPaths.set(absPath, targetPath);
              }
            } else if (stats.isSymbolicLink()) {
              const targetPath = follow ? await fsrealpath(path6) : path6;
              if (this.fsw.closed)
                return;
              const parent = sysPath.dirname(wh.watchPath);
              this.fsw._getWatchedDir(parent).add(wh.watchPath);
              this.fsw._emit(EV_ADD, wh.watchPath, stats);
              closer = await this._handleDir(parent, stats, initialAdd, depth, path6, wh, targetPath);
              if (this.fsw.closed)
                return;
              if (targetPath !== void 0) {
                this.fsw._symlinkPaths.set(sysPath.resolve(path6), targetPath);
              }
            } else {
              closer = this._handleFile(wh.watchPath, stats, initialAdd);
            }
            ready();
            this.fsw._addPathCloser(path6, closer);
            return false;
          } catch (error3) {
            if (this.fsw._handleError(error3)) {
              ready();
              return path6;
            }
          }
        }
      };
      module.exports = NodeFsHandler;
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/fsevents-handler.js
  var require_fsevents_handler = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/fsevents-handler.js"(exports, module) {
      "use strict";
      var fs5 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var fsevents;
      try {
        fsevents = __require2("fsevents");
      } catch (error3) {
        if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
          console.error(error3);
      }
      if (fsevents) {
        const mtch = process.version.match(/v(\d+)\.(\d+)/);
        if (mtch && mtch[1] && mtch[2]) {
          const maj = Number.parseInt(mtch[1], 10);
          const min = Number.parseInt(mtch[2], 10);
          if (maj === 8 && min < 16) {
            fsevents = void 0;
          }
        }
      }
      var {
        EV_ADD,
        EV_CHANGE,
        EV_ADD_DIR,
        EV_UNLINK,
        EV_ERROR,
        STR_DATA,
        STR_END,
        FSEVENT_CREATED,
        FSEVENT_MODIFIED,
        FSEVENT_DELETED,
        FSEVENT_MOVED,
        // FSEVENT_CLONED,
        FSEVENT_UNKNOWN,
        FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
        FSEVENT_TYPE_FILE,
        FSEVENT_TYPE_DIRECTORY,
        FSEVENT_TYPE_SYMLINK,
        ROOT_GLOBSTAR,
        DIR_SUFFIX,
        DOT_SLASH,
        FUNCTION_TYPE,
        EMPTY_FN,
        IDENTITY_FN
      } = require_constants3();
      var Depth = (value) => isNaN(value) ? {} : { depth: value };
      var stat4 = promisify(fs5.stat);
      var lstat6 = promisify(fs5.lstat);
      var realpath2 = promisify(fs5.realpath);
      var statMethods = { stat: stat4, lstat: lstat6 };
      var FSEventsWatchers = /* @__PURE__ */ new Map();
      var consolidateThreshhold = 10;
      var wrongEventFlags = /* @__PURE__ */ new Set([
        69888,
        70400,
        71424,
        72704,
        73472,
        131328,
        131840,
        262912
      ]);
      var createFSEventsInstance = (path6, callback) => {
        const stop = fsevents.watch(path6, callback);
        return { stop };
      };
      function setFSEventsListener(path6, realPath, listener, rawEmitter) {
        let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
        const parentPath = sysPath.dirname(watchPath);
        let cont = FSEventsWatchers.get(watchPath);
        if (couldConsolidate(parentPath)) {
          watchPath = parentPath;
        }
        const resolvedPath = sysPath.resolve(path6);
        const hasSymlink = resolvedPath !== realPath;
        const filteredListener = (fullPath, flags, info) => {
          if (hasSymlink)
            fullPath = fullPath.replace(realPath, resolvedPath);
          if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
            listener(fullPath, flags, info);
        };
        let watchedParent = false;
        for (const watchedPath of FSEventsWatchers.keys()) {
          if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
            watchPath = watchedPath;
            cont = FSEventsWatchers.get(watchPath);
            watchedParent = true;
            break;
          }
        }
        if (cont || watchedParent) {
          cont.listeners.add(filteredListener);
        } else {
          cont = {
            listeners: /* @__PURE__ */ new Set([filteredListener]),
            rawEmitter,
            watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
              if (!cont.listeners.size)
                return;
              if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS)
                return;
              const info = fsevents.getInfo(fullPath, flags);
              cont.listeners.forEach((list) => {
                list(fullPath, flags, info);
              });
              cont.rawEmitter(info.event, fullPath, info);
            })
          };
          FSEventsWatchers.set(watchPath, cont);
        }
        return () => {
          const lst = cont.listeners;
          lst.delete(filteredListener);
          if (!lst.size) {
            FSEventsWatchers.delete(watchPath);
            if (cont.watcher)
              return cont.watcher.stop().then(() => {
                cont.rawEmitter = cont.watcher = void 0;
                Object.freeze(cont);
              });
          }
        };
      }
      var couldConsolidate = (path6) => {
        let count = 0;
        for (const watchPath of FSEventsWatchers.keys()) {
          if (watchPath.indexOf(path6) === 0) {
            count++;
            if (count >= consolidateThreshhold) {
              return true;
            }
          }
        }
        return false;
      };
      var canUse = () => fsevents && FSEventsWatchers.size < 128;
      var calcDepth = (path6, root) => {
        let i = 0;
        while (!path6.indexOf(root) && (path6 = sysPath.dirname(path6)) !== root)
          i++;
        return i;
      };
      var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
      var FsEventsHandler = class {
        /**
         * @param {import('../index').FSWatcher} fsw
         */
        constructor(fsw) {
          this.fsw = fsw;
        }
        checkIgnored(path6, stats) {
          const ipaths = this.fsw._ignoredPaths;
          if (this.fsw._isIgnored(path6, stats)) {
            ipaths.add(path6);
            if (stats && stats.isDirectory()) {
              ipaths.add(path6 + ROOT_GLOBSTAR);
            }
            return true;
          }
          ipaths.delete(path6);
          ipaths.delete(path6 + ROOT_GLOBSTAR);
        }
        addOrChange(path6, fullPath, realPath, parent, watchedDir, item, info, opts) {
          const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
          this.handleEvent(event, path6, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
        async checkExists(path6, fullPath, realPath, parent, watchedDir, item, info, opts) {
          try {
            const stats = await stat4(path6);
            if (this.fsw.closed)
              return;
            if (sameTypes(info, stats)) {
              this.addOrChange(path6, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
              this.handleEvent(EV_UNLINK, path6, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } catch (error3) {
            if (error3.code === "EACCES") {
              this.addOrChange(path6, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
              this.handleEvent(EV_UNLINK, path6, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        }
        handleEvent(event, path6, fullPath, realPath, parent, watchedDir, item, info, opts) {
          if (this.fsw.closed || this.checkIgnored(path6))
            return;
          if (event === EV_UNLINK) {
            const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
            if (isDirectory || watchedDir.has(item)) {
              this.fsw._remove(parent, item, isDirectory);
            }
          } else {
            if (event === EV_ADD) {
              if (info.type === FSEVENT_TYPE_DIRECTORY)
                this.fsw._getWatchedDir(path6);
              if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
                return this._addToFsEvents(path6, false, true, curDepth);
              }
              this.fsw._getWatchedDir(parent).add(item);
            }
            const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
            this.fsw._emit(eventName, path6);
            if (eventName === EV_ADD_DIR)
              this._addToFsEvents(path6, false, true);
          }
        }
        /**
         * Handle symlinks encountered during directory scan
         * @param {String} watchPath  - file/dir path to be watched with fsevents
         * @param {String} realPath   - real path (in case of symlinks)
         * @param {Function} transform  - path transformer
         * @param {Function} globFilter - path filter in case a glob pattern was provided
         * @returns {Function} closer for the watcher instance
        */
        _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
          if (this.fsw.closed || this.fsw._isIgnored(watchPath))
            return;
          const opts = this.fsw.options;
          const watchCallback = async (fullPath, flags, info) => {
            if (this.fsw.closed)
              return;
            if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
              return;
            const path6 = transform(sysPath.join(
              watchPath,
              sysPath.relative(watchPath, fullPath)
            ));
            if (globFilter && !globFilter(path6))
              return;
            const parent = sysPath.dirname(path6);
            const item = sysPath.basename(path6);
            const watchedDir = this.fsw._getWatchedDir(
              info.type === FSEVENT_TYPE_DIRECTORY ? path6 : parent
            );
            if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
              if (typeof opts.ignored === FUNCTION_TYPE) {
                let stats;
                try {
                  stats = await stat4(path6);
                } catch (error3) {
                }
                if (this.fsw.closed)
                  return;
                if (this.checkIgnored(path6, stats))
                  return;
                if (sameTypes(info, stats)) {
                  this.addOrChange(path6, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path6, fullPath, realPath, parent, watchedDir, item, info, opts);
                }
              } else {
                this.checkExists(path6, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              switch (info.event) {
                case FSEVENT_CREATED:
                case FSEVENT_MODIFIED:
                  return this.addOrChange(path6, fullPath, realPath, parent, watchedDir, item, info, opts);
                case FSEVENT_DELETED:
                case FSEVENT_MOVED:
                  return this.checkExists(path6, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            }
          };
          const closer = setFSEventsListener(
            watchPath,
            realPath,
            watchCallback,
            this.fsw._emitRaw
          );
          this.fsw._emitReady();
          return closer;
        }
        /**
         * Handle symlinks encountered during directory scan
         * @param {String} linkPath path to symlink
         * @param {String} fullPath absolute path to the symlink
         * @param {Function} transform pre-existing path transformer
         * @param {Number} curDepth level of subdirectories traversed to where symlink is
         * @returns {Promise<void>}
         */
        async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
          if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
            return;
          this.fsw._symlinkPaths.set(fullPath, true);
          this.fsw._incrReadyCount();
          try {
            const linkTarget = await realpath2(linkPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(linkTarget)) {
              return this.fsw._emitReady();
            }
            this.fsw._incrReadyCount();
            this._addToFsEvents(linkTarget || linkPath, (path6) => {
              let aliasedPath = linkPath;
              if (linkTarget && linkTarget !== DOT_SLASH) {
                aliasedPath = path6.replace(linkTarget, linkPath);
              } else if (path6 !== DOT_SLASH) {
                aliasedPath = sysPath.join(linkPath, path6);
              }
              return transform(aliasedPath);
            }, false, curDepth);
          } catch (error3) {
            if (this.fsw._handleError(error3)) {
              return this.fsw._emitReady();
            }
          }
        }
        /**
         *
         * @param {Path} newPath
         * @param {fs.Stats} stats
         */
        emitAdd(newPath, stats, processPath, opts, forceAdd) {
          const pp = processPath(newPath);
          const isDir2 = stats.isDirectory();
          const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
          const base2 = sysPath.basename(pp);
          if (isDir2)
            this.fsw._getWatchedDir(pp);
          if (dirObj.has(base2))
            return;
          dirObj.add(base2);
          if (!opts.ignoreInitial || forceAdd === true) {
            this.fsw._emit(isDir2 ? EV_ADD_DIR : EV_ADD, pp, stats);
          }
        }
        initWatch(realPath, path6, wh, processPath) {
          if (this.fsw.closed)
            return;
          const closer = this._watchWithFsEvents(
            wh.watchPath,
            sysPath.resolve(realPath || wh.watchPath),
            processPath,
            wh.globFilter
          );
          this.fsw._addPathCloser(path6, closer);
        }
        /**
         * Handle added path with fsevents
         * @param {String} path file/dir path or glob pattern
         * @param {Function|Boolean=} transform converts working path to what the user expects
         * @param {Boolean=} forceAdd ensure add is emitted
         * @param {Number=} priorDepth Level of subdirectories already traversed.
         * @returns {Promise<void>}
         */
        async _addToFsEvents(path6, transform, forceAdd, priorDepth) {
          if (this.fsw.closed) {
            return;
          }
          const opts = this.fsw.options;
          const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
          const wh = this.fsw._getWatchHelpers(path6);
          try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
              throw null;
            }
            if (stats.isDirectory()) {
              if (!wh.globFilter)
                this.emitAdd(processPath(path6), stats, processPath, opts, forceAdd);
              if (priorDepth && priorDepth > opts.depth)
                return;
              this.fsw._readdirp(wh.watchPath, {
                fileFilter: (entry) => wh.filterPath(entry),
                directoryFilter: (entry) => wh.filterDir(entry),
                ...Depth(opts.depth - (priorDepth || 0))
              }).on(STR_DATA, (entry) => {
                if (this.fsw.closed) {
                  return;
                }
                if (entry.stats.isDirectory() && !wh.filterPath(entry))
                  return;
                const joinedPath = sysPath.join(wh.watchPath, entry.path);
                const { fullPath } = entry;
                if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                  const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                  this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                } else {
                  this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                }
              }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
                this.fsw._emitReady();
              });
            } else {
              this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
              this.fsw._emitReady();
            }
          } catch (error3) {
            if (!error3 || this.fsw._handleError(error3)) {
              this.fsw._emitReady();
              this.fsw._emitReady();
            }
          }
          if (opts.persistent && forceAdd !== true) {
            if (typeof transform === FUNCTION_TYPE) {
              this.initWatch(void 0, path6, wh, processPath);
            } else {
              let realPath;
              try {
                realPath = await realpath2(wh.watchPath);
              } catch (e) {
              }
              this.initWatch(realPath, path6, wh, processPath);
            }
          }
        }
      };
      module.exports = FsEventsHandler;
      module.exports.canUse = canUse;
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/index.js
  var require_chokidar = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/index.js"(exports) {
      "use strict";
      var { EventEmitter: EventEmitter3 } = __require2("events");
      var fs5 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var readdirp = require_readdirp();
      var anymatch = require_anymatch().default;
      var globParent = require_glob_parent();
      var isGlob = require_is_glob();
      var braces = require_braces();
      var normalizePath2 = require_normalize_path();
      var NodeFsHandler = require_nodefs_handler();
      var FsEventsHandler = require_fsevents_handler();
      var {
        EV_ALL,
        EV_READY,
        EV_ADD,
        EV_CHANGE,
        EV_UNLINK,
        EV_ADD_DIR,
        EV_UNLINK_DIR,
        EV_RAW,
        EV_ERROR,
        STR_CLOSE,
        STR_END,
        BACK_SLASH_RE,
        DOUBLE_SLASH_RE,
        SLASH_OR_BACK_SLASH_RE,
        DOT_RE,
        REPLACER_RE,
        SLASH,
        SLASH_SLASH,
        BRACE_START,
        BANG,
        ONE_DOT,
        TWO_DOTS,
        GLOBSTAR: GLOBSTAR2,
        SLASH_GLOBSTAR,
        ANYMATCH_OPTS,
        STRING_TYPE,
        FUNCTION_TYPE,
        EMPTY_STR,
        EMPTY_FN,
        isWindows,
        isMacos,
        isIBMi
      } = require_constants3();
      var stat4 = promisify(fs5.stat);
      var readdir4 = promisify(fs5.readdir);
      var arrify = (value = []) => Array.isArray(value) ? value : [value];
      var flatten = (list, result = []) => {
        list.forEach((item) => {
          if (Array.isArray(item)) {
            flatten(item, result);
          } else {
            result.push(item);
          }
        });
        return result;
      };
      var unifyPaths = (paths_) => {
        const paths = flatten(arrify(paths_));
        if (!paths.every((p) => typeof p === STRING_TYPE)) {
          throw new TypeError(`Non-string provided as watch path: ${paths}`);
        }
        return paths.map(normalizePathToUnix);
      };
      var toUnix = (string2) => {
        let str = string2.replace(BACK_SLASH_RE, SLASH);
        let prepend = false;
        if (str.startsWith(SLASH_SLASH)) {
          prepend = true;
        }
        while (str.match(DOUBLE_SLASH_RE)) {
          str = str.replace(DOUBLE_SLASH_RE, SLASH);
        }
        if (prepend) {
          str = SLASH + str;
        }
        return str;
      };
      var normalizePathToUnix = (path6) => toUnix(sysPath.normalize(toUnix(path6)));
      var normalizeIgnored = (cwd = EMPTY_STR) => (path6) => {
        if (typeof path6 !== STRING_TYPE)
          return path6;
        return normalizePathToUnix(sysPath.isAbsolute(path6) ? path6 : sysPath.join(cwd, path6));
      };
      var getAbsolutePath = (path6, cwd) => {
        if (sysPath.isAbsolute(path6)) {
          return path6;
        }
        if (path6.startsWith(BANG)) {
          return BANG + sysPath.join(cwd, path6.slice(1));
        }
        return sysPath.join(cwd, path6);
      };
      var undef = (opts, key) => opts[key] === void 0;
      var DirEntry = class {
        /**
         * @param {Path} dir
         * @param {Function} removeWatcher
         */
        constructor(dir, removeWatcher) {
          this.path = dir;
          this._removeWatcher = removeWatcher;
          this.items = /* @__PURE__ */ new Set();
        }
        add(item) {
          const { items } = this;
          if (!items)
            return;
          if (item !== ONE_DOT && item !== TWO_DOTS)
            items.add(item);
        }
        async remove(item) {
          const { items } = this;
          if (!items)
            return;
          items.delete(item);
          if (items.size > 0)
            return;
          const dir = this.path;
          try {
            await readdir4(dir);
          } catch (err2) {
            if (this._removeWatcher) {
              this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
            }
          }
        }
        has(item) {
          const { items } = this;
          if (!items)
            return;
          return items.has(item);
        }
        /**
         * @returns {Array<String>}
         */
        getChildren() {
          const { items } = this;
          if (!items)
            return;
          return [...items.values()];
        }
        dispose() {
          this.items.clear();
          delete this.path;
          delete this._removeWatcher;
          delete this.items;
          Object.freeze(this);
        }
      };
      var STAT_METHOD_F = "stat";
      var STAT_METHOD_L = "lstat";
      var WatchHelper = class {
        constructor(path6, watchPath, follow, fsw) {
          this.fsw = fsw;
          this.path = path6 = path6.replace(REPLACER_RE, EMPTY_STR);
          this.watchPath = watchPath;
          this.fullWatchPath = sysPath.resolve(watchPath);
          this.hasGlob = watchPath !== path6;
          if (path6 === EMPTY_STR)
            this.hasGlob = false;
          this.globSymlink = this.hasGlob && follow ? void 0 : false;
          this.globFilter = this.hasGlob ? anymatch(path6, void 0, ANYMATCH_OPTS) : false;
          this.dirParts = this.getDirParts(path6);
          this.dirParts.forEach((parts) => {
            if (parts.length > 1)
              parts.pop();
          });
          this.followSymlinks = follow;
          this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
        }
        checkGlobSymlink(entry) {
          if (this.globSymlink === void 0) {
            this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
          }
          if (this.globSymlink) {
            return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
          }
          return entry.fullPath;
        }
        entryPath(entry) {
          return sysPath.join(
            this.watchPath,
            sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
          );
        }
        filterPath(entry) {
          const { stats } = entry;
          if (stats && stats.isSymbolicLink())
            return this.filterDir(entry);
          const resolvedPath = this.entryPath(entry);
          const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
          return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
        }
        getDirParts(path6) {
          if (!this.hasGlob)
            return [];
          const parts = [];
          const expandedPath = path6.includes(BRACE_START) ? braces.expand(path6) : [path6];
          expandedPath.forEach((path7) => {
            parts.push(sysPath.relative(this.watchPath, path7).split(SLASH_OR_BACK_SLASH_RE));
          });
          return parts;
        }
        filterDir(entry) {
          if (this.hasGlob) {
            const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
            let globstar = false;
            this.unmatchedGlob = !this.dirParts.some((parts) => {
              return parts.every((part, i) => {
                if (part === GLOBSTAR2)
                  globstar = true;
                return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
              });
            });
          }
          return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
        }
      };
      var FSWatcher = class extends EventEmitter3 {
        // Not indenting methods for history sake; for now.
        constructor(_opts) {
          super();
          const opts = {};
          if (_opts)
            Object.assign(opts, _opts);
          this._watched = /* @__PURE__ */ new Map();
          this._closers = /* @__PURE__ */ new Map();
          this._ignoredPaths = /* @__PURE__ */ new Set();
          this._throttled = /* @__PURE__ */ new Map();
          this._symlinkPaths = /* @__PURE__ */ new Map();
          this._streams = /* @__PURE__ */ new Set();
          this.closed = false;
          if (undef(opts, "persistent"))
            opts.persistent = true;
          if (undef(opts, "ignoreInitial"))
            opts.ignoreInitial = false;
          if (undef(opts, "ignorePermissionErrors"))
            opts.ignorePermissionErrors = false;
          if (undef(opts, "interval"))
            opts.interval = 100;
          if (undef(opts, "binaryInterval"))
            opts.binaryInterval = 300;
          if (undef(opts, "disableGlobbing"))
            opts.disableGlobbing = false;
          opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
          if (undef(opts, "useFsEvents"))
            opts.useFsEvents = !opts.usePolling;
          const canUseFsEvents = FsEventsHandler.canUse();
          if (!canUseFsEvents)
            opts.useFsEvents = false;
          if (undef(opts, "usePolling") && !opts.useFsEvents) {
            opts.usePolling = isMacos;
          }
          if (isIBMi) {
            opts.usePolling = true;
          }
          const envPoll = process.env.CHOKIDAR_USEPOLLING;
          if (envPoll !== void 0) {
            const envLower = envPoll.toLowerCase();
            if (envLower === "false" || envLower === "0") {
              opts.usePolling = false;
            } else if (envLower === "true" || envLower === "1") {
              opts.usePolling = true;
            } else {
              opts.usePolling = !!envLower;
            }
          }
          const envInterval = process.env.CHOKIDAR_INTERVAL;
          if (envInterval) {
            opts.interval = Number.parseInt(envInterval, 10);
          }
          if (undef(opts, "atomic"))
            opts.atomic = !opts.usePolling && !opts.useFsEvents;
          if (opts.atomic)
            this._pendingUnlinks = /* @__PURE__ */ new Map();
          if (undef(opts, "followSymlinks"))
            opts.followSymlinks = true;
          if (undef(opts, "awaitWriteFinish"))
            opts.awaitWriteFinish = false;
          if (opts.awaitWriteFinish === true)
            opts.awaitWriteFinish = {};
          const awf = opts.awaitWriteFinish;
          if (awf) {
            if (!awf.stabilityThreshold)
              awf.stabilityThreshold = 2e3;
            if (!awf.pollInterval)
              awf.pollInterval = 100;
            this._pendingWrites = /* @__PURE__ */ new Map();
          }
          if (opts.ignored)
            opts.ignored = arrify(opts.ignored);
          let readyCalls = 0;
          this._emitReady = () => {
            readyCalls++;
            if (readyCalls >= this._readyCount) {
              this._emitReady = EMPTY_FN;
              this._readyEmitted = true;
              process.nextTick(() => this.emit(EV_READY));
            }
          };
          this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
          this._readyEmitted = false;
          this.options = opts;
          if (opts.useFsEvents) {
            this._fsEventsHandler = new FsEventsHandler(this);
          } else {
            this._nodeFsHandler = new NodeFsHandler(this);
          }
          Object.freeze(opts);
        }
        // Public methods
        /**
         * Adds paths to be watched on an existing FSWatcher instance
         * @param {Path|Array<Path>} paths_
         * @param {String=} _origAdd private; for handling non-existent paths to be watched
         * @param {Boolean=} _internal private; indicates a non-user add
         * @returns {FSWatcher} for chaining
         */
        add(paths_, _origAdd, _internal) {
          const { cwd, disableGlobbing } = this.options;
          this.closed = false;
          let paths = unifyPaths(paths_);
          if (cwd) {
            paths = paths.map((path6) => {
              const absPath = getAbsolutePath(path6, cwd);
              if (disableGlobbing || !isGlob(path6)) {
                return absPath;
              }
              return normalizePath2(absPath);
            });
          }
          paths = paths.filter((path6) => {
            if (path6.startsWith(BANG)) {
              this._ignoredPaths.add(path6.slice(1));
              return false;
            }
            this._ignoredPaths.delete(path6);
            this._ignoredPaths.delete(path6 + SLASH_GLOBSTAR);
            this._userIgnored = void 0;
            return true;
          });
          if (this.options.useFsEvents && this._fsEventsHandler) {
            if (!this._readyCount)
              this._readyCount = paths.length;
            if (this.options.persistent)
              this._readyCount += paths.length;
            paths.forEach((path6) => this._fsEventsHandler._addToFsEvents(path6));
          } else {
            if (!this._readyCount)
              this._readyCount = 0;
            this._readyCount += paths.length;
            Promise.all(
              paths.map(async (path6) => {
                const res = await this._nodeFsHandler._addToNodeFs(path6, !_internal, 0, 0, _origAdd);
                if (res)
                  this._emitReady();
                return res;
              })
            ).then((results) => {
              if (this.closed)
                return;
              results.filter((item) => item).forEach((item) => {
                this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
              });
            });
          }
          return this;
        }
        /**
         * Close watchers or start ignoring events from specified paths.
         * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
         * @returns {FSWatcher} for chaining
        */
        unwatch(paths_) {
          if (this.closed)
            return this;
          const paths = unifyPaths(paths_);
          const { cwd } = this.options;
          paths.forEach((path6) => {
            if (!sysPath.isAbsolute(path6) && !this._closers.has(path6)) {
              if (cwd)
                path6 = sysPath.join(cwd, path6);
              path6 = sysPath.resolve(path6);
            }
            this._closePath(path6);
            this._ignoredPaths.add(path6);
            if (this._watched.has(path6)) {
              this._ignoredPaths.add(path6 + SLASH_GLOBSTAR);
            }
            this._userIgnored = void 0;
          });
          return this;
        }
        /**
         * Close watchers and remove all listeners from watched paths.
         * @returns {Promise<void>}.
        */
        close() {
          if (this.closed)
            return this._closePromise;
          this.closed = true;
          this.removeAllListeners();
          const closers = [];
          this._closers.forEach((closerList) => closerList.forEach((closer) => {
            const promise = closer();
            if (promise instanceof Promise)
              closers.push(promise);
          }));
          this._streams.forEach((stream2) => stream2.destroy());
          this._userIgnored = void 0;
          this._readyCount = 0;
          this._readyEmitted = false;
          this._watched.forEach((dirent) => dirent.dispose());
          ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
            this[`_${key}`].clear();
          });
          this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
          return this._closePromise;
        }
        /**
         * Expose list of watched paths
         * @returns {Object} for chaining
        */
        getWatched() {
          const watchList = {};
          this._watched.forEach((entry, dir) => {
            const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
            watchList[key || ONE_DOT] = entry.getChildren().sort();
          });
          return watchList;
        }
        emitWithAll(event, args) {
          this.emit(...args);
          if (event !== EV_ERROR)
            this.emit(EV_ALL, ...args);
        }
        // Common helpers
        // --------------
        /**
         * Normalize and emit events.
         * Calling _emit DOES NOT MEAN emit() would be called!
         * @param {EventName} event Type of event
         * @param {Path} path File or directory path
         * @param {*=} val1 arguments to be passed with event
         * @param {*=} val2
         * @param {*=} val3
         * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
         */
        async _emit(event, path6, val1, val2, val3) {
          if (this.closed)
            return;
          const opts = this.options;
          if (isWindows)
            path6 = sysPath.normalize(path6);
          if (opts.cwd)
            path6 = sysPath.relative(opts.cwd, path6);
          const args = [event, path6];
          if (val3 !== void 0)
            args.push(val1, val2, val3);
          else if (val2 !== void 0)
            args.push(val1, val2);
          else if (val1 !== void 0)
            args.push(val1);
          const awf = opts.awaitWriteFinish;
          let pw;
          if (awf && (pw = this._pendingWrites.get(path6))) {
            pw.lastChange = /* @__PURE__ */ new Date();
            return this;
          }
          if (opts.atomic) {
            if (event === EV_UNLINK) {
              this._pendingUnlinks.set(path6, args);
              setTimeout(() => {
                this._pendingUnlinks.forEach((entry, path7) => {
                  this.emit(...entry);
                  this.emit(EV_ALL, ...entry);
                  this._pendingUnlinks.delete(path7);
                });
              }, typeof opts.atomic === "number" ? opts.atomic : 100);
              return this;
            }
            if (event === EV_ADD && this._pendingUnlinks.has(path6)) {
              event = args[0] = EV_CHANGE;
              this._pendingUnlinks.delete(path6);
            }
          }
          if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
            const awfEmit = (err2, stats) => {
              if (err2) {
                event = args[0] = EV_ERROR;
                args[1] = err2;
                this.emitWithAll(event, args);
              } else if (stats) {
                if (args.length > 2) {
                  args[2] = stats;
                } else {
                  args.push(stats);
                }
                this.emitWithAll(event, args);
              }
            };
            this._awaitWriteFinish(path6, awf.stabilityThreshold, event, awfEmit);
            return this;
          }
          if (event === EV_CHANGE) {
            const isThrottled = !this._throttle(EV_CHANGE, path6, 50);
            if (isThrottled)
              return this;
          }
          if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
            const fullPath = opts.cwd ? sysPath.join(opts.cwd, path6) : path6;
            let stats;
            try {
              stats = await stat4(fullPath);
            } catch (err2) {
            }
            if (!stats || this.closed)
              return;
            args.push(stats);
          }
          this.emitWithAll(event, args);
          return this;
        }
        /**
         * Common handler for errors
         * @param {Error} error
         * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
         */
        _handleError(error3) {
          const code = error3 && error3.code;
          if (error3 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
            this.emit(EV_ERROR, error3);
          }
          return error3 || this.closed;
        }
        /**
         * Helper utility for throttling
         * @param {ThrottleType} actionType type being throttled
         * @param {Path} path being acted upon
         * @param {Number} timeout duration of time to suppress duplicate actions
         * @returns {Object|false} tracking object or false if action should be suppressed
         */
        _throttle(actionType, path6, timeout) {
          if (!this._throttled.has(actionType)) {
            this._throttled.set(actionType, /* @__PURE__ */ new Map());
          }
          const action = this._throttled.get(actionType);
          const actionPath = action.get(path6);
          if (actionPath) {
            actionPath.count++;
            return false;
          }
          let timeoutObject;
          const clear = () => {
            const item = action.get(path6);
            const count = item ? item.count : 0;
            action.delete(path6);
            clearTimeout(timeoutObject);
            if (item)
              clearTimeout(item.timeoutObject);
            return count;
          };
          timeoutObject = setTimeout(clear, timeout);
          const thr = { timeoutObject, clear, count: 0 };
          action.set(path6, thr);
          return thr;
        }
        _incrReadyCount() {
          return this._readyCount++;
        }
        /**
         * Awaits write operation to finish.
         * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
         * @param {Path} path being acted upon
         * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
         * @param {EventName} event
         * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
         */
        _awaitWriteFinish(path6, threshold, event, awfEmit) {
          let timeoutHandler;
          let fullPath = path6;
          if (this.options.cwd && !sysPath.isAbsolute(path6)) {
            fullPath = sysPath.join(this.options.cwd, path6);
          }
          const now = /* @__PURE__ */ new Date();
          const awaitWriteFinish = (prevStat) => {
            fs5.stat(fullPath, (err2, curStat) => {
              if (err2 || !this._pendingWrites.has(path6)) {
                if (err2 && err2.code !== "ENOENT")
                  awfEmit(err2);
                return;
              }
              const now2 = Number(/* @__PURE__ */ new Date());
              if (prevStat && curStat.size !== prevStat.size) {
                this._pendingWrites.get(path6).lastChange = now2;
              }
              const pw = this._pendingWrites.get(path6);
              const df = now2 - pw.lastChange;
              if (df >= threshold) {
                this._pendingWrites.delete(path6);
                awfEmit(void 0, curStat);
              } else {
                timeoutHandler = setTimeout(
                  awaitWriteFinish,
                  this.options.awaitWriteFinish.pollInterval,
                  curStat
                );
              }
            });
          };
          if (!this._pendingWrites.has(path6)) {
            this._pendingWrites.set(path6, {
              lastChange: now,
              cancelWait: () => {
                this._pendingWrites.delete(path6);
                clearTimeout(timeoutHandler);
                return event;
              }
            });
            timeoutHandler = setTimeout(
              awaitWriteFinish,
              this.options.awaitWriteFinish.pollInterval
            );
          }
        }
        _getGlobIgnored() {
          return [...this._ignoredPaths.values()];
        }
        /**
         * Determines whether user has asked to ignore this path.
         * @param {Path} path filepath or dir
         * @param {fs.Stats=} stats result of fs.stat
         * @returns {Boolean}
         */
        _isIgnored(path6, stats) {
          if (this.options.atomic && DOT_RE.test(path6))
            return true;
          if (!this._userIgnored) {
            const { cwd } = this.options;
            const ign = this.options.ignored;
            const ignored = ign && ign.map(normalizeIgnored(cwd));
            const paths = arrify(ignored).filter((path7) => typeof path7 === STRING_TYPE && !isGlob(path7)).map((path7) => path7 + SLASH_GLOBSTAR);
            const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
            this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
          }
          return this._userIgnored([path6, stats]);
        }
        _isntIgnored(path6, stat5) {
          return !this._isIgnored(path6, stat5);
        }
        /**
         * Provides a set of common helpers and properties relating to symlink and glob handling.
         * @param {Path} path file, directory, or glob pattern being watched
         * @param {Number=} depth at any depth > 0, this isn't a glob
         * @returns {WatchHelper} object containing helpers for this path
         */
        _getWatchHelpers(path6, depth) {
          const watchPath = depth || this.options.disableGlobbing || !isGlob(path6) ? path6 : globParent(path6);
          const follow = this.options.followSymlinks;
          return new WatchHelper(path6, watchPath, follow, this);
        }
        // Directory helpers
        // -----------------
        /**
         * Provides directory tracking objects
         * @param {String} directory path of the directory
         * @returns {DirEntry} the directory's tracking object
         */
        _getWatchedDir(directory) {
          if (!this._boundRemove)
            this._boundRemove = this._remove.bind(this);
          const dir = sysPath.resolve(directory);
          if (!this._watched.has(dir))
            this._watched.set(dir, new DirEntry(dir, this._boundRemove));
          return this._watched.get(dir);
        }
        // File helpers
        // ------------
        /**
         * Check for read permissions.
         * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
         * @param {fs.Stats} stats - object, result of fs_stat
         * @returns {Boolean} indicates whether the file can be read
        */
        _hasReadPermissions(stats) {
          if (this.options.ignorePermissionErrors)
            return true;
          const md = stats && Number.parseInt(stats.mode, 10);
          const st = md & 511;
          const it = Number.parseInt(st.toString(8)[0], 10);
          return Boolean(4 & it);
        }
        /**
         * Handles emitting unlink events for
         * files and directories, and via recursion, for
         * files and directories within directories that are unlinked
         * @param {String} directory within which the following item is located
         * @param {String} item      base path of item/directory
         * @returns {void}
        */
        _remove(directory, item, isDirectory) {
          const path6 = sysPath.join(directory, item);
          const fullPath = sysPath.resolve(path6);
          isDirectory = isDirectory != null ? isDirectory : this._watched.has(path6) || this._watched.has(fullPath);
          if (!this._throttle("remove", path6, 100))
            return;
          if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
            this.add(directory, item, true);
          }
          const wp = this._getWatchedDir(path6);
          const nestedDirectoryChildren = wp.getChildren();
          nestedDirectoryChildren.forEach((nested) => this._remove(path6, nested));
          const parent = this._getWatchedDir(directory);
          const wasTracked = parent.has(item);
          parent.remove(item);
          if (this._symlinkPaths.has(fullPath)) {
            this._symlinkPaths.delete(fullPath);
          }
          let relPath = path6;
          if (this.options.cwd)
            relPath = sysPath.relative(this.options.cwd, path6);
          if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
            const event = this._pendingWrites.get(relPath).cancelWait();
            if (event === EV_ADD)
              return;
          }
          this._watched.delete(path6);
          this._watched.delete(fullPath);
          const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
          if (wasTracked && !this._isIgnored(path6))
            this._emit(eventName, path6);
          if (!this.options.useFsEvents) {
            this._closePath(path6);
          }
        }
        /**
         * Closes all watchers for a path
         * @param {Path} path
         */
        _closePath(path6) {
          this._closeFile(path6);
          const dir = sysPath.dirname(path6);
          this._getWatchedDir(dir).remove(sysPath.basename(path6));
        }
        /**
         * Closes only file-specific watchers
         * @param {Path} path
         */
        _closeFile(path6) {
          const closers = this._closers.get(path6);
          if (!closers)
            return;
          closers.forEach((closer) => closer());
          this._closers.delete(path6);
        }
        /**
         *
         * @param {Path} path
         * @param {Function} closer
         */
        _addPathCloser(path6, closer) {
          if (!closer)
            return;
          let list = this._closers.get(path6);
          if (!list) {
            list = [];
            this._closers.set(path6, list);
          }
          list.push(closer);
        }
        _readdirp(root, opts) {
          if (this.closed)
            return;
          const options = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
          let stream2 = readdirp(root, options);
          this._streams.add(stream2);
          stream2.once(STR_CLOSE, () => {
            stream2 = void 0;
          });
          stream2.once(STR_END, () => {
            if (stream2) {
              this._streams.delete(stream2);
              stream2 = void 0;
            }
          });
          return stream2;
        }
      };
      exports.FSWatcher = FSWatcher;
      var watch3 = (paths, options) => {
        const watcher = new FSWatcher(options);
        watcher.add(paths);
        return watcher;
      };
      exports.watch = watch3;
    }
  });

  // ../../node_modules/.pnpm/esbuild@0.24.0/node_modules/esbuild/lib/main.js
  var require_main = __commonJS({
    "../../node_modules/.pnpm/esbuild@0.24.0/node_modules/esbuild/lib/main.js"(exports, module) {
      "use strict";
      var __defProp12 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export3 = (target, all) => {
        for (var name in all)
          __defProp12(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp12(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod2) => __copyProps2(__defProp12({}, "__esModule", { value: true }), mod2);
      var node_exports = {};
      __export3(node_exports, {
        analyzeMetafile: () => analyzeMetafile,
        analyzeMetafileSync: () => analyzeMetafileSync,
        build: () => build3,
        buildSync: () => buildSync,
        context: () => context2,
        default: () => node_default3,
        formatMessages: () => formatMessages,
        formatMessagesSync: () => formatMessagesSync,
        initialize: () => initialize,
        stop: () => stop,
        transform: () => transform,
        transformSync: () => transformSync,
        version: () => version3
      });
      module.exports = __toCommonJS2(node_exports);
      function encodePacket(packet) {
        let visit2 = (value) => {
          if (value === null) {
            bb.write8(0);
          } else if (typeof value === "boolean") {
            bb.write8(1);
            bb.write8(+value);
          } else if (typeof value === "number") {
            bb.write8(2);
            bb.write32(value | 0);
          } else if (typeof value === "string") {
            bb.write8(3);
            bb.write(encodeUTF8(value));
          } else if (value instanceof Uint8Array) {
            bb.write8(4);
            bb.write(value);
          } else if (value instanceof Array) {
            bb.write8(5);
            bb.write32(value.length);
            for (let item of value) {
              visit2(item);
            }
          } else {
            let keys4 = Object.keys(value);
            bb.write8(6);
            bb.write32(keys4.length);
            for (let key of keys4) {
              bb.write(encodeUTF8(key));
              visit2(value[key]);
            }
          }
        };
        let bb = new ByteBuffer();
        bb.write32(0);
        bb.write32(packet.id << 1 | +!packet.isRequest);
        visit2(packet.value);
        writeUInt32LE(bb.buf, bb.len - 4, 0);
        return bb.buf.subarray(0, bb.len);
      }
      function decodePacket(bytes2) {
        let visit2 = () => {
          switch (bb.read8()) {
            case 0:
              return null;
            case 1:
              return !!bb.read8();
            case 2:
              return bb.read32();
            case 3:
              return decodeUTF8(bb.read());
            case 4:
              return bb.read();
            case 5: {
              let count = bb.read32();
              let value2 = [];
              for (let i = 0; i < count; i++) {
                value2.push(visit2());
              }
              return value2;
            }
            case 6: {
              let count = bb.read32();
              let value2 = {};
              for (let i = 0; i < count; i++) {
                value2[decodeUTF8(bb.read())] = visit2();
              }
              return value2;
            }
            default:
              throw new Error("Invalid packet");
          }
        };
        let bb = new ByteBuffer(bytes2);
        let id = bb.read32();
        let isRequest2 = (id & 1) === 0;
        id >>>= 1;
        let value = visit2();
        if (bb.ptr !== bytes2.length) {
          throw new Error("Invalid packet");
        }
        return { id, isRequest: isRequest2, value };
      }
      var ByteBuffer = class {
        constructor(buf = new Uint8Array(1024)) {
          this.buf = buf;
          this.len = 0;
          this.ptr = 0;
        }
        _write(delta) {
          if (this.len + delta > this.buf.length) {
            let clone5 = new Uint8Array((this.len + delta) * 2);
            clone5.set(this.buf);
            this.buf = clone5;
          }
          this.len += delta;
          return this.len - delta;
        }
        write8(value) {
          let offset = this._write(1);
          this.buf[offset] = value;
        }
        write32(value) {
          let offset = this._write(4);
          writeUInt32LE(this.buf, value, offset);
        }
        write(bytes2) {
          let offset = this._write(4 + bytes2.length);
          writeUInt32LE(this.buf, bytes2.length, offset);
          this.buf.set(bytes2, offset + 4);
        }
        _read(delta) {
          if (this.ptr + delta > this.buf.length) {
            throw new Error("Invalid packet");
          }
          this.ptr += delta;
          return this.ptr - delta;
        }
        read8() {
          return this.buf[this._read(1)];
        }
        read32() {
          return readUInt32LE(this.buf, this._read(4));
        }
        read() {
          let length = this.read32();
          let bytes2 = new Uint8Array(length);
          let ptr = this._read(bytes2.length);
          bytes2.set(this.buf.subarray(ptr, ptr + length));
          return bytes2;
        }
      };
      var encodeUTF8;
      var decodeUTF8;
      var encodeInvariant;
      if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
        let encoder = new TextEncoder();
        let decoder = new TextDecoder();
        encodeUTF8 = (text) => encoder.encode(text);
        decodeUTF8 = (bytes2) => decoder.decode(bytes2);
        encodeInvariant = 'new TextEncoder().encode("")';
      } else if (typeof Buffer !== "undefined") {
        encodeUTF8 = (text) => Buffer.from(text);
        decodeUTF8 = (bytes2) => {
          let { buffer, byteOffset, byteLength } = bytes2;
          return Buffer.from(buffer, byteOffset, byteLength).toString();
        };
        encodeInvariant = 'Buffer.from("")';
      } else {
        throw new Error("No UTF-8 codec found");
      }
      if (!(encodeUTF8("") instanceof Uint8Array))
        throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
      function readUInt32LE(buffer, offset) {
        return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
      }
      function writeUInt32LE(buffer, value, offset) {
        buffer[offset++] = value;
        buffer[offset++] = value >> 8;
        buffer[offset++] = value >> 16;
        buffer[offset++] = value >> 24;
      }
      var quote = JSON.stringify;
      var buildLogLevelDefault = "warning";
      var transformLogLevelDefault = "silent";
      function validateTarget(target) {
        validateStringValue(target, "target");
        if (target.indexOf(",") >= 0)
          throw new Error(`Invalid target: ${target}`);
        return target;
      }
      var canBeAnything = () => null;
      var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
      var mustBeString = (value) => typeof value === "string" ? null : "a string";
      var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
      var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
      var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
      var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
      var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
      var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
      var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
      var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
      var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
      var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
      var mustBeStringOrArray = (value) => typeof value === "string" || Array.isArray(value) ? null : "a string or an array";
      var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
      var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
      function getFlag(object2, keys4, key, mustBeFn) {
        let value = object2[key];
        keys4[key + ""] = true;
        if (value === void 0)
          return void 0;
        let mustBe = mustBeFn(value);
        if (mustBe !== null)
          throw new Error(`${quote(key)} must be ${mustBe}`);
        return value;
      }
      function checkForInvalidFlags(object2, keys4, where) {
        for (let key in object2) {
          if (!(key in keys4)) {
            throw new Error(`Invalid option ${where}: ${quote(key)}`);
          }
        }
      }
      function validateInitializeOptions(options) {
        let keys4 = /* @__PURE__ */ Object.create(null);
        let wasmURL = getFlag(options, keys4, "wasmURL", mustBeStringOrURL);
        let wasmModule = getFlag(options, keys4, "wasmModule", mustBeWebAssemblyModule);
        let worker = getFlag(options, keys4, "worker", mustBeBoolean);
        checkForInvalidFlags(options, keys4, "in initialize() call");
        return {
          wasmURL,
          wasmModule,
          worker
        };
      }
      function validateMangleCache(mangleCache) {
        let validated;
        if (mangleCache !== void 0) {
          validated = /* @__PURE__ */ Object.create(null);
          for (let key in mangleCache) {
            let value = mangleCache[key];
            if (typeof value === "string" || value === false) {
              validated[key] = value;
            } else {
              throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
            }
          }
        }
        return validated;
      }
      function pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault) {
        let color = getFlag(options, keys4, "color", mustBeBoolean);
        let logLevel = getFlag(options, keys4, "logLevel", mustBeString);
        let logLimit = getFlag(options, keys4, "logLimit", mustBeInteger);
        if (color !== void 0)
          flags.push(`--color=${color}`);
        else if (isTTY2)
          flags.push(`--color=true`);
        flags.push(`--log-level=${logLevel || logLevelDefault}`);
        flags.push(`--log-limit=${logLimit || 0}`);
      }
      function validateStringValue(value, what, key) {
        if (typeof value !== "string") {
          throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
        }
        return value;
      }
      function pushCommonFlags(flags, options, keys4) {
        let legalComments = getFlag(options, keys4, "legalComments", mustBeString);
        let sourceRoot = getFlag(options, keys4, "sourceRoot", mustBeString);
        let sourcesContent = getFlag(options, keys4, "sourcesContent", mustBeBoolean);
        let target = getFlag(options, keys4, "target", mustBeStringOrArray);
        let format = getFlag(options, keys4, "format", mustBeString);
        let globalName = getFlag(options, keys4, "globalName", mustBeString);
        let mangleProps = getFlag(options, keys4, "mangleProps", mustBeRegExp);
        let reserveProps = getFlag(options, keys4, "reserveProps", mustBeRegExp);
        let mangleQuoted = getFlag(options, keys4, "mangleQuoted", mustBeBoolean);
        let minify = getFlag(options, keys4, "minify", mustBeBoolean);
        let minifySyntax = getFlag(options, keys4, "minifySyntax", mustBeBoolean);
        let minifyWhitespace = getFlag(options, keys4, "minifyWhitespace", mustBeBoolean);
        let minifyIdentifiers = getFlag(options, keys4, "minifyIdentifiers", mustBeBoolean);
        let lineLimit = getFlag(options, keys4, "lineLimit", mustBeInteger);
        let drop = getFlag(options, keys4, "drop", mustBeArray);
        let dropLabels = getFlag(options, keys4, "dropLabels", mustBeArray);
        let charset = getFlag(options, keys4, "charset", mustBeString);
        let treeShaking = getFlag(options, keys4, "treeShaking", mustBeBoolean);
        let ignoreAnnotations = getFlag(options, keys4, "ignoreAnnotations", mustBeBoolean);
        let jsx = getFlag(options, keys4, "jsx", mustBeString);
        let jsxFactory = getFlag(options, keys4, "jsxFactory", mustBeString);
        let jsxFragment = getFlag(options, keys4, "jsxFragment", mustBeString);
        let jsxImportSource = getFlag(options, keys4, "jsxImportSource", mustBeString);
        let jsxDev = getFlag(options, keys4, "jsxDev", mustBeBoolean);
        let jsxSideEffects = getFlag(options, keys4, "jsxSideEffects", mustBeBoolean);
        let define2 = getFlag(options, keys4, "define", mustBeObject);
        let logOverride = getFlag(options, keys4, "logOverride", mustBeObject);
        let supported = getFlag(options, keys4, "supported", mustBeObject);
        let pure = getFlag(options, keys4, "pure", mustBeArray);
        let keepNames = getFlag(options, keys4, "keepNames", mustBeBoolean);
        let platform2 = getFlag(options, keys4, "platform", mustBeString);
        let tsconfigRaw = getFlag(options, keys4, "tsconfigRaw", mustBeStringOrObject);
        if (legalComments)
          flags.push(`--legal-comments=${legalComments}`);
        if (sourceRoot !== void 0)
          flags.push(`--source-root=${sourceRoot}`);
        if (sourcesContent !== void 0)
          flags.push(`--sources-content=${sourcesContent}`);
        if (target) {
          if (Array.isArray(target))
            flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
          else
            flags.push(`--target=${validateTarget(target)}`);
        }
        if (format)
          flags.push(`--format=${format}`);
        if (globalName)
          flags.push(`--global-name=${globalName}`);
        if (platform2)
          flags.push(`--platform=${platform2}`);
        if (tsconfigRaw)
          flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
        if (minify)
          flags.push("--minify");
        if (minifySyntax)
          flags.push("--minify-syntax");
        if (minifyWhitespace)
          flags.push("--minify-whitespace");
        if (minifyIdentifiers)
          flags.push("--minify-identifiers");
        if (lineLimit)
          flags.push(`--line-limit=${lineLimit}`);
        if (charset)
          flags.push(`--charset=${charset}`);
        if (treeShaking !== void 0)
          flags.push(`--tree-shaking=${treeShaking}`);
        if (ignoreAnnotations)
          flags.push(`--ignore-annotations`);
        if (drop)
          for (let what of drop)
            flags.push(`--drop:${validateStringValue(what, "drop")}`);
        if (dropLabels)
          flags.push(`--drop-labels=${Array.from(dropLabels).map((what) => validateStringValue(what, "dropLabels")).join(",")}`);
        if (mangleProps)
          flags.push(`--mangle-props=${mangleProps.source}`);
        if (reserveProps)
          flags.push(`--reserve-props=${reserveProps.source}`);
        if (mangleQuoted !== void 0)
          flags.push(`--mangle-quoted=${mangleQuoted}`);
        if (jsx)
          flags.push(`--jsx=${jsx}`);
        if (jsxFactory)
          flags.push(`--jsx-factory=${jsxFactory}`);
        if (jsxFragment)
          flags.push(`--jsx-fragment=${jsxFragment}`);
        if (jsxImportSource)
          flags.push(`--jsx-import-source=${jsxImportSource}`);
        if (jsxDev)
          flags.push(`--jsx-dev`);
        if (jsxSideEffects)
          flags.push(`--jsx-side-effects`);
        if (define2) {
          for (let key in define2) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid define: ${key}`);
            flags.push(`--define:${key}=${validateStringValue(define2[key], "define", key)}`);
          }
        }
        if (logOverride) {
          for (let key in logOverride) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid log override: ${key}`);
            flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
          }
        }
        if (supported) {
          for (let key in supported) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid supported: ${key}`);
            const value = supported[key];
            if (typeof value !== "boolean")
              throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
            flags.push(`--supported:${key}=${value}`);
          }
        }
        if (pure)
          for (let fn of pure)
            flags.push(`--pure:${validateStringValue(fn, "pure")}`);
        if (keepNames)
          flags.push(`--keep-names`);
      }
      function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
        var _a22;
        let flags = [];
        let entries = [];
        let keys4 = /* @__PURE__ */ Object.create(null);
        let stdinContents = null;
        let stdinResolveDir = null;
        pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault);
        pushCommonFlags(flags, options, keys4);
        let sourcemap = getFlag(options, keys4, "sourcemap", mustBeStringOrBoolean);
        let bundle = getFlag(options, keys4, "bundle", mustBeBoolean);
        let splitting = getFlag(options, keys4, "splitting", mustBeBoolean);
        let preserveSymlinks = getFlag(options, keys4, "preserveSymlinks", mustBeBoolean);
        let metafile = getFlag(options, keys4, "metafile", mustBeBoolean);
        let outfile = getFlag(options, keys4, "outfile", mustBeString);
        let outdir = getFlag(options, keys4, "outdir", mustBeString);
        let outbase = getFlag(options, keys4, "outbase", mustBeString);
        let tsconfig = getFlag(options, keys4, "tsconfig", mustBeString);
        let resolveExtensions = getFlag(options, keys4, "resolveExtensions", mustBeArray);
        let nodePathsInput = getFlag(options, keys4, "nodePaths", mustBeArray);
        let mainFields = getFlag(options, keys4, "mainFields", mustBeArray);
        let conditions = getFlag(options, keys4, "conditions", mustBeArray);
        let external = getFlag(options, keys4, "external", mustBeArray);
        let packages = getFlag(options, keys4, "packages", mustBeString);
        let alias = getFlag(options, keys4, "alias", mustBeObject);
        let loader = getFlag(options, keys4, "loader", mustBeObject);
        let outExtension = getFlag(options, keys4, "outExtension", mustBeObject);
        let publicPath = getFlag(options, keys4, "publicPath", mustBeString);
        let entryNames = getFlag(options, keys4, "entryNames", mustBeString);
        let chunkNames = getFlag(options, keys4, "chunkNames", mustBeString);
        let assetNames = getFlag(options, keys4, "assetNames", mustBeString);
        let inject = getFlag(options, keys4, "inject", mustBeArray);
        let banner = getFlag(options, keys4, "banner", mustBeObject);
        let footer = getFlag(options, keys4, "footer", mustBeObject);
        let entryPoints = getFlag(options, keys4, "entryPoints", mustBeEntryPoints);
        let absWorkingDir = getFlag(options, keys4, "absWorkingDir", mustBeString);
        let stdin = getFlag(options, keys4, "stdin", mustBeObject);
        let write = (_a22 = getFlag(options, keys4, "write", mustBeBoolean)) != null ? _a22 : writeDefault;
        let allowOverwrite = getFlag(options, keys4, "allowOverwrite", mustBeBoolean);
        let mangleCache = getFlag(options, keys4, "mangleCache", mustBeObject);
        keys4.plugins = true;
        checkForInvalidFlags(options, keys4, `in ${callName}() call`);
        if (sourcemap)
          flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
        if (bundle)
          flags.push("--bundle");
        if (allowOverwrite)
          flags.push("--allow-overwrite");
        if (splitting)
          flags.push("--splitting");
        if (preserveSymlinks)
          flags.push("--preserve-symlinks");
        if (metafile)
          flags.push(`--metafile`);
        if (outfile)
          flags.push(`--outfile=${outfile}`);
        if (outdir)
          flags.push(`--outdir=${outdir}`);
        if (outbase)
          flags.push(`--outbase=${outbase}`);
        if (tsconfig)
          flags.push(`--tsconfig=${tsconfig}`);
        if (packages)
          flags.push(`--packages=${packages}`);
        if (resolveExtensions) {
          let values = [];
          for (let value of resolveExtensions) {
            validateStringValue(value, "resolve extension");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid resolve extension: ${value}`);
            values.push(value);
          }
          flags.push(`--resolve-extensions=${values.join(",")}`);
        }
        if (publicPath)
          flags.push(`--public-path=${publicPath}`);
        if (entryNames)
          flags.push(`--entry-names=${entryNames}`);
        if (chunkNames)
          flags.push(`--chunk-names=${chunkNames}`);
        if (assetNames)
          flags.push(`--asset-names=${assetNames}`);
        if (mainFields) {
          let values = [];
          for (let value of mainFields) {
            validateStringValue(value, "main field");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid main field: ${value}`);
            values.push(value);
          }
          flags.push(`--main-fields=${values.join(",")}`);
        }
        if (conditions) {
          let values = [];
          for (let value of conditions) {
            validateStringValue(value, "condition");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid condition: ${value}`);
            values.push(value);
          }
          flags.push(`--conditions=${values.join(",")}`);
        }
        if (external)
          for (let name of external)
            flags.push(`--external:${validateStringValue(name, "external")}`);
        if (alias) {
          for (let old in alias) {
            if (old.indexOf("=") >= 0)
              throw new Error(`Invalid package name in alias: ${old}`);
            flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
          }
        }
        if (banner) {
          for (let type3 in banner) {
            if (type3.indexOf("=") >= 0)
              throw new Error(`Invalid banner file type: ${type3}`);
            flags.push(`--banner:${type3}=${validateStringValue(banner[type3], "banner", type3)}`);
          }
        }
        if (footer) {
          for (let type3 in footer) {
            if (type3.indexOf("=") >= 0)
              throw new Error(`Invalid footer file type: ${type3}`);
            flags.push(`--footer:${type3}=${validateStringValue(footer[type3], "footer", type3)}`);
          }
        }
        if (inject)
          for (let path32 of inject)
            flags.push(`--inject:${validateStringValue(path32, "inject")}`);
        if (loader) {
          for (let ext2 in loader) {
            if (ext2.indexOf("=") >= 0)
              throw new Error(`Invalid loader extension: ${ext2}`);
            flags.push(`--loader:${ext2}=${validateStringValue(loader[ext2], "loader", ext2)}`);
          }
        }
        if (outExtension) {
          for (let ext2 in outExtension) {
            if (ext2.indexOf("=") >= 0)
              throw new Error(`Invalid out extension: ${ext2}`);
            flags.push(`--out-extension:${ext2}=${validateStringValue(outExtension[ext2], "out extension", ext2)}`);
          }
        }
        if (entryPoints) {
          if (Array.isArray(entryPoints)) {
            for (let i = 0, n = entryPoints.length; i < n; i++) {
              let entryPoint = entryPoints[i];
              if (typeof entryPoint === "object" && entryPoint !== null) {
                let entryPointKeys = /* @__PURE__ */ Object.create(null);
                let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
                let output2 = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
                checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
                if (input === void 0)
                  throw new Error('Missing property "in" for entry point at index ' + i);
                if (output2 === void 0)
                  throw new Error('Missing property "out" for entry point at index ' + i);
                entries.push([output2, input]);
              } else {
                entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
              }
            }
          } else {
            for (let key in entryPoints) {
              entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
            }
          }
        }
        if (stdin) {
          let stdinKeys = /* @__PURE__ */ Object.create(null);
          let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
          let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
          let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
          let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
          checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
          if (sourcefile)
            flags.push(`--sourcefile=${sourcefile}`);
          if (loader2)
            flags.push(`--loader=${loader2}`);
          if (resolveDir)
            stdinResolveDir = resolveDir;
          if (typeof contents === "string")
            stdinContents = encodeUTF8(contents);
          else if (contents instanceof Uint8Array)
            stdinContents = contents;
        }
        let nodePaths = [];
        if (nodePathsInput) {
          for (let value of nodePathsInput) {
            value += "";
            nodePaths.push(value);
          }
        }
        return {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
        let flags = [];
        let keys4 = /* @__PURE__ */ Object.create(null);
        pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault);
        pushCommonFlags(flags, options, keys4);
        let sourcemap = getFlag(options, keys4, "sourcemap", mustBeStringOrBoolean);
        let sourcefile = getFlag(options, keys4, "sourcefile", mustBeString);
        let loader = getFlag(options, keys4, "loader", mustBeString);
        let banner = getFlag(options, keys4, "banner", mustBeString);
        let footer = getFlag(options, keys4, "footer", mustBeString);
        let mangleCache = getFlag(options, keys4, "mangleCache", mustBeObject);
        checkForInvalidFlags(options, keys4, `in ${callName}() call`);
        if (sourcemap)
          flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader)
          flags.push(`--loader=${loader}`);
        if (banner)
          flags.push(`--banner=${banner}`);
        if (footer)
          flags.push(`--footer=${footer}`);
        return {
          flags,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      function createChannel(streamIn) {
        const requestCallbacksByKey = {};
        const closeData = { didClose: false, reason: "" };
        let responseCallbacks = {};
        let nextRequestID = 0;
        let nextBuildKey = 0;
        let stdout = new Uint8Array(16 * 1024);
        let stdoutUsed = 0;
        let readFromStdout = (chunk) => {
          let limit = stdoutUsed + chunk.length;
          if (limit > stdout.length) {
            let swap = new Uint8Array(limit * 2);
            swap.set(stdout);
            stdout = swap;
          }
          stdout.set(chunk, stdoutUsed);
          stdoutUsed += chunk.length;
          let offset = 0;
          while (offset + 4 <= stdoutUsed) {
            let length = readUInt32LE(stdout, offset);
            if (offset + 4 + length > stdoutUsed) {
              break;
            }
            offset += 4;
            handleIncomingPacket(stdout.subarray(offset, offset + length));
            offset += length;
          }
          if (offset > 0) {
            stdout.copyWithin(0, offset, stdoutUsed);
            stdoutUsed -= offset;
          }
        };
        let afterClose = (error3) => {
          closeData.didClose = true;
          if (error3)
            closeData.reason = ": " + (error3.message || error3);
          const text = "The service was stopped" + closeData.reason;
          for (let id in responseCallbacks) {
            responseCallbacks[id](text, null);
          }
          responseCallbacks = {};
        };
        let sendRequest = (refs, value, callback) => {
          if (closeData.didClose)
            return callback("The service is no longer running" + closeData.reason, null);
          let id = nextRequestID++;
          responseCallbacks[id] = (error3, response) => {
            try {
              callback(error3, response);
            } finally {
              if (refs)
                refs.unref();
            }
          };
          if (refs)
            refs.ref();
          streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
        };
        let sendResponse = (id, value) => {
          if (closeData.didClose)
            throw new Error("The service is no longer running" + closeData.reason);
          streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
        };
        let handleRequest = async (id, request) => {
          try {
            if (request.command === "ping") {
              sendResponse(id, {});
              return;
            }
            if (typeof request.key === "number") {
              const requestCallbacks = requestCallbacksByKey[request.key];
              if (!requestCallbacks) {
                return;
              }
              const callback = requestCallbacks[request.command];
              if (callback) {
                await callback(id, request);
                return;
              }
            }
            throw new Error(`Invalid command: ` + request.command);
          } catch (e) {
            const errors2 = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
            try {
              sendResponse(id, { errors: errors2 });
            } catch {
            }
          }
        };
        let isFirstPacket = true;
        let handleIncomingPacket = (bytes2) => {
          if (isFirstPacket) {
            isFirstPacket = false;
            let binaryVersion = String.fromCharCode(...bytes2);
            if (binaryVersion !== "0.24.0") {
              throw new Error(`Cannot start service: Host version "${"0.24.0"}" does not match binary version ${quote(binaryVersion)}`);
            }
            return;
          }
          let packet = decodePacket(bytes2);
          if (packet.isRequest) {
            handleRequest(packet.id, packet.value);
          } else {
            let callback = responseCallbacks[packet.id];
            delete responseCallbacks[packet.id];
            if (packet.value.error)
              callback(packet.value.error, {});
            else
              callback(null, packet.value);
          }
        };
        let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
          let refCount = 0;
          const buildKey = nextBuildKey++;
          const requestCallbacks = {};
          const buildRefs = {
            ref() {
              if (++refCount === 1) {
                if (refs)
                  refs.ref();
              }
            },
            unref() {
              if (--refCount === 0) {
                delete requestCallbacksByKey[buildKey];
                if (refs)
                  refs.unref();
              }
            }
          };
          requestCallbacksByKey[buildKey] = requestCallbacks;
          buildRefs.ref();
          buildOrContextImpl(
            callName,
            buildKey,
            sendRequest,
            sendResponse,
            buildRefs,
            streamIn,
            requestCallbacks,
            options,
            isTTY2,
            defaultWD2,
            (err2, res) => {
              try {
                callback(err2, res);
              } finally {
                buildRefs.unref();
              }
            }
          );
        };
        let transform2 = ({ callName, refs, input, options, isTTY: isTTY2, fs: fs32, callback }) => {
          const details = createObjectStash();
          let start = (inputPath) => {
            try {
              if (typeof input !== "string" && !(input instanceof Uint8Array))
                throw new Error('The input to "transform" must be a string or a Uint8Array');
              let {
                flags,
                mangleCache
              } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
              let request = {
                command: "transform",
                flags,
                inputFS: inputPath !== null,
                input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
              };
              if (mangleCache)
                request.mangleCache = mangleCache;
              sendRequest(refs, request, (error3, response) => {
                if (error3)
                  return callback(new Error(error3), null);
                let errors2 = replaceDetailsInMessages(response.errors, details);
                let warnings = replaceDetailsInMessages(response.warnings, details);
                let outstanding = 1;
                let next = () => {
                  if (--outstanding === 0) {
                    let result = {
                      warnings,
                      code: response.code,
                      map: response.map,
                      mangleCache: void 0,
                      legalComments: void 0
                    };
                    if ("legalComments" in response)
                      result.legalComments = response == null ? void 0 : response.legalComments;
                    if (response.mangleCache)
                      result.mangleCache = response == null ? void 0 : response.mangleCache;
                    callback(null, result);
                  }
                };
                if (errors2.length > 0)
                  return callback(failureErrorWithLog("Transform failed", errors2, warnings), null);
                if (response.codeFS) {
                  outstanding++;
                  fs32.readFile(response.code, (err2, contents) => {
                    if (err2 !== null) {
                      callback(err2, null);
                    } else {
                      response.code = contents;
                      next();
                    }
                  });
                }
                if (response.mapFS) {
                  outstanding++;
                  fs32.readFile(response.map, (err2, contents) => {
                    if (err2 !== null) {
                      callback(err2, null);
                    } else {
                      response.map = contents;
                      next();
                    }
                  });
                }
                next();
              });
            } catch (e) {
              let flags = [];
              try {
                pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
              } catch {
              }
              const error3 = extractErrorMessageV8(e, streamIn, details, void 0, "");
              sendRequest(refs, { command: "error", flags, error: error3 }, () => {
                error3.detail = details.load(error3.detail);
                callback(failureErrorWithLog("Transform failed", [error3], []), null);
              });
            }
          };
          if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
            let next = start;
            start = () => fs32.writeFile(input, next);
          }
          start(null);
        };
        let formatMessages2 = ({ callName, refs, messages, options, callback }) => {
          if (!options)
            throw new Error(`Missing second argument in ${callName}() call`);
          let keys4 = {};
          let kind = getFlag(options, keys4, "kind", mustBeString);
          let color = getFlag(options, keys4, "color", mustBeBoolean);
          let terminalWidth = getFlag(options, keys4, "terminalWidth", mustBeInteger);
          checkForInvalidFlags(options, keys4, `in ${callName}() call`);
          if (kind === void 0)
            throw new Error(`Missing "kind" in ${callName}() call`);
          if (kind !== "error" && kind !== "warning")
            throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
          let request = {
            command: "format-msgs",
            messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
            isWarning: kind === "warning"
          };
          if (color !== void 0)
            request.color = color;
          if (terminalWidth !== void 0)
            request.terminalWidth = terminalWidth;
          sendRequest(refs, request, (error3, response) => {
            if (error3)
              return callback(new Error(error3), null);
            callback(null, response.messages);
          });
        };
        let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
          if (options === void 0)
            options = {};
          let keys4 = {};
          let color = getFlag(options, keys4, "color", mustBeBoolean);
          let verbose = getFlag(options, keys4, "verbose", mustBeBoolean);
          checkForInvalidFlags(options, keys4, `in ${callName}() call`);
          let request = {
            command: "analyze-metafile",
            metafile
          };
          if (color !== void 0)
            request.color = color;
          if (verbose !== void 0)
            request.verbose = verbose;
          sendRequest(refs, request, (error3, response) => {
            if (error3)
              return callback(new Error(error3), null);
            callback(null, response.result);
          });
        };
        return {
          readFromStdout,
          afterClose,
          service: {
            buildOrContext,
            transform: transform2,
            formatMessages: formatMessages2,
            analyzeMetafile: analyzeMetafile2
          }
        };
      }
      function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
        const details = createObjectStash();
        const isContext = callName === "context";
        const handleError = (e, pluginName) => {
          const flags = [];
          try {
            pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
          } catch {
          }
          const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
          sendRequest(refs, { command: "error", flags, error: message }, () => {
            message.detail = details.load(message.detail);
            callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
          });
        };
        let plugins;
        if (typeof options === "object") {
          const value = options.plugins;
          if (value !== void 0) {
            if (!Array.isArray(value))
              return handleError(new Error(`"plugins" must be an array`), "");
            plugins = value;
          }
        }
        if (plugins && plugins.length > 0) {
          if (streamIn.isSync)
            return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
          handlePlugins(
            buildKey,
            sendRequest,
            sendResponse,
            refs,
            streamIn,
            requestCallbacks,
            options,
            plugins,
            details
          ).then(
            (result) => {
              if (!result.ok)
                return handleError(result.error, result.pluginName);
              try {
                buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
              } catch (e) {
                handleError(e, "");
              }
            },
            (e) => handleError(e, "")
          );
          return;
        }
        try {
          buildOrContextContinue(null, (result, done) => done([], []), () => {
          });
        } catch (e) {
          handleError(e, "");
        }
        function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
          const writeDefault = streamIn.hasFS;
          const {
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir,
            nodePaths,
            mangleCache
          } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
          if (write && !streamIn.hasFS)
            throw new Error(`The "write" option is unavailable in this environment`);
          const request = {
            command: "build",
            key: buildKey,
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir: absWorkingDir || defaultWD2,
            nodePaths,
            context: isContext
          };
          if (requestPlugins)
            request.plugins = requestPlugins;
          if (mangleCache)
            request.mangleCache = mangleCache;
          const buildResponseToResult = (response, callback2) => {
            const result = {
              errors: replaceDetailsInMessages(response.errors, details),
              warnings: replaceDetailsInMessages(response.warnings, details),
              outputFiles: void 0,
              metafile: void 0,
              mangleCache: void 0
            };
            const originalErrors = result.errors.slice();
            const originalWarnings = result.warnings.slice();
            if (response.outputFiles)
              result.outputFiles = response.outputFiles.map(convertOutputFiles);
            if (response.metafile)
              result.metafile = JSON.parse(response.metafile);
            if (response.mangleCache)
              result.mangleCache = response.mangleCache;
            if (response.writeToStdout !== void 0)
              console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
            runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
              if (originalErrors.length > 0 || onEndErrors.length > 0) {
                const error3 = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
                return callback2(error3, null, onEndErrors, onEndWarnings);
              }
              callback2(null, result, onEndErrors, onEndWarnings);
            });
          };
          let latestResultPromise;
          let provideLatestResult;
          if (isContext)
            requestCallbacks["on-end"] = (id, request2) => new Promise((resolve10) => {
              buildResponseToResult(request2, (err2, result, onEndErrors, onEndWarnings) => {
                const response = {
                  errors: onEndErrors,
                  warnings: onEndWarnings
                };
                if (provideLatestResult)
                  provideLatestResult(err2, result);
                latestResultPromise = void 0;
                provideLatestResult = void 0;
                sendResponse(id, response);
                resolve10();
              });
            });
          sendRequest(refs, request, (error3, response) => {
            if (error3)
              return callback(new Error(error3), null);
            if (!isContext) {
              return buildResponseToResult(response, (err2, res) => {
                scheduleOnDisposeCallbacks();
                return callback(err2, res);
              });
            }
            if (response.errors.length > 0) {
              return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
            }
            let didDispose = false;
            const result = {
              rebuild: () => {
                if (!latestResultPromise)
                  latestResultPromise = new Promise((resolve10, reject) => {
                    let settlePromise;
                    provideLatestResult = (err2, result2) => {
                      if (!settlePromise)
                        settlePromise = () => err2 ? reject(err2) : resolve10(result2);
                    };
                    const triggerAnotherBuild = () => {
                      const request2 = {
                        command: "rebuild",
                        key: buildKey
                      };
                      sendRequest(refs, request2, (error22, response2) => {
                        if (error22) {
                          reject(new Error(error22));
                        } else if (settlePromise) {
                          settlePromise();
                        } else {
                          triggerAnotherBuild();
                        }
                      });
                    };
                    triggerAnotherBuild();
                  });
                return latestResultPromise;
              },
              watch: (options2 = {}) => new Promise((resolve10, reject) => {
                if (!streamIn.hasFS)
                  throw new Error(`Cannot use the "watch" API in this environment`);
                const keys4 = {};
                checkForInvalidFlags(options2, keys4, `in watch() call`);
                const request2 = {
                  command: "watch",
                  key: buildKey
                };
                sendRequest(refs, request2, (error22) => {
                  if (error22)
                    reject(new Error(error22));
                  else
                    resolve10(void 0);
                });
              }),
              serve: (options2 = {}) => new Promise((resolve10, reject) => {
                if (!streamIn.hasFS)
                  throw new Error(`Cannot use the "serve" API in this environment`);
                const keys4 = {};
                const port = getFlag(options2, keys4, "port", mustBeInteger);
                const host = getFlag(options2, keys4, "host", mustBeString);
                const servedir = getFlag(options2, keys4, "servedir", mustBeString);
                const keyfile = getFlag(options2, keys4, "keyfile", mustBeString);
                const certfile = getFlag(options2, keys4, "certfile", mustBeString);
                const fallback = getFlag(options2, keys4, "fallback", mustBeString);
                const onRequest = getFlag(options2, keys4, "onRequest", mustBeFunction);
                checkForInvalidFlags(options2, keys4, `in serve() call`);
                const request2 = {
                  command: "serve",
                  key: buildKey,
                  onRequest: !!onRequest
                };
                if (port !== void 0)
                  request2.port = port;
                if (host !== void 0)
                  request2.host = host;
                if (servedir !== void 0)
                  request2.servedir = servedir;
                if (keyfile !== void 0)
                  request2.keyfile = keyfile;
                if (certfile !== void 0)
                  request2.certfile = certfile;
                if (fallback !== void 0)
                  request2.fallback = fallback;
                sendRequest(refs, request2, (error22, response2) => {
                  if (error22)
                    return reject(new Error(error22));
                  if (onRequest) {
                    requestCallbacks["serve-request"] = (id, request3) => {
                      onRequest(request3.args);
                      sendResponse(id, {});
                    };
                  }
                  resolve10(response2);
                });
              }),
              cancel: () => new Promise((resolve10) => {
                if (didDispose)
                  return resolve10();
                const request2 = {
                  command: "cancel",
                  key: buildKey
                };
                sendRequest(refs, request2, () => {
                  resolve10();
                });
              }),
              dispose: () => new Promise((resolve10) => {
                if (didDispose)
                  return resolve10();
                didDispose = true;
                const request2 = {
                  command: "dispose",
                  key: buildKey
                };
                sendRequest(refs, request2, () => {
                  resolve10();
                  scheduleOnDisposeCallbacks();
                  refs.unref();
                });
              })
            };
            refs.ref();
            callback(null, result);
          });
        }
      }
      var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
        let onStartCallbacks = [];
        let onEndCallbacks = [];
        let onResolveCallbacks = {};
        let onLoadCallbacks = {};
        let onDisposeCallbacks = [];
        let nextCallbackID = 0;
        let i = 0;
        let requestPlugins = [];
        let isSetupDone = false;
        plugins = [...plugins];
        for (let item of plugins) {
          let keys4 = {};
          if (typeof item !== "object")
            throw new Error(`Plugin at index ${i} must be an object`);
          const name = getFlag(item, keys4, "name", mustBeString);
          if (typeof name !== "string" || name === "")
            throw new Error(`Plugin at index ${i} is missing a name`);
          try {
            let setup = getFlag(item, keys4, "setup", mustBeFunction);
            if (typeof setup !== "function")
              throw new Error(`Plugin is missing a setup function`);
            checkForInvalidFlags(item, keys4, `on plugin ${quote(name)}`);
            let plugin = {
              name,
              onStart: false,
              onEnd: false,
              onResolve: [],
              onLoad: []
            };
            i++;
            let resolve10 = (path32, options = {}) => {
              if (!isSetupDone)
                throw new Error('Cannot call "resolve" before plugin setup has completed');
              if (typeof path32 !== "string")
                throw new Error(`The path to resolve must be a string`);
              let keys22 = /* @__PURE__ */ Object.create(null);
              let pluginName = getFlag(options, keys22, "pluginName", mustBeString);
              let importer = getFlag(options, keys22, "importer", mustBeString);
              let namespace = getFlag(options, keys22, "namespace", mustBeString);
              let resolveDir = getFlag(options, keys22, "resolveDir", mustBeString);
              let kind = getFlag(options, keys22, "kind", mustBeString);
              let pluginData = getFlag(options, keys22, "pluginData", canBeAnything);
              let importAttributes = getFlag(options, keys22, "with", mustBeObject);
              checkForInvalidFlags(options, keys22, "in resolve() call");
              return new Promise((resolve22, reject) => {
                const request = {
                  command: "resolve",
                  path: path32,
                  key: buildKey,
                  pluginName: name
                };
                if (pluginName != null)
                  request.pluginName = pluginName;
                if (importer != null)
                  request.importer = importer;
                if (namespace != null)
                  request.namespace = namespace;
                if (resolveDir != null)
                  request.resolveDir = resolveDir;
                if (kind != null)
                  request.kind = kind;
                else
                  throw new Error(`Must specify "kind" when calling "resolve"`);
                if (pluginData != null)
                  request.pluginData = details.store(pluginData);
                if (importAttributes != null)
                  request.with = sanitizeStringMap(importAttributes, "with");
                sendRequest(refs, request, (error3, response) => {
                  if (error3 !== null)
                    reject(new Error(error3));
                  else
                    resolve22({
                      errors: replaceDetailsInMessages(response.errors, details),
                      warnings: replaceDetailsInMessages(response.warnings, details),
                      path: response.path,
                      external: response.external,
                      sideEffects: response.sideEffects,
                      namespace: response.namespace,
                      suffix: response.suffix,
                      pluginData: details.load(response.pluginData)
                    });
                });
              });
            };
            let promise = setup({
              initialOptions,
              resolve: resolve10,
              onStart(callback) {
                let registeredText = `This error came from the "onStart" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                onStartCallbacks.push({ name, callback, note: registeredNote });
                plugin.onStart = true;
              },
              onEnd(callback) {
                let registeredText = `This error came from the "onEnd" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                onEndCallbacks.push({ name, callback, note: registeredNote });
                plugin.onEnd = true;
              },
              onResolve(options, callback) {
                let registeredText = `This error came from the "onResolve" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                let keys22 = {};
                let filter2 = getFlag(options, keys22, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys22, "namespace", mustBeString);
                checkForInvalidFlags(options, keys22, `in onResolve() call for plugin ${quote(name)}`);
                if (filter2 == null)
                  throw new Error(`onResolve() call is missing a filter`);
                let id = nextCallbackID++;
                onResolveCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onResolve.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              onLoad(options, callback) {
                let registeredText = `This error came from the "onLoad" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                let keys22 = {};
                let filter2 = getFlag(options, keys22, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys22, "namespace", mustBeString);
                checkForInvalidFlags(options, keys22, `in onLoad() call for plugin ${quote(name)}`);
                if (filter2 == null)
                  throw new Error(`onLoad() call is missing a filter`);
                let id = nextCallbackID++;
                onLoadCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onLoad.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              onDispose(callback) {
                onDisposeCallbacks.push(callback);
              },
              esbuild: streamIn.esbuild
            });
            if (promise)
              await promise;
            requestPlugins.push(plugin);
          } catch (e) {
            return { ok: false, error: e, pluginName: name };
          }
        }
        requestCallbacks["on-start"] = async (id, request) => {
          details.clear();
          let response = { errors: [], warnings: [] };
          await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
            try {
              let result = await callback();
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let errors2 = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onStart() callback in plugin ${quote(name)}`);
                if (errors2 != null)
                  response.errors.push(...sanitizeMessages(errors2, "errors", details, name, void 0));
                if (warnings != null)
                  response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name, void 0));
              }
            } catch (e) {
              response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
            }
          }));
          sendResponse(id, response);
        };
        requestCallbacks["on-resolve"] = async (id, request) => {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onResolveCallbacks[id2]);
              let result = await callback({
                path: request.path,
                importer: request.importer,
                namespace: request.namespace,
                resolveDir: request.resolveDir,
                kind: request.kind,
                pluginData: details.load(request.pluginData),
                with: request.with
              });
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let pluginName = getFlag(result, keys4, "pluginName", mustBeString);
                let path32 = getFlag(result, keys4, "path", mustBeString);
                let namespace = getFlag(result, keys4, "namespace", mustBeString);
                let suffix = getFlag(result, keys4, "suffix", mustBeString);
                let external = getFlag(result, keys4, "external", mustBeBoolean);
                let sideEffects = getFlag(result, keys4, "sideEffects", mustBeBoolean);
                let pluginData = getFlag(result, keys4, "pluginData", canBeAnything);
                let errors2 = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys4, "watchFiles", mustBeArray);
                let watchDirs = getFlag(result, keys4, "watchDirs", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onResolve() callback in plugin ${quote(name)}`);
                response.id = id2;
                if (pluginName != null)
                  response.pluginName = pluginName;
                if (path32 != null)
                  response.path = path32;
                if (namespace != null)
                  response.namespace = namespace;
                if (suffix != null)
                  response.suffix = suffix;
                if (external != null)
                  response.external = external;
                if (sideEffects != null)
                  response.sideEffects = sideEffects;
                if (pluginData != null)
                  response.pluginData = details.store(pluginData);
                if (errors2 != null)
                  response.errors = sanitizeMessages(errors2, "errors", details, name, void 0);
                if (warnings != null)
                  response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                if (watchFiles != null)
                  response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null)
                  response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e) {
              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        };
        requestCallbacks["on-load"] = async (id, request) => {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onLoadCallbacks[id2]);
              let result = await callback({
                path: request.path,
                namespace: request.namespace,
                suffix: request.suffix,
                pluginData: details.load(request.pluginData),
                with: request.with
              });
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let pluginName = getFlag(result, keys4, "pluginName", mustBeString);
                let contents = getFlag(result, keys4, "contents", mustBeStringOrUint8Array);
                let resolveDir = getFlag(result, keys4, "resolveDir", mustBeString);
                let pluginData = getFlag(result, keys4, "pluginData", canBeAnything);
                let loader = getFlag(result, keys4, "loader", mustBeString);
                let errors2 = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys4, "watchFiles", mustBeArray);
                let watchDirs = getFlag(result, keys4, "watchDirs", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onLoad() callback in plugin ${quote(name)}`);
                response.id = id2;
                if (pluginName != null)
                  response.pluginName = pluginName;
                if (contents instanceof Uint8Array)
                  response.contents = contents;
                else if (contents != null)
                  response.contents = encodeUTF8(contents);
                if (resolveDir != null)
                  response.resolveDir = resolveDir;
                if (pluginData != null)
                  response.pluginData = details.store(pluginData);
                if (loader != null)
                  response.loader = loader;
                if (errors2 != null)
                  response.errors = sanitizeMessages(errors2, "errors", details, name, void 0);
                if (warnings != null)
                  response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                if (watchFiles != null)
                  response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null)
                  response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e) {
              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        };
        let runOnEndCallbacks = (result, done) => done([], []);
        if (onEndCallbacks.length > 0) {
          runOnEndCallbacks = (result, done) => {
            (async () => {
              const onEndErrors = [];
              const onEndWarnings = [];
              for (const { name, callback, note } of onEndCallbacks) {
                let newErrors;
                let newWarnings;
                try {
                  const value = await callback(result);
                  if (value != null) {
                    if (typeof value !== "object")
                      throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
                    let keys4 = {};
                    let errors2 = getFlag(value, keys4, "errors", mustBeArray);
                    let warnings = getFlag(value, keys4, "warnings", mustBeArray);
                    checkForInvalidFlags(value, keys4, `from onEnd() callback in plugin ${quote(name)}`);
                    if (errors2 != null)
                      newErrors = sanitizeMessages(errors2, "errors", details, name, void 0);
                    if (warnings != null)
                      newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                  }
                } catch (e) {
                  newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];
                }
                if (newErrors) {
                  onEndErrors.push(...newErrors);
                  try {
                    result.errors.push(...newErrors);
                  } catch {
                  }
                }
                if (newWarnings) {
                  onEndWarnings.push(...newWarnings);
                  try {
                    result.warnings.push(...newWarnings);
                  } catch {
                  }
                }
              }
              done(onEndErrors, onEndWarnings);
            })();
          };
        }
        let scheduleOnDisposeCallbacks = () => {
          for (const cb of onDisposeCallbacks) {
            setTimeout(() => cb(), 0);
          }
        };
        isSetupDone = true;
        return {
          ok: true,
          requestPlugins,
          runOnEndCallbacks,
          scheduleOnDisposeCallbacks
        };
      };
      function createObjectStash() {
        const map2 = /* @__PURE__ */ new Map();
        let nextID = 0;
        return {
          clear() {
            map2.clear();
          },
          load(id) {
            return map2.get(id);
          },
          store(value) {
            if (value === void 0)
              return -1;
            const id = nextID++;
            map2.set(id, value);
            return id;
          }
        };
      }
      function extractCallerV8(e, streamIn, ident) {
        let note;
        let tried = false;
        return () => {
          if (tried)
            return note;
          tried = true;
          try {
            let lines = (e.stack + "").split("\n");
            lines.splice(1, 1);
            let location = parseStackLinesV8(streamIn, lines, ident);
            if (location) {
              note = { text: e.message, location };
              return note;
            }
          } catch {
          }
        };
      }
      function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
        let text = "Internal error";
        let location = null;
        try {
          text = (e && e.message || e) + "";
        } catch {
        }
        try {
          location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
        } catch {
        }
        return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
      }
      function parseStackLinesV8(streamIn, lines, ident) {
        let at = "    at ";
        if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
          for (let i = 1; i < lines.length; i++) {
            let line = lines[i];
            if (!line.startsWith(at))
              continue;
            line = line.slice(at.length);
            while (true) {
              let match3 = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
              if (match3) {
                line = match3[1];
                continue;
              }
              match3 = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
              if (match3) {
                line = match3[1];
                continue;
              }
              match3 = /^(\S+):(\d+):(\d+)$/.exec(line);
              if (match3) {
                let contents;
                try {
                  contents = streamIn.readFileSync(match3[1], "utf8");
                } catch {
                  break;
                }
                let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match3[2] - 1] || "";
                let column = +match3[3] - 1;
                let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
                return {
                  file: match3[1],
                  namespace: "file",
                  line: +match3[2],
                  column: encodeUTF8(lineText.slice(0, column)).length,
                  length: encodeUTF8(lineText.slice(column, column + length)).length,
                  lineText: lineText + "\n" + lines.slice(1).join("\n"),
                  suggestion: ""
                };
              }
              break;
            }
          }
        }
        return null;
      }
      function failureErrorWithLog(text, errors2, warnings) {
        let limit = 5;
        text += errors2.length < 1 ? "" : ` with ${errors2.length} error${errors2.length < 2 ? "" : "s"}:` + errors2.slice(0, limit + 1).map((e, i) => {
          if (i === limit)
            return "\n...";
          if (!e.location)
            return `
error: ${e.text}`;
          let { file, line, column } = e.location;
          let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
          return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
        }).join("");
        let error3 = new Error(text);
        for (const [key, value] of [["errors", errors2], ["warnings", warnings]]) {
          Object.defineProperty(error3, key, {
            configurable: true,
            enumerable: true,
            get: () => value,
            set: (value2) => Object.defineProperty(error3, key, {
              configurable: true,
              enumerable: true,
              value: value2
            })
          });
        }
        return error3;
      }
      function replaceDetailsInMessages(messages, stash) {
        for (const message of messages) {
          message.detail = stash.load(message.detail);
        }
        return messages;
      }
      function sanitizeLocation(location, where, terminalWidth) {
        if (location == null)
          return null;
        let keys4 = {};
        let file = getFlag(location, keys4, "file", mustBeString);
        let namespace = getFlag(location, keys4, "namespace", mustBeString);
        let line = getFlag(location, keys4, "line", mustBeInteger);
        let column = getFlag(location, keys4, "column", mustBeInteger);
        let length = getFlag(location, keys4, "length", mustBeInteger);
        let lineText = getFlag(location, keys4, "lineText", mustBeString);
        let suggestion = getFlag(location, keys4, "suggestion", mustBeString);
        checkForInvalidFlags(location, keys4, where);
        if (lineText) {
          const relevantASCII = lineText.slice(
            0,
            (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)
          );
          if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
            lineText = relevantASCII;
          }
        }
        return {
          file: file || "",
          namespace: namespace || "",
          line: line || 0,
          column: column || 0,
          length: length || 0,
          lineText: lineText || "",
          suggestion: suggestion || ""
        };
      }
      function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
        let messagesClone = [];
        let index = 0;
        for (const message of messages) {
          let keys4 = {};
          let id = getFlag(message, keys4, "id", mustBeString);
          let pluginName = getFlag(message, keys4, "pluginName", mustBeString);
          let text = getFlag(message, keys4, "text", mustBeString);
          let location = getFlag(message, keys4, "location", mustBeObjectOrNull);
          let notes = getFlag(message, keys4, "notes", mustBeArray);
          let detail = getFlag(message, keys4, "detail", canBeAnything);
          let where = `in element ${index} of "${property}"`;
          checkForInvalidFlags(message, keys4, where);
          let notesClone = [];
          if (notes) {
            for (const note of notes) {
              let noteKeys = {};
              let noteText = getFlag(note, noteKeys, "text", mustBeString);
              let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
              checkForInvalidFlags(note, noteKeys, where);
              notesClone.push({
                text: noteText || "",
                location: sanitizeLocation(noteLocation, where, terminalWidth)
              });
            }
          }
          messagesClone.push({
            id: id || "",
            pluginName: pluginName || fallbackPluginName,
            text: text || "",
            location: sanitizeLocation(location, where, terminalWidth),
            notes: notesClone,
            detail: stash ? stash.store(detail) : -1
          });
          index++;
        }
        return messagesClone;
      }
      function sanitizeStringArray(values, property) {
        const result = [];
        for (const value of values) {
          if (typeof value !== "string")
            throw new Error(`${quote(property)} must be an array of strings`);
          result.push(value);
        }
        return result;
      }
      function sanitizeStringMap(map2, property) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key in map2) {
          const value = map2[key];
          if (typeof value !== "string")
            throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);
          result[key] = value;
        }
        return result;
      }
      function convertOutputFiles({ path: path32, contents, hash: hash3 }) {
        let text = null;
        return {
          path: path32,
          contents,
          hash: hash3,
          get text() {
            const binary = this.contents;
            if (text === null || binary !== contents) {
              contents = binary;
              text = decodeUTF8(binary);
            }
            return text;
          }
        };
      }
      var fs5 = __require2("fs");
      var os2 = __require2("os");
      var path6 = __require2("path");
      var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
      var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
      var packageDarwin_arm64 = "@esbuild/darwin-arm64";
      var packageDarwin_x64 = "@esbuild/darwin-x64";
      var knownWindowsPackages = {
        "win32 arm64 LE": "@esbuild/win32-arm64",
        "win32 ia32 LE": "@esbuild/win32-ia32",
        "win32 x64 LE": "@esbuild/win32-x64"
      };
      var knownUnixlikePackages = {
        "aix ppc64 BE": "@esbuild/aix-ppc64",
        "android arm64 LE": "@esbuild/android-arm64",
        "darwin arm64 LE": "@esbuild/darwin-arm64",
        "darwin x64 LE": "@esbuild/darwin-x64",
        "freebsd arm64 LE": "@esbuild/freebsd-arm64",
        "freebsd x64 LE": "@esbuild/freebsd-x64",
        "linux arm LE": "@esbuild/linux-arm",
        "linux arm64 LE": "@esbuild/linux-arm64",
        "linux ia32 LE": "@esbuild/linux-ia32",
        "linux mips64el LE": "@esbuild/linux-mips64el",
        "linux ppc64 LE": "@esbuild/linux-ppc64",
        "linux riscv64 LE": "@esbuild/linux-riscv64",
        "linux s390x BE": "@esbuild/linux-s390x",
        "linux x64 LE": "@esbuild/linux-x64",
        "linux loong64 LE": "@esbuild/linux-loong64",
        "netbsd x64 LE": "@esbuild/netbsd-x64",
        "openbsd arm64 LE": "@esbuild/openbsd-arm64",
        "openbsd x64 LE": "@esbuild/openbsd-x64",
        "sunos x64 LE": "@esbuild/sunos-x64"
      };
      var knownWebAssemblyFallbackPackages = {
        "android arm LE": "@esbuild/android-arm",
        "android x64 LE": "@esbuild/android-x64"
      };
      function pkgAndSubpathForCurrentPlatform() {
        let pkg;
        let subpath;
        let isWASM = false;
        let platformKey = `${process.platform} ${os2.arch()} ${os2.endianness()}`;
        if (platformKey in knownWindowsPackages) {
          pkg = knownWindowsPackages[platformKey];
          subpath = "esbuild.exe";
        } else if (platformKey in knownUnixlikePackages) {
          pkg = knownUnixlikePackages[platformKey];
          subpath = "bin/esbuild";
        } else if (platformKey in knownWebAssemblyFallbackPackages) {
          pkg = knownWebAssemblyFallbackPackages[platformKey];
          subpath = "bin/esbuild";
          isWASM = true;
        } else {
          throw new Error(`Unsupported platform: ${platformKey}`);
        }
        return { pkg, subpath, isWASM };
      }
      function pkgForSomeOtherPlatform() {
        const libMainJS = __require2.resolve("esbuild");
        const nodeModulesDirectory = path6.dirname(path6.dirname(path6.dirname(libMainJS)));
        if (path6.basename(nodeModulesDirectory) === "node_modules") {
          for (const unixKey in knownUnixlikePackages) {
            try {
              const pkg = knownUnixlikePackages[unixKey];
              if (fs5.existsSync(path6.join(nodeModulesDirectory, pkg)))
                return pkg;
            } catch {
            }
          }
          for (const windowsKey in knownWindowsPackages) {
            try {
              const pkg = knownWindowsPackages[windowsKey];
              if (fs5.existsSync(path6.join(nodeModulesDirectory, pkg)))
                return pkg;
            } catch {
            }
          }
        }
        return null;
      }
      function downloadedBinPath(pkg, subpath) {
        const esbuildLibDir = path6.dirname(__require2.resolve("esbuild"));
        return path6.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path6.basename(subpath)}`);
      }
      function generateBinPath() {
        if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
          if (!fs5.existsSync(ESBUILD_BINARY_PATH)) {
            console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
          } else {
            return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
          }
        }
        const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
        let binPath;
        try {
          binPath = __require2.resolve(`${pkg}/${subpath}`);
        } catch (e) {
          binPath = downloadedBinPath(pkg, subpath);
          if (!fs5.existsSync(binPath)) {
            try {
              __require2.resolve(pkg);
            } catch {
              const otherPkg = pkgForSomeOtherPlatform();
              if (otherPkg) {
                let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                  suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                }
                throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
              }
              throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
            }
            throw e;
          }
        }
        if (/\.zip\//.test(binPath)) {
          let pnpapi;
          try {
            pnpapi = __require2("pnpapi");
          } catch (e) {
          }
          if (pnpapi) {
            const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
            const binTargetPath = path6.join(
              root,
              "node_modules",
              ".cache",
              "esbuild",
              `pnpapi-${pkg.replace("/", "-")}-${"0.24.0"}-${path6.basename(subpath)}`
            );
            if (!fs5.existsSync(binTargetPath)) {
              fs5.mkdirSync(path6.dirname(binTargetPath), { recursive: true });
              fs5.copyFileSync(binPath, binTargetPath);
              fs5.chmodSync(binTargetPath, 493);
            }
            return { binPath: binTargetPath, isWASM };
          }
        }
        return { binPath, isWASM };
      }
      var child_process = __require2("child_process");
      var crypto4 = __require2("crypto");
      var path23 = __require2("path");
      var fs23 = __require2("fs");
      var os22 = __require2("os");
      var tty = __require2("tty");
      var worker_threads;
      if (process.env.ESBUILD_WORKER_THREADS !== "0") {
        try {
          worker_threads = __require2("worker_threads");
        } catch {
        }
        let [major2, minor2] = process.versions.node.split(".");
        if (
          // <v12.17.0 does not work
          +major2 < 12 || +major2 === 12 && +minor2 < 17 || +major2 === 13 && +minor2 < 13
        ) {
          worker_threads = void 0;
        }
      }
      var _a2;
      var isInternalWorkerThread = ((_a2 = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a2.esbuildVersion) === "0.24.0";
      var esbuildCommandAndArgs = () => {
        if ((!ESBUILD_BINARY_PATH || false) && (path23.basename(__filename) !== "main.js" || path23.basename(__dirname) !== "lib")) {
          throw new Error(
            `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
          );
        }
        if (false) {
          return ["node", [path23.join(__dirname, "..", "bin", "esbuild")]];
        } else {
          const { binPath, isWASM } = generateBinPath();
          if (isWASM) {
            return ["node", [binPath]];
          } else {
            return [binPath, []];
          }
        }
      };
      var isTTY = () => tty.isatty(2);
      var fsSync = {
        readFile(tempFile, callback) {
          try {
            let contents = fs23.readFileSync(tempFile, "utf8");
            try {
              fs23.unlinkSync(tempFile);
            } catch {
            }
            callback(null, contents);
          } catch (err2) {
            callback(err2, null);
          }
        },
        writeFile(contents, callback) {
          try {
            let tempFile = randomFileName();
            fs23.writeFileSync(tempFile, contents);
            callback(tempFile);
          } catch {
            callback(null);
          }
        }
      };
      var fsAsync = {
        readFile(tempFile, callback) {
          try {
            fs23.readFile(tempFile, "utf8", (err2, contents) => {
              try {
                fs23.unlink(tempFile, () => callback(err2, contents));
              } catch {
                callback(err2, contents);
              }
            });
          } catch (err2) {
            callback(err2, null);
          }
        },
        writeFile(contents, callback) {
          try {
            let tempFile = randomFileName();
            fs23.writeFile(tempFile, contents, (err2) => err2 !== null ? callback(null) : callback(tempFile));
          } catch {
            callback(null);
          }
        }
      };
      var version3 = "0.24.0";
      var build3 = (options) => ensureServiceIsRunning().build(options);
      var context2 = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
      var transform = (input, options) => ensureServiceIsRunning().transform(input, options);
      var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
      var analyzeMetafile = (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options);
      var buildSync = (options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.buildSync(options);
        }
        let result;
        runServiceSync((service) => service.buildOrContext({
          callName: "buildSync",
          refs: null,
          options,
          isTTY: isTTY(),
          defaultWD,
          callback: (err2, res) => {
            if (err2)
              throw err2;
            result = res;
          }
        }));
        return result;
      };
      var transformSync = (input, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.transformSync(input, options);
        }
        let result;
        runServiceSync((service) => service.transform({
          callName: "transformSync",
          refs: null,
          input,
          options: options || {},
          isTTY: isTTY(),
          fs: fsSync,
          callback: (err2, res) => {
            if (err2)
              throw err2;
            result = res;
          }
        }));
        return result;
      };
      var formatMessagesSync = (messages, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.formatMessagesSync(messages, options);
        }
        let result;
        runServiceSync((service) => service.formatMessages({
          callName: "formatMessagesSync",
          refs: null,
          messages,
          options,
          callback: (err2, res) => {
            if (err2)
              throw err2;
            result = res;
          }
        }));
        return result;
      };
      var analyzeMetafileSync = (metafile, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.analyzeMetafileSync(metafile, options);
        }
        let result;
        runServiceSync((service) => service.analyzeMetafile({
          callName: "analyzeMetafileSync",
          refs: null,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options,
          callback: (err2, res) => {
            if (err2)
              throw err2;
            result = res;
          }
        }));
        return result;
      };
      var stop = () => {
        if (stopService)
          stopService();
        if (workerThreadService)
          workerThreadService.stop();
        return Promise.resolve();
      };
      var initializeWasCalled = false;
      var initialize = (options) => {
        options = validateInitializeOptions(options || {});
        if (options.wasmURL)
          throw new Error(`The "wasmURL" option only works in the browser`);
        if (options.wasmModule)
          throw new Error(`The "wasmModule" option only works in the browser`);
        if (options.worker)
          throw new Error(`The "worker" option only works in the browser`);
        if (initializeWasCalled)
          throw new Error('Cannot call "initialize" more than once');
        ensureServiceIsRunning();
        initializeWasCalled = true;
        return Promise.resolve();
      };
      var defaultWD = process.cwd();
      var longLivedService;
      var stopService;
      var ensureServiceIsRunning = () => {
        if (longLivedService)
          return longLivedService;
        let [command, args] = esbuildCommandAndArgs();
        let child = child_process.spawn(command, args.concat(`--service=${"0.24.0"}`, "--ping"), {
          windowsHide: true,
          stdio: ["pipe", "pipe", "inherit"],
          cwd: defaultWD
        });
        let { readFromStdout, afterClose, service } = createChannel({
          writeToStdin(bytes2) {
            child.stdin.write(bytes2, (err2) => {
              if (err2)
                afterClose(err2);
            });
          },
          readFileSync: fs23.readFileSync,
          isSync: false,
          hasFS: true,
          esbuild: node_exports
        });
        child.stdin.on("error", afterClose);
        child.on("error", afterClose);
        const stdin = child.stdin;
        const stdout = child.stdout;
        stdout.on("data", readFromStdout);
        stdout.on("end", afterClose);
        stopService = () => {
          stdin.destroy();
          stdout.destroy();
          child.kill();
          initializeWasCalled = false;
          longLivedService = void 0;
          stopService = void 0;
        };
        let refCount = 0;
        child.unref();
        if (stdin.unref) {
          stdin.unref();
        }
        if (stdout.unref) {
          stdout.unref();
        }
        const refs = {
          ref() {
            if (++refCount === 1)
              child.ref();
          },
          unref() {
            if (--refCount === 0)
              child.unref();
          }
        };
        longLivedService = {
          build: (options) => new Promise((resolve10, reject) => {
            service.buildOrContext({
              callName: "build",
              refs,
              options,
              isTTY: isTTY(),
              defaultWD,
              callback: (err2, res) => err2 ? reject(err2) : resolve10(res)
            });
          }),
          context: (options) => new Promise((resolve10, reject) => service.buildOrContext({
            callName: "context",
            refs,
            options,
            isTTY: isTTY(),
            defaultWD,
            callback: (err2, res) => err2 ? reject(err2) : resolve10(res)
          })),
          transform: (input, options) => new Promise((resolve10, reject) => service.transform({
            callName: "transform",
            refs,
            input,
            options: options || {},
            isTTY: isTTY(),
            fs: fsAsync,
            callback: (err2, res) => err2 ? reject(err2) : resolve10(res)
          })),
          formatMessages: (messages, options) => new Promise((resolve10, reject) => service.formatMessages({
            callName: "formatMessages",
            refs,
            messages,
            options,
            callback: (err2, res) => err2 ? reject(err2) : resolve10(res)
          })),
          analyzeMetafile: (metafile, options) => new Promise((resolve10, reject) => service.analyzeMetafile({
            callName: "analyzeMetafile",
            refs,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options,
            callback: (err2, res) => err2 ? reject(err2) : resolve10(res)
          }))
        };
        return longLivedService;
      };
      var runServiceSync = (callback) => {
        let [command, args] = esbuildCommandAndArgs();
        let stdin = new Uint8Array();
        let { readFromStdout, afterClose, service } = createChannel({
          writeToStdin(bytes2) {
            if (stdin.length !== 0)
              throw new Error("Must run at most one command");
            stdin = bytes2;
          },
          isSync: true,
          hasFS: true,
          esbuild: node_exports
        });
        callback(service);
        let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.24.0"}`), {
          cwd: defaultWD,
          windowsHide: true,
          input: stdin,
          // We don't know how large the output could be. If it's too large, the
          // command will fail with ENOBUFS. Reserve 16mb for now since that feels
          // like it should be enough. Also allow overriding this with an environment
          // variable.
          maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
        });
        readFromStdout(stdout);
        afterClose(null);
      };
      var randomFileName = () => {
        return path23.join(os22.tmpdir(), `esbuild-${crypto4.randomBytes(32).toString("hex")}`);
      };
      var workerThreadService = null;
      var startWorkerThreadService = (worker_threads2) => {
        let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
        let worker = new worker_threads2.Worker(__filename, {
          workerData: { workerPort, defaultWD, esbuildVersion: "0.24.0" },
          transferList: [workerPort],
          // From node's documentation: https://nodejs.org/api/worker_threads.html
          //
          //   Take care when launching worker threads from preload scripts (scripts loaded
          //   and run using the `-r` command line flag). Unless the `execArgv` option is
          //   explicitly set, new Worker threads automatically inherit the command line flags
          //   from the running process and will preload the same preload scripts as the main
          //   thread. If the preload script unconditionally launches a worker thread, every
          //   thread spawned will spawn another until the application crashes.
          //
          execArgv: []
        });
        let nextID = 0;
        let fakeBuildError = (text) => {
          let error3 = new Error(`Build failed with 1 error:
error: ${text}`);
          let errors2 = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
          error3.errors = errors2;
          error3.warnings = [];
          return error3;
        };
        let validateBuildSyncOptions = (options) => {
          if (!options)
            return;
          let plugins = options.plugins;
          if (plugins && plugins.length > 0)
            throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
        };
        let applyProperties = (object2, properties) => {
          for (let key in properties) {
            object2[key] = properties[key];
          }
        };
        let runCallSync = (command, args) => {
          let id = nextID++;
          let sharedBuffer = new SharedArrayBuffer(8);
          let sharedBufferView = new Int32Array(sharedBuffer);
          let msg = { sharedBuffer, id, command, args };
          worker.postMessage(msg);
          let status = Atomics.wait(sharedBufferView, 0, 0);
          if (status !== "ok" && status !== "not-equal")
            throw new Error("Internal error: Atomics.wait() failed: " + status);
          let { message: { id: id2, resolve: resolve10, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
          if (id !== id2)
            throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
          if (reject) {
            applyProperties(reject, properties);
            throw reject;
          }
          return resolve10;
        };
        worker.unref();
        return {
          buildSync(options) {
            validateBuildSyncOptions(options);
            return runCallSync("build", [options]);
          },
          transformSync(input, options) {
            return runCallSync("transform", [input, options]);
          },
          formatMessagesSync(messages, options) {
            return runCallSync("formatMessages", [messages, options]);
          },
          analyzeMetafileSync(metafile, options) {
            return runCallSync("analyzeMetafile", [metafile, options]);
          },
          stop() {
            worker.terminate();
            workerThreadService = null;
          }
        };
      };
      var startSyncServiceWorker = () => {
        let workerPort = worker_threads.workerData.workerPort;
        let parentPort = worker_threads.parentPort;
        let extractProperties = (object2) => {
          let properties = {};
          if (object2 && typeof object2 === "object") {
            for (let key in object2) {
              properties[key] = object2[key];
            }
          }
          return properties;
        };
        try {
          let service = ensureServiceIsRunning();
          defaultWD = worker_threads.workerData.defaultWD;
          parentPort.on("message", (msg) => {
            (async () => {
              let { sharedBuffer, id, command, args } = msg;
              let sharedBufferView = new Int32Array(sharedBuffer);
              try {
                switch (command) {
                  case "build":
                    workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                    break;
                  case "transform":
                    workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                    break;
                  case "formatMessages":
                    workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                    break;
                  case "analyzeMetafile":
                    workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                    break;
                  default:
                    throw new Error(`Invalid command: ${command}`);
                }
              } catch (reject) {
                workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
              }
              Atomics.add(sharedBufferView, 0, 1);
              Atomics.notify(sharedBufferView, 0, Infinity);
            })();
          });
        } catch (reject) {
          parentPort.on("message", (msg) => {
            let { sharedBuffer, id } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          });
        }
      };
      if (isInternalWorkerThread) {
        startSyncServiceWorker();
      }
      var node_default3 = node_exports;
    }
  });

  // ../../node_modules/.pnpm/joycon@3.1.1/node_modules/joycon/lib/index.js
  var require_lib4 = __commonJS({
    "../../node_modules/.pnpm/joycon@3.1.1/node_modules/joycon/lib/index.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _fs = _interopRequireDefault(__require2("fs"));
      var _path = _interopRequireDefault(__require2("path"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var readFileSync9 = (fp) => {
        return _fs.default.readFileSync(fp, "utf8");
      };
      var pathExists = (fp) => new Promise((resolve10) => {
        _fs.default.access(fp, (err2) => {
          resolve10(!err2);
        });
      });
      var pathExistsSync = _fs.default.existsSync;
      var JoyCon2 = class {
        constructor({
          files,
          cwd = process.cwd(),
          stopDir,
          packageKey,
          parseJSON = JSON.parse
        } = {}) {
          this.options = {
            files,
            cwd,
            stopDir,
            packageKey,
            parseJSON
          };
          this.existsCache = /* @__PURE__ */ new Map();
          this.loaders = /* @__PURE__ */ new Set();
          this.packageJsonCache = /* @__PURE__ */ new Map();
          this.loadCache = /* @__PURE__ */ new Map();
        }
        addLoader(loader) {
          this.loaders.add(loader);
          return this;
        }
        removeLoader(name) {
          for (const loader of this.loaders) {
            if (name && loader.name === name) {
              this.loaders.delete(loader);
            }
          }
          return this;
        }
        async recusivelyResolve(options) {
          if (options.cwd === options.stopDir || _path.default.basename(options.cwd) === "node_modules") {
            return null;
          }
          for (const filename of options.files) {
            const file = _path.default.resolve(options.cwd, filename);
            const exists2 = process.env.NODE_ENV !== "test" && this.existsCache.has(file) ? this.existsCache.get(file) : await pathExists(file);
            this.existsCache.set(file, exists2);
            if (exists2) {
              if (!options.packageKey || _path.default.basename(file) !== "package.json") {
                return file;
              }
              const data = __require2(file);
              delete __require2.cache[file];
              const hasPackageKey = Object.prototype.hasOwnProperty.call(data, options.packageKey);
              if (hasPackageKey) {
                this.packageJsonCache.set(file, data);
                return file;
              }
            }
            continue;
          }
          return this.recusivelyResolve(Object.assign({}, options, {
            cwd: _path.default.dirname(options.cwd)
          }));
        }
        recusivelyResolveSync(options) {
          if (options.cwd === options.stopDir || _path.default.basename(options.cwd) === "node_modules") {
            return null;
          }
          for (const filename of options.files) {
            const file = _path.default.resolve(options.cwd, filename);
            const exists2 = process.env.NODE_ENV !== "test" && this.existsCache.has(file) ? this.existsCache.get(file) : pathExistsSync(file);
            this.existsCache.set(file, exists2);
            if (exists2) {
              if (!options.packageKey || _path.default.basename(file) !== "package.json") {
                return file;
              }
              const data = __require2(file);
              delete __require2.cache[file];
              const hasPackageKey = Object.prototype.hasOwnProperty.call(data, options.packageKey);
              if (hasPackageKey) {
                this.packageJsonCache.set(file, data);
                return file;
              }
            }
            continue;
          }
          return this.recusivelyResolveSync(Object.assign({}, options, {
            cwd: _path.default.dirname(options.cwd)
          }));
        }
        async resolve(...args) {
          const options = this.normalizeOptions(args);
          return this.recusivelyResolve(options);
        }
        resolveSync(...args) {
          const options = this.normalizeOptions(args);
          return this.recusivelyResolveSync(options);
        }
        runLoaderSync(loader, filepath) {
          return loader.loadSync(filepath);
        }
        runLoader(loader, filepath) {
          if (!loader.load)
            return loader.loadSync(filepath);
          return loader.load(filepath);
        }
        async load(...args) {
          const options = this.normalizeOptions(args);
          const filepath = await this.recusivelyResolve(options);
          if (filepath) {
            const defaultLoader = {
              test: /\.+/,
              loadSync: (filepath2) => {
                const extname = _path.default.extname(filepath2).slice(1);
                if (extname === "js" || extname === "cjs") {
                  delete __require2.cache[filepath2];
                  return __require2(filepath2);
                }
                if (this.packageJsonCache.has(filepath2)) {
                  return this.packageJsonCache.get(filepath2)[options.packageKey];
                }
                const data2 = this.options.parseJSON(readFileSync9(filepath2));
                return data2;
              }
            };
            const loader = this.findLoader(filepath) || defaultLoader;
            let data;
            if (this.loadCache.has(filepath)) {
              data = this.loadCache.get(filepath);
            } else {
              data = await this.runLoader(loader, filepath);
              this.loadCache.set(filepath, data);
            }
            return {
              path: filepath,
              data
            };
          }
          return {};
        }
        loadSync(...args) {
          const options = this.normalizeOptions(args);
          const filepath = this.recusivelyResolveSync(options);
          if (filepath) {
            const defaultLoader = {
              test: /\.+/,
              loadSync: (filepath2) => {
                const extname = _path.default.extname(filepath2).slice(1);
                if (extname === "js" || extname === "cjs") {
                  delete __require2.cache[filepath2];
                  return __require2(filepath2);
                }
                if (this.packageJsonCache.has(filepath2)) {
                  return this.packageJsonCache.get(filepath2)[options.packageKey];
                }
                const data2 = this.options.parseJSON(readFileSync9(filepath2));
                return data2;
              }
            };
            const loader = this.findLoader(filepath) || defaultLoader;
            let data;
            if (this.loadCache.has(filepath)) {
              data = this.loadCache.get(filepath);
            } else {
              data = this.runLoaderSync(loader, filepath);
              this.loadCache.set(filepath, data);
            }
            return {
              path: filepath,
              data
            };
          }
          return {};
        }
        findLoader(filepath) {
          for (const loader of this.loaders) {
            if (loader.test && loader.test.test(filepath)) {
              return loader;
            }
          }
          return null;
        }
        clearCache() {
          this.existsCache.clear();
          this.packageJsonCache.clear();
          this.loadCache.clear();
          return this;
        }
        normalizeOptions(args) {
          const options = Object.assign({}, this.options);
          if (Object.prototype.toString.call(args[0]) === "[object Object]") {
            Object.assign(options, args[0]);
          } else {
            if (args[0]) {
              options.files = args[0];
            }
            if (args[1]) {
              options.cwd = args[1];
            }
            if (args[2]) {
              options.stopDir = args[2];
            }
          }
          options.cwd = _path.default.resolve(options.cwd);
          options.stopDir = options.stopDir ? _path.default.resolve(options.stopDir) : _path.default.parse(options.cwd).root;
          if (!options.files || options.files.length === 0) {
            throw new Error("[joycon] files must be an non-empty array!");
          }
          options.__normalized__ = true;
          return options;
        }
      };
      exports.default = JoyCon2;
      module.exports = JoyCon2;
      module.exports.default = JoyCon2;
    }
  });

  // ../../node_modules/.pnpm/property-expr@2.0.5/node_modules/property-expr/index.js
  var require_property_expr = __commonJS({
    "../../node_modules/.pnpm/property-expr@2.0.5/node_modules/property-expr/index.js"(exports, module) {
      "use strict";
      function Cache(maxSize) {
        this._maxSize = maxSize;
        this.clear();
      }
      Cache.prototype.clear = function() {
        this._size = 0;
        this._values = /* @__PURE__ */ Object.create(null);
      };
      Cache.prototype.get = function(key) {
        return this._values[key];
      };
      Cache.prototype.set = function(key, value) {
        this._size >= this._maxSize && this.clear();
        if (!(key in this._values))
          this._size++;
        return this._values[key] = value;
      };
      var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
      var DIGIT_REGEX = /^\d+$/;
      var LEAD_DIGIT_REGEX = /^\d/;
      var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
      var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
      var MAX_CACHE_SIZE = 512;
      var pathCache = new Cache(MAX_CACHE_SIZE);
      var setCache = new Cache(MAX_CACHE_SIZE);
      var getCache = new Cache(MAX_CACHE_SIZE);
      module.exports = {
        Cache,
        split: split3,
        normalizePath: normalizePath2,
        setter: function(path6) {
          var parts = normalizePath2(path6);
          return setCache.get(path6) || setCache.set(path6, function setter(obj, value) {
            var index = 0;
            var len = parts.length;
            var data = obj;
            while (index < len - 1) {
              var part = parts[index];
              if (part === "__proto__" || part === "constructor" || part === "prototype") {
                return obj;
              }
              data = data[parts[index++]];
            }
            data[parts[index]] = value;
          });
        },
        getter: function(path6, safe) {
          var parts = normalizePath2(path6);
          return getCache.get(path6) || getCache.set(path6, function getter2(data) {
            var index = 0, len = parts.length;
            while (index < len) {
              if (data != null || !safe)
                data = data[parts[index++]];
              else
                return;
            }
            return data;
          });
        },
        join: function(segments) {
          return segments.reduce(function(path6, part) {
            return path6 + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path6 ? "." : "") + part);
          }, "");
        },
        forEach: function(path6, cb, thisArg) {
          forEach2(Array.isArray(path6) ? path6 : split3(path6), cb, thisArg);
        }
      };
      function normalizePath2(path6) {
        return pathCache.get(path6) || pathCache.set(
          path6,
          split3(path6).map(function(part) {
            return part.replace(CLEAN_QUOTES_REGEX, "$2");
          })
        );
      }
      function split3(path6) {
        return path6.match(SPLIT_REGEX) || [""];
      }
      function forEach2(parts, iter, thisArg) {
        var len = parts.length, part, idx, isArray, isBracket;
        for (idx = 0; idx < len; idx++) {
          part = parts[idx];
          if (part) {
            if (shouldBeQuoted(part)) {
              part = '"' + part + '"';
            }
            isBracket = isQuoted(part);
            isArray = !isBracket && /^\d+$/.test(part);
            iter.call(thisArg, part, isBracket, isArray, idx, parts);
          }
        }
      }
      function isQuoted(str) {
        return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
      }
      function hasLeadingNumber(part) {
        return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
      }
      function hasSpecialChars(part) {
        return SPEC_CHAR_REGEX.test(part);
      }
      function shouldBeQuoted(part) {
        return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
      }
    }
  });

  // ../../node_modules/.pnpm/tiny-case@1.0.3/node_modules/tiny-case/index.js
  var require_tiny_case = __commonJS({
    "../../node_modules/.pnpm/tiny-case@1.0.3/node_modules/tiny-case/index.js"(exports, module) {
      var reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
      var words = (str) => str.match(reWords) || [];
      var upperFirst3 = (str) => str[0].toUpperCase() + str.slice(1);
      var join10 = (str, d) => words(str).join(d).toLowerCase();
      var camelCase3 = (str) => words(str).reduce(
        (acc, next) => `${acc}${!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()}`,
        ""
      );
      var pascalCase = (str) => upperFirst3(camelCase3(str));
      var snakeCase2 = (str) => join10(str, "_");
      var kebabCase = (str) => join10(str, "-");
      var sentenceCase = (str) => upperFirst3(join10(str, " "));
      var titleCase = (str) => words(str).map(upperFirst3).join(" ");
      module.exports = {
        words,
        upperFirst: upperFirst3,
        camelCase: camelCase3,
        pascalCase,
        snakeCase: snakeCase2,
        kebabCase,
        sentenceCase,
        titleCase
      };
    }
  });

  // ../../node_modules/.pnpm/toposort@2.0.2/node_modules/toposort/index.js
  var require_toposort = __commonJS({
    "../../node_modules/.pnpm/toposort@2.0.2/node_modules/toposort/index.js"(exports, module) {
      module.exports = function(edges) {
        return toposort2(uniqueNodes(edges), edges);
      };
      module.exports.array = toposort2;
      function toposort2(nodes, edges) {
        var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
        edges.forEach(function(edge) {
          if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
            throw new Error("Unknown node. There is an unknown node in the supplied edges.");
          }
        });
        while (i--) {
          if (!visited[i])
            visit2(nodes[i], i, /* @__PURE__ */ new Set());
        }
        return sorted;
        function visit2(node2, i2, predecessors) {
          if (predecessors.has(node2)) {
            var nodeRep;
            try {
              nodeRep = ", node was:" + JSON.stringify(node2);
            } catch (e) {
              nodeRep = "";
            }
            throw new Error("Cyclic dependency" + nodeRep);
          }
          if (!nodesHash.has(node2)) {
            throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node2));
          }
          if (visited[i2])
            return;
          visited[i2] = true;
          var outgoing = outgoingEdges.get(node2) || /* @__PURE__ */ new Set();
          outgoing = Array.from(outgoing);
          if (i2 = outgoing.length) {
            predecessors.add(node2);
            do {
              var child = outgoing[--i2];
              visit2(child, nodesHash.get(child), predecessors);
            } while (i2);
            predecessors.delete(node2);
          }
          sorted[--cursor] = node2;
        }
      }
      function uniqueNodes(arr) {
        var res = /* @__PURE__ */ new Set();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          res.add(edge[0]);
          res.add(edge[1]);
        }
        return Array.from(res);
      }
      function makeOutgoingEdges(arr) {
        var edges = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          if (!edges.has(edge[0]))
            edges.set(edge[0], /* @__PURE__ */ new Set());
          if (!edges.has(edge[1]))
            edges.set(edge[1], /* @__PURE__ */ new Set());
          edges.get(edge[0]).add(edge[1]);
        }
        return edges;
      }
      function makeNodesHash(arr) {
        var res = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          res.set(arr[i], i);
        }
        return res;
      }
    }
  });

  // src/cli/utils/logger.ts
  var import_chalk = __toESM(require_source());
  var loggingConfig = {
    isDebugEnabled: false,
    isLoggingEnabled: true
  };
  function configureLogging(params) {
    loggingConfig.isLoggingEnabled = params.isLoggingEnabled;
    loggingConfig.isDebugEnabled = params.isDebugEnabled && loggingConfig.isLoggingEnabled;
  }
  function log(...data) {
    if (loggingConfig.isLoggingEnabled) {
      console.log(data.join(" "));
    }
  }
  function debug(...data) {
    if (loggingConfig.isDebugEnabled) {
      log(data);
    }
  }
  function error(...data) {
    console.log(import_chalk.default.red(data.join(" ")));
  }
  function warn(...data) {
    log(import_chalk.default.yellow(data.join(" ")));
  }

  // ../versions/dist/index.mjs
  function getBuiltinVersions() {
    return {
      FORC: "0.66.5",
      FUEL_CORE: "0.40.2",
      FUELS: "0.98.0"
    };
  }
  function parseVersion(version3) {
    const [major2, minor2, patch] = version3.split(".").map((v) => parseInt(v, 10));
    return { major: major2, minor: minor2, patch };
  }
  function versionDiffs(version1, version22) {
    const semver1 = parseVersion(version1);
    const semver2 = parseVersion(version22);
    const major2 = semver1.major - semver2.major;
    const minor2 = semver1.minor - semver2.minor;
    const patch = semver1.patch - semver2.patch;
    return {
      major: major2,
      minor: minor2,
      patch,
      fullVersionDiff: major2 || minor2 || patch
    };
  }
  function gt(version1, version22) {
    const { fullVersionDiff } = versionDiffs(version1, version22);
    return fullVersionDiff > 0;
  }
  function eq(version1, version22) {
    const { fullVersionDiff } = versionDiffs(version1, version22);
    return fullVersionDiff === 0;
  }
  function majorEq(version1, version22) {
    const { major: major2 } = versionDiffs(version1, version22);
    return major2 === 0;
  }
  function minorEq(version1, version22) {
    const { minor: minor2 } = versionDiffs(version1, version22);
    return minor2 === 0;
  }
  function patchEq(version1, version22) {
    const { patch } = versionDiffs(version1, version22);
    return patch === 0;
  }
  function checkFuelCoreVersionCompatibility(networkVersion) {
    const { FUEL_CORE: supportedVersion } = getBuiltinVersions();
    if (/^\d+\.\d+\.\d+\D+/m.test(networkVersion)) {
      console.warn(`You're running against an unreleased fuel-core version: ${networkVersion}. Things may work as expected, but it's not guaranteed. Please use a released version.      
This unreleased fuel-core build may include features and updates not yet supported by this version of the TS-SDK.`);
    }
    return {
      supportedVersion,
      isMajorSupported: majorEq(networkVersion, supportedVersion),
      isMinorSupported: minorEq(networkVersion, supportedVersion),
      isPatchSupported: patchEq(networkVersion, supportedVersion)
    };
  }
  var versions = getBuiltinVersions();

  // ../../node_modules/.pnpm/commander@12.1.0/node_modules/commander/esm.mjs
  var import_index = __toESM(require_commander(), 1);
  var {
    program,
    createCommand,
    createArgument,
    createOption,
    CommanderError,
    InvalidArgumentError,
    InvalidOptionArgumentError,
    // deprecated old name
    Command,
    Argument,
    Option,
    Help
  } = import_index.default;

  // ../errors/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var ErrorCode = /* @__PURE__ */ ((ErrorCode22) => {
    ErrorCode22["NO_ABIS_FOUND"] = "no-abis-found";
    ErrorCode22["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
    ErrorCode22["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
    ErrorCode22["INVALID_COMPONENT"] = "invalid-component";
    ErrorCode22["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
    ErrorCode22["TYPE_NOT_FOUND"] = "type-not-found";
    ErrorCode22["LOG_TYPE_NOT_FOUND"] = "log-type-not-found";
    ErrorCode22["TYPE_NOT_SUPPORTED"] = "type-not-supported";
    ErrorCode22["INVALID_DECODE_VALUE"] = "invalid-decode-value";
    ErrorCode22["JSON_ABI_ERROR"] = "json-abi-error";
    ErrorCode22["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
    ErrorCode22["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
    ErrorCode22["CODER_NOT_FOUND"] = "coder-not-found";
    ErrorCode22["INVALID_DATA"] = "invalid-data";
    ErrorCode22["FUNCTION_NOT_FOUND"] = "function-not-found";
    ErrorCode22["UNSUPPORTED_ENCODING_VERSION"] = "unsupported-encoding-version";
    ErrorCode22["TIMEOUT_EXCEEDED"] = "timeout-exceeded";
    ErrorCode22["CONFIG_FILE_NOT_FOUND"] = "config-file-not-found";
    ErrorCode22["CONFIG_FILE_ALREADY_EXISTS"] = "config-file-already-exists";
    ErrorCode22["WORKSPACE_NOT_DETECTED"] = "workspace-not-detected";
    ErrorCode22["INVALID_ADDRESS"] = "invalid-address";
    ErrorCode22["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
    ErrorCode22["INVALID_B256_ADDRESS"] = "invalid-b256-address";
    ErrorCode22["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
    ErrorCode22["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
    ErrorCode22["MISSING_PROVIDER"] = "missing-provider";
    ErrorCode22["INVALID_PROVIDER"] = "invalid-provider";
    ErrorCode22["CONNECTION_REFUSED"] = "connection-refused";
    ErrorCode22["INVALID_URL"] = "invalid-url";
    ErrorCode22["INVALID_PUBLIC_KEY"] = "invalid-public-key";
    ErrorCode22["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
    ErrorCode22["HD_WALLET_ERROR"] = "hd-wallet-error";
    ErrorCode22["MISSING_CONNECTOR"] = "missing-connector";
    ErrorCode22["PARSE_FAILED"] = "parse-failed";
    ErrorCode22["ENCODE_ERROR"] = "encode-error";
    ErrorCode22["DECODE_ERROR"] = "decode-error";
    ErrorCode22["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
    ErrorCode22["INVALID_TTL"] = "invalid-ttl";
    ErrorCode22["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
    ErrorCode22["NOT_IMPLEMENTED"] = "not-implemented";
    ErrorCode22["NOT_SUPPORTED"] = "not-supported";
    ErrorCode22["CONVERTING_FAILED"] = "converting-error";
    ErrorCode22["ELEMENT_NOT_FOUND"] = "element-not-found";
    ErrorCode22["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
    ErrorCode22["INVALID_REQUEST"] = "invalid-request";
    ErrorCode22["INVALID_TRANSFER_AMOUNT"] = "invalid-transfer-amount";
    ErrorCode22["NOT_ENOUGH_FUNDS"] = "not-enough-funds";
    ErrorCode22["INVALID_CREDENTIALS"] = "invalid-credentials";
    ErrorCode22["HASHER_LOCKED"] = "hasher-locked";
    ErrorCode22["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
    ErrorCode22["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
    ErrorCode22["MAX_FEE_TOO_LOW"] = "max-fee-too-low";
    ErrorCode22["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
    ErrorCode22["TRANSACTION_FAILED"] = "transaction-failed";
    ErrorCode22["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
    ErrorCode22["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
    ErrorCode22["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
    ErrorCode22["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
    ErrorCode22["UNSUPPORTED_TRANSACTION_TYPE"] = "unsupported-transaction-type";
    ErrorCode22["TRANSACTION_ERROR"] = "transaction-error";
    ErrorCode22["INVALID_POLICY_TYPE"] = "invalid-policy-type";
    ErrorCode22["DUPLICATED_POLICY"] = "duplicated-policy";
    ErrorCode22["TRANSACTION_SQUEEZED_OUT"] = "transaction-squeezed-out";
    ErrorCode22["CONTRACT_SIZE_EXCEEDS_LIMIT"] = "contract-size-exceeds-limit";
    ErrorCode22["INVALID_CHUNK_SIZE_MULTIPLIER"] = "invalid-chunk-size-multiplier";
    ErrorCode22["MAX_INPUTS_EXCEEDED"] = "max-inputs-exceeded";
    ErrorCode22["FUNDS_TOO_LOW"] = "funds-too-low";
    ErrorCode22["MAX_OUTPUTS_EXCEEDED"] = "max-outputs-exceeded";
    ErrorCode22["MAX_COINS_REACHED"] = "max-coins-reached";
    ErrorCode22["ASSET_BURN_DETECTED"] = "asset-burn-detected";
    ErrorCode22["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
    ErrorCode22["INVALID_WORD_LIST"] = "invalid-word-list";
    ErrorCode22["INVALID_MNEMONIC"] = "invalid-mnemonic";
    ErrorCode22["INVALID_ENTROPY"] = "invalid-entropy";
    ErrorCode22["INVALID_SEED"] = "invalid-seed";
    ErrorCode22["INVALID_CHECKSUM"] = "invalid-checksum";
    ErrorCode22["INVALID_PASSWORD"] = "invalid-password";
    ErrorCode22["ACCOUNT_REQUIRED"] = "account-required";
    ErrorCode22["UNLOCKED_WALLET_REQUIRED"] = "unlocked-wallet-required";
    ErrorCode22["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
    ErrorCode22["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
    ErrorCode22["SCRIPT_REVERTED"] = "script-reverted";
    ErrorCode22["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
    ErrorCode22["STREAM_PARSING_ERROR"] = "stream-parsing-error";
    ErrorCode22["NODE_LAUNCH_FAILED"] = "node-launch-failed";
    ErrorCode22["UNKNOWN"] = "unknown";
    return ErrorCode22;
  })(ErrorCode || {});
  var _FuelError = class extends Error {
    VERSIONS = versions;
    metadata;
    rawError;
    static parse(e) {
      const error3 = e;
      if (error3.code === void 0) {
        throw new _FuelError(
          "parse-failed",
          "Failed to parse the error object. The required 'code' property is missing."
        );
      }
      const enumValues = Object.values(ErrorCode);
      const codeIsKnown = enumValues.includes(error3.code);
      if (!codeIsKnown) {
        throw new _FuelError(
          "parse-failed",
          `Unknown error code: ${error3.code}. Accepted codes: ${enumValues.join(", ")}.`
        );
      }
      return new _FuelError(error3.code, error3.message);
    }
    code;
    constructor(code, message, metadata = {}, rawError = null) {
      super(message);
      this.code = code;
      this.name = "FuelError";
      this.metadata = metadata;
      this.rawError = rawError;
    }
    toObject() {
      const { code, name, message, metadata, VERSIONS, rawError } = this;
      return { code, name, message, metadata, VERSIONS, rawError };
    }
  };
  var FuelError = _FuelError;
  __publicField2(FuelError, "CODES", ErrorCode);

  // ../abi-typegen/dist/cli.mjs
  var import_fs14 = __require2("fs");

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/index.js
  var import_brace_expansion = __toESM(require_brace_expansion(), 1);

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/assert-valid-pattern.js
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/brace-expressions.js
  var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
    "[:alpha:]": ["\\p{L}\\p{Nl}", true],
    "[:ascii:]": ["\\x00-\\x7f", false],
    "[:blank:]": ["\\p{Zs}\\t", true],
    "[:cntrl:]": ["\\p{Cc}", true],
    "[:digit:]": ["\\p{Nd}", true],
    "[:graph:]": ["\\p{Z}\\p{C}", true, true],
    "[:lower:]": ["\\p{Ll}", true],
    "[:print:]": ["\\p{C}", true],
    "[:punct:]": ["\\p{P}", true],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
    "[:upper:]": ["\\p{Lu}", true],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
    "[:xdigit:]": ["A-Fa-f0-9", false]
  };
  var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
  var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var rangesToString = (ranges) => ranges.join("");
  var parseClass = (glob2, position) => {
    const pos = position;
    if (glob2.charAt(pos) !== "[") {
      throw new Error("not in a brace expression");
    }
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = "";
    WHILE:
      while (i < glob2.length) {
        const c = glob2.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob2.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob2.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob2.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob2.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
    if (endPos < i) {
      return ["", false, 0, false];
    }
    if (!ranges.length && !negs.length) {
      return ["$.", false, glob2.length - pos, true];
    }
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
    const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
    return [comb, uflag, endPos - pos, true];
  };

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/unescape.js
  var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  };

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/ast.js
  var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
  var isExtglobType = (c) => types.has(c);
  var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
  var startNoDot = "(?!\\.)";
  var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
  var justDots = /* @__PURE__ */ new Set(["..", "."]);
  var reSpecials = new Set("().*{}+?[]^$\\!");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var qmark = "[^/]";
  var star = qmark + "*?";
  var starNoEmpty = qmark + "+?";
  var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
  var _AST = class {
    constructor(type3, parent, options = {}) {
      __privateAdd(this, _fillNegs);
      __privateAdd(this, _partsToRegExp);
      __publicField(this, "type");
      __privateAdd(this, _root, void 0);
      __privateAdd(this, _hasMagic, void 0);
      __privateAdd(this, _uflag, false);
      __privateAdd(this, _parts, []);
      __privateAdd(this, _parent, void 0);
      __privateAdd(this, _parentIndex, void 0);
      __privateAdd(this, _negs, void 0);
      __privateAdd(this, _filledNegs, false);
      __privateAdd(this, _options, void 0);
      __privateAdd(this, _toString, void 0);
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      __privateAdd(this, _emptyExt, false);
      this.type = type3;
      if (type3)
        __privateSet(this, _hasMagic, true);
      __privateSet(this, _parent, parent);
      __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
      __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
      __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
      if (type3 === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
        __privateGet(this, _negs).push(this);
      __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
    }
    get hasMagic() {
      if (__privateGet(this, _hasMagic) !== void 0)
        return __privateGet(this, _hasMagic);
      for (const p of __privateGet(this, _parts)) {
        if (typeof p === "string")
          continue;
        if (p.type || p.hasMagic)
          return __privateSet(this, _hasMagic, true);
      }
      return __privateGet(this, _hasMagic);
    }
    // reconstructs the pattern
    toString() {
      if (__privateGet(this, _toString) !== void 0)
        return __privateGet(this, _toString);
      if (!this.type) {
        return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
      } else {
        return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
      }
    }
    push(...parts) {
      for (const p of parts) {
        if (p === "")
          continue;
        if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
          throw new Error("invalid part: " + p);
        }
        __privateGet(this, _parts).push(p);
      }
    }
    toJSON() {
      const ret4 = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
      if (this.isStart() && !this.type)
        ret4.unshift([]);
      if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!")) {
        ret4.push({});
      }
      return ret4;
    }
    isStart() {
      if (__privateGet(this, _root) === this)
        return true;
      if (!__privateGet(this, _parent)?.isStart())
        return false;
      if (__privateGet(this, _parentIndex) === 0)
        return true;
      const p = __privateGet(this, _parent);
      for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
        const pp = __privateGet(p, _parts)[i];
        if (!(pp instanceof _AST && pp.type === "!")) {
          return false;
        }
      }
      return true;
    }
    isEnd() {
      if (__privateGet(this, _root) === this)
        return true;
      if (__privateGet(this, _parent)?.type === "!")
        return true;
      if (!__privateGet(this, _parent)?.isEnd())
        return false;
      if (!this.type)
        return __privateGet(this, _parent)?.isEnd();
      const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
      return __privateGet(this, _parentIndex) === pl - 1;
    }
    copyIn(part) {
      if (typeof part === "string")
        this.push(part);
      else
        this.push(part.clone(this));
    }
    clone(parent) {
      const c = new _AST(this.type, parent);
      for (const p of __privateGet(this, _parts)) {
        c.copyIn(p);
      }
      return c;
    }
    static fromGlob(pattern, options = {}) {
      var _a2;
      const ast = new _AST(null, void 0, options);
      __privateMethod(_a2 = _AST, _parseAST, parseAST_fn).call(_a2, pattern, ast, 0, options);
      return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
      if (this !== __privateGet(this, _root))
        return __privateGet(this, _root).toMMPattern();
      const glob2 = this.toString();
      const [re, body, hasMagic2, uflag] = this.toRegExpSource();
      const anyMagic = hasMagic2 || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
      if (!anyMagic) {
        return body;
      }
      const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob2
      });
    }
    get options() {
      return __privateGet(this, _options);
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
      const dot = allowDot ?? !!__privateGet(this, _options).dot;
      if (__privateGet(this, _root) === this)
        __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
      if (!this.type) {
        const noEmpty = this.isStart() && this.isEnd();
        const src = __privateGet(this, _parts).map((p) => {
          var _a2;
          const [re, _, hasMagic2, uflag] = typeof p === "string" ? __privateMethod(_a2 = _AST, _parseGlob, parseGlob_fn).call(_a2, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
          __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic2);
          __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
          return re;
        }).join("");
        let start2 = "";
        if (this.isStart()) {
          if (typeof __privateGet(this, _parts)[0] === "string") {
            const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
            if (!dotTravAllowed) {
              const aps = addPatternStart;
              const needNoTrav = (
                // dots are allowed, and the pattern starts with [ or .
                dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                src.startsWith("\\.\\.") && aps.has(src.charAt(4))
              );
              const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
              start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
            }
          }
        }
        let end = "";
        if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!") {
          end = "(?:$|\\/)";
        }
        const final2 = start2 + src + end;
        return [
          final2,
          unescape(src),
          __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
          __privateGet(this, _uflag)
        ];
      }
      const repeated = this.type === "*" || this.type === "+";
      const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
      let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        const s = this.toString();
        __privateSet(this, _parts, [s]);
        this.type = null;
        __privateSet(this, _hasMagic, void 0);
        return [s, unescape(this.toString()), false, false];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
      if (bodyDotAllowed === body) {
        bodyDotAllowed = "";
      }
      if (bodyDotAllowed) {
        body = `(?:${body})(?:${bodyDotAllowed})*?`;
      }
      let final = "";
      if (this.type === "!" && __privateGet(this, _emptyExt)) {
        final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
      } else {
        const close = this.type === "!" ? (
          // !() must match something,but !(x) can match ''
          "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
        ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
        final = start + body + close;
      }
      return [
        final,
        unescape(body),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
  };
  var AST = _AST;
  _root = new WeakMap();
  _hasMagic = new WeakMap();
  _uflag = new WeakMap();
  _parts = new WeakMap();
  _parent = new WeakMap();
  _parentIndex = new WeakMap();
  _negs = new WeakMap();
  _filledNegs = new WeakMap();
  _options = new WeakMap();
  _toString = new WeakMap();
  _emptyExt = new WeakMap();
  _fillNegs = new WeakSet();
  fillNegs_fn = function() {
    if (this !== __privateGet(this, _root))
      throw new Error("should only call on root");
    if (__privateGet(this, _filledNegs))
      return this;
    this.toString();
    __privateSet(this, _filledNegs, true);
    let n;
    while (n = __privateGet(this, _negs).pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = __privateGet(p, _parent);
      while (pp) {
        for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
          for (const part of __privateGet(n, _parts)) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(__privateGet(pp, _parts)[i]);
          }
        }
        p = pp;
        pp = __privateGet(p, _parent);
      }
    }
    return this;
  };
  _parseAST = new WeakSet();
  parseAST_fn = function(str, ast, pos, opt) {
    var _a2, _b2;
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str.length) {
        const c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = __privateMethod(_a2 = _AST, _parseAST, parseAST_fn).call(_a2, str, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = __privateMethod(_b2 = _AST, _parseAST, parseAST_fn).call(_b2, str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && __privateGet(ast, _parts).length === 0) {
          __privateSet(ast, _emptyExt, true);
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    __privateSet(ast, _hasMagic, void 0);
    __privateSet(ast, _parts, [str.substring(pos - 1)]);
    return i;
  };
  _partsToRegExp = new WeakSet();
  partsToRegExp_fn = function(dot) {
    return __privateGet(this, _parts).map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
      __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  };
  _parseGlob = new WeakSet();
  parseGlob_fn = function(glob2, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob2.length; i++) {
      const c = glob2.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob2.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob2 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob2), !!hasMagic2, uflag];
  };
  __privateAdd(AST, _parseAST);
  __privateAdd(AST, _parseGlob);

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/escape.js
  var escape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
  };

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/index.js
  var minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
  var starDotExtTest = (ext2) => (f2) => !f2.startsWith(".") && f2.endsWith(ext2);
  var starDotExtTestDot = (ext2) => (f2) => f2.endsWith(ext2);
  var starDotExtTestNocase = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f2) => !f2.startsWith(".") && f2.toLowerCase().endsWith(ext2);
  };
  var starDotExtTestNocaseDot = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f2) => f2.toLowerCase().endsWith(ext2);
  };
  var starDotStarRE = /^\*+\.\*+$/;
  var starDotStarTest = (f2) => !f2.startsWith(".") && f2.includes(".");
  var starDotStarTestDot = (f2) => f2 !== "." && f2 !== ".." && f2.includes(".");
  var dotStarRE = /^\.\*+$/;
  var dotStarTest = (f2) => f2 !== "." && f2 !== ".." && f2.startsWith(".");
  var starRE = /^\*+$/;
  var starTest = (f2) => f2.length !== 0 && !f2.startsWith(".");
  var starTestDot = (f2) => f2.length !== 0 && f2 !== "." && f2 !== "..";
  var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
  var qmarksTestNocase = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
  };
  var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
  };
  var qmarksTestDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
  };
  var qmarksTest = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
  };
  var qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f2) => f2.length === len && !f2.startsWith(".");
  };
  var qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f2) => f2.length === len && f2 !== "." && f2 !== "..";
  };
  var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
  var path = {
    win32: { sep: "\\" },
    posix: { sep: "/" }
  };
  var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
  minimatch.sep = sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var qmark2 = "[^/]";
  var star2 = qmark2 + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
  minimatch.filter = filter;
  var ext = (a, b = {}) => Object.assign({}, a, b);
  var defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
      Minimatch: class Minimatch extends orig.Minimatch {
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class AST extends orig.AST {
        /* c8 ignore start */
        constructor(type3, parent, options = {}) {
          super(type3, parent, ext(def, options));
        }
        /* c8 ignore stop */
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: (options) => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR
    });
  };
  minimatch.defaults = defaults;
  var braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return (0, import_brace_expansion.default)(pattern);
  };
  minimatch.braceExpand = braceExpand;
  var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
  minimatch.makeRe = makeRe;
  var match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f2) => mm.match(f2));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  minimatch.match = match;
  var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
  var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var Minimatch = class {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      assertValidPattern(pattern);
      options = options || {};
      this.options = options;
      this.pattern = pattern;
      this.platform = options.platform || defaultPlatform;
      this.isWindows = this.platform === "win32";
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
      this.regexp = null;
      this.negate = false;
      this.nonegate = !!options.nonegate;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.nocase = !!this.options.nocase;
      this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
      this.globSet = [];
      this.globParts = [];
      this.set = [];
      this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) {
        return true;
      }
      for (const pattern of this.set) {
        for (const part of pattern) {
          if (typeof part !== "string")
            return true;
        }
      }
      return false;
    }
    debug(..._) {
    }
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      this.globSet = [...new Set(this.braceExpand())];
      if (options.debug) {
        this.debug = (...args) => console.error(...args);
      }
      this.debug(this.pattern, this.globSet);
      const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts);
      this.debug(this.pattern, this.globParts);
      let set = this.globParts.map((s, _, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
          const isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) {
            return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
          } else if (isDrive) {
            return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
          }
        }
        return s.map((ss) => this.parse(ss));
      });
      this.debug(this.pattern, set);
      this.set = set.filter((s) => s.indexOf(false) === -1);
      if (this.isWindows) {
        for (let i = 0; i < this.set.length; i++) {
          const p = this.set[i];
          if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
            p[2] = "?";
          }
        }
      }
      this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
      if (this.options.noglobstar) {
        for (let i = 0; i < globParts.length; i++) {
          for (let j = 0; j < globParts[i].length; j++) {
            if (globParts[i][j] === "**") {
              globParts[i][j] = "*";
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        globParts = this.firstPhasePreProcess(globParts);
        globParts = this.secondPhasePreProcess(globParts);
      } else if (optimizationLevel >= 1) {
        globParts = this.levelOneOptimize(globParts);
      } else {
        globParts = this.adjascentGlobstarOptimize(globParts);
      }
      return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
      return globParts.map((parts) => {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let i = gs;
          while (parts[i + 1] === "**") {
            i++;
          }
          if (i !== gs) {
            parts.splice(gs, i - gs);
          }
        }
        return parts;
      });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
      return globParts.map((parts) => {
        parts = parts.reduce((set, part) => {
          const prev = set[set.length - 1];
          if (part === "**" && prev === "**") {
            return set;
          }
          if (part === "..") {
            if (prev && prev !== ".." && prev !== "." && prev !== "**") {
              set.pop();
              return set;
            }
          }
          set.push(part);
          return set;
        }, []);
        return parts.length === 0 ? [""] : parts;
      });
    }
    levelTwoFileOptimize(parts) {
      if (!Array.isArray(parts)) {
        parts = this.slashSplit(parts);
      }
      let didSomething = false;
      do {
        didSomething = false;
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            parts.splice(dd - 1, 2);
            dd -= 2;
          }
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
      let didSomething = false;
      do {
        didSomething = false;
        for (let parts of globParts) {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let gss = gs;
            while (parts[gss + 1] === "**") {
              gss++;
            }
            if (gss > gs) {
              parts.splice(gs + 1, gss - gs);
            }
            let next = parts[gs + 1];
            const p = parts[gs + 2];
            const p2 = parts[gs + 3];
            if (next !== "..")
              continue;
            if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
              continue;
            }
            didSomething = true;
            parts.splice(gs, 1);
            const other = parts.slice(0);
            other[gs] = "**";
            globParts.push(other);
            gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              const needDot = dd === 1 && parts[dd + 1] === "**";
              const splin = needDot ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin);
              if (parts.length === 0)
                parts.push("");
              dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
      for (let i = 0; i < globParts.length - 1; i++) {
        for (let j = i + 1; j < globParts.length; j++) {
          const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
          if (matched) {
            globParts[i] = [];
            globParts[j] = matched;
            break;
          }
        }
      }
      return globParts.filter((gs) => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
      let ai = 0;
      let bi = 0;
      let result = [];
      let which = "";
      while (ai < a.length && bi < b.length) {
        if (a[ai] === b[bi]) {
          result.push(which === "b" ? b[bi] : a[ai]);
          ai++;
          bi++;
        } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
          result.push(a[ai]);
          ai++;
        } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
          result.push(b[bi]);
          bi++;
        } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
          if (which === "b")
            return false;
          which = "a";
          result.push(a[ai]);
          ai++;
          bi++;
        } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
          if (which === "a")
            return false;
          which = "b";
          result.push(b[bi]);
          ai++;
          bi++;
        } else {
          return false;
        }
      }
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
      const options = this.options;
      if (this.isWindows) {
        const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
        const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
        const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
        const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
        const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
        const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
        if (typeof fdi === "number" && typeof pdi === "number") {
          const [fd2, pd] = [file[fdi], pattern[pdi]];
          if (fd2.toLowerCase() === pd.toLowerCase()) {
            pattern[pdi] = fd2;
            if (pdi > fdi) {
              pattern = pattern.slice(pdi);
            } else if (fdi > pdi) {
              file = file.slice(fdi);
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        file = this.levelTwoFileOptimize(file);
      }
      this.debug("matchOne", this, { file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl2 = file.length, pl = pattern.length; fi < fl2 && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f2 = file[fi];
        this.debug(pattern, p, f2);
        if (p === false) {
          return false;
        }
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f2]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl2; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl2) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl2, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl2) {
              return true;
            }
          }
          return false;
        }
        let hit;
        if (typeof p === "string") {
          hit = f2 === p;
          this.debug("string match", p, f2, hit);
        } else {
          hit = p.test(f2);
          this.debug("pattern match", p, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl2 && pi === pl) {
        return true;
      } else if (fi === fl2) {
        return partial;
      } else if (pi === pl) {
        return fi === fl2 - 1 && file[fi] === "";
      } else {
        throw new Error("wtf?");
      }
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      let m;
      let fastTest = null;
      if (m = pattern.match(starRE)) {
        fastTest = options.dot ? starTestDot : starTest;
      } else if (m = pattern.match(starDotExtRE)) {
        fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
      } else if (m = pattern.match(qmarksRE)) {
        fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
      } else if (m = pattern.match(starDotStarRE)) {
        fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
      } else if (m = pattern.match(dotStarRE)) {
        fastTest = dotStarTest;
      }
      const re = AST.fromGlob(pattern, this.options).toMMPattern();
      if (fastTest && typeof re === "object") {
        Reflect.defineProperty(re, "test", { value: fastTest });
      }
      return re;
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
      const flags = new Set(options.nocase ? ["i"] : []);
      let re = set.map((pattern) => {
        const pp = pattern.map((p) => {
          if (p instanceof RegExp) {
            for (const f2 of p.flags.split(""))
              flags.add(f2);
          }
          return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
        });
        pp.forEach((p, i) => {
          const next = pp[i + 1];
          const prev = pp[i - 1];
          if (p !== GLOBSTAR || prev === GLOBSTAR) {
            return;
          }
          if (prev === void 0) {
            if (next !== void 0 && next !== GLOBSTAR) {
              pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
            } else {
              pp[i] = twoStar;
            }
          } else if (next === void 0) {
            pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
          } else if (next !== GLOBSTAR) {
            pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
            pp[i + 1] = GLOBSTAR;
          }
        });
        return pp.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$";
      if (this.negate)
        re = "^(?!" + re + ").+$";
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    slashSplit(p) {
      if (this.preserveMultipleSlashes) {
        return p.split("/");
      } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
        return ["", ...p.split(/\/+/)];
      } else {
        return p.split(/\/+/);
      }
    }
    match(f2, partial = this.partial) {
      this.debug("match", f2, this.pattern);
      if (this.comment) {
        return false;
      }
      if (this.empty) {
        return f2 === "";
      }
      if (f2 === "/" && partial) {
        return true;
      }
      const options = this.options;
      if (this.isWindows) {
        f2 = f2.split("\\").join("/");
      }
      const ff = this.slashSplit(f2);
      this.debug(this.pattern, "split", ff);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename = ff[ff.length - 1];
      if (!filename) {
        for (let i = ff.length - 2; !filename && i >= 0; i--) {
          filename = ff[i];
        }
      }
      for (let i = 0; i < set.length; i++) {
        const pattern = set[i];
        let file = ff;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) {
            return true;
          }
          return !this.negate;
        }
      }
      if (options.flipNegate) {
        return false;
      }
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  };
  minimatch.AST = AST;
  minimatch.Minimatch = Minimatch;
  minimatch.escape = escape;
  minimatch.unescape = unescape;

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/glob.js
  var import_node_url2 = __require2("url");

  // ../../node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/esm/index.js
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var warned = /* @__PURE__ */ new Set();
  var PROCESS = typeof process === "object" && !!process ? process : {};
  var emitWarning = (msg, type3, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type3, code, fn) : console.error(`[${code}] ${type3}: ${msg}`);
  };
  var AC = globalThis.AbortController;
  var AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(_, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS();
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  var shouldWarn = (code) => !warned.has(code);
  var TYPE = Symbol("type");
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
  var ZeroArray = class extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  };
  var _constructing;
  var _Stack = class {
    heap;
    length;
    static create(max2) {
      const HeapCls = getUintArray(max2);
      if (!HeapCls)
        return [];
      __privateSet(_Stack, _constructing, true);
      const s = new _Stack(max2, HeapCls);
      __privateSet(_Stack, _constructing, false);
      return s;
    }
    constructor(max2, HeapCls) {
      if (!__privateGet(_Stack, _constructing)) {
        throw new TypeError("instantiate Stack using Stack.create(n)");
      }
      this.heap = new HeapCls(max2);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  var Stack = _Stack;
  _constructing = new WeakMap();
  // private constructor
  __privateAdd(Stack, _constructing, false);
  var LRUCache = class {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
      return {
        // properties
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        // methods
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context2) => c.#backgroundFetch(k, index, options, context2),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options) => c.#indexes(options),
        rindexes: (options) => c.#rindexes(options),
        isStale: (index) => c.#isStale(index)
      };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
      return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
      return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
      return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
      return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
      return this.#fetchMethod;
    }
    get memoMethod() {
      return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
      return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options) {
      const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
      if (max2 !== 0 && !isPosInt(max2)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max2 ? getUintArray(max2) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max2);
      }
      this.#max = max2;
      this.#maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.#maxSize;
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (memoMethod !== void 0 && typeof memoMethod !== "function") {
        throw new TypeError("memoMethod must be a function if defined");
      }
      this.#memoMethod = memoMethod;
      if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.#fetchMethod = fetchMethod;
      this.#hasFetchMethod = !!fetchMethod;
      this.#keyMap = /* @__PURE__ */ new Map();
      this.#keyList = new Array(max2).fill(void 0);
      this.#valList = new Array(max2).fill(void 0);
      this.#next = new UintArray(max2);
      this.#prev = new UintArray(max2);
      this.#head = 0;
      this.#tail = 0;
      this.#free = Stack.create(max2);
      this.#size = 0;
      this.#calculatedSize = 0;
      if (typeof dispose === "function") {
        this.#dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.#disposeAfter = disposeAfter;
        this.#disposed = [];
      } else {
        this.#disposeAfter = void 0;
        this.#disposed = void 0;
      }
      this.#hasDispose = !!this.#dispose;
      this.#hasDisposeAfter = !!this.#disposeAfter;
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.#initializeSizeTracking();
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max);
      const starts = new ZeroArray(this.#max);
      this.#ttls = ttls;
      this.#starts = starts;
      this.#setItemTTL = (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.#delete(this.#keyList[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      };
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.#keyMap.get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      this.#isStale = (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => {
    };
    #statusTTL = () => {
    };
    #setItemTTL = () => {
    };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0;
      this.#sizes = sizes;
      this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index];
        sizes[index] = 0;
      };
      this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      };
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size;
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize) {
            this.#evict(true);
          }
        }
        this.#calculatedSize += sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.#calculatedSize;
        }
      };
    }
    #removeItemSize = (_i) => {
    };
    #addItemSize = (_i, _s, _st) => {
    };
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail; true; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#head) {
            break;
          } else {
            i = this.#prev[i];
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head; true; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#tail) {
            break;
          } else {
            i = this.#next[i];
          }
        }
      }
    }
    #isValidIndex(index) {
      return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
      for (const i of this.#indexes()) {
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
      for (const i of this.#rindexes()) {
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
      return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = "LRUCache";
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions);
        }
      }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
      let deleted = false;
      for (const i of this.#rindexes({ allowStale: true })) {
        if (this.#isStale(i)) {
          this.#delete(this.#keyList[i], "expire");
          deleted = true;
        }
      }
      return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
      const i = this.#keyMap.get(key);
      if (i === void 0)
        return void 0;
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        return void 0;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        const ttl = this.#ttls[i];
        const start = this.#starts[i];
        if (ttl && start) {
          const remain = ttl - (perf.now() - start);
          entry.ttl = remain;
          entry.start = Date.now();
        }
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
      const arr = [];
      for (const i of this.#indexes({ allowStale: true })) {
        const key = this.#keyList[i];
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0 || key === void 0)
          continue;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          const age = perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
      if (v === void 0) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.#delete(k, "set");
        return this;
      }
      let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
      if (index === void 0) {
        index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
        this.#keyList[index] = k;
        this.#valList[index] = v;
        this.#keyMap.set(k, index);
        this.#next[this.#tail] = index;
        this.#prev[index] = this.#tail;
        this.#tail = index;
        this.#size++;
        this.#addItemSize(index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
      } else {
        this.#moveToTail(index);
        const oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: s } = oldVal;
            if (s !== void 0 && !noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(s, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([s, k, "set"]);
              }
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, "set"]);
            }
          }
          this.#removeItemSize(index);
          this.#addItemSize(index, size, status);
          this.#valList[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== void 0)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking();
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start);
        }
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head];
          this.#evict(true);
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== void 0) {
            return val;
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head;
      const k = this.#keyList[head];
      const v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "evict");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "evict"]);
        }
      }
      this.#removeItemSize(head);
      if (free) {
        this.#keyList[head] = void 0;
        this.#valList[head] = void 0;
        this.#free.push(head);
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0;
        this.#free.length = 0;
      } else {
        this.#head = this.#next[head];
      }
      this.#keyMap.delete(k);
      this.#size--;
      return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
          return false;
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index);
          }
          if (status) {
            status.has = "hit";
            this.#statusTTL(status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          this.#statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = this.#keyMap.get(k);
      if (index === void 0 || !allowStale && this.#isStale(index)) {
        return;
      }
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context2) {
      const v = index === void 0 ? void 0 : this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context: context2
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (this.#valList[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              this.#valList[index] = bf2.__staleWhileFetching;
            } else {
              this.#delete(k, "fetch");
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (this.#valList[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            this.#delete(k, "fetch");
          } else if (!allowStaleAborted) {
            this.#valList[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = this.#keyMap.get(k);
      } else {
        this.#valList[index] = bf;
      }
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context: context2,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.#keyMap.get(k);
      if (index === void 0) {
        if (status)
          status.fetch = "miss";
        const p = this.#backgroundFetch(k, index, options, context2);
        return p.__returned = p;
      } else {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== void 0;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        const p = this.#backgroundFetch(k, index, options, context2);
        const hasStale = p.__staleWhileFetching !== void 0;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions);
      if (v === void 0)
        throw new Error("fetch() returned undefined");
      return v;
    }
    memo(k, memoOptions = {}) {
      const memoMethod = this.#memoMethod;
      if (!memoMethod) {
        throw new Error("no memoMethod provided to constructor");
      }
      const { context: context2, forceRefresh, ...options } = memoOptions;
      const v = this.get(k, options);
      if (!forceRefresh && v !== void 0)
        return v;
      const vv = memoMethod(k, v, {
        options,
        context: context2
      });
      this.set(k, vv, options);
      return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        const value = this.#valList[index];
        const fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.#delete(k, "expire");
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : void 0;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== void 0) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : void 0;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    #connect(p, n) {
      this.#prev[n] = p;
      this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index];
        } else {
          this.#connect(this.#prev[index], this.#next[index]);
        }
        this.#connect(this.#tail, index);
        this.#tail = index;
      }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
      return this.#delete(k, "delete");
    }
    #delete(k, reason) {
      let deleted = false;
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          deleted = true;
          if (this.#size === 1) {
            this.#clear(reason);
          } else {
            this.#removeItemSize(index);
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason);
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason]);
              }
            }
            this.#keyMap.delete(k);
            this.#keyList[index] = void 0;
            this.#valList[index] = void 0;
            if (index === this.#tail) {
              this.#tail = this.#prev[index];
            } else if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              const pi = this.#prev[index];
              this.#next[pi] = this.#next[index];
              const ni = this.#next[index];
              this.#prev[ni] = this.#prev[index];
            }
            this.#size--;
            this.#free.push(index);
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
      return this.#clear("delete");
    }
    #clear(reason) {
      for (const index of this.#rindexes({ allowStale: true })) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.#keyList[index];
          if (this.#hasDispose) {
            this.#dispose?.(v, k, reason);
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, reason]);
          }
        }
      }
      this.#keyMap.clear();
      this.#valList.fill(void 0);
      this.#keyList.fill(void 0);
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0);
        this.#starts.fill(0);
      }
      if (this.#sizes) {
        this.#sizes.fill(0);
      }
      this.#head = 0;
      this.#tail = 0;
      this.#free.length = 0;
      this.#calculatedSize = 0;
      this.#size = 0;
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  };

  // ../../node_modules/.pnpm/path-scurry@1.11.1/node_modules/path-scurry/dist/esm/index.js
  var import_node_path = __require2("path");
  var import_node_url = __require2("url");
  var import_fs = __require2("fs");
  var actualFS = __toESM(__require2("fs"), 1);
  var import_promises = __require2("fs/promises");

  // ../../node_modules/.pnpm/minipass@7.1.2/node_modules/minipass/dist/esm/index.js
  var import_node_events = __require2("events");
  var import_node_stream = __toESM(__require2("stream"), 1);
  var import_node_string_decoder = __require2("string_decoder");
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof import_node_stream.default || isReadable(s) || isWritable(s));
  var isReadable = (s) => !!s && typeof s === "object" && s instanceof import_node_events.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
  s.pipe !== import_node_stream.default.Writable.prototype.pipe;
  var isWritable = (s) => !!s && typeof s === "object" && s instanceof import_node_events.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFER = Symbol("buffer");
  var PIPES = Symbol("pipes");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var ERROR = Symbol("error");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var ABORT = Symbol("abort");
  var ABORTED = Symbol("aborted");
  var SIGNAL = Symbol("signal");
  var DATALISTENERS = Symbol("dataListeners");
  var DISCARDED = Symbol("discarded");
  var defer = (fn) => Promise.resolve().then(fn);
  var nodefer = (fn) => fn();
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  var Pipe = class {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      this.dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) {
    }
    /* c8 ignore stop */
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  };
  var PipeProxyErrors = class extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  };
  var isObjectModeOptions = (o) => !!o.objectMode;
  var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
  var Minipass = class extends import_node_events.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
      const options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string") {
        throw new TypeError("Encoding and objectMode may not be used together");
      }
      if (isObjectModeOptions(options)) {
        this[OBJECTMODE] = true;
        this[ENCODING] = null;
      } else if (isEncodingOptions(options)) {
        this[ENCODING] = options.encoding;
        this[OBJECTMODE] = false;
      } else {
        this[OBJECTMODE] = false;
        this[ENCODING] = null;
      }
      this[ASYNC] = !!options.async;
      this[DECODER] = this[ENCODING] ? new import_node_string_decoder.StringDecoder(this[ENCODING]) : null;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      const { signal } = options;
      if (signal) {
        this[SIGNAL] = signal;
        if (signal.aborted) {
          this[ABORT]();
        } else {
          signal.addEventListener("abort", () => this[ABORT]());
        }
      }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
      return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
      return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
      throw new Error("objectMode must be set at instantiation time");
    }
    /**
     * true if this is an async stream
     */
    get ["async"]() {
      return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL]?.reason);
      this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
      return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : nodefer;
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk)) {
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        } else if (isArrayBufferLike(chunk)) {
          chunk = Buffer.from(chunk);
        } else if (typeof chunk !== "string") {
          throw new Error("Non-contiguous data written to non-objectMode stream");
        }
      }
      if (this[OBJECTMODE]) {
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (typeof chunk === "string" && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING]) {
        chunk = this[DECODER].write(chunk);
      }
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
      if (this[DESTROYED])
        return null;
      this[DISCARDED] = false;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        this[BUFFER] = [
          this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
        ];
      }
      const ret4 = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret4;
    }
    [READ](n, chunk) {
      if (this[OBJECTMODE])
        this[BUFFERSHIFT]();
      else {
        const c = chunk;
        if (n === c.length || n === null)
          this[BUFFERSHIFT]();
        else if (typeof c === "string") {
          this[BUFFER][0] = c.slice(n);
          chunk = c.slice(0, n);
          this[BUFFERLENGTH] -= n;
        } else {
          this[BUFFER][0] = c.subarray(n);
          chunk = c.subarray(0, n);
          this[BUFFERLENGTH] -= n;
        }
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = void 0;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (chunk !== void 0)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this[FLOWING] || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
      if (this[DESTROYED])
        return;
      if (!this[DATALISTENERS] && !this[PIPES].length) {
        this[DISCARDED] = true;
      }
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
      return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
      this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
      return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
      return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
      if (this[DESTROYED])
        return dest;
      this[DISCARDED] = false;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES].length === 1) {
          if (this[FLOWING] && this[DATALISTENERS] === 0) {
            this[FLOWING] = false;
          }
          this[PIPES] = [];
        } else
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
      const ret4 = super.on(ev, handler);
      if (ev === "data") {
        this[DISCARDED] = false;
        this[DATALISTENERS]++;
        if (!this[PIPES].length && !this[FLOWING]) {
          this[RESUME]();
        }
      } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
        super.emit("readable");
      } else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        const h = handler;
        if (this[ASYNC])
          defer(() => h.call(this, this[EMITTED_ERROR]));
        else
          h.call(this, this[EMITTED_ERROR]);
      }
      return ret4;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
      const ret4 = super.off(ev, handler);
      if (ev === "data") {
        this[DATALISTENERS] = this.listeners("data").length;
        if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret4;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
      const ret4 = super.removeAllListeners(ev);
      if (ev === "data" || ev === void 0) {
        this[DATALISTENERS] = 0;
        if (!this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret4;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
      const data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
        return false;
      } else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return false;
        const ret5 = super.emit("close");
        this.removeAllListeners("close");
        return ret5;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret5 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret5;
      } else if (ev === "resume") {
        const ret5 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret5;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret5 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret5;
      }
      const ret4 = super.emit(ev, ...args);
      this[MAYBE_EMIT_END]();
      return ret4;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret4 = this[DISCARDED] ? false : super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret4;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return false;
      this[EMITTED_END] = true;
      this.readable = false;
      return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          if (!this[DISCARDED])
            super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret4 = super.emit("end");
      this.removeAllListeners("end");
      return ret4;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
      const buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      await p;
      return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
      if (this[OBJECTMODE]) {
        throw new Error("cannot concat in objectMode");
      }
      const buf = await this.collect();
      return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
      return new Promise((resolve10, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve10());
      });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = async () => {
        this.pause();
        stopped = true;
        return { value: void 0, done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve10;
        let reject;
        const onerr = (er) => {
          this.off("data", ondata);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.off("error", onerr);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          this.pause();
          resolve10({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.off("error", onerr);
          this.off("data", ondata);
          this.off(DESTROYED, ondestroy);
          stop();
          resolve10({ done: true, value: void 0 });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve10 = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = () => {
        this.pause();
        this.off(ERROR, stop);
        this.off(DESTROYED, stop);
        this.off("end", stop);
        stopped = true;
        return { done: true, value: void 0 };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { done: false, value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[DISCARDED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      const wc = this;
      if (typeof wc.close === "function" && !this[CLOSED])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
      return isStream;
    }
  };

  // ../../node_modules/.pnpm/path-scurry@1.11.1/node_modules/path-scurry/dist/esm/index.js
  var realpathSync = import_fs.realpathSync.native;
  var defaultFS = {
    lstatSync: import_fs.lstatSync,
    readdir: import_fs.readdir,
    readdirSync: import_fs.readdirSync,
    readlinkSync: import_fs.readlinkSync,
    realpathSync,
    promises: {
      lstat: import_promises.lstat,
      readdir: import_promises.readdir,
      readlink: import_promises.readlink,
      realpath: import_promises.realpath
    }
  };
  var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
    ...defaultFS,
    ...fsOption,
    promises: {
      ...defaultFS.promises,
      ...fsOption.promises || {}
    }
  };
  var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
  var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
  var eitherSep = /[\\\/]/;
  var UNKNOWN = 0;
  var IFIFO = 1;
  var IFCHR = 2;
  var IFDIR = 4;
  var IFBLK = 6;
  var IFREG = 8;
  var IFLNK = 10;
  var IFSOCK = 12;
  var IFMT = 15;
  var IFMT_UNKNOWN = ~IFMT;
  var READDIR_CALLED = 16;
  var LSTAT_CALLED = 32;
  var ENOTDIR = 64;
  var ENOENT = 128;
  var ENOREADLINK = 256;
  var ENOREALPATH = 512;
  var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
  var TYPEMASK = 1023;
  var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
  var normalizeCache = /* @__PURE__ */ new Map();
  var normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
      return c;
    const n = s.normalize("NFKD");
    normalizeCache.set(s, n);
    return n;
  };
  var normalizeNocaseCache = /* @__PURE__ */ new Map();
  var normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
      return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
  };
  var ResolveCache = class extends LRUCache {
    constructor() {
      super({ max: 256 });
    }
  };
  var ChildrenCache = class extends LRUCache {
    constructor(maxSize = 16 * 1024) {
      super({
        maxSize,
        // parent + children
        sizeCalculation: (a) => a.length + 1
      });
    }
  };
  var setAsCwd = Symbol("PathScurry setAsCwd");
  var PathBase = class {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    /**
     * boolean indicating that this path is the current working directory
     * of the PathScurry collection that contains it.
     */
    isCWD = false;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
      return this.#dev;
    }
    #mode;
    get mode() {
      return this.#mode;
    }
    #nlink;
    get nlink() {
      return this.#nlink;
    }
    #uid;
    get uid() {
      return this.#uid;
    }
    #gid;
    get gid() {
      return this.#gid;
    }
    #rdev;
    get rdev() {
      return this.#rdev;
    }
    #blksize;
    get blksize() {
      return this.#blksize;
    }
    #ino;
    get ino() {
      return this.#ino;
    }
    #size;
    get size() {
      return this.#size;
    }
    #blocks;
    get blocks() {
      return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
      return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
      return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
      return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
      return this.#birthtimeMs;
    }
    #atime;
    get atime() {
      return this.#atime;
    }
    #mtime;
    get mtime() {
      return this.#mtime;
    }
    #ctime;
    get ctime() {
      return this.#ctime;
    }
    #birthtime;
    get birthtime() {
      return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['parentPath'] refers to the path of the
     * directory that was passed to readdir. For root entries, it's the path
     * to the entry itself.
     */
    get parentPath() {
      return (this.parent || this).fullpath();
    }
    /**
     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
     * this property refers to the *parent* path, not the path object itself.
     */
    get path() {
      return this.parentPath;
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      this.name = name;
      this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
      this.#type = type3 & TYPEMASK;
      this.nocase = nocase;
      this.roots = roots;
      this.root = root || this;
      this.#children = children;
      this.#fullpath = opts.fullpath;
      this.#relative = opts.relative;
      this.#relativePosix = opts.relativePosix;
      this.parent = opts.parent;
      if (this.parent) {
        this.#fs = this.parent.#fs;
      } else {
        this.#fs = fsFromOption(opts.fs);
      }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
      if (this.#depth !== void 0)
        return this.#depth;
      if (!this.parent)
        return this.#depth = 0;
      return this.#depth = this.parent.depth() + 1;
    }
    /**
     * @internal
     */
    childrenCache() {
      return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path6) {
      if (!path6) {
        return this;
      }
      const rootPath = this.getRootString(path6);
      const dir = path6.substring(rootPath.length);
      const dirParts = dir.split(this.splitSep);
      const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
      return result;
    }
    #resolveParts(dirParts) {
      let p = this;
      for (const part of dirParts) {
        p = p.child(part);
      }
      return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
      const cached = this.#children.get(this);
      if (cached) {
        return cached;
      }
      const children = Object.assign([], { provisional: 0 });
      this.#children.set(this, children);
      this.#type &= ~READDIR_CALLED;
      return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
      if (pathPart === "" || pathPart === ".") {
        return this;
      }
      if (pathPart === "..") {
        return this.parent || this;
      }
      const children = this.children();
      const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
      for (const p of children) {
        if (p.#matchName === name) {
          return p;
        }
      }
      const s = this.parent ? this.sep : "";
      const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
      const pchild = this.newChild(pathPart, UNKNOWN, {
        ...opts,
        parent: this,
        fullpath
      });
      if (!this.canReaddir()) {
        pchild.#type |= ENOENT;
      }
      children.push(pchild);
      return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
      if (this.isCWD)
        return "";
      if (this.#relative !== void 0) {
        return this.#relative;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relative = this.name;
      }
      const pv = p.relative();
      return pv + (!pv || !p.parent ? "" : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
      if (this.sep === "/")
        return this.relative();
      if (this.isCWD)
        return "";
      if (this.#relativePosix !== void 0)
        return this.#relativePosix;
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relativePosix = this.fullpathPosix();
      }
      const pv = p.relativePosix();
      return pv + (!pv || !p.parent ? "" : "/") + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
      if (this.#fullpath !== void 0) {
        return this.#fullpath;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#fullpath = this.name;
      }
      const pv = p.fullpath();
      const fp = pv + (!p.parent ? "" : this.sep) + name;
      return this.#fullpath = fp;
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
      if (this.#fullpathPosix !== void 0)
        return this.#fullpathPosix;
      if (this.sep === "/")
        return this.#fullpathPosix = this.fullpath();
      if (!this.parent) {
        const p2 = this.fullpath().replace(/\\/g, "/");
        if (/^[a-z]:\//i.test(p2)) {
          return this.#fullpathPosix = `//?/${p2}`;
        } else {
          return this.#fullpathPosix = p2;
        }
      }
      const p = this.parent;
      const pfpp = p.fullpathPosix();
      const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
      return this.#fullpathPosix = fpp;
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
      return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type3) {
      return this[`is${type3}`]();
    }
    getType() {
      return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
        /* c8 ignore start */
        this.isSocket() ? "Socket" : "Unknown"
      );
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
      return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
      return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
      return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
      return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
      return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
      return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
      return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
      return this.#type & LSTAT_CALLED ? this : void 0;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
      return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
      return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
      const children = this.children();
      return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
      if (this.#linkTarget)
        return true;
      if (!this.parent)
        return false;
      const ifmt = this.#type & IFMT;
      return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
      return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
      return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
      return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return void 0;
      }
      if (!this.parent) {
        return void 0;
      }
      try {
        const read = await this.#fs.promises.readlink(this.fullpath());
        const linkTarget = (await this.parent.realpath())?.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return void 0;
      }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return void 0;
      }
      if (!this.parent) {
        return void 0;
      }
      try {
        const read = this.#fs.readlinkSync(this.fullpath());
        const linkTarget = this.parent.realpathSync()?.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return void 0;
      }
    }
    #readdirSuccess(children) {
      this.#type |= READDIR_CALLED;
      for (let p = children.provisional; p < children.length; p++) {
        const c = children[p];
        if (c)
          c.#markENOENT();
      }
    }
    #markENOENT() {
      if (this.#type & ENOENT)
        return;
      this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
      this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
      const children = this.children();
      children.provisional = 0;
      for (const p of children) {
        p.#markENOENT();
      }
    }
    #markENOREALPATH() {
      this.#type |= ENOREALPATH;
      this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
      if (this.#type & ENOTDIR)
        return;
      let t = this.#type;
      if ((t & IFMT) === IFDIR)
        t &= IFMT_UNKNOWN;
      this.#type = t | ENOTDIR;
      this.#markChildrenENOENT();
    }
    #readdirFail(code = "") {
      if (code === "ENOTDIR" || code === "EPERM") {
        this.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      } else {
        this.children().provisional = 0;
      }
    }
    #lstatFail(code = "") {
      if (code === "ENOTDIR") {
        const p = this.parent;
        p.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      }
    }
    #readlinkFail(code = "") {
      let ter = this.#type;
      ter |= ENOREADLINK;
      if (code === "ENOENT")
        ter |= ENOENT;
      if (code === "EINVAL" || code === "UNKNOWN") {
        ter &= IFMT_UNKNOWN;
      }
      this.#type = ter;
      if (code === "ENOTDIR" && this.parent) {
        this.parent.#markENOTDIR();
      }
    }
    #readdirAddChild(e, c) {
      return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
    }
    #readdirAddNewChild(e, c) {
      const type3 = entToType(e);
      const child = this.newChild(e.name, type3, { parent: this });
      const ifmt = child.#type & IFMT;
      if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
        child.#type |= ENOTDIR;
      }
      c.unshift(child);
      c.provisional++;
      return child;
    }
    #readdirMaybePromoteChild(e, c) {
      for (let p = c.provisional; p < c.length; p++) {
        const pchild = c[p];
        const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
        if (name !== pchild.#matchName) {
          continue;
        }
        return this.#readdirPromoteChild(e, pchild, p, c);
      }
    }
    #readdirPromoteChild(e, p, index, c) {
      const v = p.name;
      p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
      if (v !== e.name)
        p.name = e.name;
      if (index !== c.provisional) {
        if (index === c.length - 1)
          c.pop();
        else
          c.splice(index, 1);
        c.unshift(p);
      }
      c.provisional++;
      return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(this.#fs.lstatSync(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    #applyStat(st) {
      const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev: dev2, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
      this.#atime = atime;
      this.#atimeMs = atimeMs;
      this.#birthtime = birthtime;
      this.#birthtimeMs = birthtimeMs;
      this.#blksize = blksize;
      this.#blocks = blocks;
      this.#ctime = ctime;
      this.#ctimeMs = ctimeMs;
      this.#dev = dev2;
      this.#gid = gid;
      this.#ino = ino;
      this.#mode = mode;
      this.#mtime = mtime;
      this.#mtimeMs = mtimeMs;
      this.#nlink = nlink;
      this.#rdev = rdev;
      this.#size = size;
      this.#uid = uid;
      const ifmt = entToType(st);
      this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
      if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
        this.#type |= ENOTDIR;
      }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
      this.#readdirCBInFlight = false;
      const cbs = this.#onReaddirCB.slice();
      this.#onReaddirCB.length = 0;
      cbs.forEach((cb) => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
      if (!this.canReaddir()) {
        if (allowZalgo)
          cb(null, []);
        else
          queueMicrotask(() => cb(null, []));
        return;
      }
      const children = this.children();
      if (this.calledReaddir()) {
        const c = children.slice(0, children.provisional);
        if (allowZalgo)
          cb(null, c);
        else
          queueMicrotask(() => cb(null, c));
        return;
      }
      this.#onReaddirCB.push(cb);
      if (this.#readdirCBInFlight) {
        return;
      }
      this.#readdirCBInFlight = true;
      const fullpath = this.fullpath();
      this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
        if (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        } else {
          for (const e of entries) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        }
        this.#callOnReaddirCB(children.slice(0, children.provisional));
        return;
      });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      if (this.#asyncReaddirInFlight) {
        await this.#asyncReaddirInFlight;
      } else {
        let resolve10 = () => {
        };
        this.#asyncReaddirInFlight = new Promise((res) => resolve10 = res);
        try {
          for (const e of await this.#fs.promises.readdir(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        this.#asyncReaddirInFlight = void 0;
        resolve10();
      }
      return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      try {
        for (const e of this.#fs.readdirSync(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      return children.slice(0, children.provisional);
    }
    canReaddir() {
      if (this.#type & ENOCHILD)
        return false;
      const ifmt = IFMT & this.#type;
      if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
        return false;
      }
      return true;
    }
    shouldWalk(dirs, walkFilter) {
      return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return void 0;
      try {
        const rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_) {
        this.#markENOREALPATH();
      }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return void 0;
      try {
        const rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_) {
        this.#markENOREALPATH();
      }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
      if (oldCwd === this)
        return;
      oldCwd.isCWD = false;
      this.isCWD = true;
      const changed = /* @__PURE__ */ new Set([]);
      let rp = [];
      let p = this;
      while (p && p.parent) {
        changed.add(p);
        p.#relative = rp.join(this.sep);
        p.#relativePosix = rp.join("/");
        p = p.parent;
        rp.push("..");
      }
      p = oldCwd;
      while (p && p.parent && !changed.has(p)) {
        p.#relative = void 0;
        p.#relativePosix = void 0;
        p = p.parent;
      }
    }
  };
  var PathWin32 = class extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = "\\";
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type3, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type3 = UNKNOWN, opts = {}) {
      return new PathWin32(name, type3, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path6) {
      return import_node_path.win32.parse(path6).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
      rootPath = uncToDrive(rootPath.toUpperCase());
      if (rootPath === this.root.name) {
        return this.root;
      }
      for (const [compare, root] of Object.entries(this.roots)) {
        if (this.sameRoot(rootPath, compare)) {
          return this.roots[rootPath] = root;
        }
      }
      return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
      rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
      return rootPath === compare;
    }
  };
  var PathPosix = class extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = "/";
    /**
     * separator for generating path strings
     */
    sep = "/";
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type3, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path6) {
      return path6.startsWith("/") ? "/" : "";
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
      return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type3 = UNKNOWN, opts = {}) {
      return new PathPosix(name, type3, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
  };
  var PathScurryBase = class {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs5 = defaultFS } = {}) {
      this.#fs = fsFromOption(fs5);
      if (cwd instanceof URL || cwd.startsWith("file://")) {
        cwd = (0, import_node_url.fileURLToPath)(cwd);
      }
      const cwdPath = pathImpl.resolve(cwd);
      this.roots = /* @__PURE__ */ Object.create(null);
      this.rootPath = this.parseRootPath(cwdPath);
      this.#resolveCache = new ResolveCache();
      this.#resolvePosixCache = new ResolveCache();
      this.#children = new ChildrenCache(childrenCacheSize);
      const split3 = cwdPath.substring(this.rootPath.length).split(sep2);
      if (split3.length === 1 && !split3[0]) {
        split3.pop();
      }
      if (nocase === void 0) {
        throw new TypeError("must provide nocase setting to PathScurryBase ctor");
      }
      this.nocase = nocase;
      this.root = this.newRoot(this.#fs);
      this.roots[this.rootPath] = this.root;
      let prev = this.root;
      let len = split3.length - 1;
      const joinSep = pathImpl.sep;
      let abs = this.rootPath;
      let sawFirst = false;
      for (const part of split3) {
        const l = len--;
        prev = prev.child(part, {
          relative: new Array(l).fill("..").join(joinSep),
          relativePosix: new Array(l).fill("..").join("/"),
          fullpath: abs += (sawFirst ? "" : joinSep) + part
        });
        sawFirst = true;
      }
      this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path6 = this.cwd) {
      if (typeof path6 === "string") {
        path6 = this.cwd.resolve(path6);
      }
      return path6.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
      return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
      let r = "";
      for (let i = paths.length - 1; i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolveCache.get(r);
      if (cached !== void 0) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpath();
      this.#resolveCache.set(r, result);
      return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
      let r = "";
      for (let i = paths.length - 1; i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolvePosixCache.get(r);
      if (cached !== void 0) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpathPosix();
      this.#resolvePosixCache.set(r, result);
      return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else {
        const p = await entry.readdir();
        return withFileTypes ? p : p.map((e) => e.name);
      }
    }
    readdirSync(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else if (withFileTypes) {
        return entry.readdirSync();
      } else {
        return entry.readdirSync().map((e) => e.name);
      }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.readlink();
      return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.readlinkSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.realpath();
      return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.realpathSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set();
      const walk = (dir, cb) => {
        dirs.add(dir);
        dir.readdirCB((er, entries) => {
          if (er) {
            return cb(er);
          }
          let len = entries.length;
          if (!len)
            return cb();
          const next = () => {
            if (--len === 0) {
              cb();
            }
          };
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            if (follow && e.isSymbolicLink()) {
              e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
            } else {
              if (e.shouldWalk(dirs, walkFilter)) {
                walk(e, next);
              } else {
                next();
              }
            }
          }
        }, true);
      };
      const start = entry;
      return new Promise((res, rej) => {
        walk(start, (er) => {
          if (er)
            return rej(er);
          res(results);
        });
      });
    }
    walkSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
      return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        options = entry;
        entry = this.cwd;
      }
      return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      if (!filter2 || filter2(entry)) {
        yield withFileTypes ? entry : entry.fullpath();
      }
      const dirs = /* @__PURE__ */ new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            yield withFileTypes ? e : e.fullpath();
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
    }
    stream(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new Minipass({ objectMode: true });
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set();
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const onReaddir = (er, entries, didRealpaths = false) => {
            if (er)
              return results.emit("error", er);
            if (follow && !didRealpaths) {
              const promises2 = [];
              for (const e of entries) {
                if (e.isSymbolicLink()) {
                  promises2.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                }
              }
              if (promises2.length) {
                Promise.all(promises2).then(() => onReaddir(null, entries, true));
                return;
              }
            }
            for (const e of entries) {
              if (e && (!filter2 || filter2(e))) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              const r = e.realpathCached() || e;
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
            if (paused && !results.flowing) {
              results.once("drain", process2);
            } else if (!sync2) {
              process2();
            }
          };
          let sync2 = true;
          dir.readdirCB(onReaddir, true);
          sync2 = false;
        }
      };
      process2();
      return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new Minipass({ objectMode: true });
      const dirs = /* @__PURE__ */ new Set();
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
        }
        if (paused && !results.flowing)
          results.once("drain", process2);
      };
      process2();
      return results;
    }
    chdir(path6 = this.cwd) {
      const oldCwd = this.cwd;
      this.cwd = typeof path6 === "string" ? this.cwd.resolve(path6) : path6;
      this.cwd[setAsCwd](oldCwd);
    }
  };
  var PathScurryWin32 = class extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = "\\";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, import_node_path.win32, "\\", { ...opts, nocase });
      this.nocase = nocase;
      for (let p = this.cwd; p; p = p.parent) {
        p.nocase = this.nocase;
      }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
      return import_node_path.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs5) {
      return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs5 });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
      return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
    }
  };
  var PathScurryPosix = class extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = "/";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = false } = opts;
      super(cwd, import_node_path.posix, "/", { ...opts, nocase });
      this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
      return "/";
    }
    /**
     * @internal
     */
    newRoot(fs5) {
      return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs5 });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
      return p.startsWith("/");
    }
  };
  var PathScurryDarwin = class extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, { ...opts, nocase });
    }
  };
  var Path = process.platform === "win32" ? PathWin32 : PathPosix;
  var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/pattern.js
  var isPatternList = (pl) => pl.length >= 1;
  var isGlobList = (gl) => gl.length >= 1;
  var Pattern = class {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform2) {
      if (!isPatternList(patternList)) {
        throw new TypeError("empty pattern list");
      }
      if (!isGlobList(globList)) {
        throw new TypeError("empty glob list");
      }
      if (globList.length !== patternList.length) {
        throw new TypeError("mismatched pattern list and glob list lengths");
      }
      this.length = patternList.length;
      if (index < 0 || index >= this.length) {
        throw new TypeError("index out of range");
      }
      this.#patternList = patternList;
      this.#globList = globList;
      this.#index = index;
      this.#platform = platform2;
      if (this.#index === 0) {
        if (this.isUNC()) {
          const [p0, p1, p2, p3, ...prest] = this.#patternList;
          const [g0, g1, g2, g3, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = [p0, p1, p2, p3, ""].join("/");
          const g = [g0, g1, g2, g3, ""].join("/");
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        } else if (this.isDrive() || this.isAbsolute()) {
          const [p1, ...prest] = this.#patternList;
          const [g1, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = p1 + "/";
          const g = g1 + "/";
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        }
      }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
      return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
      return typeof this.#patternList[this.#index] === "string";
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
      return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
      return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
      return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
      return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
      if (this.#rest !== void 0)
        return this.#rest;
      if (!this.hasMore())
        return this.#rest = null;
      this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
      this.#rest.#isAbsolute = this.#isAbsolute;
      this.#rest.#isUNC = this.#isUNC;
      this.#rest.#isDrive = this.#isDrive;
      return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
      const pl = this.#patternList;
      return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
      const pl = this.#patternList;
      return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
      const pl = this.#patternList;
      return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
      const p = this.#patternList[0];
      return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
      return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
      if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
        return false;
      this.#followGlobstar = false;
      return true;
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/ignore.js
  var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
  var Ignore = class {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform2 = defaultPlatform2 }) {
      this.relative = [];
      this.absolute = [];
      this.relativeChildren = [];
      this.absoluteChildren = [];
      this.platform = platform2;
      this.mmopts = {
        dot: true,
        nobrace,
        nocase,
        noext,
        noglobstar,
        optimizationLevel: 2,
        platform: platform2,
        nocomment: true,
        nonegate: true
      };
      for (const ign of ignored)
        this.add(ign);
    }
    add(ign) {
      const mm = new Minimatch(ign, this.mmopts);
      for (let i = 0; i < mm.set.length; i++) {
        const parsed = mm.set[i];
        const globParts = mm.globParts[i];
        if (!parsed || !globParts) {
          throw new Error("invalid pattern object");
        }
        while (parsed[0] === "." && globParts[0] === ".") {
          parsed.shift();
          globParts.shift();
        }
        const p = new Pattern(parsed, globParts, 0, this.platform);
        const m = new Minimatch(p.globString(), this.mmopts);
        const children = globParts[globParts.length - 1] === "**";
        const absolute = p.isAbsolute();
        if (absolute)
          this.absolute.push(m);
        else
          this.relative.push(m);
        if (children) {
          if (absolute)
            this.absoluteChildren.push(m);
          else
            this.relativeChildren.push(m);
        }
      }
    }
    ignored(p) {
      const fullpath = p.fullpath();
      const fullpaths = `${fullpath}/`;
      const relative2 = p.relative() || ".";
      const relatives = `${relative2}/`;
      for (const m of this.relative) {
        if (m.match(relative2) || m.match(relatives))
          return true;
      }
      for (const m of this.absolute) {
        if (m.match(fullpath) || m.match(fullpaths))
          return true;
      }
      return false;
    }
    childrenIgnored(p) {
      const fullpath = p.fullpath() + "/";
      const relative2 = (p.relative() || ".") + "/";
      for (const m of this.relativeChildren) {
        if (m.match(relative2))
          return true;
      }
      for (const m of this.absoluteChildren) {
        if (m.match(fullpath))
          return true;
      }
      return false;
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/processor.js
  var HasWalkedCache = class {
    store;
    constructor(store = /* @__PURE__ */ new Map()) {
      this.store = store;
    }
    copy() {
      return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
      return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
      const fullpath = target.fullpath();
      const cached = this.store.get(fullpath);
      if (cached)
        cached.add(pattern.globString());
      else
        this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
    }
  };
  var MatchRecord = class {
    store = /* @__PURE__ */ new Map();
    add(target, absolute, ifDir) {
      const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
      const current = this.store.get(target);
      this.store.set(target, current === void 0 ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
      return [...this.store.entries()].map(([path6, n]) => [
        path6,
        !!(n & 2),
        !!(n & 1)
      ]);
    }
  };
  var SubWalks = class {
    store = /* @__PURE__ */ new Map();
    add(target, pattern) {
      if (!target.canReaddir()) {
        return;
      }
      const subs = this.store.get(target);
      if (subs) {
        if (!subs.find((p) => p.globString() === pattern.globString())) {
          subs.push(pattern);
        }
      } else
        this.store.set(target, [pattern]);
    }
    get(target) {
      const subs = this.store.get(target);
      if (!subs) {
        throw new Error("attempting to walk unknown path");
      }
      return subs;
    }
    entries() {
      return this.keys().map((k) => [k, this.store.get(k)]);
    }
    keys() {
      return [...this.store.keys()].filter((t) => t.canReaddir());
    }
  };
  var Processor = class {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
      this.opts = opts;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
      this.patterns = patterns;
      const processingSet = patterns.map((p) => [target, p]);
      for (let [t, pattern] of processingSet) {
        this.hasWalkedCache.storeWalked(t, pattern);
        const root = pattern.root();
        const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
        if (root) {
          t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
          const rest2 = pattern.rest();
          if (!rest2) {
            this.matches.add(t, true, false);
            continue;
          } else {
            pattern = rest2;
          }
        }
        if (t.isENOENT())
          continue;
        let p;
        let rest;
        let changed = false;
        while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
          const c = t.resolve(p);
          t = c;
          pattern = rest;
          changed = true;
        }
        p = pattern.pattern();
        rest = pattern.rest();
        if (changed) {
          if (this.hasWalkedCache.hasWalked(t, pattern))
            continue;
          this.hasWalkedCache.storeWalked(t, pattern);
        }
        if (typeof p === "string") {
          const ifDir = p === ".." || p === "" || p === ".";
          this.matches.add(t.resolve(p), absolute, ifDir);
          continue;
        } else if (p === GLOBSTAR) {
          if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
            this.subwalks.add(t, pattern);
          }
          const rp = rest?.pattern();
          const rrest = rest?.rest();
          if (!rest || (rp === "" || rp === ".") && !rrest) {
            this.matches.add(t, absolute, rp === "" || rp === ".");
          } else {
            if (rp === "..") {
              const tp = t.parent || t;
              if (!rrest)
                this.matches.add(tp, absolute, true);
              else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                this.subwalks.add(tp, rrest);
              }
            }
          }
        } else if (p instanceof RegExp) {
          this.subwalks.add(t, pattern);
        }
      }
      return this;
    }
    subwalkTargets() {
      return this.subwalks.keys();
    }
    child() {
      return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
      const patterns = this.subwalks.get(parent);
      const results = this.child();
      for (const e of entries) {
        for (const pattern of patterns) {
          const absolute = pattern.isAbsolute();
          const p = pattern.pattern();
          const rest = pattern.rest();
          if (p === GLOBSTAR) {
            results.testGlobstar(e, pattern, rest, absolute);
          } else if (p instanceof RegExp) {
            results.testRegExp(e, p, rest, absolute);
          } else {
            results.testString(e, p, rest, absolute);
          }
        }
      }
      return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
      if (this.dot || !e.name.startsWith(".")) {
        if (!pattern.hasMore()) {
          this.matches.add(e, absolute, false);
        }
        if (e.canReaddir()) {
          if (this.follow || !e.isSymbolicLink()) {
            this.subwalks.add(e, pattern);
          } else if (e.isSymbolicLink()) {
            if (rest && pattern.checkFollowGlobstar()) {
              this.subwalks.add(e, rest);
            } else if (pattern.markFollowGlobstar()) {
              this.subwalks.add(e, pattern);
            }
          }
        }
      }
      if (rest) {
        const rp = rest.pattern();
        if (typeof rp === "string" && // dots and empty were handled already
        rp !== ".." && rp !== "" && rp !== ".") {
          this.testString(e, rp, rest.rest(), absolute);
        } else if (rp === "..") {
          const ep = e.parent || e;
          this.subwalks.add(ep, rest);
        } else if (rp instanceof RegExp) {
          this.testRegExp(e, rp, rest.rest(), absolute);
        }
      }
    }
    testRegExp(e, p, rest, absolute) {
      if (!p.test(e.name))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
    testString(e, p, rest, absolute) {
      if (!e.isNamed(p))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/walker.js
  var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
  var GlobUtil = class {
    path;
    patterns;
    opts;
    seen = /* @__PURE__ */ new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path6, opts) {
      this.patterns = patterns;
      this.path = path6;
      this.opts = opts;
      this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
      this.includeChildMatches = opts.includeChildMatches !== false;
      if (opts.ignore || !this.includeChildMatches) {
        this.#ignore = makeIgnore(opts.ignore ?? [], opts);
        if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
          const m = "cannot ignore child matches, ignore lacks add() method.";
          throw new Error(m);
        }
      }
      this.maxDepth = opts.maxDepth || Infinity;
      if (opts.signal) {
        this.signal = opts.signal;
        this.signal.addEventListener("abort", () => {
          this.#onResume.length = 0;
        });
      }
    }
    #ignored(path6) {
      return this.seen.has(path6) || !!this.#ignore?.ignored?.(path6);
    }
    #childrenIgnored(path6) {
      return !!this.#ignore?.childrenIgnored?.(path6);
    }
    // backpressure mechanism
    pause() {
      this.paused = true;
    }
    resume() {
      if (this.signal?.aborted)
        return;
      this.paused = false;
      let fn = void 0;
      while (!this.paused && (fn = this.#onResume.shift())) {
        fn();
      }
    }
    onResume(fn) {
      if (this.signal?.aborted)
        return;
      if (!this.paused) {
        fn();
      } else {
        this.#onResume.push(fn);
      }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return void 0;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || await e.realpath();
        if (!rpc)
          return void 0;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      const s = needStat ? await e.lstat() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        const target = await s.realpath();
        if (target && (target.isUnknown() || this.opts.stat)) {
          await target.lstat();
        }
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
      return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
    }
    matchCheckSync(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return void 0;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || e.realpathSync();
        if (!rpc)
          return void 0;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      const s = needStat ? e.lstatSync() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        const target = s.realpathSync();
        if (target && (target?.isUnknown() || this.opts.stat)) {
          target.lstatSync();
        }
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
      if (this.#ignored(e))
        return;
      if (!this.includeChildMatches && this.#ignore?.add) {
        const ign = `${e.relativePosix()}/**`;
        this.#ignore.add(ign);
      }
      const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
      this.seen.add(e);
      const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
      if (this.opts.withFileTypes) {
        this.matchEmit(e);
      } else if (abs) {
        const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
        this.matchEmit(abs2 + mark);
      } else {
        const rel = this.opts.posix ? e.relativePosix() : e.relative();
        const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
        this.matchEmit(!rel ? "." + mark : pre + rel + mark);
      }
    }
    async match(e, absolute, ifDir) {
      const p = await this.matchCheck(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
      const p = this.matchCheckSync(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const childrenCached = t.readdirCached();
        if (t.calledReaddir())
          this.walkCB3(t, childrenCached, processor, next);
        else {
          t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
        }
      }
      next();
    }
    walkCB3(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2(target2, patterns, processor.child(), next);
      }
      next();
    }
    walkCBSync(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const children = t.readdirSync();
        this.walkCB3Sync(t, children, processor, next);
      }
      next();
    }
    walkCB3Sync(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2Sync(target2, patterns, processor.child(), next);
      }
      next();
    }
  };
  var GlobWalker = class extends GlobUtil {
    matches = /* @__PURE__ */ new Set();
    constructor(patterns, path6, opts) {
      super(patterns, path6, opts);
    }
    matchEmit(e) {
      this.matches.add(e);
    }
    async walk() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        await this.path.lstat();
      }
      await new Promise((res, rej) => {
        this.walkCB(this.path, this.patterns, () => {
          if (this.signal?.aborted) {
            rej(this.signal.reason);
          } else {
            res(this.matches);
          }
        });
      });
      return this.matches;
    }
    walkSync() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => {
        if (this.signal?.aborted)
          throw this.signal.reason;
      });
      return this.matches;
    }
  };
  var GlobStream = class extends GlobUtil {
    results;
    constructor(patterns, path6, opts) {
      super(patterns, path6, opts);
      this.results = new Minipass({
        signal: this.signal,
        objectMode: true
      });
      this.results.on("drain", () => this.resume());
      this.results.on("resume", () => this.resume());
    }
    matchEmit(e) {
      this.results.write(e);
      if (!this.results.flowing)
        this.pause();
    }
    stream() {
      const target = this.path;
      if (target.isUnknown()) {
        target.lstat().then(() => {
          this.walkCB(target, this.patterns, () => this.results.end());
        });
      } else {
        this.walkCB(target, this.patterns, () => this.results.end());
      }
      return this.results;
    }
    streamSync() {
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => this.results.end());
      return this.results;
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/glob.js
  var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
  var Glob = class {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
      if (!opts)
        throw new TypeError("glob options required");
      this.withFileTypes = !!opts.withFileTypes;
      this.signal = opts.signal;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.dotRelative = !!opts.dotRelative;
      this.nodir = !!opts.nodir;
      this.mark = !!opts.mark;
      if (!opts.cwd) {
        this.cwd = "";
      } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
        opts.cwd = (0, import_node_url2.fileURLToPath)(opts.cwd);
      }
      this.cwd = opts.cwd || "";
      this.root = opts.root;
      this.magicalBraces = !!opts.magicalBraces;
      this.nobrace = !!opts.nobrace;
      this.noext = !!opts.noext;
      this.realpath = !!opts.realpath;
      this.absolute = opts.absolute;
      this.includeChildMatches = opts.includeChildMatches !== false;
      this.noglobstar = !!opts.noglobstar;
      this.matchBase = !!opts.matchBase;
      this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
      this.stat = !!opts.stat;
      this.ignore = opts.ignore;
      if (this.withFileTypes && this.absolute !== void 0) {
        throw new Error("cannot set absolute and withFileTypes:true");
      }
      if (typeof pattern === "string") {
        pattern = [pattern];
      }
      this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        pattern = pattern.map((p) => p.replace(/\\/g, "/"));
      }
      if (this.matchBase) {
        if (opts.noglobstar) {
          throw new TypeError("base matching requires globstar");
        }
        pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
      }
      this.pattern = pattern;
      this.platform = opts.platform || defaultPlatform3;
      this.opts = { ...opts, platform: this.platform };
      if (opts.scurry) {
        this.scurry = opts.scurry;
        if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
          throw new Error("nocase option contradicts provided scurry option");
        }
      } else {
        const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
        this.scurry = new Scurry(this.cwd, {
          nocase: opts.nocase,
          fs: opts.fs
        });
      }
      this.nocase = this.scurry.nocase;
      const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
      const mmo = {
        // default nocase based on platform
        ...opts,
        dot: this.dot,
        matchBase: this.matchBase,
        nobrace: this.nobrace,
        nocase: this.nocase,
        nocaseMagicOnly,
        nocomment: true,
        noext: this.noext,
        nonegate: true,
        optimizationLevel: 2,
        platform: this.platform,
        windowsPathsNoEscape: this.windowsPathsNoEscape,
        debug: !!this.opts.debug
      };
      const mms = this.pattern.map((p) => new Minimatch(p, mmo));
      const [matchSet, globParts] = mms.reduce((set, m) => {
        set[0].push(...m.set);
        set[1].push(...m.globParts);
        return set;
      }, [[], []]);
      this.patterns = matchSet.map((set, i) => {
        const g = globParts[i];
        if (!g)
          throw new Error("invalid pattern object");
        return new Pattern(set, g, 0, this.platform);
      });
    }
    async walk() {
      return [
        ...await new GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walk()
      ];
    }
    walkSync() {
      return [
        ...new GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walkSync()
      ];
    }
    stream() {
      return new GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).stream();
    }
    streamSync() {
      return new GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
      return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
      return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/has-magic.js
  var hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
      pattern = [pattern];
    }
    for (const p of pattern) {
      if (new Minimatch(p, options).hasMagic())
        return true;
    }
    return false;
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/index.js
  function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
  }
  function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
  }
  function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
  }
  async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
  }
  function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
  }
  function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
  }
  var streamSync = globStreamSync;
  var stream = Object.assign(globStream, { sync: globStreamSync });
  var iterateSync = globIterateSync;
  var iterate = Object.assign(globIterate, {
    sync: globIterateSync
  });
  var sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync
  });
  var glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob,
    hasMagic,
    escape,
    unescape
  });
  glob.glob = glob;

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/mkdirp-manual.js
  var import_path = __require2("path");

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/opts-arg.js
  var import_fs2 = __require2("fs");
  var optsArg = (opts) => {
    if (!opts) {
      opts = { mode: 511 };
    } else if (typeof opts === "object") {
      opts = { mode: 511, ...opts };
    } else if (typeof opts === "number") {
      opts = { mode: opts };
    } else if (typeof opts === "string") {
      opts = { mode: parseInt(opts, 8) };
    } else {
      throw new TypeError("invalid options argument");
    }
    const resolved = opts;
    const optsFs = opts.fs || {};
    opts.mkdir = opts.mkdir || optsFs.mkdir || import_fs2.mkdir;
    opts.mkdirAsync = opts.mkdirAsync ? opts.mkdirAsync : async (path6, options) => {
      return new Promise((res, rej) => resolved.mkdir(path6, options, (er, made) => er ? rej(er) : res(made)));
    };
    opts.stat = opts.stat || optsFs.stat || import_fs2.stat;
    opts.statAsync = opts.statAsync ? opts.statAsync : async (path6) => new Promise((res, rej) => resolved.stat(path6, (err2, stats) => err2 ? rej(err2) : res(stats)));
    opts.statSync = opts.statSync || optsFs.statSync || import_fs2.statSync;
    opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || import_fs2.mkdirSync;
    return resolved;
  };

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/mkdirp-manual.js
  var mkdirpManualSync = (path6, options, made) => {
    const parent = (0, import_path.dirname)(path6);
    const opts = { ...optsArg(options), recursive: false };
    if (parent === path6) {
      try {
        return opts.mkdirSync(path6, opts);
      } catch (er) {
        const fer = er;
        if (fer && fer.code !== "EISDIR") {
          throw er;
        }
        return;
      }
    }
    try {
      opts.mkdirSync(path6, opts);
      return made || path6;
    } catch (er) {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManualSync(path6, opts, mkdirpManualSync(parent, opts, made));
      }
      if (fer && fer.code !== "EEXIST" && fer && fer.code !== "EROFS") {
        throw er;
      }
      try {
        if (!opts.statSync(path6).isDirectory())
          throw er;
      } catch (_) {
        throw er;
      }
    }
  };
  var mkdirpManual = Object.assign(async (path6, options, made) => {
    const opts = optsArg(options);
    opts.recursive = false;
    const parent = (0, import_path.dirname)(path6);
    if (parent === path6) {
      return opts.mkdirAsync(path6, opts).catch((er) => {
        const fer = er;
        if (fer && fer.code !== "EISDIR") {
          throw er;
        }
      });
    }
    return opts.mkdirAsync(path6, opts).then(() => made || path6, async (er) => {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path6, opts, made2));
      }
      if (fer && fer.code !== "EEXIST" && fer.code !== "EROFS") {
        throw er;
      }
      return opts.statAsync(path6).then((st) => {
        if (st.isDirectory()) {
          return made;
        } else {
          throw er;
        }
      }, () => {
        throw er;
      });
    });
  }, { sync: mkdirpManualSync });

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/mkdirp-native.js
  var import_path3 = __require2("path");

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/find-made.js
  var import_path2 = __require2("path");
  var findMade = async (opts, parent, path6) => {
    if (path6 === parent) {
      return;
    }
    return opts.statAsync(parent).then(
      (st) => st.isDirectory() ? path6 : void 0,
      // will fail later
      // will fail later
      (er) => {
        const fer = er;
        return fer && fer.code === "ENOENT" ? findMade(opts, (0, import_path2.dirname)(parent), parent) : void 0;
      }
    );
  };
  var findMadeSync = (opts, parent, path6) => {
    if (path6 === parent) {
      return void 0;
    }
    try {
      return opts.statSync(parent).isDirectory() ? path6 : void 0;
    } catch (er) {
      const fer = er;
      return fer && fer.code === "ENOENT" ? findMadeSync(opts, (0, import_path2.dirname)(parent), parent) : void 0;
    }
  };

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/mkdirp-native.js
  var mkdirpNativeSync = (path6, options) => {
    const opts = optsArg(options);
    opts.recursive = true;
    const parent = (0, import_path3.dirname)(path6);
    if (parent === path6) {
      return opts.mkdirSync(path6, opts);
    }
    const made = findMadeSync(opts, path6);
    try {
      opts.mkdirSync(path6, opts);
      return made;
    } catch (er) {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManualSync(path6, opts);
      } else {
        throw er;
      }
    }
  };
  var mkdirpNative = Object.assign(async (path6, options) => {
    const opts = { ...optsArg(options), recursive: true };
    const parent = (0, import_path3.dirname)(path6);
    if (parent === path6) {
      return await opts.mkdirAsync(path6, opts);
    }
    return findMade(opts, path6).then((made) => opts.mkdirAsync(path6, opts).then((m) => made || m).catch((er) => {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManual(path6, opts);
      } else {
        throw er;
      }
    }));
  }, { sync: mkdirpNativeSync });

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/path-arg.js
  var import_path4 = __require2("path");
  var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var pathArg = (path6) => {
    if (/\0/.test(path6)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path: path6,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path6 = (0, import_path4.resolve)(path6);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const { root } = (0, import_path4.parse)(path6);
      if (badWinChars.test(path6.substring(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path6,
          code: "EINVAL"
        });
      }
    }
    return path6;
  };

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/use-native.js
  var import_fs3 = __require2("fs");
  var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  var useNativeSync = !hasNative ? () => false : (opts) => optsArg(opts).mkdirSync === import_fs3.mkdirSync;
  var useNative = Object.assign(!hasNative ? () => false : (opts) => optsArg(opts).mkdir === import_fs3.mkdir, {
    sync: useNativeSync
  });

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/index.js
  var mkdirpSync = (path6, opts) => {
    path6 = pathArg(path6);
    const resolved = optsArg(opts);
    return useNativeSync(resolved) ? mkdirpNativeSync(path6, resolved) : mkdirpManualSync(path6, resolved);
  };
  var mkdirp = Object.assign(async (path6, opts) => {
    path6 = pathArg(path6);
    const resolved = optsArg(opts);
    return useNative(resolved) ? mkdirpNative(path6, resolved) : mkdirpManual(path6, resolved);
  }, {
    mkdirpSync,
    mkdirpNative,
    mkdirpNativeSync,
    mkdirpManual,
    mkdirpManualSync,
    sync: mkdirpSync,
    native: mkdirpNative,
    nativeSync: mkdirpNativeSync,
    manual: mkdirpManual,
    manualSync: mkdirpManualSync,
    useNative,
    useNativeSync
  });

  // ../abi-typegen/dist/cli.mjs
  var import_path10 = __require2("path");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/opt-arg.js
  var typeOrUndef = (val, t) => typeof val === "undefined" || typeof val === t;
  var isRimrafOptions = (o) => !!o && typeof o === "object" && typeOrUndef(o.preserveRoot, "boolean") && typeOrUndef(o.tmp, "string") && typeOrUndef(o.maxRetries, "number") && typeOrUndef(o.retryDelay, "number") && typeOrUndef(o.backoff, "number") && typeOrUndef(o.maxBackoff, "number") && (typeOrUndef(o.glob, "boolean") || o.glob && typeof o.glob === "object") && typeOrUndef(o.filter, "function");
  var assertRimrafOptions = (o) => {
    if (!isRimrafOptions(o)) {
      throw new Error("invalid rimraf options");
    }
  };
  var optArgT = (opt) => {
    assertRimrafOptions(opt);
    const { glob: glob2, ...options } = opt;
    if (!glob2) {
      return options;
    }
    const globOpt = glob2 === true ? opt.signal ? { signal: opt.signal } : {} : opt.signal ? {
      signal: opt.signal,
      ...glob2
    } : glob2;
    return {
      ...options,
      glob: {
        ...globOpt,
        // always get absolute paths from glob, to ensure
        // that we are referencing the correct thing.
        absolute: true,
        withFileTypes: false
      }
    };
  };
  var optArg = (opt = {}) => optArgT(opt);
  var optArgSync = (opt = {}) => optArgT(opt);

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/path-arg.js
  var import_path5 = __require2("path");
  var import_util = __require2("util");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/platform.js
  var platform_default = process.env.__TESTING_RIMRAF_PLATFORM__ || process.platform;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/path-arg.js
  var pathArg2 = (path6, opt = {}) => {
    const type3 = typeof path6;
    if (type3 !== "string") {
      const ctor = path6 && type3 === "object" && path6.constructor;
      const received = ctor && ctor.name ? `an instance of ${ctor.name}` : type3 === "object" ? (0, import_util.inspect)(path6) : `type ${type3} ${path6}`;
      const msg = `The "path" argument must be of type string. Received ${received}`;
      throw Object.assign(new TypeError(msg), {
        path: path6,
        code: "ERR_INVALID_ARG_TYPE"
      });
    }
    if (/\0/.test(path6)) {
      const msg = "path must be a string without null bytes";
      throw Object.assign(new TypeError(msg), {
        path: path6,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path6 = (0, import_path5.resolve)(path6);
    const { root } = (0, import_path5.parse)(path6);
    if (path6 === root && opt.preserveRoot !== false) {
      const msg = "refusing to remove root directory without preserveRoot:false";
      throw Object.assign(new Error(msg), {
        path: path6,
        code: "ERR_PRESERVE_ROOT"
      });
    }
    if (platform_default === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const { root: root2 } = (0, import_path5.parse)(path6);
      if (badWinChars.test(path6.substring(root2.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path6,
          code: "EINVAL"
        });
      }
    }
    return path6;
  };
  var path_arg_default = pathArg2;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/fs.js
  var import_fs4 = __toESM(__require2("fs"), 1);
  var import_fs5 = __require2("fs");
  var import_fs6 = __require2("fs");
  var readdirSync2 = (path6) => (0, import_fs6.readdirSync)(path6, { withFileTypes: true });
  var chmod = (path6, mode) => new Promise((res, rej) => import_fs4.default.chmod(path6, mode, (er, ...d) => er ? rej(er) : res(...d)));
  var mkdir3 = (path6, options) => new Promise((res, rej) => import_fs4.default.mkdir(path6, options, (er, made) => er ? rej(er) : res(made)));
  var readdir2 = (path6) => new Promise((res, rej) => import_fs4.default.readdir(path6, { withFileTypes: true }, (er, data) => er ? rej(er) : res(data)));
  var rename = (oldPath, newPath) => new Promise((res, rej) => import_fs4.default.rename(oldPath, newPath, (er, ...d) => er ? rej(er) : res(...d)));
  var rm = (path6, options) => new Promise((res, rej) => import_fs4.default.rm(path6, options, (er, ...d) => er ? rej(er) : res(...d)));
  var rmdir = (path6) => new Promise((res, rej) => import_fs4.default.rmdir(path6, (er, ...d) => er ? rej(er) : res(...d)));
  var stat2 = (path6) => new Promise((res, rej) => import_fs4.default.stat(path6, (er, data) => er ? rej(er) : res(data)));
  var lstat2 = (path6) => new Promise((res, rej) => import_fs4.default.lstat(path6, (er, data) => er ? rej(er) : res(data)));
  var unlink = (path6) => new Promise((res, rej) => import_fs4.default.unlink(path6, (er, ...d) => er ? rej(er) : res(...d)));
  var promises = {
    chmod,
    mkdir: mkdir3,
    readdir: readdir2,
    rename,
    rm,
    rmdir,
    stat: stat2,
    lstat: lstat2,
    unlink
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-posix.js
  var import_path6 = __require2("path");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/readdir-or-error.js
  var { readdir: readdir3 } = promises;
  var readdirOrError = (path6) => readdir3(path6).catch((er) => er);
  var readdirOrErrorSync = (path6) => {
    try {
      return readdirSync2(path6);
    } catch (er) {
      return er;
    }
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/ignore-enoent.js
  var ignoreENOENT = async (p) => p.catch((er) => {
    if (er.code !== "ENOENT") {
      throw er;
    }
  });
  var ignoreENOENTSync = (fn) => {
    try {
      return fn();
    } catch (er) {
      if (er?.code !== "ENOENT") {
        throw er;
      }
    }
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-posix.js
  var { lstat: lstat3, rmdir: rmdir2, unlink: unlink2 } = promises;
  var rimrafPosix = async (path6, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return await rimrafPosixDir(path6, opt, await lstat3(path6));
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafPosixSync = (path6, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return rimrafPosixDirSync(path6, opt, (0, import_fs5.lstatSync)(path6));
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafPosixDir = async (path6, opt, ent) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const entries = ent.isDirectory() ? await readdirOrError(path6) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !await opt.filter(path6, ent)) {
        return false;
      }
      await ignoreENOENT(unlink2(path6));
      return true;
    }
    const removedAll = (await Promise.all(entries.map((ent2) => rimrafPosixDir((0, import_path6.resolve)(path6, ent2.name), opt, ent2)))).reduce((a, b) => a && b, true);
    if (!removedAll) {
      return false;
    }
    if (opt.preserveRoot === false && path6 === (0, import_path6.parse)(path6).root) {
      return false;
    }
    if (opt.filter && !await opt.filter(path6, ent)) {
      return false;
    }
    await ignoreENOENT(rmdir2(path6));
    return true;
  };
  var rimrafPosixDirSync = (path6, opt, ent) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !opt.filter(path6, ent)) {
        return false;
      }
      ignoreENOENTSync(() => (0, import_fs5.unlinkSync)(path6));
      return true;
    }
    let removedAll = true;
    for (const ent2 of entries) {
      const p = (0, import_path6.resolve)(path6, ent2.name);
      removedAll = rimrafPosixDirSync(p, opt, ent2) && removedAll;
    }
    if (opt.preserveRoot === false && path6 === (0, import_path6.parse)(path6).root) {
      return false;
    }
    if (!removedAll) {
      return false;
    }
    if (opt.filter && !opt.filter(path6, ent)) {
      return false;
    }
    ignoreENOENTSync(() => (0, import_fs5.rmdirSync)(path6));
    return true;
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-windows.js
  var import_path9 = __require2("path");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/fix-eperm.js
  var { chmod: chmod2 } = promises;
  var fixEPERM = (fn) => async (path6) => {
    try {
      return await fn(path6);
    } catch (er) {
      const fer = er;
      if (fer?.code === "ENOENT") {
        return;
      }
      if (fer?.code === "EPERM") {
        try {
          await chmod2(path6, 438);
        } catch (er2) {
          const fer2 = er2;
          if (fer2?.code === "ENOENT") {
            return;
          }
          throw er;
        }
        return await fn(path6);
      }
      throw er;
    }
  };
  var fixEPERMSync = (fn) => (path6) => {
    try {
      return fn(path6);
    } catch (er) {
      const fer = er;
      if (fer?.code === "ENOENT") {
        return;
      }
      if (fer?.code === "EPERM") {
        try {
          (0, import_fs5.chmodSync)(path6, 438);
        } catch (er2) {
          const fer2 = er2;
          if (fer2?.code === "ENOENT") {
            return;
          }
          throw er;
        }
        return fn(path6);
      }
      throw er;
    }
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/retry-busy.js
  var MAXBACKOFF = 200;
  var RATE = 1.2;
  var MAXRETRIES = 10;
  var codes = /* @__PURE__ */ new Set(["EMFILE", "ENFILE", "EBUSY"]);
  var retryBusy = (fn) => {
    const method = async (path6, opt, backoff = 1, total = 0) => {
      const mbo = opt.maxBackoff || MAXBACKOFF;
      const rate = opt.backoff || RATE;
      const max2 = opt.maxRetries || MAXRETRIES;
      let retries = 0;
      while (true) {
        try {
          return await fn(path6);
        } catch (er) {
          const fer = er;
          if (fer?.path === path6 && fer?.code && codes.has(fer.code)) {
            backoff = Math.ceil(backoff * rate);
            total = backoff + total;
            if (total < mbo) {
              return new Promise((res, rej) => {
                setTimeout(() => {
                  method(path6, opt, backoff, total).then(res, rej);
                }, backoff);
              });
            }
            if (retries < max2) {
              retries++;
              continue;
            }
          }
          throw er;
        }
      }
    };
    return method;
  };
  var retryBusySync = (fn) => {
    const method = (path6, opt) => {
      const max2 = opt.maxRetries || MAXRETRIES;
      let retries = 0;
      while (true) {
        try {
          return fn(path6);
        } catch (er) {
          const fer = er;
          if (fer?.path === path6 && fer?.code && codes.has(fer.code) && retries < max2) {
            retries++;
            continue;
          }
          throw er;
        }
      }
    };
    return method;
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-move-remove.js
  var import_path8 = __require2("path");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/default-tmp.js
  var import_os = __require2("os");
  var import_path7 = __require2("path");
  var { stat: stat3 } = promises;
  var isDirSync = (path6) => {
    try {
      return (0, import_fs5.statSync)(path6).isDirectory();
    } catch (er) {
      return false;
    }
  };
  var isDir = (path6) => stat3(path6).then((st) => st.isDirectory(), () => false);
  var win32DefaultTmp = async (path6) => {
    const { root } = (0, import_path7.parse)(path6);
    const tmp = (0, import_os.tmpdir)();
    const { root: tmpRoot } = (0, import_path7.parse)(tmp);
    if (root.toLowerCase() === tmpRoot.toLowerCase()) {
      return tmp;
    }
    const driveTmp = (0, import_path7.resolve)(root, "/temp");
    if (await isDir(driveTmp)) {
      return driveTmp;
    }
    return root;
  };
  var win32DefaultTmpSync = (path6) => {
    const { root } = (0, import_path7.parse)(path6);
    const tmp = (0, import_os.tmpdir)();
    const { root: tmpRoot } = (0, import_path7.parse)(tmp);
    if (root.toLowerCase() === tmpRoot.toLowerCase()) {
      return tmp;
    }
    const driveTmp = (0, import_path7.resolve)(root, "/temp");
    if (isDirSync(driveTmp)) {
      return driveTmp;
    }
    return root;
  };
  var posixDefaultTmp = async () => (0, import_os.tmpdir)();
  var posixDefaultTmpSync = () => (0, import_os.tmpdir)();
  var defaultTmp = platform_default === "win32" ? win32DefaultTmp : posixDefaultTmp;
  var defaultTmpSync = platform_default === "win32" ? win32DefaultTmpSync : posixDefaultTmpSync;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-move-remove.js
  var { lstat: lstat4, rename: rename2, unlink: unlink3, rmdir: rmdir3, chmod: chmod3 } = promises;
  var uniqueFilename = (path6) => `.${(0, import_path8.basename)(path6)}.${Math.random()}`;
  var unlinkFixEPERM = async (path6) => unlink3(path6).catch((er) => {
    if (er.code === "EPERM") {
      return chmod3(path6, 438).then(() => unlink3(path6), (er2) => {
        if (er2.code === "ENOENT") {
          return;
        }
        throw er;
      });
    } else if (er.code === "ENOENT") {
      return;
    }
    throw er;
  });
  var unlinkFixEPERMSync = (path6) => {
    try {
      (0, import_fs5.unlinkSync)(path6);
    } catch (er) {
      if (er?.code === "EPERM") {
        try {
          return (0, import_fs5.chmodSync)(path6, 438);
        } catch (er2) {
          if (er2?.code === "ENOENT") {
            return;
          }
          throw er;
        }
      } else if (er?.code === "ENOENT") {
        return;
      }
      throw er;
    }
  };
  var rimrafMoveRemove = async (path6, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return await rimrafMoveRemoveDir(path6, opt, await lstat4(path6));
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafMoveRemoveDir = async (path6, opt, ent) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    if (!opt.tmp) {
      return rimrafMoveRemoveDir(path6, { ...opt, tmp: await defaultTmp(path6) }, ent);
    }
    if (path6 === opt.tmp && (0, import_path8.parse)(path6).root !== path6) {
      throw new Error("cannot delete temp directory used for deletion");
    }
    const entries = ent.isDirectory() ? await readdirOrError(path6) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !await opt.filter(path6, ent)) {
        return false;
      }
      await ignoreENOENT(tmpUnlink(path6, opt.tmp, unlinkFixEPERM));
      return true;
    }
    const removedAll = (await Promise.all(entries.map((ent2) => rimrafMoveRemoveDir((0, import_path8.resolve)(path6, ent2.name), opt, ent2)))).reduce((a, b) => a && b, true);
    if (!removedAll) {
      return false;
    }
    if (opt.preserveRoot === false && path6 === (0, import_path8.parse)(path6).root) {
      return false;
    }
    if (opt.filter && !await opt.filter(path6, ent)) {
      return false;
    }
    await ignoreENOENT(tmpUnlink(path6, opt.tmp, rmdir3));
    return true;
  };
  var tmpUnlink = async (path6, tmp, rm3) => {
    const tmpFile = (0, import_path8.resolve)(tmp, uniqueFilename(path6));
    await rename2(path6, tmpFile);
    return await rm3(tmpFile);
  };
  var rimrafMoveRemoveSync = (path6, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return rimrafMoveRemoveDirSync(path6, opt, (0, import_fs5.lstatSync)(path6));
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafMoveRemoveDirSync = (path6, opt, ent) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    if (!opt.tmp) {
      return rimrafMoveRemoveDirSync(path6, { ...opt, tmp: defaultTmpSync(path6) }, ent);
    }
    const tmp = opt.tmp;
    if (path6 === opt.tmp && (0, import_path8.parse)(path6).root !== path6) {
      throw new Error("cannot delete temp directory used for deletion");
    }
    const entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !opt.filter(path6, ent)) {
        return false;
      }
      ignoreENOENTSync(() => tmpUnlinkSync(path6, tmp, unlinkFixEPERMSync));
      return true;
    }
    let removedAll = true;
    for (const ent2 of entries) {
      const p = (0, import_path8.resolve)(path6, ent2.name);
      removedAll = rimrafMoveRemoveDirSync(p, opt, ent2) && removedAll;
    }
    if (!removedAll) {
      return false;
    }
    if (opt.preserveRoot === false && path6 === (0, import_path8.parse)(path6).root) {
      return false;
    }
    if (opt.filter && !opt.filter(path6, ent)) {
      return false;
    }
    ignoreENOENTSync(() => tmpUnlinkSync(path6, tmp, import_fs5.rmdirSync));
    return true;
  };
  var tmpUnlinkSync = (path6, tmp, rmSync3) => {
    const tmpFile = (0, import_path8.resolve)(tmp, uniqueFilename(path6));
    (0, import_fs5.renameSync)(path6, tmpFile);
    return rmSync3(tmpFile);
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-windows.js
  var { unlink: unlink4, rmdir: rmdir4, lstat: lstat5 } = promises;
  var rimrafWindowsFile = retryBusy(fixEPERM(unlink4));
  var rimrafWindowsFileSync = retryBusySync(fixEPERMSync(import_fs5.unlinkSync));
  var rimrafWindowsDirRetry = retryBusy(fixEPERM(rmdir4));
  var rimrafWindowsDirRetrySync = retryBusySync(fixEPERMSync(import_fs5.rmdirSync));
  var rimrafWindowsDirMoveRemoveFallback = async (path6, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const { filter: filter2, ...options } = opt;
    try {
      return await rimrafWindowsDirRetry(path6, options);
    } catch (er) {
      if (er?.code === "ENOTEMPTY") {
        return await rimrafMoveRemove(path6, options);
      }
      throw er;
    }
  };
  var rimrafWindowsDirMoveRemoveFallbackSync = (path6, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const { filter: filter2, ...options } = opt;
    try {
      return rimrafWindowsDirRetrySync(path6, options);
    } catch (er) {
      const fer = er;
      if (fer?.code === "ENOTEMPTY") {
        return rimrafMoveRemoveSync(path6, options);
      }
      throw er;
    }
  };
  var START = Symbol("start");
  var CHILD = Symbol("child");
  var FINISH = Symbol("finish");
  var rimrafWindows = async (path6, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return await rimrafWindowsDir(path6, opt, await lstat5(path6), START);
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafWindowsSync = (path6, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return rimrafWindowsDirSync(path6, opt, (0, import_fs5.lstatSync)(path6), START);
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafWindowsDir = async (path6, opt, ent, state = START) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const entries = ent.isDirectory() ? await readdirOrError(path6) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !await opt.filter(path6, ent)) {
        return false;
      }
      await ignoreENOENT(rimrafWindowsFile(path6, opt));
      return true;
    }
    const s = state === START ? CHILD : state;
    const removedAll = (await Promise.all(entries.map((ent2) => rimrafWindowsDir((0, import_path9.resolve)(path6, ent2.name), opt, ent2, s)))).reduce((a, b) => a && b, true);
    if (state === START) {
      return rimrafWindowsDir(path6, opt, ent, FINISH);
    } else if (state === FINISH) {
      if (opt.preserveRoot === false && path6 === (0, import_path9.parse)(path6).root) {
        return false;
      }
      if (!removedAll) {
        return false;
      }
      if (opt.filter && !await opt.filter(path6, ent)) {
        return false;
      }
      await ignoreENOENT(rimrafWindowsDirMoveRemoveFallback(path6, opt));
    }
    return true;
  };
  var rimrafWindowsDirSync = (path6, opt, ent, state = START) => {
    const entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !opt.filter(path6, ent)) {
        return false;
      }
      ignoreENOENTSync(() => rimrafWindowsFileSync(path6, opt));
      return true;
    }
    let removedAll = true;
    for (const ent2 of entries) {
      const s = state === START ? CHILD : state;
      const p = (0, import_path9.resolve)(path6, ent2.name);
      removedAll = rimrafWindowsDirSync(p, opt, ent2, s) && removedAll;
    }
    if (state === START) {
      return rimrafWindowsDirSync(path6, opt, ent, FINISH);
    } else if (state === FINISH) {
      if (opt.preserveRoot === false && path6 === (0, import_path9.parse)(path6).root) {
        return false;
      }
      if (!removedAll) {
        return false;
      }
      if (opt.filter && !opt.filter(path6, ent)) {
        return false;
      }
      ignoreENOENTSync(() => {
        rimrafWindowsDirMoveRemoveFallbackSync(path6, opt);
      });
    }
    return true;
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-manual.js
  var rimrafManual = platform_default === "win32" ? rimrafWindows : rimrafPosix;
  var rimrafManualSync = platform_default === "win32" ? rimrafWindowsSync : rimrafPosixSync;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-native.js
  var { rm: rm2 } = promises;
  var rimrafNative = async (path6, opt) => {
    await rm2(path6, {
      ...opt,
      force: true,
      recursive: true
    });
    return true;
  };
  var rimrafNativeSync = (path6, opt) => {
    (0, import_fs5.rmSync)(path6, {
      ...opt,
      force: true,
      recursive: true
    });
    return true;
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/use-native.js
  var version2 = process.env.__TESTING_RIMRAF_NODE_VERSION__ || process.version;
  var versArr2 = version2.replace(/^v/, "").split(".");
  var [major = 0, minor = 0] = versArr2.map((v) => parseInt(v, 10));
  var hasNative2 = major > 14 || major === 14 && minor >= 14;
  var useNative2 = !hasNative2 || platform_default === "win32" ? () => false : (opt) => !opt?.signal && !opt?.filter;
  var useNativeSync2 = !hasNative2 || platform_default === "win32" ? () => false : (opt) => !opt?.signal && !opt?.filter;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/index.js
  var wrap = (fn) => async (path6, opt) => {
    const options = optArg(opt);
    if (options.glob) {
      path6 = await glob(path6, options.glob);
    }
    if (Array.isArray(path6)) {
      return !!(await Promise.all(path6.map((p) => fn(path_arg_default(p, options), options)))).reduce((a, b) => a && b, true);
    } else {
      return !!await fn(path_arg_default(path6, options), options);
    }
  };
  var wrapSync = (fn) => (path6, opt) => {
    const options = optArgSync(opt);
    if (options.glob) {
      path6 = globSync(path6, options.glob);
    }
    if (Array.isArray(path6)) {
      return !!path6.map((p) => fn(path_arg_default(p, options), options)).reduce((a, b) => a && b, true);
    } else {
      return !!fn(path_arg_default(path6, options), options);
    }
  };
  var nativeSync = wrapSync(rimrafNativeSync);
  var native = Object.assign(wrap(rimrafNative), { sync: nativeSync });
  var manualSync = wrapSync(rimrafManualSync);
  var manual = Object.assign(wrap(rimrafManual), { sync: manualSync });
  var windowsSync = wrapSync(rimrafWindowsSync);
  var windows = Object.assign(wrap(rimrafWindows), { sync: windowsSync });
  var posixSync = wrapSync(rimrafPosixSync);
  var posix2 = Object.assign(wrap(rimrafPosix), { sync: posixSync });
  var moveRemoveSync = wrapSync(rimrafMoveRemoveSync);
  var moveRemove = Object.assign(wrap(rimrafMoveRemove), {
    sync: moveRemoveSync
  });
  var rimrafSync = wrapSync((path6, opt) => useNativeSync2(opt) ? rimrafNativeSync(path6, opt) : rimrafManualSync(path6, opt));
  var rimraf_ = wrap((path6, opt) => useNative2(opt) ? rimrafNative(path6, opt) : rimrafManual(path6, opt));
  var rimraf = Object.assign(rimraf_, {
    rimraf: rimraf_,
    sync: rimrafSync,
    rimrafSync,
    manual,
    manualSync,
    native,
    nativeSync,
    posix: posix2,
    posixSync,
    windows,
    windowsSync,
    moveRemove,
    moveRemoveSync
  });
  rimraf.rimraf = rimraf;

  // ../math/dist/index.mjs
  var import_bn = __toESM(require_bn(), 1);
  var DEFAULT_PRECISION = 9;
  var DEFAULT_MIN_PRECISION = 3;
  var DEFAULT_DECIMAL_UNITS = 9;
  var BN = class extends import_bn.default {
    MAX_U64 = "0xFFFFFFFFFFFFFFFF";
    constructor(value, base2, endian) {
      let bnValue = value;
      let bnBase = base2;
      if (BN.isBN(value)) {
        bnValue = value.toArray();
      } else if (typeof value === "string" && value.slice(0, 2) === "0x") {
        bnValue = value.substring(2);
        bnBase = base2 || "hex";
      }
      super(bnValue == null ? 0 : bnValue, bnBase, endian);
    }
    // ANCHOR: HELPERS
    // make sure we always include `0x` in hex strings
    toString(base2, length) {
      const output2 = super.toString(base2, length);
      if (base2 === 16 || base2 === "hex") {
        return `0x${output2}`;
      }
      return output2;
    }
    toHex(bytesPadding) {
      const bytes2 = bytesPadding || 0;
      const bytesLength = bytes2 * 2;
      if (this.isNeg()) {
        throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to hex.");
      }
      if (bytesPadding && this.byteLength() > bytesPadding) {
        throw new FuelError(
          ErrorCode.CONVERTING_FAILED,
          `Provided value ${this} is too large. It should fit within ${bytesPadding} bytes.`
        );
      }
      return this.toString(16, bytesLength);
    }
    toBytes(bytesPadding) {
      if (this.isNeg()) {
        throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to bytes.");
      }
      return Uint8Array.from(this.toArray(void 0, bytesPadding));
    }
    toJSON() {
      return this.toString(16);
    }
    valueOf() {
      return this.toString();
    }
    format(options) {
      const {
        units = DEFAULT_DECIMAL_UNITS,
        precision: initialPrecision = DEFAULT_PRECISION,
        minPrecision: initialMinPrecision = DEFAULT_MIN_PRECISION
      } = options || {};
      if (units === 0) {
        return this.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      const minPrecision = initialMinPrecision > initialPrecision ? initialPrecision : initialMinPrecision;
      const precision = initialPrecision > initialMinPrecision ? initialPrecision : initialMinPrecision;
      const formattedUnits = this.formatUnits(units);
      const [integerPart, fractionalPart = ""] = formattedUnits.split(".");
      const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      if (precision === 0) {
        return formattedInteger;
      }
      let formattedFractional = fractionalPart.replace(/0+$/, "");
      if (formattedFractional.length > precision) {
        if (integerPart === "0") {
          const firstNonZeroIndex = formattedFractional.search(/[1-9]/);
          if (firstNonZeroIndex >= 0 && firstNonZeroIndex < precision) {
            formattedFractional = formattedFractional.slice(0, precision);
          } else {
            formattedFractional = formattedFractional.slice(0, firstNonZeroIndex + 1);
          }
        } else {
          formattedFractional = formattedFractional.slice(0, precision);
        }
      } else {
        formattedFractional = formattedFractional.slice(0, precision);
      }
      if (formattedFractional.length < minPrecision) {
        formattedFractional = formattedFractional.padEnd(minPrecision, "0");
      }
      if (formattedFractional === "" && minPrecision === 0) {
        return formattedInteger;
      }
      return formattedFractional ? `${formattedInteger}.${formattedFractional}` : formattedInteger;
    }
    formatUnits(units = DEFAULT_DECIMAL_UNITS) {
      const valueString = this.toString();
      const valueLength = valueString.length;
      if (valueLength <= units) {
        const paddedZeros = "0".repeat(units - valueLength);
        return `0.${paddedZeros}${valueString}`;
      }
      const integerPart = valueString.slice(0, valueLength - units);
      const fractionalPart = valueString.slice(valueLength - units);
      return `${integerPart}.${fractionalPart}`;
    }
    // END ANCHOR: HELPERS
    // ANCHOR: OVERRIDES to accept better inputs
    add(v) {
      return this.caller(v, "add");
    }
    pow(v) {
      return this.caller(v, "pow");
    }
    sub(v) {
      return this.caller(v, "sub");
    }
    div(v) {
      return this.caller(v, "div");
    }
    mul(v) {
      return this.caller(v, "mul");
    }
    mod(v) {
      return this.caller(v, "mod");
    }
    divRound(v) {
      return this.caller(v, "divRound");
    }
    lt(v) {
      return this.caller(v, "lt");
    }
    lte(v) {
      return this.caller(v, "lte");
    }
    gt(v) {
      return this.caller(v, "gt");
    }
    gte(v) {
      return this.caller(v, "gte");
    }
    eq(v) {
      return this.caller(v, "eq");
    }
    cmp(v) {
      return this.caller(v, "cmp");
    }
    // END ANCHOR: OVERRIDES to accept better inputs
    // ANCHOR: OVERRIDES to output our BN type
    sqr() {
      return new BN(super.sqr().toArray());
    }
    neg() {
      return new BN(super.neg().toArray());
    }
    abs() {
      return new BN(super.abs().toArray());
    }
    toTwos(width) {
      return new BN(super.toTwos(width).toArray());
    }
    fromTwos(width) {
      return new BN(super.fromTwos(width).toArray());
    }
    // END ANCHOR: OVERRIDES to output our BN type
    // ANCHOR: OVERRIDES to avoid losing references
    caller(v, methodName) {
      const output2 = super[methodName](new BN(v));
      if (BN.isBN(output2)) {
        return new BN(output2.toArray());
      }
      if (typeof output2 === "boolean") {
        return output2;
      }
      return output2;
    }
    clone() {
      return new BN(this.toArray());
    }
    mulTo(num, out) {
      const output2 = new import_bn.default(this.toArray()).mulTo(num, out);
      return new BN(output2.toArray());
    }
    egcd(p) {
      const { a, b, gcd } = new import_bn.default(this.toArray()).egcd(p);
      return {
        a: new BN(a.toArray()),
        b: new BN(b.toArray()),
        gcd: new BN(gcd.toArray())
      };
    }
    divmod(num, mode, positive) {
      const { div, mod: mod2 } = new import_bn.default(this.toArray()).divmod(new BN(num), mode, positive);
      return {
        div: new BN(div?.toArray()),
        mod: new BN(mod2?.toArray())
      };
    }
    maxU64() {
      return this.gte(this.MAX_U64) ? new BN(this.MAX_U64) : this;
    }
    max(num) {
      return this.gte(num) ? new BN(num) : this;
    }
    normalizeZeroToOne() {
      return this.isZero() ? new BN(1) : this;
    }
    // END ANCHOR: OVERRIDES to avoid losing references
  };
  var bn = (value, base2, endian) => new BN(value, base2, endian);
  bn.parseUnits = (value, units = DEFAULT_DECIMAL_UNITS) => {
    const valueToParse = value === "." ? "0." : value;
    const [valueUnits = "0", valueDecimals = "0"] = valueToParse.split(".");
    const length = valueDecimals.length;
    if (units === 0) {
      const valueWithoutDecimals = valueToParse.replace(",", "").split(".")[0];
      return bn(valueWithoutDecimals);
    }
    if (length > units) {
      throw new FuelError(
        ErrorCode.CONVERTING_FAILED,
        `Decimal can't have more than ${units} digits.`
      );
    }
    const decimals = Array.from({ length: units }).fill("0");
    decimals.splice(0, length, valueDecimals);
    const amount = `${valueUnits.replaceAll(",", "")}${decimals.join("")}`;
    return bn(amount);
  };
  function toNumber(value) {
    return bn(value).toNumber();
  }
  function toHex(value, bytesPadding) {
    return bn(value).toHex(bytesPadding);
  }
  function toBytes(value, bytesPadding) {
    return bn(value).toBytes(bytesPadding);
  }

  // ../../node_modules/.pnpm/fflate@0.8.2/node_modules/fflate/esm/index.mjs
  var import_module = __require2("module");
  var require2 = (0, import_module.createRequire)("/");
  var Worker;
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {
  }
  var u8 = Uint8Array;
  var u16 = Uint16Array;
  var i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
      b[i] = start += 1 << eb[i - 1];
    }
    var r = new i32(b[30]);
    for (var i = 1; i < 30; ++i) {
      for (var j = b[i]; j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }
    return { b, r };
  };
  var _a = freb(fleb, 2);
  var fl = _a.b;
  var revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0);
  var fd = _b.b;
  var revfd = _b.r;
  var rev = new u16(32768);
  for (i = 0; i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var x;
  var i;
  var hMap = function(cd, mb, r) {
    var s = cd.length;
    var i = 0;
    var l = new u16(mb);
    for (; i < s; ++i) {
      if (cd[i])
        ++l[cd[i] - 1];
    }
    var le = new u16(mb);
    for (i = 1; i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          var sv = i << 4 | cd[i];
          var r_1 = mb - cd[i];
          var v = le[cd[i] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (i = 0; i < 144; ++i)
    flt[i] = 8;
  var i;
  for (i = 144; i < 256; ++i)
    flt[i] = 9;
  var i;
  for (i = 256; i < 280; ++i)
    flt[i] = 7;
  var i;
  for (i = 280; i < 288; ++i)
    flt[i] = 8;
  var i;
  var fdt = new u8(32);
  for (i = 0; i < 32; ++i)
    fdt[i] = 5;
  var i;
  var flm = /* @__PURE__ */ hMap(flt, 9, 0);
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
      if (a[i] > m)
        m = a[i];
    }
    return m;
  };
  var bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  };
  var bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  var shft = function(p) {
    return (p + 7) / 8 | 0;
  };
  var slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    return new u8(v.subarray(s, e));
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  };
  var inflt = function(dat, st, buf, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf;
    var resize = noBuf || st.i != 2;
    var noSt = st.i;
    if (noBuf)
      buf = new u8(sl * 3);
    var cbuf = function(l2) {
      var bl = buf.length;
      if (l2 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type3 = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type3) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t * 8, st.f = final;
          continue;
        } else if (type3 == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type3 == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i = 0; i < hcLen; ++i) {
            clt[clim[i]] = bits(dat, pos + i * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i = 0; i < tl; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i++] = c;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i = sym - 257, b = fleb[i];
            add = bits(dat, pos, (1 << b) - 1) + fl[i];
            pos += b;
          }
          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + 131072);
          var end = bt + add;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (; bt < end; ++bt)
            buf[bt] = buf[bt - dt];
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
  };
  var wbits = function(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
  };
  var wbits16 = function(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
    d[o + 2] |= v >> 16;
  };
  var hTree = function(d, mb) {
    var t = [];
    for (var i = 0; i < d.length; ++i) {
      if (d[i])
        t.push({ s: i, f: d[i] });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s)
      return { t: et, l: 0 };
    if (s == 1) {
      var v = new u8(t[0].s + 1);
      v[t[0].s] = 1;
      return { t: v, l: 1 };
    }
    t.sort(function(a, b) {
      return a.f - b.f;
    });
    t.push({ s: -1, f: 25001 });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = { s: -1, f: l.f + r.f, l, r };
    while (i1 != s - 1) {
      l = t[t[i0].f < t[i2].f ? i0++ : i2++];
      r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
      t[i1++] = { s: -1, f: l.f + r.f, l, r };
    }
    var maxSym = t2[0].s;
    for (var i = 1; i < s; ++i) {
      if (t2[i].s > maxSym)
        maxSym = t2[i].s;
    }
    var tr3 = new u16(maxSym + 1);
    var mbt = ln(t[i1 - 1], tr3, 0);
    if (mbt > mb) {
      var i = 0, dt = 0;
      var lft = mbt - mb, cst = 1 << lft;
      t2.sort(function(a, b) {
        return tr3[b.s] - tr3[a.s] || a.f - b.f;
      });
      for (; i < s; ++i) {
        var i2_1 = t2[i].s;
        if (tr3[i2_1] > mb) {
          dt += cst - (1 << mbt - tr3[i2_1]);
          tr3[i2_1] = mb;
        } else
          break;
      }
      dt >>= lft;
      while (dt > 0) {
        var i2_2 = t2[i].s;
        if (tr3[i2_2] < mb)
          dt -= 1 << mb - tr3[i2_2]++ - 1;
        else
          ++i;
      }
      for (; i >= 0 && dt; --i) {
        var i2_3 = t2[i].s;
        if (tr3[i2_3] == mb) {
          --tr3[i2_3];
          ++dt;
        }
      }
      mbt = mb;
    }
    return { t: new u8(tr3), l: mbt };
  };
  var ln = function(n, l, d) {
    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
  };
  var lc = function(c) {
    var s = c.length;
    while (s && !c[--s])
      ;
    var cl = new u16(++s);
    var cli = 0, cln = c[0], cls = 1;
    var w = function(v) {
      cl[cli++] = v;
    };
    for (var i = 1; i <= s; ++i) {
      if (c[i] == cln && i != s)
        ++cls;
      else {
        if (!cln && cls > 2) {
          for (; cls > 138; cls -= 138)
            w(32754);
          if (cls > 2) {
            w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
            cls = 0;
          }
        } else if (cls > 3) {
          w(cln), --cls;
          for (; cls > 6; cls -= 6)
            w(8304);
          if (cls > 2)
            w(cls - 3 << 5 | 8208), cls = 0;
        }
        while (cls--)
          w(cln);
        cls = 1;
        cln = c[i];
      }
    }
    return { c: cl.subarray(0, cli), n: s };
  };
  var clen = function(cf, cl) {
    var l = 0;
    for (var i = 0; i < cl.length; ++i)
      l += cf[i] * cl[i];
    return l;
  };
  var wfblk = function(out, pos, dat) {
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for (var i = 0; i < s; ++i)
      out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
  };
  var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, final);
    ++lf[256];
    var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
    var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for (var i = 0; i < lclt.length; ++i)
      ++lcfreq[lclt[i] & 31];
    for (var i = 0; i < lcdt.length; ++i)
      ++lcfreq[lcdt[i] & 31];
    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
      ;
    var flen = bl + 5 << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen)
      return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
      lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
      var llm = hMap(lct, mlcb, 0);
      wbits(out, p, nlc - 257);
      wbits(out, p + 5, ndc - 1);
      wbits(out, p + 10, nlcc - 4);
      p += 14;
      for (var i = 0; i < nlcc; ++i)
        wbits(out, p + 3 * i, lct[clim[i]]);
      p += 3 * nlcc;
      var lcts = [lclt, lcdt];
      for (var it = 0; it < 2; ++it) {
        var clct = lcts[it];
        for (var i = 0; i < clct.length; ++i) {
          var len = clct[i] & 31;
          wbits(out, p, llm[len]), p += lct[len];
          if (len > 15)
            wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
        }
      }
    } else {
      lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i = 0; i < li; ++i) {
      var sym = syms[i];
      if (sym > 255) {
        var len = sym >> 18 & 31;
        wbits16(out, p, lm[len + 257]), p += ll[len + 257];
        if (len > 7)
          wbits(out, p, sym >> 23 & 31), p += fleb[len];
        var dst = sym & 31;
        wbits16(out, p, dm[dst]), p += dl[dst];
        if (dst > 3)
          wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
      } else {
        wbits16(out, p, lm[sym]), p += ll[sym];
      }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
  };
  var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  var et = /* @__PURE__ */ new u8(0);
  var dflt = function(dat, lvl, plvl, pre, post, st) {
    var s = st.z || dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
    var w = o.subarray(pre, o.length - post);
    var lst = st.l;
    var pos = (st.r || 0) & 7;
    if (lvl) {
      if (pos)
        w[0] = st.r >> 3;
      var opt = deo[lvl - 1];
      var n = opt >> 13, c = opt & 8191;
      var msk_1 = (1 << plvl) - 1;
      var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
      var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
      var hsh = function(i2) {
        return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
      };
      var syms = new i32(25e3);
      var lf = new u16(288), df = new u16(32);
      var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
      for (; i + 2 < s; ++i) {
        var hv = hsh(i);
        var imod = i & 32767, pimod = head[hv];
        prev[imod] = pimod;
        head[hv] = imod;
        if (wi <= i) {
          var rem = s - i;
          if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
            pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
            li = lc_1 = eb = 0, bs = i;
            for (var j = 0; j < 286; ++j)
              lf[j] = 0;
            for (var j = 0; j < 30; ++j)
              df[j] = 0;
          }
          var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
          if (rem > 2 && hv == hsh(i - dif)) {
            var maxn = Math.min(n, rem) - 1;
            var maxd = Math.min(32767, i);
            var ml = Math.min(258, rem);
            while (dif <= maxd && --ch_1 && imod != pimod) {
              if (dat[i + l] == dat[i + l - dif]) {
                var nl = 0;
                for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                  ;
                if (nl > l) {
                  l = nl, d = dif;
                  if (nl > maxn)
                    break;
                  var mmd = Math.min(dif, nl - 2);
                  var md = 0;
                  for (var j = 0; j < mmd; ++j) {
                    var ti = i - dif + j & 32767;
                    var pti = prev[ti];
                    var cd = ti - pti & 32767;
                    if (cd > md)
                      md = cd, pimod = ti;
                  }
                }
              }
              imod = pimod, pimod = prev[imod];
              dif += imod - pimod & 32767;
            }
          }
          if (d) {
            syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
            var lin = revfl[l] & 31, din = revfd[d] & 31;
            eb += fleb[lin] + fdeb[din];
            ++lf[257 + lin];
            ++df[din];
            wi = i + l;
            ++lc_1;
          } else {
            syms[li++] = dat[i];
            ++lf[dat[i]];
          }
        }
      }
      for (i = Math.max(i, wi); i < s; ++i) {
        syms[li++] = dat[i];
        ++lf[dat[i]];
      }
      pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
      if (!lst) {
        st.r = pos & 7 | w[pos / 8 | 0] << 3;
        pos -= 7;
        st.h = head, st.p = prev, st.i = i, st.w = wi;
      }
    } else {
      for (var i = st.w || 0; i < s + lst; i += 65535) {
        var e = i + 65535;
        if (e >= s) {
          w[pos / 8 | 0] = lst;
          e = s;
        }
        pos = wfblk(w, pos + 1, dat.subarray(i, e));
      }
      st.i = s;
    }
    return slc(o, 0, pre + shft(pos) + post);
  };
  var crct = /* @__PURE__ */ function() {
    var t = new Int32Array(256);
    for (var i = 0; i < 256; ++i) {
      var c = i, k = 9;
      while (--k)
        c = (c & 1 && -306674912) ^ c >>> 1;
      t[i] = c;
    }
    return t;
  }();
  var crc = function() {
    var c = -1;
    return {
      p: function(d) {
        var cr = c;
        for (var i = 0; i < d.length; ++i)
          cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
        c = cr;
      },
      d: function() {
        return ~c;
      }
    };
  };
  var dopt = function(dat, opt, pre, post, st) {
    if (!st) {
      st = { l: 1 };
      if (opt.dictionary) {
        var dict = opt.dictionary.subarray(-32768);
        var newDat = new u8(dict.length + dat.length);
        newDat.set(dict);
        newDat.set(dat, dict.length);
        dat = newDat;
        st.w = dict.length;
      }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
  };
  var wbytes = function(d, b, v) {
    for (; v; ++b)
      d[b] = v, v >>>= 8;
  };
  var gzh = function(c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
    if (o.mtime != 0)
      wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
    if (fn) {
      c[3] = 8;
      for (var i = 0; i <= fn.length; ++i)
        c[i + 10] = fn.charCodeAt(i);
    }
  };
  var gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
      err(6, "invalid gzip data");
    var flg = d[3];
    var st = 10;
    if (flg & 4)
      st += (d[10] | d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
      ;
    return st + (flg & 2);
  };
  var gzl = function(d) {
    var l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
  };
  var gzhl = function(o) {
    return 10 + (o.filename ? o.filename.length + 1 : 0);
  };
  function gzipSync(data, opts) {
    if (!opts)
      opts = {};
    var c = crc(), l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
  }
  function gunzipSync(data, opts) {
    var st = gzs(data);
    if (st + 8 > data.length)
      err(6, "invalid gzip data");
    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }

  // ../utils/dist/index.mjs
  var __defProp3 = Object.defineProperty;
  var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField3 = (obj, key, value) => {
    __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var capitalizeString = (str) => {
    if (!str.length) {
      return str;
    }
    return str[0].toUpperCase() + str.slice(1);
  };
  var chunkAndPadBytes = (bytes2, chunkSize) => {
    const chunks = [];
    for (let offset = 0; offset < bytes2.length; offset += chunkSize) {
      const chunk = new Uint8Array(chunkSize);
      chunk.set(bytes2.slice(offset, offset + chunkSize));
      chunks.push(chunk);
    }
    const lastChunk = chunks[chunks.length - 1];
    const remainingBytes = bytes2.length % chunkSize;
    const paddedChunkLength = remainingBytes + (8 - remainingBytes % 8) % 8;
    const newChunk = lastChunk.slice(0, paddedChunkLength);
    chunks[chunks.length - 1] = newChunk;
    return chunks;
  };
  var arrayify = (value, name, copy = true) => {
    if (value instanceof Uint8Array) {
      if (copy) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    const nameMessage = name ? ` ${name} -` : "";
    const message = `invalid data:${nameMessage} ${value}
If you are attempting to transform a hex value, please make sure it is being passed as a string and wrapped in quotes.`;
    throw new FuelError(ErrorCode.INVALID_DATA, message);
  };
  var concatBytes = (arrays) => {
    const byteArrays = arrays.map((array2) => {
      if (array2 instanceof Uint8Array) {
        return array2;
      }
      return Uint8Array.from(array2);
    });
    const totalSize = byteArrays.reduce((accum, item) => accum + item.length, 0);
    const concatenated = new Uint8Array(totalSize);
    byteArrays.reduce((offset, object2) => {
      concatenated.set(object2, offset);
      return offset + object2.length;
    }, 0);
    return concatenated;
  };
  var concat = (arrays) => {
    const bytes2 = arrays.map((v) => arrayify(v));
    return concatBytes(bytes2);
  };
  var HexCharacters = "0123456789abcdef";
  function hexlify(data) {
    const bytes2 = arrayify(data);
    let result = "0x";
    for (let i = 0; i < bytes2.length; i++) {
      const v = bytes2[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  var normalizeString = (str) => {
    const transformations = [
      (s) => s.replace(/\s+/g, "-"),
      // spaces to -
      (s) => s.replace(/\./g, "-"),
      // dots to -
      (s) => s.replace(/_/g, "-"),
      // underscore to -
      (s) => s.replace(/-[a-z]/g, (match3) => match3.slice(-1).toUpperCase()),
      // delete '-' and capitalize the letter after them
      (s) => s.replace(/-/g, ""),
      // delete any '-' left
      (s) => s.replace(/^\d+/, ""),
      // removes leading digits
      (s) => s[0].toUpperCase() + s.slice(1)
      // capitalize first letter
    ];
    const output2 = transformations.reduce((s, t) => t(s), str);
    if (output2 === "") {
      const errMsg = `The provided string '${str}' results in an empty output after`.concat(
        ` normalization, therefore, it can't normalize string.`
      );
      throw new FuelError(ErrorCode.PARSE_FAILED, errMsg);
    }
    return output2;
  };
  var TAI64_LEAP_SECONDS = 37;
  var TAI64_UNIX_OFFSET = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);
  var msToSeconds = (ms) => Math.floor(ms / 1e3);
  var secondsToMs = (seconds) => seconds * 1e3;
  var tai64ToUnixSeconds = (tai64) => Number(BigInt(tai64) - TAI64_UNIX_OFFSET);
  var unixSecondsToTai64 = (unixSeconds) => String(BigInt(unixSeconds) + TAI64_UNIX_OFFSET);
  var tai64ToUnixMilliseconds = (tai64) => secondsToMs(tai64ToUnixSeconds(tai64));
  var _DateTime = class extends Date {
    /**
     * Generates a new DateTime instance from a Tai64 timestamp.
     *
     * @param tai64 - Tai64 timestamp
     * @returns a new DateTime instance
     */
    static fromTai64(tai64) {
      return new _DateTime(tai64ToUnixMilliseconds(tai64));
    }
    /**
     * @param unixMilliseconds - unix milliseconds timestamp
     * @returns a new DateTime instance
     */
    static fromUnixMilliseconds(unixMilliseconds) {
      return new _DateTime(unixMilliseconds);
    }
    /**
     * @param unixSeconds - unix seconds timestamp
     * @returns a new DateTime instance
     */
    static fromUnixSeconds(unixSeconds) {
      return new _DateTime(secondsToMs(unixSeconds));
    }
    /**
     * Hide the constructor to prevent direct instantiation.
     */
    constructor(date2) {
      super(date2);
    }
    /**
     * Returns the Tai64 timestamp.
     *
     * @returns the Tai64 timestamp
     */
    toTai64() {
      return unixSecondsToTai64(this.toUnixSeconds());
    }
    /**
     * @returns the unix milliseconds timestamp
     */
    toUnixMilliseconds() {
      return this.getTime();
    }
    /**
     * @returns the unix seconds timestamp
     */
    toUnixSeconds() {
      return msToSeconds(this.getTime());
    }
  };
  var DateTime = _DateTime;
  __publicField3(DateTime, "TAI64_NULL", "");
  function sleep(time) {
    return new Promise((resolve10) => {
      setTimeout(() => {
        resolve10(true);
      }, time);
    });
  }
  var chainConfig_default = {
    chain_name: "local_testnet",
    consensus_parameters: {
      V2: {
        tx_params: {
          V1: {
            max_inputs: 255,
            max_outputs: 255,
            max_witnesses: 255,
            max_gas_per_tx: 3e7,
            max_size: 112640,
            max_bytecode_subsections: 256
          }
        },
        predicate_params: {
          V1: {
            max_predicate_length: 24576,
            max_predicate_data_length: 24576,
            max_message_data_length: 102400,
            max_gas_per_predicate: 1e6
          }
        },
        script_params: {
          V1: {
            max_script_length: 102400,
            max_script_data_length: 102400
          }
        },
        contract_params: {
          V1: {
            contract_max_size: 112640,
            max_storage_slots: 1760
          }
        },
        fee_params: {
          V1: {
            gas_price_factor: 115e4,
            gas_per_byte: 63
          }
        },
        chain_id: 0,
        gas_costs: {
          V4: {
            add: 2,
            addi: 2,
            and: 2,
            andi: 2,
            bal: 274,
            bhei: 2,
            bhsh: 2,
            burn: 7566,
            cb: 2,
            cfsi: 2,
            div: 2,
            divi: 2,
            eck1: 1489,
            ecr1: 20513,
            eq: 2,
            exp: 2,
            expi: 2,
            flag: 2,
            gm: 2,
            gt: 2,
            gtf: 3,
            ji: 2,
            jmp: 2,
            jne: 2,
            jnei: 2,
            jnzi: 2,
            jmpf: 2,
            jmpb: 2,
            jnzf: 2,
            jnzb: 2,
            jnef: 2,
            jneb: 2,
            lb: 2,
            log: 80,
            lt: 2,
            lw: 2,
            mint: 6566,
            mlog: 2,
            mod: 2,
            modi: 2,
            move: 2,
            movi: 1,
            mroo: 3,
            mul: 2,
            muli: 2,
            mldv: 3,
            noop: 1,
            not: 2,
            or: 1,
            ori: 2,
            poph: 2,
            popl: 2,
            pshh: 5,
            pshl: 5,
            ret_contract: 43,
            rvrt_contract: 39,
            sb: 2,
            sll: 2,
            slli: 2,
            srl: 2,
            srli: 2,
            srw: 237,
            sub: 2,
            subi: 2,
            sw: 2,
            sww: 5708,
            time: 106,
            tr: 9253,
            tro: 7199,
            wdcm: 2,
            wqcm: 2,
            wdop: 2,
            wqop: 3,
            wdml: 3,
            wqml: 3,
            wddv: 3,
            wqdv: 4,
            wdmd: 6,
            wqmd: 9,
            wdam: 6,
            wqam: 6,
            wdmm: 6,
            wqmm: 6,
            xor: 2,
            xori: 2,
            aloc: {
              LightOperation: {
                base: 2,
                units_per_gas: 35
              }
            },
            bsiz: {
              LightOperation: {
                base: 25,
                units_per_gas: 564
              }
            },
            bldd: {
              LightOperation: {
                base: 33,
                units_per_gas: 130
              }
            },
            cfe: {
              LightOperation: {
                base: 10,
                units_per_gas: 62
              }
            },
            cfei: {
              LightOperation: {
                base: 10,
                units_per_gas: 66
              }
            },
            call: {
              LightOperation: {
                base: 6934,
                units_per_gas: 14
              }
            },
            ccp: {
              LightOperation: {
                base: 21,
                units_per_gas: 155
              }
            },
            croo: {
              LightOperation: {
                base: 69,
                units_per_gas: 4
              }
            },
            csiz: {
              LightOperation: {
                base: 25,
                units_per_gas: 580
              }
            },
            ed19: {
              LightOperation: {
                base: 3232,
                units_per_gas: 7
              }
            },
            k256: {
              LightOperation: {
                base: 21,
                units_per_gas: 6
              }
            },
            ldc: {
              LightOperation: {
                base: 84,
                units_per_gas: 113
              }
            },
            logd: {
              LightOperation: {
                base: 278,
                units_per_gas: 5
              }
            },
            mcl: {
              LightOperation: {
                base: 2,
                units_per_gas: 1282
              }
            },
            mcli: {
              LightOperation: {
                base: 2,
                units_per_gas: 1250
              }
            },
            mcp: {
              LightOperation: {
                base: 3,
                units_per_gas: 385
              }
            },
            mcpi: {
              LightOperation: {
                base: 7,
                units_per_gas: 585
              }
            },
            meq: {
              LightOperation: {
                base: 2,
                units_per_gas: 1234
              }
            },
            retd_contract: {
              LightOperation: {
                base: 227,
                units_per_gas: 5
              }
            },
            s256: {
              LightOperation: {
                base: 25,
                units_per_gas: 5
              }
            },
            scwq: {
              HeavyOperation: {
                base: 5666,
                gas_per_unit: 6628
              }
            },
            smo: {
              LightOperation: {
                base: 14635,
                units_per_gas: 3
              }
            },
            srwq: {
              HeavyOperation: {
                base: 245,
                gas_per_unit: 243
              }
            },
            swwq: {
              HeavyOperation: {
                base: 5661,
                gas_per_unit: 5776
              }
            },
            contract_root: {
              LightOperation: {
                base: 24,
                units_per_gas: 3
              }
            },
            state_root: {
              HeavyOperation: {
                base: 189,
                gas_per_unit: 96
              }
            },
            new_storage_per_byte: 63,
            vm_initialization: {
              LightOperation: {
                base: 3127,
                units_per_gas: 61
              }
            }
          }
        },
        base_asset_id: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07",
        block_gas_limit: 3e7,
        block_transaction_size_limit: 260096,
        privileged_address: "0000000000000000000000000000000000000000000000000000000000000000"
      }
    },
    consensus: {
      PoA: {
        signing_key: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d"
      }
    }
  };
  var metadata_default = {
    chain_config: "chainConfig.json",
    table_encoding: {
      Json: {
        filepath: "stateConfig.json"
      }
    }
  };
  var stateConfig_default = {
    coins: [],
    messages: [],
    contracts: [],
    blobs: [],
    block_height: 0,
    da_block_height: 0
  };
  var defaultSnapshotConfigs = {
    chainConfig: chainConfig_default,
    metadata: metadata_default,
    stateConfig: stateConfig_default
  };
  var defaultConsensusKey = "0xa449b1ffee0e2205fa924c6740cc48b3b473aa28587df6dab12abc245d1f5298";
  function isDefined(value) {
    return value !== void 0;
  }
  var BN_0 = bn(0);
  var BN_58 = bn(58);
  var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var Lookup = null;
  function getAlpha(letter) {
    if (Lookup == null) {
      Lookup = {};
      for (let i = 0; i < Alphabet.length; i++) {
        Lookup[Alphabet[i]] = bn(i);
      }
    }
    const result = Lookup[letter];
    if (result == null) {
      throw new FuelError(ErrorCode.INVALID_DATA, `invalid base58 value ${letter}`);
    }
    return bn(result);
  }
  function encodeBase58(_value) {
    const bytes2 = arrayify(_value);
    let value = bn(bytes2);
    let result = "";
    while (value.gt(BN_0)) {
      result = Alphabet[Number(value.mod(BN_58))] + result;
      value = value.div(BN_58);
    }
    for (let i = 0; i < bytes2.length; i++) {
      if (bytes2[i]) {
        break;
      }
      result = Alphabet[0] + result;
    }
    return result;
  }
  function decodeBase58(value) {
    let result = BN_0;
    for (let i = 0; i < value.length; i++) {
      result = result.mul(BN_58);
      result = result.add(getAlpha(value[i].toString()));
    }
    return result;
  }
  function dataSlice(data, start, end) {
    const bytes2 = arrayify(data);
    if (end != null && end > bytes2.length) {
      throw new FuelError(ErrorCode.INVALID_DATA, "cannot slice beyond data bounds");
    }
    return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
  }
  function toUtf8Bytes(stri, form = true) {
    let str = stri;
    if (form) {
      str = stri.normalize("NFC");
    }
    const result = [];
    for (let i = 0; i < str.length; i += 1) {
      const c = str.charCodeAt(i);
      if (c < 128) {
        result.push(c);
      } else if (c < 2048) {
        result.push(c >> 6 | 192);
        result.push(c & 63 | 128);
      } else if ((c & 64512) === 55296) {
        i += 1;
        const c2 = str.charCodeAt(i);
        if (i >= str.length || (c2 & 64512) !== 56320) {
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            "Invalid UTF-8 in the input string."
          );
        }
        const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c >> 12 | 224);
        result.push(c >> 6 & 63 | 128);
        result.push(c & 63 | 128);
      }
    }
    return new Uint8Array(result);
  }
  function onError(reason, offset, bytes2, output2, badCodepoint) {
    console.log(`invalid codepoint at offset ${offset}; ${reason}, bytes: ${bytes2}`);
    return offset;
  }
  function helper(codePoints) {
    return codePoints.map((codePoint) => {
      if (codePoint <= 65535) {
        return String.fromCharCode(codePoint);
      }
      codePoint -= 65536;
      return String.fromCharCode(
        (codePoint >> 10 & 1023) + 55296,
        (codePoint & 1023) + 56320
      );
    }).join("");
  }
  function getUtf8CodePoints(_bytes) {
    const bytes2 = arrayify(_bytes, "bytes");
    const result = [];
    let i = 0;
    while (i < bytes2.length) {
      const c = bytes2[i++];
      if (c >> 7 === 0) {
        result.push(c);
        continue;
      }
      let extraLength = null;
      let overlongMask = null;
      if ((c & 224) === 192) {
        extraLength = 1;
        overlongMask = 127;
      } else if ((c & 240) === 224) {
        extraLength = 2;
        overlongMask = 2047;
      } else if ((c & 248) === 240) {
        extraLength = 3;
        overlongMask = 65535;
      } else {
        if ((c & 192) === 128) {
          i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
        } else {
          i += onError("BAD_PREFIX", i - 1, bytes2, result);
        }
        continue;
      }
      if (i - 1 + extraLength >= bytes2.length) {
        i += onError("OVERRUN", i - 1, bytes2, result);
        continue;
      }
      let res = c & (1 << 8 - extraLength - 1) - 1;
      for (let j = 0; j < extraLength; j++) {
        const nextChar = bytes2[i];
        if ((nextChar & 192) !== 128) {
          i += onError("MISSING_CONTINUE", i, bytes2, result);
          res = null;
          break;
        }
        res = res << 6 | nextChar & 63;
        i++;
      }
      if (res === null) {
        continue;
      }
      if (res > 1114111) {
        i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
        continue;
      }
      if (res >= 55296 && res <= 57343) {
        i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
        continue;
      }
      if (res <= overlongMask) {
        i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
        continue;
      }
      result.push(res);
    }
    return result;
  }
  function toUtf8String(bytes2) {
    return helper(getUtf8CodePoints(bytes2));
  }
  var compressBytecode = (bytecodeAsBinary) => {
    if (!bytecodeAsBinary) {
      return "";
    }
    const bytecodeCompressBytes = arrayify(bytecodeAsBinary);
    const bytecodeCompressGzipped = gzipSync(bytecodeCompressBytes, { mtime: 0 });
    const bytecodeCompressBinary = String.fromCharCode.apply(
      null,
      new Uint8Array(bytecodeCompressGzipped)
    );
    const bytecodeCompressEncoded = btoa(bytecodeCompressBinary);
    return bytecodeCompressEncoded;
  };
  var decompressBytecode = (bytecodeAsBase64) => {
    const bytecodeDecompressBinary = atob(bytecodeAsBase64);
    const bytecodeDecompressDecoded = new Uint8Array(bytecodeDecompressBinary.length).map(
      (_, i) => bytecodeDecompressBinary.charCodeAt(i)
    );
    const bytecodeDecompressBytes = gunzipSync(bytecodeDecompressDecoded);
    return bytecodeDecompressBytes;
  };
  function assertUnreachable(_x) {
    throw new Error("Didn't expect to get here");
  }

  // ../abi-typegen/dist/cli.mjs
  var import_path11 = __require2("path");
  var import_handlebars = __toESM(require_lib(), 1);

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_isPlaceholder.js
  function _isPlaceholder(a) {
    return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_curry1.js
  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_curry2.js
  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function(_b2) {
            return fn(a, _b2);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a2) {
            return fn(_a2, b);
          }) : _isPlaceholder(b) ? _curry1(function(_b2) {
            return fn(a, _b2);
          }) : fn(a, b);
      }
    };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_isArray.js
  var isArray_default = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
  };

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_isTransformer.js
  function _isTransformer(obj) {
    return obj != null && typeof obj["@@transducer/step"] === "function";
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_dispatchable.js
  function _dispatchable(methodNames, transducerCreator, fn) {
    return function() {
      if (arguments.length === 0) {
        return fn();
      }
      var obj = arguments[arguments.length - 1];
      if (!isArray_default(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === "function") {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_xfBase.js
  var xfBase_default = {
    init: function() {
      return this.xf["@@transducer/init"]();
    },
    result: function(result) {
      return this.xf["@@transducer/result"](result);
    }
  };

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_arrayFromIterator.js
  function _arrayFromIterator(iter) {
    var list = [];
    var next;
    while (!(next = iter.next()).done) {
      list.push(next.value);
    }
    return list;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_includesWith.js
  function _includesWith(pred, x, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_functionName.js
  function _functionName(f2) {
    var match3 = String(f2).match(/^function (\w*)/);
    return match3 == null ? "" : match3[1];
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_has.js
  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_objectIs.js
  function _objectIs(a, b) {
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    } else {
      return a !== a && b !== b;
    }
  }
  var objectIs_default = typeof Object.is === "function" ? Object.is : _objectIs;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_isArguments.js
  var toString = Object.prototype.toString;
  var _isArguments = /* @__PURE__ */ function() {
    return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
      return toString.call(x) === "[object Arguments]";
    } : function _isArguments2(x) {
      return _has("callee", x);
    };
  }();
  var isArguments_default = _isArguments;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/keys.js
  var hasEnumBug = !/* @__PURE__ */ {
    toString: null
  }.propertyIsEnumerable("toString");
  var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
  var hasArgsEnumBug = /* @__PURE__ */ function() {
    "use strict";
    return arguments.propertyIsEnumerable("length");
  }();
  var contains = function contains2(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };
  var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : /* @__PURE__ */ _curry1(function keys3(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== "length")) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });
  var keys_default = keys;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/type.js
  var type = /* @__PURE__ */ _curry1(function type2(val) {
    return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
  });
  var type_default = type;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_equals.js
  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);
    var b = _arrayFromIterator(bIterator);
    function eq3(_a2, _b2) {
      return _equals(_a2, _b2, stackA.slice(), stackB.slice());
    }
    return !_includesWith(function(b2, aItem) {
      return !_includesWith(eq3, aItem, b2);
    }, b, a);
  }
  function _equals(a, b, stackA, stackB) {
    if (objectIs_default(a, b)) {
      return true;
    }
    var typeA = type_default(a);
    if (typeA !== type_default(b)) {
      return false;
    }
    if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
      return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
    }
    if (typeof a.equals === "function" || typeof b.equals === "function") {
      return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
    }
    switch (typeA) {
      case "Arguments":
      case "Array":
      case "Object":
        if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
          return a === b;
        }
        break;
      case "Boolean":
      case "Number":
      case "String":
        if (!(typeof a === typeof b && objectIs_default(a.valueOf(), b.valueOf()))) {
          return false;
        }
        break;
      case "Date":
        if (!objectIs_default(a.valueOf(), b.valueOf())) {
          return false;
        }
        break;
      case "Error":
        return a.name === b.name && a.message === b.message;
      case "RegExp":
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }
        break;
    }
    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }
    switch (typeA) {
      case "Map":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
      case "Set":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
      case "Arguments":
      case "Array":
      case "Object":
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "Error":
      case "RegExp":
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "ArrayBuffer":
        break;
      default:
        return false;
    }
    var keysA = keys_default(a);
    if (keysA.length !== keys_default(b).length) {
      return false;
    }
    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }
      idx -= 1;
    }
    return true;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/equals.js
  var equals = /* @__PURE__ */ _curry2(function equals2(a, b) {
    return _equals(a, b, [], []);
  });
  var equals_default = equals;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_indexOf.js
  function _indexOf(list, a, idx) {
    var inf, item;
    if (typeof list.indexOf === "function") {
      switch (typeof a) {
        case "number":
          if (a === 0) {
            inf = 1 / a;
            while (idx < list.length) {
              item = list[idx];
              if (item === 0 && 1 / item === inf) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          } else if (a !== a) {
            while (idx < list.length) {
              item = list[idx];
              if (typeof item === "number" && item !== item) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          }
          return list.indexOf(a, idx);
        case "string":
        case "boolean":
        case "function":
        case "undefined":
          return list.indexOf(a, idx);
        case "object":
          if (a === null) {
            return list.indexOf(a, idx);
          }
      }
    }
    while (idx < list.length) {
      if (equals_default(list[idx], a)) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_includes.js
  function _includes(a, list) {
    return _indexOf(list, a, 0) >= 0;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_cloneRegExp.js
  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : "") + (pattern.dotAll ? "s" : ""));
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_clone.js
  function _clone(value, deep, map2) {
    map2 || (map2 = new _ObjectMap());
    if (_isPrimitive(value)) {
      return value;
    }
    var copy = function copy2(copiedValue) {
      var cachedCopy = map2.get(value);
      if (cachedCopy) {
        return cachedCopy;
      }
      map2.set(value, copiedValue);
      for (var key in value) {
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          copiedValue[key] = deep ? _clone(value[key], true, map2) : value[key];
        }
      }
      return copiedValue;
    };
    switch (type_default(value)) {
      case "Object":
        return copy(Object.create(Object.getPrototypeOf(value)));
      case "Array":
        return copy(Array(value.length));
      case "Date":
        return new Date(value.valueOf());
      case "RegExp":
        return _cloneRegExp(value);
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array":
        return value.slice();
      default:
        return value;
    }
  }
  function _isPrimitive(param) {
    var type3 = typeof param;
    return param == null || type3 != "object" && type3 != "function";
  }
  var _ObjectMap = /* @__PURE__ */ function() {
    function _ObjectMap2() {
      this.map = {};
      this.length = 0;
    }
    _ObjectMap2.prototype.set = function(key, value) {
      var hashedKey = this.hash(key);
      var bucket = this.map[hashedKey];
      if (!bucket) {
        this.map[hashedKey] = bucket = [];
      }
      bucket.push([key, value]);
      this.length += 1;
    };
    _ObjectMap2.prototype.hash = function(key) {
      var hashedKey = [];
      for (var value in key) {
        hashedKey.push(Object.prototype.toString.call(key[value]));
      }
      return hashedKey.join();
    };
    _ObjectMap2.prototype.get = function(key) {
      if (this.length <= 180) {
        for (var p in this.map) {
          var bucket = this.map[p];
          for (var i = 0; i < bucket.length; i += 1) {
            var element = bucket[i];
            if (element[0] === key) {
              return element[1];
            }
          }
        }
        return;
      }
      var hashedKey = this.hash(key);
      var bucket = this.map[hashedKey];
      if (!bucket) {
        return;
      }
      for (var i = 0; i < bucket.length; i += 1) {
        var element = bucket[i];
        if (element[0] === key) {
          return element[1];
        }
      }
    };
    return _ObjectMap2;
  }();

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/clone.js
  var clone = /* @__PURE__ */ _curry1(function clone2(value) {
    return value != null && typeof value.clone === "function" ? value.clone() : _clone(value, true);
  });
  var clone_default = clone;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_identity.js
  function _identity(x) {
    return x;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/identity.js
  var identity = /* @__PURE__ */ _curry1(_identity);
  var identity_default = identity;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_Set.js
  var _Set = /* @__PURE__ */ function() {
    function _Set2() {
      this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
      this._items = {};
    }
    _Set2.prototype.add = function(item) {
      return !hasOrAdd(item, true, this);
    };
    _Set2.prototype.has = function(item) {
      return hasOrAdd(item, false, this);
    };
    return _Set2;
  }();
  function hasOrAdd(item, shouldAdd, set) {
    var type3 = typeof item;
    var prevSize, newSize;
    switch (type3) {
      case "string":
      case "number":
        if (item === 0 && 1 / item === -Infinity) {
          if (set._items["-0"]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items["-0"] = true;
            }
            return false;
          }
        }
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type3 in set._items)) {
            if (shouldAdd) {
              set._items[type3] = {};
              set._items[type3][item] = true;
            }
            return false;
          } else if (item in set._items[type3]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type3][item] = true;
            }
            return false;
          }
        }
      case "boolean":
        if (type3 in set._items) {
          var bIdx = item ? 1 : 0;
          if (set._items[type3][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type3][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set._items[type3] = item ? [false, true] : [true, false];
          }
          return false;
        }
      case "function":
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type3 in set._items)) {
            if (shouldAdd) {
              set._items[type3] = [item];
            }
            return false;
          }
          if (!_includes(item, set._items[type3])) {
            if (shouldAdd) {
              set._items[type3].push(item);
            }
            return false;
          }
          return true;
        }
      case "undefined":
        if (set._items[type3]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type3] = true;
          }
          return false;
        }
      case "object":
        if (item === null) {
          if (!set._items["null"]) {
            if (shouldAdd) {
              set._items["null"] = true;
            }
            return false;
          }
          return true;
        }
      default:
        type3 = Object.prototype.toString.call(item);
        if (!(type3 in set._items)) {
          if (shouldAdd) {
            set._items[type3] = [item];
          }
          return false;
        }
        if (!_includes(item, set._items[type3])) {
          if (shouldAdd) {
            set._items[type3].push(item);
          }
          return false;
        }
        return true;
    }
  }
  var Set_default = _Set;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_xuniqBy.js
  var XUniqBy = /* @__PURE__ */ function() {
    function XUniqBy2(f2, xf) {
      this.xf = xf;
      this.f = f2;
      this.set = new Set_default();
    }
    XUniqBy2.prototype["@@transducer/init"] = xfBase_default.init;
    XUniqBy2.prototype["@@transducer/result"] = xfBase_default.result;
    XUniqBy2.prototype["@@transducer/step"] = function(result, input) {
      return this.set.add(this.f(input)) ? this.xf["@@transducer/step"](result, input) : result;
    };
    return XUniqBy2;
  }();
  function _xuniqBy(f2) {
    return function(xf) {
      return new XUniqBy(f2, xf);
    };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/uniqBy.js
  var uniqBy = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xuniqBy, function(fn, list) {
    var set = new Set_default();
    var result = [];
    var idx = 0;
    var appliedItem, item;
    while (idx < list.length) {
      item = list[idx];
      appliedItem = fn(item);
      if (set.add(appliedItem)) {
        result.push(item);
      }
      idx += 1;
    }
    return result;
  }));
  var uniqBy_default = uniqBy;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/uniq.js
  var uniq = /* @__PURE__ */ uniqBy_default(identity_default);
  var uniq_default = uniq;

  // ../abi-typegen/dist/cli.mjs
  var import_path12 = __require2("path");
  var import_path13 = __require2("path");
  var import_fs15 = __require2("fs");
  var import_fs16 = __require2("fs");
  var __defProp4 = Object.defineProperty;
  var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField4 = (obj, key, value) => {
    __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var AType = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _EmptyType = class extends AType {
    name = "empty";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: "undefined",
        outputLabel: "void"
      };
    }
    static isSuitableFor(params) {
      return _EmptyType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var EmptyType = _EmptyType;
  __publicField4(EmptyType, "swayType", "()");
  __publicField4(EmptyType, "MATCH_REGEX", /^\(\)$/m);
  var _OptionType = class extends AType {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType = _OptionType;
  __publicField4(OptionType, "swayType", "enum Option");
  __publicField4(OptionType, "MATCH_REGEX", /^enum (std::option::)?Option$/m);
  function findType(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  var getFunctionInputs = (params) => {
    const { types: types2, inputs } = params;
    let isMandatory = false;
    return inputs.reduceRight((result, input) => {
      const type3 = findType({ types: types2, typeId: input.type });
      const isTypeMandatory = !EmptyType.isSuitableFor({ type: type3.rawAbiType.type }) && !OptionType.isSuitableFor({ type: type3.rawAbiType.type });
      isMandatory = isMandatory || isTypeMandatory;
      return [{ ...input, isOptional: !isMandatory }, ...result];
    }, []);
  };
  function parseTypeArguments(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      const currentTypeId = typeArgument.type;
      const currentType = findType({ types: types2, typeId: currentTypeId });
      const currentLabel = currentType.attributes[attributeKey];
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output2 = buffer.join(", ");
    if (parentLabel) {
      output2 = `${parentLabel}<${output2}>`;
    }
    return output2;
  }
  function resolveInputLabel(types2, typeId, typeArguments) {
    const type3 = findType({ types: types2, typeId });
    let typeDecl;
    if (typeArguments?.length) {
      typeDecl = parseTypeArguments({
        types: types2,
        target: "input",
        parentTypeId: typeId,
        typeArguments
      });
    } else {
      typeDecl = type3.attributes.inputLabel;
    }
    return typeDecl;
  }
  var Function2 = class {
    name;
    types;
    rawAbiFunction;
    attributes;
    constructor(params) {
      this.rawAbiFunction = params.rawAbiFunction;
      this.types = params.types;
      this.name = params.rawAbiFunction.name;
      this.attributes = {
        inputs: this.bundleInputTypes(),
        output: this.bundleOutputTypes(),
        prefixedInputs: this.bundleInputTypes(true)
      };
    }
    bundleInputTypes(shouldPrefixParams = false) {
      const { types: types2 } = this;
      const inputs = getFunctionInputs({ types: types2, inputs: this.rawAbiFunction.inputs }).map(
        ({ isOptional, ...input }) => {
          const { name, type: typeId, typeArguments } = input;
          const typeDecl = resolveInputLabel(types2, typeId, typeArguments);
          if (shouldPrefixParams) {
            const optionalSuffix = isOptional ? "?" : "";
            return `${name}${optionalSuffix}: ${typeDecl}`;
          }
          return typeDecl;
        }
      );
      return inputs.join(", ");
    }
    bundleOutputTypes() {
      return parseTypeArguments({
        types: this.types,
        target: "output",
        typeArguments: [this.rawAbiFunction.output]
      });
    }
    getDeclaration() {
      const { name } = this;
      const { prefixedInputs, output: output2 } = this.attributes;
      const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output2}>`;
      return decl;
    }
  };
  function makeFunction(params) {
    const { types: types2, rawAbiFunction } = params;
    return new Function2({ types: types2, rawAbiFunction });
  }
  function parseFunctions(params) {
    const { types: types2, rawAbiFunctions } = params;
    const functions = rawAbiFunctions.map(
      (rawAbiFunction) => makeFunction({ types: types2, rawAbiFunction })
    );
    return functions;
  }
  var _ArrayType = class extends AType {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType = _ArrayType;
  __publicField4(ArrayType, "swayType", "[_; 2]");
  __publicField4(ArrayType, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType = class extends AType {
    name = "str";
    static isSuitableFor(params) {
      return _StrType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType = _StrType;
  __publicField4(StrType, "swayType", "str[3]");
  __publicField4(StrType, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type = class extends StrType {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type = _B256Type;
  __publicField4(B256Type, "swayType", "b256");
  __publicField4(B256Type, "MATCH_REGEX", /^b256$/m);
  var _B512Type = class extends B256Type {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type = _B512Type;
  __publicField4(B512Type, "swayType", "struct B512");
  __publicField4(B512Type, "MATCH_REGEX", /^struct (std::b512::)?B512$/m);
  var _BoolType = class extends AType {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType = _BoolType;
  __publicField4(BoolType, "swayType", "bool");
  __publicField4(BoolType, "MATCH_REGEX", /^bool$/m);
  var _BytesType = class extends ArrayType {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType = _BytesType;
  __publicField4(BytesType, "swayType", "struct Bytes");
  __publicField4(BytesType, "MATCH_REGEX", /^struct (std::bytes::)?Bytes/m);
  function extractStructName(params) {
    const { rawAbiType, regex } = params;
    const matches = rawAbiType.type.match(regex);
    const match3 = matches?.[2] ?? matches?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _ResultType = class extends AType {
    name = "result";
    static isSuitableFor(params) {
      return _ResultType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Result`,
        outputLabel: `Result`
      };
      return this.attributes;
    }
  };
  var ResultType = _ResultType;
  __publicField4(ResultType, "swayType", "enum Result");
  __publicField4(ResultType, "MATCH_REGEX", /^enum (std::result::)?Result$/m);
  var _EnumType = class extends AType {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType.IGNORE_REGEXES.some((r) => r.test(params.type));
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _EnumType.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash3, row) => ({
          ...hash3,
          [row.rawAbiType.typeId]: row.rawAbiType.type
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => typeHash[type3] === EmptyType.swayType)) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const type3 = findType({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return contents.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var EnumType = _EnumType;
  __publicField4(EnumType, "swayType", "enum MyEnumName");
  __publicField4(EnumType, "MATCH_REGEX", /^enum (.+::)?(.+)$/m);
  __publicField4(EnumType, "IGNORE_REGEXES", [OptionType.MATCH_REGEX, ResultType.MATCH_REGEX]);
  var _EvmAddressType = class extends AType {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType = _EvmAddressType;
  __publicField4(EvmAddressType, "swayType", "struct EvmAddress");
  __publicField4(EvmAddressType, "MATCH_REGEX", /^struct (std::vm::evm::evm_address::)?EvmAddress$/m);
  var _GenericType = class extends AType {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _GenericType.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType = _GenericType;
  __publicField4(GenericType, "swayType", "generic T");
  __publicField4(GenericType, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _U8Type = class extends AType {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type = _U8Type;
  __publicField4(U8Type, "swayType", "u8");
  __publicField4(U8Type, "MATCH_REGEX", /^u8$/m);
  var _U64Type = class extends U8Type {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type = _U64Type;
  __publicField4(U64Type, "swayType", "u64");
  __publicField4(U64Type, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr = class extends U64Type {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr = _RawUntypedPtr;
  __publicField4(RawUntypedPtr, "swayType", "raw untyped ptr");
  __publicField4(RawUntypedPtr, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice = class extends ArrayType {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice = _RawUntypedSlice;
  __publicField4(RawUntypedSlice, "swayType", "raw untyped slice");
  __publicField4(RawUntypedSlice, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType = class extends AType {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType = _StdStringType;
  __publicField4(StdStringType, "swayType", "struct String");
  __publicField4(StdStringType, "MATCH_REGEX", /^struct (std::string::)?String/m);
  var _StrSliceType = class extends AType {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StrSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StrSliceType = _StrSliceType;
  __publicField4(StrSliceType, "swayType", "str");
  __publicField4(StrSliceType, "MATCH_REGEX", /^str$/m);
  var _StructType = class extends AType {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _StructType.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType = _StructType;
  __publicField4(StructType, "swayType", "struct MyStruct");
  __publicField4(StructType, "MATCH_REGEX", /^struct (.+::)?(.+)$/m);
  __publicField4(StructType, "IGNORE_REGEX", /^struct (std::.*)?(Vec|RawVec|EvmAddress|Bytes|String|RawBytes)$/m);
  var _TupleType = class extends AType {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType = _TupleType;
  __publicField4(TupleType, "swayType", "(_, _, _)");
  __publicField4(TupleType, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type = class extends U8Type {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type = _U16Type;
  __publicField4(U16Type, "swayType", "u16");
  __publicField4(U16Type, "MATCH_REGEX", /^u16$/m);
  var _U256Type = class extends U64Type {
    name = "u256";
    static isSuitableFor(params) {
      return _U256Type.MATCH_REGEX.test(params.type);
    }
  };
  var U256Type = _U256Type;
  __publicField4(U256Type, "swayType", "u256");
  __publicField4(U256Type, "MATCH_REGEX", /^u256$/m);
  var _U32Type = class extends U8Type {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type = _U32Type;
  __publicField4(U32Type, "swayType", "u32");
  __publicField4(U32Type, "MATCH_REGEX", /^u32$/m);
  var _VectorType = class extends ArrayType {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType = _VectorType;
  __publicField4(VectorType, "swayType", "struct Vec");
  __publicField4(VectorType, "MATCH_REGEX", /^struct (std::vec::)?Vec/m);
  __publicField4(VectorType, "IGNORE_REGEX", /^struct (std::vec::)?RawVec$/m);
  var supportedTypes = [
    EmptyType,
    ArrayType,
    B256Type,
    B512Type,
    BoolType,
    BytesType,
    EnumType,
    GenericType,
    OptionType,
    RawUntypedPtr,
    RawUntypedSlice,
    StdStringType,
    StrType,
    StrSliceType,
    StructType,
    TupleType,
    U16Type,
    U32Type,
    U64Type,
    U256Type,
    U8Type,
    VectorType,
    EvmAddressType,
    ResultType
  ];
  function makeType(params) {
    const { rawAbiType } = params;
    const { type: type3 } = rawAbiType;
    const TypeClass = supportedTypes.find((tc) => tc.isSuitableFor({ type: type3 }));
    if (!TypeClass) {
      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Type not supported: ${type3}`);
    }
    return new TypeClass(params);
  }
  function shouldSkipAbiType(params) {
    const ignoreList = [
      "struct RawVec",
      "struct std::vec::RawVec",
      "struct RawBytes",
      "struct std::bytes::RawBytes"
    ];
    const shouldSkip = ignoreList.indexOf(params.type) >= 0;
    return shouldSkip;
  }
  function parseTypes(params) {
    const types2 = [];
    params.rawAbiTypes.forEach((rawAbiType) => {
      const { type: type3 } = rawAbiType;
      const skip = shouldSkipAbiType({ type: type3 });
      if (!skip) {
        const parsedType = makeType({ rawAbiType });
        types2.push(parsedType);
      }
    });
    types2.forEach((type3) => {
      type3.parseComponentsAttributes({ types: types2 });
    });
    return types2;
  }
  var findTypeByConcreteId = (types2, id) => types2.find((x) => x.concreteTypeId === id);
  var findConcreteTypeById = (abi2, id) => abi2.concreteTypes.find((x) => x.concreteTypeId === id);
  function finsertTypeIdByConcreteTypeId(abi2, types2, id) {
    const concreteType = findConcreteTypeById(abi2, id);
    if (concreteType.metadataTypeId !== void 0) {
      return concreteType.metadataTypeId;
    }
    const type3 = findTypeByConcreteId(types2, id);
    if (type3) {
      return type3.typeId;
    }
    types2.push({
      typeId: types2.length,
      type: concreteType.type,
      components: parseComponents(concreteType.components),
      concreteTypeId: id,
      typeParameters: concreteType.typeParameters ?? null,
      originalConcreteTypeId: concreteType?.concreteTypeId
    });
    return types2.length - 1;
  }
  function parseFunctionTypeArguments(abi2, types2, concreteType) {
    return concreteType.typeArguments?.map((cTypeId) => {
      const self2 = findConcreteTypeById(abi2, cTypeId);
      const type3 = !isNaN(cTypeId) ? cTypeId : finsertTypeIdByConcreteTypeId(abi2, types2, cTypeId);
      return {
        name: "",
        type: type3,
        // originalTypeId: cTypeId,
        typeArguments: parseFunctionTypeArguments(abi2, types2, self2)
      };
    }) ?? null;
  }
  function parseConcreteType(abi2, types2, concreteTypeId, name) {
    const type3 = finsertTypeIdByConcreteTypeId(abi2, types2, concreteTypeId);
    const concrete = findConcreteTypeById(abi2, concreteTypeId);
    return {
      name: name ?? "",
      type: type3,
      // concreteTypeId,
      typeArguments: parseFunctionTypeArguments(abi2, types2, concrete)
    };
  }
  function parseComponents(abi2, types2, components) {
    return components?.map((component) => {
      const { typeId, name, typeArguments } = component;
      const type3 = !isNaN(typeId) ? typeId : finsertTypeIdByConcreteTypeId(abi2, types2, typeId);
      return {
        name,
        type: type3,
        // originalTypeId: typeId,
        typeArguments: parseComponents(abi2, types2, typeArguments)
      };
    }) ?? null;
  }
  function transpileAbi(abi2) {
    if (!abi2.specVersion) {
      return abi2;
    }
    const types2 = [];
    abi2.metadataTypes.forEach((m) => {
      const t = {
        typeId: m.metadataTypeId,
        type: m.type,
        components: m.components ?? (m.type === "()" ? [] : null),
        typeParameters: m.typeParameters ?? null
      };
      types2.push(t);
    });
    types2.forEach((t) => {
      t.components = parseComponents(abi2, types2, t.components);
    });
    const functions = abi2.functions.map((fn) => {
      const inputs = fn.inputs.map(
        ({ concreteTypeId, name }) => parseConcreteType(abi2, types2, concreteTypeId, name)
      );
      const output2 = parseConcreteType(abi2, types2, fn.output, "");
      return { ...fn, inputs, output: output2 };
    });
    const configurables = abi2.configurables.map((conf) => ({
      name: conf.name,
      configurableType: parseConcreteType(abi2, types2, conf.concreteTypeId),
      offset: conf.offset
    }));
    const loggedTypes = abi2.loggedTypes.map((log4) => ({
      logId: log4.logId,
      loggedType: parseConcreteType(abi2, types2, log4.concreteTypeId)
    }));
    const transpiled = {
      encoding: abi2.encodingVersion,
      types: types2,
      functions,
      loggedTypes,
      messagesTypes: abi2.messagesTypes,
      configurables
    };
    return transpiled;
  }
  var Configurable = class {
    name;
    inputLabel;
    constructor(params) {
      const {
        types: types2,
        rawAbiConfigurable: {
          name,
          configurableType: { type: type3, typeArguments }
        }
      } = params;
      this.name = name;
      this.inputLabel = resolveInputLabel(types2, type3, typeArguments);
    }
  };
  var Abi = class {
    capitalizedName;
    camelizedName;
    programType;
    filepath;
    outputDir;
    commonTypesInUse = [];
    rawContents;
    hexlifiedBinContents;
    storageSlotsContents;
    types;
    functions;
    configurables;
    constructor(params) {
      const {
        filepath,
        outputDir,
        rawContents,
        hexlifiedBinContents,
        programType,
        storageSlotsContents
      } = params;
      const abiNameRegex = /([^/]+)-abi\.json$/m;
      const abiName = filepath.match(abiNameRegex);
      const couldNotParseName = !abiName || abiName.length === 0;
      if (couldNotParseName) {
        throw new FuelError(
          ErrorCode.PARSE_FAILED,
          `Could not parse name from ABI file: ${filepath}.`
        );
      }
      this.programType = programType;
      this.capitalizedName = `${normalizeString(abiName[1])}`;
      this.camelizedName = this.capitalizedName.replace(/^./m, (x) => x.toLowerCase());
      this.filepath = filepath;
      this.rawContents = rawContents;
      this.hexlifiedBinContents = hexlifiedBinContents;
      this.storageSlotsContents = storageSlotsContents;
      this.outputDir = outputDir;
      const { types: types2, functions, configurables } = this.parse();
      this.types = types2;
      this.functions = functions;
      this.configurables = configurables;
      this.computeCommonTypesInUse();
    }
    parse() {
      const transpiled = transpileAbi(this.rawContents);
      const {
        types: rawAbiTypes,
        functions: rawAbiFunctions,
        configurables: rawAbiConfigurables
      } = transpiled;
      const types2 = parseTypes({ rawAbiTypes });
      const functions = parseFunctions({ rawAbiFunctions, types: types2 });
      const configurables = rawAbiConfigurables.map(
        (rawAbiConfigurable) => new Configurable({ types: types2, rawAbiConfigurable })
      );
      return {
        types: types2,
        functions,
        configurables
      };
    }
    computeCommonTypesInUse() {
      const customTypesTable = {
        option: "Option",
        enum: "Enum",
        vector: "Vec",
        result: "Result"
      };
      this.commonTypesInUse = [];
      Object.keys(customTypesTable).forEach((typeName) => {
        const isInUse = !!this.types.find((t) => t.name === typeName);
        if (isInUse) {
          const commonTypeLabel = customTypesTable[typeName];
          this.commonTypesInUse.push(commonTypeLabel);
        }
      });
    }
  };
  var ProgramTypeEnum = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum || {});
  var header_default = "/* Autogenerated file. Do not edit manually. */\n\n/* eslint-disable max-classes-per-file */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/consistent-type-imports */\n\n\n/*\n  Fuels version: {{FUELS}}\n{{#if FORC}}\n  Forc version: {{FORC}}\n{{/if}}\n{{#if FUEL_CORE}}\n  Fuel-Core version: {{FUEL_CORE}}\n{{/if}}\n*/\n";
  function renderHbsTemplate(params) {
    const { data, template, versions: versions2 } = params;
    const options = {
      strict: true,
      noEscape: true
    };
    const renderTemplate = import_handlebars.default.compile(template, options);
    const renderHeaderTemplate = import_handlebars.default.compile(header_default, options);
    const text = renderTemplate({
      ...data,
      header: renderHeaderTemplate(versions2)
    });
    return text.replace(/[\n]{3,}/gm, "\n\n");
  }
  var common_default = "{{header}}\n\n/**\n * Mimics Sway Enum.\n * Requires one and only one Key-Value pair and raises error if more are provided.\n */\nexport type Enum<T> = {\n  [K in keyof T]: Pick<T, K> & { [P in Exclude<keyof T, K>]?: never };\n}[keyof T];\n\n/**\n * Mimics Sway Option and Vectors.\n * Vectors are treated like arrays in Typescript.\n */\nexport type Option<T> = T | undefined;\n\nexport type Vec<T> = T[];\n\n/**\n * Mimics Sway Result enum type.\n * Ok represents the success case, while Err represents the error case.\n */\nexport type Result<T, E> = Enum<{Ok: T, Err: E}>;\n";
  function renderCommonTemplate(params) {
    const { versions: versions2 } = params;
    const text = renderHbsTemplate({ template: common_default, versions: versions2 });
    return text;
  }
  var common_default2 = "{{header}}\n\n{{#each members}}\nexport { {{this}} } from './{{this}}';\n{{/each}}\n";
  function renderIndexTemplate(params) {
    const { files, versions: versions2 } = params;
    const members = files.map((f2) => f2.path.match(/([^/]+)\.ts$/m)?.[1]);
    const text = renderHbsTemplate({
      template: common_default2,
      versions: versions2,
      data: {
        members
      }
    });
    return text;
  }
  var factory_default = '{{header}}\n\nimport { ContractFactory, decompressBytecode } from "fuels";\nimport type { Provider, Account, DeployContractOptions } from "fuels";\n\nimport { {{capitalizedName}} } from "./{{capitalizedName}}";\n\nconst bytecode = decompressBytecode("{{compressedBytecode}}");\n\nexport class {{capitalizedName}}Factory extends ContractFactory<{{capitalizedName}}> {\n\n  static readonly bytecode = bytecode;\n\n  constructor(accountOrProvider: Account | Provider) {\n    super(\n      bytecode,\n      {{capitalizedName}}.abi,\n      accountOrProvider,\n      {{capitalizedName}}.storageSlots\n    );\n  }\n\n  static deploy (\n    wallet: Account,\n    options: DeployContractOptions = {}\n  ) {\n    const factory = new {{capitalizedName}}Factory(wallet);\n    return factory.deploy(options);\n  }\n}\n';
  function renderFactoryTemplate(params) {
    const { versions: versions2, abi: abi2 } = params;
    const {
      camelizedName,
      capitalizedName,
      rawContents,
      storageSlotsContents,
      hexlifiedBinContents: hexlifiedBinString
    } = abi2;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate({
      template: factory_default,
      versions: versions2,
      data: {
        camelizedName,
        capitalizedName,
        abiJsonString,
        storageSlotsJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString)
      }
    });
    return text;
  }
  function formatEnums(params) {
    const { types: types2 } = params;
    const enums = types2.filter((t) => t.name === "enum").map((t) => {
      const et2 = t;
      const structName = et2.getStructName();
      const inputValues = et2.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = et2.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const inputNativeValues = et2.getNativeEnum({ types: types2 });
      const outputNativeValues = et2.getNativeEnum({ types: types2 });
      const typeAnnotations = et2.getStructDeclaration({ types: types2 });
      return {
        structName,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues,
        // reduces duplication
        inputNativeValues,
        outputNativeValues,
        typeAnnotations
      };
    }).sort((a, b) => a.structName < b.structName ? -1 : 1);
    return { enums };
  }
  var caseInsensitiveSort = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
  function formatImports(params) {
    const { types: types2, baseMembers = [] } = params;
    const members = types2.flatMap((t) => t.requiredFuelsMembersImports);
    const imports = uniq_default(baseMembers.concat(members).sort(caseInsensitiveSort));
    return {
      imports: imports.length ? imports : void 0
    };
  }
  function formatStructs(params) {
    const { types: types2 } = params;
    const structs = types2.filter((t) => t.name === "struct").map((t) => {
      const st = t;
      const structName = st.getStructName();
      const inputValues = st.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = st.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const typeAnnotations = st.getStructDeclaration({ types: types2 });
      return {
        structName,
        typeAnnotations,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues
        // reduces duplication
      };
    }).sort((a, b) => a.structName < b.structName ? -1 : 1);
    return { structs };
  }
  var main_default = `{{header}}

import { Contract, Interface } from "fuels";
{{#if imports}}
import type {
  Provider,
  Account,
  StorageSlot,
  Address,
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
{{#each configurables}}
  {{name}}: {{inputLabel}};
{{/each}}
}>;
{{/if}}

const abi = {{abiJsonString}};

const storageSlots: StorageSlot[] = {{storageSlotsJsonString}};

export class {{capitalizedName}}Interface extends Interface {
  constructor() {
    super(abi);
  }

  declare functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };
}

export class {{capitalizedName}} extends Contract {
  static readonly abi = abi;
  static readonly storageSlots = storageSlots;

  declare interface: {{capitalizedName}}Interface;
  declare functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };

  constructor(
    id: string | Address,
    accountOrProvider: Account | Provider,
  ) {
    super(id, abi, accountOrProvider);
  }
}
`;
  function renderMainTemplate(params) {
    const { versions: versions2, abi: abi2 } = params;
    const { camelizedName, capitalizedName, types: types2, functions, commonTypesInUse, configurables } = abi2;
    const functionsTypedefs = functions.map((f2) => f2.getDeclaration());
    const functionsFragments = functions.map((f2) => f2.name);
    const encoders = functions.map((f2) => ({
      functionName: f2.name,
      input: f2.attributes.inputs
    }));
    const decoders = functions.map((f2) => ({
      functionName: f2.name
    }));
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: ["FunctionFragment", "InvokeFunction"]
    });
    const { rawContents, storageSlotsContents } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate({
      template: main_default,
      versions: versions2,
      data: {
        camelizedName,
        capitalizedName,
        commonTypesInUse: commonTypesInUse.join(", "),
        functionsTypedefs,
        functionsFragments,
        encoders,
        decoders,
        structs,
        enums,
        imports,
        abiJsonString,
        storageSlotsJsonString,
        configurables
      }
    });
    return text;
  }
  function assembleContracts(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi2) => {
      const { capitalizedName } = abi2;
      const mainFilepath = `${outputDir}/${capitalizedName}.ts`;
      const factoryFilepath = `${outputDir}/${capitalizedName}Factory.ts`;
      const main = {
        path: mainFilepath,
        contents: renderMainTemplate({ abi: abi2, versions: versions2 })
      };
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate({ abi: abi2, versions: versions2 })
      };
      files.push(main);
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path11.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }
  var main_default2 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
  {{#each configurables}}
    {{name}}: {{inputLabel}};
  {{/each}}
}>;
{{else}}
export type {{capitalizedName}}Configurables = undefined;
{{/if}}

export type {{capitalizedName}}Inputs = [{{inputs}}];

export type {{capitalizedName}}Parameters = Omit<
  PredicateParams<{{capitalizedName}}Inputs, {{capitalizedName}}Configurables>,
  'abi' | 'bytecode'
>;

const abi = {{abiJsonString}};

const bytecode = decompressBytecode('{{compressedBytecode}}');

export class {{capitalizedName}} extends Predicate<
  {{capitalizedName}}Inputs,
  {{capitalizedName}}Configurables
> {
  static readonly abi = abi;
  static readonly bytecode = bytecode;

  constructor(params: {{capitalizedName}}Parameters) {
    super({ abi, bytecode, ...params });
  }
}
`;
  function renderMainTemplate2(params) {
    const { abi: abi2, versions: versions2 } = params;
    const { types: types2, configurables } = abi2;
    const {
      rawContents,
      capitalizedName,
      hexlifiedBinContents: hexlifiedBinString,
      commonTypesInUse
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi2.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: ["Predicate", "Provider", "InputValue", "PredicateParams", "decompressBytecode"]
    });
    const { prefixedInputs: inputs, output: output2 } = func.attributes;
    const text = renderHbsTemplate({
      template: main_default2,
      versions: versions2,
      data: {
        inputs,
        output: output2,
        structs,
        enums,
        abiJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString),
        capitalizedName,
        imports,
        configurables,
        commonTypesInUse: commonTypesInUse.join(", ")
      }
    });
    return text;
  }
  function assemblePredicates(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi2) => {
      const { capitalizedName: name } = abi2;
      const factoryFilepath = `${outputDir}/${name}.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderMainTemplate2({ abi: abi2, versions: versions2 })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path12.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }
  var main_default3 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

export type {{capitalizedName}}Inputs = [{{inputs}}];
export type {{capitalizedName}}Output = {{output}};

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
{{#each configurables}}
  {{name}}: {{inputLabel}};
{{/each}}
}>;
{{/if}}

const abi = {{abiJsonString}};

const bytecode = decompressBytecode('{{compressedBytecode}}');

export class {{capitalizedName}} extends Script<{{capitalizedName}}Inputs, {{capitalizedName}}Output> {

  static readonly abi = abi;
  static readonly bytecode = bytecode;

  constructor(wallet: Account) {
    super(bytecode, abi, wallet);
  }
}
`;
  function renderMainTemplate3(params) {
    const { abi: abi2, versions: versions2 } = params;
    const { types: types2, configurables } = abi2;
    const {
      rawContents,
      capitalizedName,
      hexlifiedBinContents: hexlifiedBinString,
      commonTypesInUse
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi2.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: ["Script", "Account", "decompressBytecode"]
    });
    const { prefixedInputs: inputs, output: output2 } = func.attributes;
    const text = renderHbsTemplate({
      template: main_default3,
      versions: versions2,
      data: {
        inputs,
        output: output2,
        structs,
        enums,
        abiJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString),
        capitalizedName,
        imports,
        configurables,
        commonTypesInUse: commonTypesInUse.join(", ")
      }
    });
    return text;
  }
  function assembleScripts(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi2) => {
      const { capitalizedName } = abi2;
      const factoryFilepath = `${outputDir}/${capitalizedName}.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderMainTemplate3({ abi: abi2, versions: versions2 })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path13.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }
  var upperFirst = (s) => s[0].toUpperCase() + s.slice(1);
  function validateBinFile(params) {
    const { abiFilepath, binFilepath, binExists, programType } = params;
    const isScript = programType === "script";
    if (!binExists && isScript) {
      throw new FuelError(
        ErrorCode.BIN_FILE_NOT_FOUND,
        [
          `Could not find BIN file for counterpart ${upperFirst(programType)} ABI.`,
          `  - ABI: ${abiFilepath}`,
          `  - BIN: ${binFilepath}`,
          programType
        ].join("\n")
      );
    }
  }
  var AbiTypeGen = class {
    abis;
    abiFiles;
    binFiles;
    storageSlotsFiles;
    outputDir;
    files;
    versions;
    constructor(params) {
      const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles, versions: versions2 } = params;
      this.outputDir = outputDir;
      this.abiFiles = abiFiles;
      this.binFiles = binFiles;
      this.storageSlotsFiles = storageSlotsFiles;
      this.versions = versions2;
      this.abis = this.abiFiles.map((abiFile) => {
        const binFilepath = abiFile.path.replace("-abi.json", ".bin");
        const relatedBinFile = this.binFiles.find(({ path: path6 }) => path6 === binFilepath);
        const storageSlotFilepath = abiFile.path.replace("-abi.json", "-storage_slots.json");
        const relatedStorageSlotsFile = this.storageSlotsFiles.find(
          ({ path: path6 }) => path6 === storageSlotFilepath
        );
        if (!relatedBinFile) {
          validateBinFile({
            abiFilepath: abiFile.path,
            binExists: !!relatedBinFile,
            binFilepath,
            programType
          });
        }
        const abi2 = new Abi({
          filepath: abiFile.path,
          rawContents: JSON.parse(abiFile.contents),
          hexlifiedBinContents: relatedBinFile?.contents,
          storageSlotsContents: relatedStorageSlotsFile?.contents,
          outputDir,
          programType
        });
        return abi2;
      });
      this.files = this.getAssembledFiles({ programType });
    }
    getAssembledFiles(params) {
      const { abis, outputDir, versions: versions2 } = this;
      const { programType } = params;
      switch (programType) {
        case "contract":
          return assembleContracts({ abis, outputDir, versions: versions2 });
        case "script":
          return assembleScripts({ abis, outputDir, versions: versions2 });
        case "predicate":
          return assemblePredicates({ abis, outputDir, versions: versions2 });
        default:
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(
              ProgramTypeEnum
            )}`
          );
      }
    }
  };
  var collectBinFilepaths = (params) => {
    const { filepaths, programType } = params;
    const binFiles = filepaths.map((abiFilepath) => {
      const binFilepath = abiFilepath.replace("-abi.json", ".bin");
      const binExists = (0, import_fs15.existsSync)(binFilepath);
      validateBinFile({ abiFilepath, binFilepath, binExists, programType });
      const bin = {
        path: binFilepath,
        contents: hexlify((0, import_fs15.readFileSync)(binFilepath))
      };
      return bin;
    });
    return binFiles;
  };
  var collectStorageSlotsFilepaths = (params) => {
    const { filepaths, programType } = params;
    const storageSlotsFiles = [];
    if (programType !== "contract") {
      return storageSlotsFiles;
    }
    filepaths.forEach((abiFilepath) => {
      const storageSlotsFilepath = abiFilepath.replace("-abi.json", "-storage_slots.json");
      const storageSlotsExists = (0, import_fs16.existsSync)(storageSlotsFilepath);
      if (storageSlotsExists) {
        const storageSlots2 = {
          path: storageSlotsFilepath,
          contents: (0, import_fs16.readFileSync)(storageSlotsFilepath, "utf-8")
        };
        storageSlotsFiles.push(storageSlots2);
      }
    });
    return storageSlotsFiles;
  };
  function runTypegen(params) {
    const { cwd, inputs, output: output2, silent, programType, filepaths: inputFilepaths } = params;
    const versions2 = { FUELS: versions.FUELS, ...params.versions };
    const cwdBasename = (0, import_path10.basename)(cwd);
    function log4(...args) {
      if (!silent) {
        console.log(args.join(" "));
      }
    }
    let filepaths = [];
    if (!inputFilepaths?.length && inputs?.length) {
      filepaths = inputs.flatMap((i) => globSync(i, { cwd }));
    } else if (inputFilepaths?.length) {
      filepaths = inputFilepaths;
    } else {
      throw new FuelError(
        ErrorCode.MISSING_REQUIRED_PARAMETER,
        `At least one parameter should be supplied: 'input' or 'filepaths'.`
      );
    }
    const abiFiles = filepaths.map((filepath) => {
      const contents = (0, import_fs14.readFileSync)(filepath, "utf-8");
      const abi2 = {
        path: filepath,
        contents
      };
      return abi2;
    });
    if (!abiFiles.length) {
      throw new FuelError(ErrorCode.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);
    }
    const binFiles = collectBinFilepaths({ filepaths, programType });
    const storageSlotsFiles = collectStorageSlotsFilepaths({ filepaths, programType });
    const abiTypeGen = new AbiTypeGen({
      outputDir: output2,
      abiFiles,
      binFiles,
      storageSlotsFiles,
      programType,
      versions: versions2
    });
    log4("Generating files..\n");
    mkdirp.sync(`${output2}`);
    abiTypeGen.files.forEach((file) => {
      rimrafSync(file.path);
      (0, import_fs14.writeFileSync)(file.path, file.contents);
      const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, "m");
      log4(` - ${file.path.replace(trimPathRegex, "")}`);
    });
    log4("\nDone.\u26A1");
  }
  function resolveProgramType(params) {
    const { contract, script, predicate } = params;
    const noneSpecified = !contract && !script && !predicate;
    if (contract || noneSpecified) {
      return "contract";
    }
    if (predicate) {
      return "predicate";
    }
    return "script";
  }
  function runCliAction(options) {
    const { inputs, output: output2, silent, contract, script, predicate } = options;
    const cwd = process.cwd();
    const programType = resolveProgramType({ contract, script, predicate });
    try {
      runTypegen({
        cwd,
        inputs,
        output: output2,
        programType,
        silent: !!silent
      });
    } catch (err2) {
      console.log(`error: ${err2.message}`);
      process.exit(1);
    }
  }
  function configureCliOptions(program2) {
    return program2.requiredOption("-i, --inputs <path|glob...>", "Input paths/globals to your ABI JSON files").requiredOption("-o, --output <dir>", "Directory path for generated files").addOption(
      new Option("-c, --contract", "Generate types for Contracts [default]").conflicts(["script", "predicate"]).implies({ script: void 0, predicate: void 0 })
    ).addOption(
      new Option("-s, --script", "Generate types for Scripts").conflicts(["contract", "predicate"]).implies({ contract: void 0, predicate: void 0 })
    ).addOption(
      new Option("-p, --predicate", "Generate types for Predicates").conflicts(["contract", "script"]).implies({ contract: void 0, script: void 0 })
    ).option("-S, --silent", "Omit output messages").action(runCliAction);
  }

  // ../versions/dist/cli.mjs
  var import_chalk2 = __toESM(require_source(), 1);
  var import_cli_table = __toESM(require_lib2(), 1);
  var import_chalk3 = __toESM(require_source(), 1);
  var import_child_process = __require2("child_process");
  var colorizeUserVersion = (params) => {
    const { version: version3, isGt, isOk } = params;
    if (isGt) {
      return import_chalk3.default.cyan(version3);
    }
    if (isOk) {
      return import_chalk3.default.green(version3);
    }
    return import_chalk3.default.red(version3);
  };
  function getBuiltinVersions2() {
    return {
      FORC: "0.66.5",
      FUEL_CORE: "0.40.2",
      FUELS: "0.98.0"
    };
  }
  function parseVersion2(version3) {
    const [major2, minor2, patch] = version3.split(".").map((v) => parseInt(v, 10));
    return { major: major2, minor: minor2, patch };
  }
  function versionDiffs2(version1, version22) {
    const semver1 = parseVersion2(version1);
    const semver2 = parseVersion2(version22);
    const major2 = semver1.major - semver2.major;
    const minor2 = semver1.minor - semver2.minor;
    const patch = semver1.patch - semver2.patch;
    return {
      major: major2,
      minor: minor2,
      patch,
      fullVersionDiff: major2 || minor2 || patch
    };
  }
  function gt2(version1, version22) {
    const { fullVersionDiff } = versionDiffs2(version1, version22);
    return fullVersionDiff > 0;
  }
  function eq2(version1, version22) {
    const { fullVersionDiff } = versionDiffs2(version1, version22);
    return fullVersionDiff === 0;
  }
  function compareSystemVersions(params) {
    const { systemForcVersion, systemFuelCoreVersion } = params;
    const versions2 = getBuiltinVersions2();
    const systemForcIsGt = gt2(systemForcVersion, versions2.FORC);
    const systemFuelCoreIsGt = gt2(systemFuelCoreVersion, versions2.FUEL_CORE);
    const systemForcIsEq = eq2(systemForcVersion, versions2.FORC);
    const systemFuelCoreIsEq = eq2(systemFuelCoreVersion, versions2.FUEL_CORE);
    const systemForcIsLt = !systemForcIsGt && !systemForcIsEq;
    const systemFuelCoreIsLt = !systemFuelCoreIsGt && !systemFuelCoreIsEq;
    return {
      systemForcIsGt,
      systemFuelCoreIsGt,
      systemForcIsEq,
      systemFuelCoreIsEq,
      systemForcIsLt,
      systemFuelCoreIsLt
    };
  }
  var fuelUpLink = "https://github.com/fuellabs/fuelup";
  var versionReg = /[0-9]+\.[0-9]+\.[0-9]/;
  var defaultForcCommand = "forc";
  var defaultFuelCoreCommand = "fuel-core";
  var getSystemVersion = (command) => {
    let version3 = null;
    let error3 = null;
    try {
      const contents = (0, import_child_process.execSync)(command, {
        stdio: ["pipe", "pipe", "ignore"],
        encoding: "utf8"
      }).toString();
      if (versionReg.test(contents)) {
        version3 = contents.match(versionReg)?.[0];
      } else {
        throw new Error(contents);
      }
    } catch (err2) {
      error3 = err2;
    }
    return {
      error: error3,
      version: version3
    };
  };
  function getSystemForc(forcPath = defaultForcCommand) {
    const { error: error3, version: v } = getSystemVersion(`${forcPath} --version`);
    return { error: error3, systemForcVersion: v, systemForcPath: forcPath };
  }
  function getSystemFuelCore(fuelCorePath = defaultFuelCoreCommand) {
    const { error: error3, version: v } = getSystemVersion(`${fuelCorePath} --version`);
    return { error: error3, systemFuelCoreVersion: v, systemFuelCorePath: fuelCorePath };
  }
  function getSystemVersions(params = {}) {
    const { forcPath, fuelCorePath } = params;
    const { error: errorForc, systemForcVersion, systemForcPath } = getSystemForc(forcPath);
    const {
      error: errorCore,
      systemFuelCoreVersion,
      systemFuelCorePath
    } = getSystemFuelCore(fuelCorePath);
    const error3 = errorForc ?? errorCore;
    return {
      error: error3,
      systemForcVersion,
      systemForcPath,
      systemFuelCoreVersion,
      systemFuelCorePath
    };
  }
  var getBinaryVersions = (params = {}) => {
    const { FUELS } = getBuiltinVersions2();
    const { systemForcVersion, systemFuelCoreVersion } = getSystemVersions(params);
    return {
      FUELS,
      FORC: systemForcVersion ?? void 0,
      FUEL_CORE: systemFuelCoreVersion ?? void 0
    };
  };
  var eitherOr = (val1, val2) => val1 ?? val2;
  function runVersions(params = {}) {
    const { error: error3, info } = console;
    const supportedVersions = getBuiltinVersions2();
    const cliTable = new import_cli_table.default({
      head: ["", import_chalk2.default.bold("Supported"), import_chalk2.default.bold(`Yours / System`), import_chalk2.default.bold("System Path")]
    });
    const {
      error: systemError,
      systemForcVersion,
      systemFuelCoreVersion,
      systemForcPath,
      systemFuelCorePath
    } = getSystemVersions(params);
    const comparisons = compareSystemVersions({
      systemForcVersion: eitherOr(systemForcVersion, "0"),
      systemFuelCoreVersion: eitherOr(systemFuelCoreVersion, "0")
    });
    const userForcColorized = colorizeUserVersion({
      version: eitherOr(systemForcVersion, "\u2014"),
      isGt: comparisons.systemForcIsGt,
      isOk: comparisons.systemForcIsEq
    });
    const userFuelCoreColorized = colorizeUserVersion({
      version: eitherOr(systemFuelCoreVersion, "\u2014"),
      isGt: comparisons.systemFuelCoreIsGt,
      isOk: comparisons.systemFuelCoreIsEq
    });
    cliTable.push(["Forc", supportedVersions.FORC, userForcColorized, systemForcPath]);
    cliTable.push([
      "Fuel-Core",
      supportedVersions.FUEL_CORE,
      userFuelCoreColorized,
      systemFuelCorePath
    ]);
    const someIsGt = comparisons.systemForcIsGt || comparisons.systemFuelCoreIsGt;
    const bothAreExact = comparisons.systemForcIsEq && comparisons.systemFuelCoreIsEq;
    let exitCode;
    if (someIsGt) {
      exitCode = 0;
      info(cliTable.toString());
      info(`
Your system's components are newer than the ones supported!`);
    } else if (bothAreExact) {
      exitCode = 0;
      info(cliTable.toString());
      info(`
You have all the right versions! \u26A1`);
    } else if (systemError) {
      exitCode = 1;
      error3(cliTable.toString());
      error3("\n - Make sure you have Forc and Fuel-Core installed");
      error3("   >> Error: ", systemError.message);
    } else {
      exitCode = 1;
      error3(cliTable.toString());
      error3(`
 - You're using outdated versions`);
    }
    if (exitCode === 1) {
      error3(`  ${import_chalk2.default.green(fuelUpLink)}`);
    }
    process.exit(exitCode);
  }

  // ../abi-typegen/dist/index.mjs
  var import_handlebars2 = __toESM(require_lib(), 1);
  var __defProp5 = Object.defineProperty;
  var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField5 = (obj, key, value) => {
    __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var AType2 = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _EmptyType2 = class extends AType2 {
    name = "empty";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: "undefined",
        outputLabel: "void"
      };
    }
    static isSuitableFor(params) {
      return _EmptyType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var EmptyType2 = _EmptyType2;
  __publicField5(EmptyType2, "swayType", "()");
  __publicField5(EmptyType2, "MATCH_REGEX", /^\(\)$/m);
  var _OptionType2 = class extends AType2 {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType2 = _OptionType2;
  __publicField5(OptionType2, "swayType", "enum Option");
  __publicField5(OptionType2, "MATCH_REGEX", /^enum (std::option::)?Option$/m);
  function findType2(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  function parseTypeArguments2(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType2({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      const currentTypeId = typeArgument.type;
      const currentType = findType2({ types: types2, typeId: currentTypeId });
      const currentLabel = currentType.attributes[attributeKey];
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments2({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output2 = buffer.join(", ");
    if (parentLabel) {
      output2 = `${parentLabel}<${output2}>`;
    }
    return output2;
  }
  var _ArrayType2 = class extends AType2 {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType2.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType2({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType2 = _ArrayType2;
  __publicField5(ArrayType2, "swayType", "[_; 2]");
  __publicField5(ArrayType2, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType2 = class extends AType2 {
    name = "str";
    static isSuitableFor(params) {
      return _StrType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType2 = _StrType2;
  __publicField5(StrType2, "swayType", "str[3]");
  __publicField5(StrType2, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type2 = class extends StrType2 {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type2.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type2 = _B256Type2;
  __publicField5(B256Type2, "swayType", "b256");
  __publicField5(B256Type2, "MATCH_REGEX", /^b256$/m);
  var _B512Type2 = class extends B256Type2 {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type2.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type2 = _B512Type2;
  __publicField5(B512Type2, "swayType", "struct B512");
  __publicField5(B512Type2, "MATCH_REGEX", /^struct (std::b512::)?B512$/m);
  var _BoolType2 = class extends AType2 {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType2 = _BoolType2;
  __publicField5(BoolType2, "swayType", "bool");
  __publicField5(BoolType2, "MATCH_REGEX", /^bool$/m);
  var _BytesType2 = class extends ArrayType2 {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType2 = _BytesType2;
  __publicField5(BytesType2, "swayType", "struct Bytes");
  __publicField5(BytesType2, "MATCH_REGEX", /^struct (std::bytes::)?Bytes/m);
  function extractStructName2(params) {
    const { rawAbiType, regex } = params;
    const matches = rawAbiType.type.match(regex);
    const match3 = matches?.[2] ?? matches?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _ResultType2 = class extends AType2 {
    name = "result";
    static isSuitableFor(params) {
      return _ResultType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Result`,
        outputLabel: `Result`
      };
      return this.attributes;
    }
  };
  var ResultType2 = _ResultType2;
  __publicField5(ResultType2, "swayType", "enum Result");
  __publicField5(ResultType2, "MATCH_REGEX", /^enum (std::result::)?Result$/m);
  var _EnumType2 = class extends AType2 {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType2.IGNORE_REGEXES.some((r) => r.test(params.type));
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _EnumType2.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash3, row) => ({
          ...hash3,
          [row.rawAbiType.typeId]: row.rawAbiType.type
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => typeHash[type3] === EmptyType2.swayType)) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const type3 = findType2({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments2({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return contents.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType2({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var EnumType2 = _EnumType2;
  __publicField5(EnumType2, "swayType", "enum MyEnumName");
  __publicField5(EnumType2, "MATCH_REGEX", /^enum (.+::)?(.+)$/m);
  __publicField5(EnumType2, "IGNORE_REGEXES", [OptionType2.MATCH_REGEX, ResultType2.MATCH_REGEX]);
  var _EvmAddressType2 = class extends AType2 {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType2 = _EvmAddressType2;
  __publicField5(EvmAddressType2, "swayType", "struct EvmAddress");
  __publicField5(EvmAddressType2, "MATCH_REGEX", /^struct (std::vm::evm::evm_address::)?EvmAddress$/m);
  var _GenericType2 = class extends AType2 {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType2.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _GenericType2.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType2 = _GenericType2;
  __publicField5(GenericType2, "swayType", "generic T");
  __publicField5(GenericType2, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _U8Type2 = class extends AType2 {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type2 = _U8Type2;
  __publicField5(U8Type2, "swayType", "u8");
  __publicField5(U8Type2, "MATCH_REGEX", /^u8$/m);
  var _U64Type2 = class extends U8Type2 {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type2 = _U64Type2;
  __publicField5(U64Type2, "swayType", "u64");
  __publicField5(U64Type2, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr2 = class extends U64Type2 {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr2.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr2 = _RawUntypedPtr2;
  __publicField5(RawUntypedPtr2, "swayType", "raw untyped ptr");
  __publicField5(RawUntypedPtr2, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice2 = class extends ArrayType2 {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice2 = _RawUntypedSlice2;
  __publicField5(RawUntypedSlice2, "swayType", "raw untyped slice");
  __publicField5(RawUntypedSlice2, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType2 = class extends AType2 {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType2 = _StdStringType2;
  __publicField5(StdStringType2, "swayType", "struct String");
  __publicField5(StdStringType2, "MATCH_REGEX", /^struct (std::string::)?String/m);
  var _StrSliceType2 = class extends AType2 {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StrSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StrSliceType2 = _StrSliceType2;
  __publicField5(StrSliceType2, "swayType", "str");
  __publicField5(StrSliceType2, "MATCH_REGEX", /^str$/m);
  var _StructType2 = class extends AType2 {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType2.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _StructType2.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType2({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments2({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType2({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType2 = _StructType2;
  __publicField5(StructType2, "swayType", "struct MyStruct");
  __publicField5(StructType2, "MATCH_REGEX", /^struct (.+::)?(.+)$/m);
  __publicField5(StructType2, "IGNORE_REGEX", /^struct (std::.*)?(Vec|RawVec|EvmAddress|Bytes|String|RawBytes)$/m);
  var _TupleType2 = class extends AType2 {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType2({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType2 = _TupleType2;
  __publicField5(TupleType2, "swayType", "(_, _, _)");
  __publicField5(TupleType2, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type2 = class extends U8Type2 {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type2 = _U16Type2;
  __publicField5(U16Type2, "swayType", "u16");
  __publicField5(U16Type2, "MATCH_REGEX", /^u16$/m);
  var _U256Type2 = class extends U64Type2 {
    name = "u256";
    static isSuitableFor(params) {
      return _U256Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U256Type2 = _U256Type2;
  __publicField5(U256Type2, "swayType", "u256");
  __publicField5(U256Type2, "MATCH_REGEX", /^u256$/m);
  var _U32Type2 = class extends U8Type2 {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type2 = _U32Type2;
  __publicField5(U32Type2, "swayType", "u32");
  __publicField5(U32Type2, "MATCH_REGEX", /^u32$/m);
  var _VectorType2 = class extends ArrayType2 {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType2.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType2 = _VectorType2;
  __publicField5(VectorType2, "swayType", "struct Vec");
  __publicField5(VectorType2, "MATCH_REGEX", /^struct (std::vec::)?Vec/m);
  __publicField5(VectorType2, "IGNORE_REGEX", /^struct (std::vec::)?RawVec$/m);
  var ProgramTypeEnum2 = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum2 || {});

  // ../abi-typegen/dist/runTypegen.mjs
  var import_fs17 = __require2("fs");
  var import_path14 = __require2("path");
  var import_path15 = __require2("path");
  var import_handlebars3 = __toESM(require_lib(), 1);
  var import_path16 = __require2("path");
  var import_path17 = __require2("path");
  var import_fs18 = __require2("fs");
  var import_fs19 = __require2("fs");
  var __defProp6 = Object.defineProperty;
  var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField6 = (obj, key, value) => {
    __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var AType3 = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _EmptyType3 = class extends AType3 {
    name = "empty";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: "undefined",
        outputLabel: "void"
      };
    }
    static isSuitableFor(params) {
      return _EmptyType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var EmptyType3 = _EmptyType3;
  __publicField6(EmptyType3, "swayType", "()");
  __publicField6(EmptyType3, "MATCH_REGEX", /^\(\)$/m);
  var _OptionType3 = class extends AType3 {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType3 = _OptionType3;
  __publicField6(OptionType3, "swayType", "enum Option");
  __publicField6(OptionType3, "MATCH_REGEX", /^enum (std::option::)?Option$/m);
  function findType3(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  var getFunctionInputs2 = (params) => {
    const { types: types2, inputs } = params;
    let isMandatory = false;
    return inputs.reduceRight((result, input) => {
      const type3 = findType3({ types: types2, typeId: input.type });
      const isTypeMandatory = !EmptyType3.isSuitableFor({ type: type3.rawAbiType.type }) && !OptionType3.isSuitableFor({ type: type3.rawAbiType.type });
      isMandatory = isMandatory || isTypeMandatory;
      return [{ ...input, isOptional: !isMandatory }, ...result];
    }, []);
  };
  function parseTypeArguments3(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType3({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      const currentTypeId = typeArgument.type;
      const currentType = findType3({ types: types2, typeId: currentTypeId });
      const currentLabel = currentType.attributes[attributeKey];
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments3({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output2 = buffer.join(", ");
    if (parentLabel) {
      output2 = `${parentLabel}<${output2}>`;
    }
    return output2;
  }
  function resolveInputLabel2(types2, typeId, typeArguments) {
    const type3 = findType3({ types: types2, typeId });
    let typeDecl;
    if (typeArguments?.length) {
      typeDecl = parseTypeArguments3({
        types: types2,
        target: "input",
        parentTypeId: typeId,
        typeArguments
      });
    } else {
      typeDecl = type3.attributes.inputLabel;
    }
    return typeDecl;
  }
  var Function3 = class {
    name;
    types;
    rawAbiFunction;
    attributes;
    constructor(params) {
      this.rawAbiFunction = params.rawAbiFunction;
      this.types = params.types;
      this.name = params.rawAbiFunction.name;
      this.attributes = {
        inputs: this.bundleInputTypes(),
        output: this.bundleOutputTypes(),
        prefixedInputs: this.bundleInputTypes(true)
      };
    }
    bundleInputTypes(shouldPrefixParams = false) {
      const { types: types2 } = this;
      const inputs = getFunctionInputs2({ types: types2, inputs: this.rawAbiFunction.inputs }).map(
        ({ isOptional, ...input }) => {
          const { name, type: typeId, typeArguments } = input;
          const typeDecl = resolveInputLabel2(types2, typeId, typeArguments);
          if (shouldPrefixParams) {
            const optionalSuffix = isOptional ? "?" : "";
            return `${name}${optionalSuffix}: ${typeDecl}`;
          }
          return typeDecl;
        }
      );
      return inputs.join(", ");
    }
    bundleOutputTypes() {
      return parseTypeArguments3({
        types: this.types,
        target: "output",
        typeArguments: [this.rawAbiFunction.output]
      });
    }
    getDeclaration() {
      const { name } = this;
      const { prefixedInputs, output: output2 } = this.attributes;
      const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output2}>`;
      return decl;
    }
  };
  function makeFunction2(params) {
    const { types: types2, rawAbiFunction } = params;
    return new Function3({ types: types2, rawAbiFunction });
  }
  function parseFunctions2(params) {
    const { types: types2, rawAbiFunctions } = params;
    const functions = rawAbiFunctions.map(
      (rawAbiFunction) => makeFunction2({ types: types2, rawAbiFunction })
    );
    return functions;
  }
  var _ArrayType3 = class extends AType3 {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType3.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType3({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType3 = _ArrayType3;
  __publicField6(ArrayType3, "swayType", "[_; 2]");
  __publicField6(ArrayType3, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType3 = class extends AType3 {
    name = "str";
    static isSuitableFor(params) {
      return _StrType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType3 = _StrType3;
  __publicField6(StrType3, "swayType", "str[3]");
  __publicField6(StrType3, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type3 = class extends StrType3 {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type3.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type3 = _B256Type3;
  __publicField6(B256Type3, "swayType", "b256");
  __publicField6(B256Type3, "MATCH_REGEX", /^b256$/m);
  var _B512Type3 = class extends B256Type3 {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type3.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type3 = _B512Type3;
  __publicField6(B512Type3, "swayType", "struct B512");
  __publicField6(B512Type3, "MATCH_REGEX", /^struct (std::b512::)?B512$/m);
  var _BoolType3 = class extends AType3 {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType3 = _BoolType3;
  __publicField6(BoolType3, "swayType", "bool");
  __publicField6(BoolType3, "MATCH_REGEX", /^bool$/m);
  var _BytesType3 = class extends ArrayType3 {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType3 = _BytesType3;
  __publicField6(BytesType3, "swayType", "struct Bytes");
  __publicField6(BytesType3, "MATCH_REGEX", /^struct (std::bytes::)?Bytes/m);
  function extractStructName3(params) {
    const { rawAbiType, regex } = params;
    const matches = rawAbiType.type.match(regex);
    const match3 = matches?.[2] ?? matches?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _ResultType3 = class extends AType3 {
    name = "result";
    static isSuitableFor(params) {
      return _ResultType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Result`,
        outputLabel: `Result`
      };
      return this.attributes;
    }
  };
  var ResultType3 = _ResultType3;
  __publicField6(ResultType3, "swayType", "enum Result");
  __publicField6(ResultType3, "MATCH_REGEX", /^enum (std::result::)?Result$/m);
  var _EnumType3 = class extends AType3 {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType3.IGNORE_REGEXES.some((r) => r.test(params.type));
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _EnumType3.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash3, row) => ({
          ...hash3,
          [row.rawAbiType.typeId]: row.rawAbiType.type
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => typeHash[type3] === EmptyType3.swayType)) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const type3 = findType3({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments3({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return contents.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType3({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var EnumType3 = _EnumType3;
  __publicField6(EnumType3, "swayType", "enum MyEnumName");
  __publicField6(EnumType3, "MATCH_REGEX", /^enum (.+::)?(.+)$/m);
  __publicField6(EnumType3, "IGNORE_REGEXES", [OptionType3.MATCH_REGEX, ResultType3.MATCH_REGEX]);
  var _EvmAddressType3 = class extends AType3 {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType3 = _EvmAddressType3;
  __publicField6(EvmAddressType3, "swayType", "struct EvmAddress");
  __publicField6(EvmAddressType3, "MATCH_REGEX", /^struct (std::vm::evm::evm_address::)?EvmAddress$/m);
  var _GenericType3 = class extends AType3 {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType3.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _GenericType3.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType3 = _GenericType3;
  __publicField6(GenericType3, "swayType", "generic T");
  __publicField6(GenericType3, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _U8Type3 = class extends AType3 {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type3 = _U8Type3;
  __publicField6(U8Type3, "swayType", "u8");
  __publicField6(U8Type3, "MATCH_REGEX", /^u8$/m);
  var _U64Type3 = class extends U8Type3 {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type3 = _U64Type3;
  __publicField6(U64Type3, "swayType", "u64");
  __publicField6(U64Type3, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr3 = class extends U64Type3 {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr3.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr3 = _RawUntypedPtr3;
  __publicField6(RawUntypedPtr3, "swayType", "raw untyped ptr");
  __publicField6(RawUntypedPtr3, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice3 = class extends ArrayType3 {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice3 = _RawUntypedSlice3;
  __publicField6(RawUntypedSlice3, "swayType", "raw untyped slice");
  __publicField6(RawUntypedSlice3, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType3 = class extends AType3 {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType3 = _StdStringType3;
  __publicField6(StdStringType3, "swayType", "struct String");
  __publicField6(StdStringType3, "MATCH_REGEX", /^struct (std::string::)?String/m);
  var _StrSliceType3 = class extends AType3 {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StrSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StrSliceType3 = _StrSliceType3;
  __publicField6(StrSliceType3, "swayType", "str");
  __publicField6(StrSliceType3, "MATCH_REGEX", /^str$/m);
  var _StructType3 = class extends AType3 {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType3.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _StructType3.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType3({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments3({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType3({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType3 = _StructType3;
  __publicField6(StructType3, "swayType", "struct MyStruct");
  __publicField6(StructType3, "MATCH_REGEX", /^struct (.+::)?(.+)$/m);
  __publicField6(StructType3, "IGNORE_REGEX", /^struct (std::.*)?(Vec|RawVec|EvmAddress|Bytes|String|RawBytes)$/m);
  var _TupleType3 = class extends AType3 {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType3({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType3 = _TupleType3;
  __publicField6(TupleType3, "swayType", "(_, _, _)");
  __publicField6(TupleType3, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type3 = class extends U8Type3 {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type3 = _U16Type3;
  __publicField6(U16Type3, "swayType", "u16");
  __publicField6(U16Type3, "MATCH_REGEX", /^u16$/m);
  var _U256Type3 = class extends U64Type3 {
    name = "u256";
    static isSuitableFor(params) {
      return _U256Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U256Type3 = _U256Type3;
  __publicField6(U256Type3, "swayType", "u256");
  __publicField6(U256Type3, "MATCH_REGEX", /^u256$/m);
  var _U32Type3 = class extends U8Type3 {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type3 = _U32Type3;
  __publicField6(U32Type3, "swayType", "u32");
  __publicField6(U32Type3, "MATCH_REGEX", /^u32$/m);
  var _VectorType3 = class extends ArrayType3 {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType3.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType3 = _VectorType3;
  __publicField6(VectorType3, "swayType", "struct Vec");
  __publicField6(VectorType3, "MATCH_REGEX", /^struct (std::vec::)?Vec/m);
  __publicField6(VectorType3, "IGNORE_REGEX", /^struct (std::vec::)?RawVec$/m);
  var supportedTypes2 = [
    EmptyType3,
    ArrayType3,
    B256Type3,
    B512Type3,
    BoolType3,
    BytesType3,
    EnumType3,
    GenericType3,
    OptionType3,
    RawUntypedPtr3,
    RawUntypedSlice3,
    StdStringType3,
    StrType3,
    StrSliceType3,
    StructType3,
    TupleType3,
    U16Type3,
    U32Type3,
    U64Type3,
    U256Type3,
    U8Type3,
    VectorType3,
    EvmAddressType3,
    ResultType3
  ];
  function makeType2(params) {
    const { rawAbiType } = params;
    const { type: type3 } = rawAbiType;
    const TypeClass = supportedTypes2.find((tc) => tc.isSuitableFor({ type: type3 }));
    if (!TypeClass) {
      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Type not supported: ${type3}`);
    }
    return new TypeClass(params);
  }
  function shouldSkipAbiType2(params) {
    const ignoreList = [
      "struct RawVec",
      "struct std::vec::RawVec",
      "struct RawBytes",
      "struct std::bytes::RawBytes"
    ];
    const shouldSkip = ignoreList.indexOf(params.type) >= 0;
    return shouldSkip;
  }
  function parseTypes2(params) {
    const types2 = [];
    params.rawAbiTypes.forEach((rawAbiType) => {
      const { type: type3 } = rawAbiType;
      const skip = shouldSkipAbiType2({ type: type3 });
      if (!skip) {
        const parsedType = makeType2({ rawAbiType });
        types2.push(parsedType);
      }
    });
    types2.forEach((type3) => {
      type3.parseComponentsAttributes({ types: types2 });
    });
    return types2;
  }
  var findTypeByConcreteId2 = (types2, id) => types2.find((x) => x.concreteTypeId === id);
  var findConcreteTypeById2 = (abi2, id) => abi2.concreteTypes.find((x) => x.concreteTypeId === id);
  function finsertTypeIdByConcreteTypeId2(abi2, types2, id) {
    const concreteType = findConcreteTypeById2(abi2, id);
    if (concreteType.metadataTypeId !== void 0) {
      return concreteType.metadataTypeId;
    }
    const type3 = findTypeByConcreteId2(types2, id);
    if (type3) {
      return type3.typeId;
    }
    types2.push({
      typeId: types2.length,
      type: concreteType.type,
      components: parseComponents2(concreteType.components),
      concreteTypeId: id,
      typeParameters: concreteType.typeParameters ?? null,
      originalConcreteTypeId: concreteType?.concreteTypeId
    });
    return types2.length - 1;
  }
  function parseFunctionTypeArguments2(abi2, types2, concreteType) {
    return concreteType.typeArguments?.map((cTypeId) => {
      const self2 = findConcreteTypeById2(abi2, cTypeId);
      const type3 = !isNaN(cTypeId) ? cTypeId : finsertTypeIdByConcreteTypeId2(abi2, types2, cTypeId);
      return {
        name: "",
        type: type3,
        // originalTypeId: cTypeId,
        typeArguments: parseFunctionTypeArguments2(abi2, types2, self2)
      };
    }) ?? null;
  }
  function parseConcreteType2(abi2, types2, concreteTypeId, name) {
    const type3 = finsertTypeIdByConcreteTypeId2(abi2, types2, concreteTypeId);
    const concrete = findConcreteTypeById2(abi2, concreteTypeId);
    return {
      name: name ?? "",
      type: type3,
      // concreteTypeId,
      typeArguments: parseFunctionTypeArguments2(abi2, types2, concrete)
    };
  }
  function parseComponents2(abi2, types2, components) {
    return components?.map((component) => {
      const { typeId, name, typeArguments } = component;
      const type3 = !isNaN(typeId) ? typeId : finsertTypeIdByConcreteTypeId2(abi2, types2, typeId);
      return {
        name,
        type: type3,
        // originalTypeId: typeId,
        typeArguments: parseComponents2(abi2, types2, typeArguments)
      };
    }) ?? null;
  }
  function transpileAbi2(abi2) {
    if (!abi2.specVersion) {
      return abi2;
    }
    const types2 = [];
    abi2.metadataTypes.forEach((m) => {
      const t = {
        typeId: m.metadataTypeId,
        type: m.type,
        components: m.components ?? (m.type === "()" ? [] : null),
        typeParameters: m.typeParameters ?? null
      };
      types2.push(t);
    });
    types2.forEach((t) => {
      t.components = parseComponents2(abi2, types2, t.components);
    });
    const functions = abi2.functions.map((fn) => {
      const inputs = fn.inputs.map(
        ({ concreteTypeId, name }) => parseConcreteType2(abi2, types2, concreteTypeId, name)
      );
      const output2 = parseConcreteType2(abi2, types2, fn.output, "");
      return { ...fn, inputs, output: output2 };
    });
    const configurables = abi2.configurables.map((conf) => ({
      name: conf.name,
      configurableType: parseConcreteType2(abi2, types2, conf.concreteTypeId),
      offset: conf.offset
    }));
    const loggedTypes = abi2.loggedTypes.map((log4) => ({
      logId: log4.logId,
      loggedType: parseConcreteType2(abi2, types2, log4.concreteTypeId)
    }));
    const transpiled = {
      encoding: abi2.encodingVersion,
      types: types2,
      functions,
      loggedTypes,
      messagesTypes: abi2.messagesTypes,
      configurables
    };
    return transpiled;
  }
  var Configurable2 = class {
    name;
    inputLabel;
    constructor(params) {
      const {
        types: types2,
        rawAbiConfigurable: {
          name,
          configurableType: { type: type3, typeArguments }
        }
      } = params;
      this.name = name;
      this.inputLabel = resolveInputLabel2(types2, type3, typeArguments);
    }
  };
  var Abi2 = class {
    capitalizedName;
    camelizedName;
    programType;
    filepath;
    outputDir;
    commonTypesInUse = [];
    rawContents;
    hexlifiedBinContents;
    storageSlotsContents;
    types;
    functions;
    configurables;
    constructor(params) {
      const {
        filepath,
        outputDir,
        rawContents,
        hexlifiedBinContents,
        programType,
        storageSlotsContents
      } = params;
      const abiNameRegex = /([^/]+)-abi\.json$/m;
      const abiName = filepath.match(abiNameRegex);
      const couldNotParseName = !abiName || abiName.length === 0;
      if (couldNotParseName) {
        throw new FuelError(
          ErrorCode.PARSE_FAILED,
          `Could not parse name from ABI file: ${filepath}.`
        );
      }
      this.programType = programType;
      this.capitalizedName = `${normalizeString(abiName[1])}`;
      this.camelizedName = this.capitalizedName.replace(/^./m, (x) => x.toLowerCase());
      this.filepath = filepath;
      this.rawContents = rawContents;
      this.hexlifiedBinContents = hexlifiedBinContents;
      this.storageSlotsContents = storageSlotsContents;
      this.outputDir = outputDir;
      const { types: types2, functions, configurables } = this.parse();
      this.types = types2;
      this.functions = functions;
      this.configurables = configurables;
      this.computeCommonTypesInUse();
    }
    parse() {
      const transpiled = transpileAbi2(this.rawContents);
      const {
        types: rawAbiTypes,
        functions: rawAbiFunctions,
        configurables: rawAbiConfigurables
      } = transpiled;
      const types2 = parseTypes2({ rawAbiTypes });
      const functions = parseFunctions2({ rawAbiFunctions, types: types2 });
      const configurables = rawAbiConfigurables.map(
        (rawAbiConfigurable) => new Configurable2({ types: types2, rawAbiConfigurable })
      );
      return {
        types: types2,
        functions,
        configurables
      };
    }
    computeCommonTypesInUse() {
      const customTypesTable = {
        option: "Option",
        enum: "Enum",
        vector: "Vec",
        result: "Result"
      };
      this.commonTypesInUse = [];
      Object.keys(customTypesTable).forEach((typeName) => {
        const isInUse = !!this.types.find((t) => t.name === typeName);
        if (isInUse) {
          const commonTypeLabel = customTypesTable[typeName];
          this.commonTypesInUse.push(commonTypeLabel);
        }
      });
    }
  };
  var ProgramTypeEnum3 = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum3 || {});
  var header_default2 = "/* Autogenerated file. Do not edit manually. */\n\n/* eslint-disable max-classes-per-file */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/consistent-type-imports */\n\n\n/*\n  Fuels version: {{FUELS}}\n{{#if FORC}}\n  Forc version: {{FORC}}\n{{/if}}\n{{#if FUEL_CORE}}\n  Fuel-Core version: {{FUEL_CORE}}\n{{/if}}\n*/\n";
  function renderHbsTemplate2(params) {
    const { data, template, versions: versions2 } = params;
    const options = {
      strict: true,
      noEscape: true
    };
    const renderTemplate = import_handlebars3.default.compile(template, options);
    const renderHeaderTemplate = import_handlebars3.default.compile(header_default2, options);
    const text = renderTemplate({
      ...data,
      header: renderHeaderTemplate(versions2)
    });
    return text.replace(/[\n]{3,}/gm, "\n\n");
  }
  var common_default3 = "{{header}}\n\n/**\n * Mimics Sway Enum.\n * Requires one and only one Key-Value pair and raises error if more are provided.\n */\nexport type Enum<T> = {\n  [K in keyof T]: Pick<T, K> & { [P in Exclude<keyof T, K>]?: never };\n}[keyof T];\n\n/**\n * Mimics Sway Option and Vectors.\n * Vectors are treated like arrays in Typescript.\n */\nexport type Option<T> = T | undefined;\n\nexport type Vec<T> = T[];\n\n/**\n * Mimics Sway Result enum type.\n * Ok represents the success case, while Err represents the error case.\n */\nexport type Result<T, E> = Enum<{Ok: T, Err: E}>;\n";
  function renderCommonTemplate2(params) {
    const { versions: versions2 } = params;
    const text = renderHbsTemplate2({ template: common_default3, versions: versions2 });
    return text;
  }
  var common_default22 = "{{header}}\n\n{{#each members}}\nexport { {{this}} } from './{{this}}';\n{{/each}}\n";
  function renderIndexTemplate2(params) {
    const { files, versions: versions2 } = params;
    const members = files.map((f2) => f2.path.match(/([^/]+)\.ts$/m)?.[1]);
    const text = renderHbsTemplate2({
      template: common_default22,
      versions: versions2,
      data: {
        members
      }
    });
    return text;
  }
  var factory_default2 = '{{header}}\n\nimport { ContractFactory, decompressBytecode } from "fuels";\nimport type { Provider, Account, DeployContractOptions } from "fuels";\n\nimport { {{capitalizedName}} } from "./{{capitalizedName}}";\n\nconst bytecode = decompressBytecode("{{compressedBytecode}}");\n\nexport class {{capitalizedName}}Factory extends ContractFactory<{{capitalizedName}}> {\n\n  static readonly bytecode = bytecode;\n\n  constructor(accountOrProvider: Account | Provider) {\n    super(\n      bytecode,\n      {{capitalizedName}}.abi,\n      accountOrProvider,\n      {{capitalizedName}}.storageSlots\n    );\n  }\n\n  static deploy (\n    wallet: Account,\n    options: DeployContractOptions = {}\n  ) {\n    const factory = new {{capitalizedName}}Factory(wallet);\n    return factory.deploy(options);\n  }\n}\n';
  function renderFactoryTemplate2(params) {
    const { versions: versions2, abi: abi2 } = params;
    const {
      camelizedName,
      capitalizedName,
      rawContents,
      storageSlotsContents,
      hexlifiedBinContents: hexlifiedBinString
    } = abi2;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate2({
      template: factory_default2,
      versions: versions2,
      data: {
        camelizedName,
        capitalizedName,
        abiJsonString,
        storageSlotsJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString)
      }
    });
    return text;
  }
  function formatEnums2(params) {
    const { types: types2 } = params;
    const enums = types2.filter((t) => t.name === "enum").map((t) => {
      const et2 = t;
      const structName = et2.getStructName();
      const inputValues = et2.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = et2.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const inputNativeValues = et2.getNativeEnum({ types: types2 });
      const outputNativeValues = et2.getNativeEnum({ types: types2 });
      const typeAnnotations = et2.getStructDeclaration({ types: types2 });
      return {
        structName,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues,
        // reduces duplication
        inputNativeValues,
        outputNativeValues,
        typeAnnotations
      };
    }).sort((a, b) => a.structName < b.structName ? -1 : 1);
    return { enums };
  }
  var caseInsensitiveSort2 = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
  function formatImports2(params) {
    const { types: types2, baseMembers = [] } = params;
    const members = types2.flatMap((t) => t.requiredFuelsMembersImports);
    const imports = uniq_default(baseMembers.concat(members).sort(caseInsensitiveSort2));
    return {
      imports: imports.length ? imports : void 0
    };
  }
  function formatStructs2(params) {
    const { types: types2 } = params;
    const structs = types2.filter((t) => t.name === "struct").map((t) => {
      const st = t;
      const structName = st.getStructName();
      const inputValues = st.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = st.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const typeAnnotations = st.getStructDeclaration({ types: types2 });
      return {
        structName,
        typeAnnotations,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues
        // reduces duplication
      };
    }).sort((a, b) => a.structName < b.structName ? -1 : 1);
    return { structs };
  }
  var main_default4 = `{{header}}

import { Contract, Interface } from "fuels";
{{#if imports}}
import type {
  Provider,
  Account,
  StorageSlot,
  Address,
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
{{#each configurables}}
  {{name}}: {{inputLabel}};
{{/each}}
}>;
{{/if}}

const abi = {{abiJsonString}};

const storageSlots: StorageSlot[] = {{storageSlotsJsonString}};

export class {{capitalizedName}}Interface extends Interface {
  constructor() {
    super(abi);
  }

  declare functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };
}

export class {{capitalizedName}} extends Contract {
  static readonly abi = abi;
  static readonly storageSlots = storageSlots;

  declare interface: {{capitalizedName}}Interface;
  declare functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };

  constructor(
    id: string | Address,
    accountOrProvider: Account | Provider,
  ) {
    super(id, abi, accountOrProvider);
  }
}
`;
  function renderMainTemplate4(params) {
    const { versions: versions2, abi: abi2 } = params;
    const { camelizedName, capitalizedName, types: types2, functions, commonTypesInUse, configurables } = abi2;
    const functionsTypedefs = functions.map((f2) => f2.getDeclaration());
    const functionsFragments = functions.map((f2) => f2.name);
    const encoders = functions.map((f2) => ({
      functionName: f2.name,
      input: f2.attributes.inputs
    }));
    const decoders = functions.map((f2) => ({
      functionName: f2.name
    }));
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({
      types: types2,
      baseMembers: ["FunctionFragment", "InvokeFunction"]
    });
    const { rawContents, storageSlotsContents } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate2({
      template: main_default4,
      versions: versions2,
      data: {
        camelizedName,
        capitalizedName,
        commonTypesInUse: commonTypesInUse.join(", "),
        functionsTypedefs,
        functionsFragments,
        encoders,
        decoders,
        structs,
        enums,
        imports,
        abiJsonString,
        storageSlotsJsonString,
        configurables
      }
    });
    return text;
  }
  function assembleContracts2(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi2) => {
      const { capitalizedName } = abi2;
      const mainFilepath = `${outputDir}/${capitalizedName}.ts`;
      const factoryFilepath = `${outputDir}/${capitalizedName}Factory.ts`;
      const main = {
        path: mainFilepath,
        contents: renderMainTemplate4({ abi: abi2, versions: versions2 })
      };
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate2({ abi: abi2, versions: versions2 })
      };
      files.push(main);
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path15.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }
  var main_default22 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
  {{#each configurables}}
    {{name}}: {{inputLabel}};
  {{/each}}
}>;
{{else}}
export type {{capitalizedName}}Configurables = undefined;
{{/if}}

export type {{capitalizedName}}Inputs = [{{inputs}}];

export type {{capitalizedName}}Parameters = Omit<
  PredicateParams<{{capitalizedName}}Inputs, {{capitalizedName}}Configurables>,
  'abi' | 'bytecode'
>;

const abi = {{abiJsonString}};

const bytecode = decompressBytecode('{{compressedBytecode}}');

export class {{capitalizedName}} extends Predicate<
  {{capitalizedName}}Inputs,
  {{capitalizedName}}Configurables
> {
  static readonly abi = abi;
  static readonly bytecode = bytecode;

  constructor(params: {{capitalizedName}}Parameters) {
    super({ abi, bytecode, ...params });
  }
}
`;
  function renderMainTemplate22(params) {
    const { abi: abi2, versions: versions2 } = params;
    const { types: types2, configurables } = abi2;
    const {
      rawContents,
      capitalizedName,
      hexlifiedBinContents: hexlifiedBinString,
      commonTypesInUse
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi2.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({
      types: types2,
      baseMembers: ["Predicate", "Provider", "InputValue", "PredicateParams", "decompressBytecode"]
    });
    const { prefixedInputs: inputs, output: output2 } = func.attributes;
    const text = renderHbsTemplate2({
      template: main_default22,
      versions: versions2,
      data: {
        inputs,
        output: output2,
        structs,
        enums,
        abiJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString),
        capitalizedName,
        imports,
        configurables,
        commonTypesInUse: commonTypesInUse.join(", ")
      }
    });
    return text;
  }
  function assemblePredicates2(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi2) => {
      const { capitalizedName: name } = abi2;
      const factoryFilepath = `${outputDir}/${name}.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderMainTemplate22({ abi: abi2, versions: versions2 })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path16.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }
  var main_default32 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

export type {{capitalizedName}}Inputs = [{{inputs}}];
export type {{capitalizedName}}Output = {{output}};

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
{{#each configurables}}
  {{name}}: {{inputLabel}};
{{/each}}
}>;
{{/if}}

const abi = {{abiJsonString}};

const bytecode = decompressBytecode('{{compressedBytecode}}');

export class {{capitalizedName}} extends Script<{{capitalizedName}}Inputs, {{capitalizedName}}Output> {

  static readonly abi = abi;
  static readonly bytecode = bytecode;

  constructor(wallet: Account) {
    super(bytecode, abi, wallet);
  }
}
`;
  function renderMainTemplate32(params) {
    const { abi: abi2, versions: versions2 } = params;
    const { types: types2, configurables } = abi2;
    const {
      rawContents,
      capitalizedName,
      hexlifiedBinContents: hexlifiedBinString,
      commonTypesInUse
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi2.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({
      types: types2,
      baseMembers: ["Script", "Account", "decompressBytecode"]
    });
    const { prefixedInputs: inputs, output: output2 } = func.attributes;
    const text = renderHbsTemplate2({
      template: main_default32,
      versions: versions2,
      data: {
        inputs,
        output: output2,
        structs,
        enums,
        abiJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString),
        capitalizedName,
        imports,
        configurables,
        commonTypesInUse: commonTypesInUse.join(", ")
      }
    });
    return text;
  }
  function assembleScripts2(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi2) => {
      const { capitalizedName } = abi2;
      const factoryFilepath = `${outputDir}/${capitalizedName}.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderMainTemplate32({ abi: abi2, versions: versions2 })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path17.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }
  var upperFirst2 = (s) => s[0].toUpperCase() + s.slice(1);
  function validateBinFile2(params) {
    const { abiFilepath, binFilepath, binExists, programType } = params;
    const isScript = programType === "script";
    if (!binExists && isScript) {
      throw new FuelError(
        ErrorCode.BIN_FILE_NOT_FOUND,
        [
          `Could not find BIN file for counterpart ${upperFirst2(programType)} ABI.`,
          `  - ABI: ${abiFilepath}`,
          `  - BIN: ${binFilepath}`,
          programType
        ].join("\n")
      );
    }
  }
  var AbiTypeGen2 = class {
    abis;
    abiFiles;
    binFiles;
    storageSlotsFiles;
    outputDir;
    files;
    versions;
    constructor(params) {
      const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles, versions: versions2 } = params;
      this.outputDir = outputDir;
      this.abiFiles = abiFiles;
      this.binFiles = binFiles;
      this.storageSlotsFiles = storageSlotsFiles;
      this.versions = versions2;
      this.abis = this.abiFiles.map((abiFile) => {
        const binFilepath = abiFile.path.replace("-abi.json", ".bin");
        const relatedBinFile = this.binFiles.find(({ path: path6 }) => path6 === binFilepath);
        const storageSlotFilepath = abiFile.path.replace("-abi.json", "-storage_slots.json");
        const relatedStorageSlotsFile = this.storageSlotsFiles.find(
          ({ path: path6 }) => path6 === storageSlotFilepath
        );
        if (!relatedBinFile) {
          validateBinFile2({
            abiFilepath: abiFile.path,
            binExists: !!relatedBinFile,
            binFilepath,
            programType
          });
        }
        const abi2 = new Abi2({
          filepath: abiFile.path,
          rawContents: JSON.parse(abiFile.contents),
          hexlifiedBinContents: relatedBinFile?.contents,
          storageSlotsContents: relatedStorageSlotsFile?.contents,
          outputDir,
          programType
        });
        return abi2;
      });
      this.files = this.getAssembledFiles({ programType });
    }
    getAssembledFiles(params) {
      const { abis, outputDir, versions: versions2 } = this;
      const { programType } = params;
      switch (programType) {
        case "contract":
          return assembleContracts2({ abis, outputDir, versions: versions2 });
        case "script":
          return assembleScripts2({ abis, outputDir, versions: versions2 });
        case "predicate":
          return assemblePredicates2({ abis, outputDir, versions: versions2 });
        default:
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(
              ProgramTypeEnum3
            )}`
          );
      }
    }
  };
  var collectBinFilepaths2 = (params) => {
    const { filepaths, programType } = params;
    const binFiles = filepaths.map((abiFilepath) => {
      const binFilepath = abiFilepath.replace("-abi.json", ".bin");
      const binExists = (0, import_fs18.existsSync)(binFilepath);
      validateBinFile2({ abiFilepath, binFilepath, binExists, programType });
      const bin = {
        path: binFilepath,
        contents: hexlify((0, import_fs18.readFileSync)(binFilepath))
      };
      return bin;
    });
    return binFiles;
  };
  var collectStorageSlotsFilepaths2 = (params) => {
    const { filepaths, programType } = params;
    const storageSlotsFiles = [];
    if (programType !== "contract") {
      return storageSlotsFiles;
    }
    filepaths.forEach((abiFilepath) => {
      const storageSlotsFilepath = abiFilepath.replace("-abi.json", "-storage_slots.json");
      const storageSlotsExists = (0, import_fs19.existsSync)(storageSlotsFilepath);
      if (storageSlotsExists) {
        const storageSlots2 = {
          path: storageSlotsFilepath,
          contents: (0, import_fs19.readFileSync)(storageSlotsFilepath, "utf-8")
        };
        storageSlotsFiles.push(storageSlots2);
      }
    });
    return storageSlotsFiles;
  };
  function runTypegen2(params) {
    const { cwd, inputs, output: output2, silent, programType, filepaths: inputFilepaths } = params;
    const versions2 = { FUELS: versions.FUELS, ...params.versions };
    const cwdBasename = (0, import_path14.basename)(cwd);
    function log4(...args) {
      if (!silent) {
        console.log(args.join(" "));
      }
    }
    let filepaths = [];
    if (!inputFilepaths?.length && inputs?.length) {
      filepaths = inputs.flatMap((i) => globSync(i, { cwd }));
    } else if (inputFilepaths?.length) {
      filepaths = inputFilepaths;
    } else {
      throw new FuelError(
        ErrorCode.MISSING_REQUIRED_PARAMETER,
        `At least one parameter should be supplied: 'input' or 'filepaths'.`
      );
    }
    const abiFiles = filepaths.map((filepath) => {
      const contents = (0, import_fs17.readFileSync)(filepath, "utf-8");
      const abi2 = {
        path: filepath,
        contents
      };
      return abi2;
    });
    if (!abiFiles.length) {
      throw new FuelError(ErrorCode.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);
    }
    const binFiles = collectBinFilepaths2({ filepaths, programType });
    const storageSlotsFiles = collectStorageSlotsFilepaths2({ filepaths, programType });
    const abiTypeGen = new AbiTypeGen2({
      outputDir: output2,
      abiFiles,
      binFiles,
      storageSlotsFiles,
      programType,
      versions: versions2
    });
    log4("Generating files..\n");
    mkdirp.sync(`${output2}`);
    abiTypeGen.files.forEach((file) => {
      rimrafSync(file.path);
      (0, import_fs17.writeFileSync)(file.path, file.contents);
      const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, "m");
      log4(` - ${file.path.replace(trimPathRegex, "")}`);
    });
    log4("\nDone.\u26A1");
  }

  // src/cli/commands/build/generateTypes.ts
  var import_fs21 = __require2("fs");
  var import_path19 = __require2("path");

  // src/cli/config/forcUtils.ts
  var import_fs20 = __require2("fs");
  var import_lodash = __toESM(require_lodash());
  var import_path18 = __require2("path");
  var import_toml = __toESM(require_toml());
  var SwayType = /* @__PURE__ */ ((SwayType2) => {
    SwayType2["contract"] = "contract";
    SwayType2["script"] = "script";
    SwayType2["predicate"] = "predicate";
    SwayType2["library"] = "library";
    return SwayType2;
  })(SwayType || {});
  var swayFiles = /* @__PURE__ */ new Map();
  var getClosestForcTomlDir = (dir) => {
    let forcPath = (0, import_path18.join)(dir, "Forc.toml");
    if ((0, import_fs20.existsSync)(forcPath)) {
      return forcPath;
    }
    const parent = (0, import_path18.join)(dir, "..");
    forcPath = getClosestForcTomlDir(parent);
    if (parent === "/" && !(0, import_fs20.existsSync)(forcPath)) {
      const msg = `TOML file not found:
  ${dir}`;
      throw new FuelError(FuelError.CODES.CONFIG_FILE_NOT_FOUND, msg);
    }
    return forcPath;
  };
  function readForcToml(contractPath) {
    if (!(0, import_fs20.existsSync)(contractPath)) {
      throw new FuelError(
        FuelError.CODES.CONFIG_FILE_NOT_FOUND,
        `TOML file not found:
  ${contractPath}`
      );
    }
    const forcPath = getClosestForcTomlDir(contractPath);
    if (!(0, import_fs20.existsSync)(forcPath)) {
      throw new FuelError(
        FuelError.CODES.CONFIG_FILE_NOT_FOUND,
        `TOML file not found:
  ${forcPath}`
      );
    }
    const forcFile = (0, import_fs20.readFileSync)(forcPath, "utf8");
    return import_toml.default.parse(forcFile);
  }
  function setForcTomlProxyAddress(contractPath, address) {
    const forcPath = getClosestForcTomlDir(contractPath);
    const tomlPristine = (0, import_fs20.readFileSync)(forcPath).toString();
    const tomlJson = readForcToml(forcPath);
    const isProxyEnabled = tomlJson.proxy?.enabled;
    const hasProxyAddress = tomlJson.proxy?.address;
    if (isProxyEnabled && hasProxyAddress) {
      return address;
    }
    const replaceReg = /(\[proxy\][\s\S]+^enabled.+$)/gm;
    const replaceStr = `$1
address = "${address}"`;
    const modifiedToml = tomlPristine.replace(replaceReg, replaceStr);
    (0, import_fs20.writeFileSync)(forcPath, modifiedToml);
    return address;
  }
  function readSwayType(path6) {
    const forcToml = readForcToml(path6);
    const entryFile = forcToml.project.entry || "main.sw";
    const swayEntryPath = (0, import_path18.join)(path6, "src", entryFile);
    if (!swayFiles.has(swayEntryPath)) {
      const swayFile = (0, import_fs20.readFileSync)(swayEntryPath, "utf8");
      const swayTypeLines = Object.values(SwayType).map((type3) => `${type3};`);
      const swayType = swayFile.split("\n").find((line) => swayTypeLines.some((swayTypeLine) => line === swayTypeLine))?.split(";")[0];
      swayFiles.set(swayEntryPath, swayType);
    }
    return swayFiles.get(swayEntryPath);
  }
  function getContractName(contractPath) {
    const { project } = readForcToml(contractPath);
    return project.name;
  }
  function getScriptName(scriptPath) {
    const { project } = readForcToml(scriptPath);
    return project.name;
  }
  function getPredicateName(predicatePath) {
    const { project } = readForcToml(predicatePath);
    return project.name;
  }
  function getContractCamelCase(contractPath) {
    const projectName = getContractName(contractPath);
    return (0, import_lodash.default)(projectName);
  }
  function getBinaryPath(contractPath, { buildMode }) {
    const projectName = getContractName(contractPath);
    return (0, import_path18.join)(contractPath, `/out/${buildMode}/${projectName}.bin`);
  }
  function getABIPath(contractPath, { buildMode }) {
    const projectName = getContractName(contractPath);
    return (0, import_path18.join)(contractPath, `/out/${buildMode}/${projectName}-abi.json`);
  }
  function getABIPaths(paths, config) {
    return Promise.all(paths.map((path6) => getABIPath(path6, config)));
  }
  var getStorageSlotsPath = (contractPath, { buildMode }) => {
    const projectName = getContractName(contractPath);
    return (0, import_path18.join)(contractPath, `/out/${buildMode}/${projectName}-storage_slots.json`);
  };

  // src/cli/templates/index.ts
  var import_handlebars4 = __toESM(require_lib());

  // src/cli/templates/index.hbs
  var templates_default = "{{#each paths}}\nexport * from './{{this}}';\n{{/each}}\n";

  // src/cli/templates/index.ts
  function renderIndexTemplate3(paths) {
    const renderTemplate = import_handlebars4.default.compile(templates_default, {
      strict: true,
      noEscape: true
    });
    return renderTemplate({
      paths
    });
  }

  // src/cli/commands/build/generateTypes.ts
  async function generateTypesForProgramType(config, paths, programType) {
    debug("Generating types..");
    let filepaths = await getABIPaths(paths, config);
    const pluralizedDirName = `${String(programType).toLocaleLowerCase()}s`;
    const versions2 = getBinaryVersions(config);
    const isScript = programType === ProgramTypeEnum2.SCRIPT;
    const isPredicate = programType === ProgramTypeEnum2.PREDICATE;
    if (isScript || isPredicate) {
      const loaderFiles = paths.flatMap((dirpath) => {
        const glob2 = `*-abi.json`;
        const cwd = `${dirpath}/out`;
        return globSync(glob2, { cwd }).map((filename) => `${dirpath}/out/${filename}`);
      });
      filepaths = filepaths.concat(loaderFiles);
    }
    runTypegen2({
      programType,
      cwd: config.basePath,
      filepaths,
      output: (0, import_path19.join)(config.output, pluralizedDirName),
      silent: !loggingConfig.isDebugEnabled,
      versions: versions2
    });
    return pluralizedDirName;
  }
  async function generateTypes(config) {
    log("Generating types..");
    const { contracts, scripts, predicates, output: output2 } = config;
    (0, import_fs21.mkdirSync)(output2, { recursive: true });
    const members = [
      { type: ProgramTypeEnum2.CONTRACT, programs: contracts },
      { type: ProgramTypeEnum2.SCRIPT, programs: scripts },
      { type: ProgramTypeEnum2.PREDICATE, programs: predicates }
    ];
    const pluralizedDirNames = await Promise.all(
      members.filter(({ programs }) => !!programs.length).map(({ programs, type: type3 }) => generateTypesForProgramType(config, programs, type3))
    );
    const indexFile = await renderIndexTemplate3(pluralizedDirNames);
    (0, import_fs21.writeFileSync)((0, import_path19.join)(config.output, "index.ts"), indexFile);
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`positive integer expected, not ${n}`);
  }
  function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  function bytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
  }
  function hash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(h.outputLen);
    number(h.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/cryptoNode.js
  var nc = __toESM(__require2("crypto"), 1);
  var crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = byteSwap(arr[i]);
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes2(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    bytes(data);
    return data;
  }
  function concatBytes2(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      bytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var toStr = {}.toString;
  function checkOpts(defaults2, opts) {
    if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults2, opts);
    return merged;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto && typeof crypto.getRandomValues === "function") {
      return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto && typeof crypto.randomBytes === "function") {
      return crypto.randomBytes(bytesLength);
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var HashMD = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js
  var SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends HashMD {
    constructor() {
      super(64, 32, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash {
    constructor(hash3, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash(hash3);
      const key = toBytes2(_key);
      this.iHash = hash3.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash3.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists(this);
      bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
  hmac.create = (hash3, key) => new HMAC(hash3, key);

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/pbkdf2.js
  function pbkdf2Init(hash3, _password, _salt, _opts) {
    hash(hash3);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    number(c);
    number(dkLen);
    number(asyncTick);
    if (c < 1)
      throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = toBytes2(_password);
    const salt = toBytes2(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash3, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    u.fill(0);
    return DK;
  }
  function pbkdf2(hash3, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/scrypt.js
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i = 0; i < 8; i += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
      out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
      XorAndSalsa(out, tail, input, ii, out, head);
      if (i > 0)
        tail += 16;
      XorAndSalsa(out, head, input, ii += 16, out, tail);
    }
  }
  function scryptInit(password, salt, _opts) {
    const opts = checkOpts({
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    number(N);
    number(r);
    number(p);
    number(dkLen);
    number(asyncTick);
    number(maxmem);
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error("progressCb should be function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N <= 1 || (N & N - 1) !== 0 || N > 2 ** 32) {
      throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");
    }
    if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
      throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    }
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
      throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    }
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
      throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    }
    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    const V = u32(new Uint8Array(blockSize * N));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => {
    };
    if (onProgress) {
      const totalBlockMix = 2 * N * p;
      const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
      let blockMixCnt = 0;
      blockMixCb = () => {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
          onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
  }
  function scrypt(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    if (!isLE)
      byteSwap32(B32);
    for (let pi = 0; pi < p; pi++) {
      const Pi2 = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi2 + i];
      for (let i = 0, pos = 0; i < N - 1; i++) {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      }
      BlockMix(V, (N - 1) * blockSize32, B32, Pi2, r);
      blockMixCb();
      for (let i = 0; i < N; i++) {
        const j = B32[Pi2 + blockSize32 - 16] % N;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi2, r);
        blockMixCb();
      }
    }
    if (!isLE)
      byteSwap32(B32);
    return scryptOutput(password, dkLen, B, V, tmp);
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha3.js
  var SHA3_PI = [];
  var SHA3_ROTL = [];
  var _SHA3_IOTA = [];
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _256n = /* @__PURE__ */ BigInt(256);
  var _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var Keccak = class extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      if (!isLE)
        byteSwap32(this.state32);
      keccakP(this.state32, this.rounds);
      if (!isLE)
        byteSwap32(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists(this);
      const { blockLen, state } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
  var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

  // ../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/ripemd160.js
  var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));
  var Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
  var idxL = [Id];
  var idxR = [Pi];
  for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
      j.push(j[i].map((k) => Rho[k]));
  var shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i) => new Uint8Array(i));
  var shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
  var shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
  var Kl = /* @__PURE__ */ new Uint32Array([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ]);
  var Kr = /* @__PURE__ */ new Uint32Array([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ]);
  function f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    else if (group === 1)
      return x & y | ~x & z;
    else if (group === 2)
      return (x | ~y) ^ z;
    else if (group === 3)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  var R_BUF = /* @__PURE__ */ new Uint32Array(16);
  var RIPEMD160 = class extends HashMD {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        R_BUF[i] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl[group], hbr = Kr[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL[group], sr = shiftsR[group];
        for (let i = 0; i < 16; i++) {
          const tl = rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i = 0; i < 16; i++) {
          const tr3 = rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr3;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      R_BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());

  // ../crypto/dist/index.mjs
  var import_crypto2 = __toESM(__require2("crypto"), 1);
  var import_crypto3 = __require2("crypto");
  var import_crypto4 = __toESM(__require2("crypto"), 1);
  var import_crypto5 = __toESM(__require2("crypto"), 1);
  var import_crypto6 = __require2("crypto");
  var import_crypto7 = __require2("crypto");
  var scrypt2 = (params) => {
    const { password, salt, n, p, r, dklen } = params;
    const derivedKey = scrypt(password, salt, { N: n, r, p, dkLen: dklen });
    return derivedKey;
  };
  var keccak256 = (data) => keccak_256(data);
  function ripemd1602(_data) {
    const data = arrayify(_data, "data");
    return ripemd160(data);
  }
  var bufferFromString = (string2, encoding = "base64") => Uint8Array.from(Buffer.from(string2, encoding));
  function pbkdf22(_password, _salt, iterations, keylen, algo) {
    const password = arrayify(_password, "password");
    const salt = arrayify(_salt, "salt");
    return hexlify((0, import_crypto3.pbkdf2Sync)(password, salt, iterations, keylen, algo));
  }
  var randomBytes2 = (length) => {
    const randomValues = Uint8Array.from(import_crypto4.default.randomBytes(length));
    return randomValues;
  };
  var stringFromBuffer = (buffer, encoding = "base64") => Buffer.from(buffer).toString(encoding);
  var ALGORITHM = "aes-256-ctr";
  var keyFromPassword = (password, saltBuffer) => {
    const passBuffer = bufferFromString(String(password).normalize("NFKC"), "utf-8");
    const key = pbkdf22(passBuffer, saltBuffer, 1e5, 32, "sha256");
    return arrayify(key);
  };
  var encrypt = async (password, data) => {
    const iv = randomBytes2(16);
    const salt = randomBytes2(32);
    const secret = keyFromPassword(password, salt);
    const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), "utf-8"));
    const cipher = await import_crypto2.default.createCipheriv(ALGORITHM, secret, iv);
    let cipherData = cipher.update(dataBuffer);
    cipherData = Buffer.concat([cipherData, cipher.final()]);
    return {
      data: stringFromBuffer(cipherData),
      iv: stringFromBuffer(iv),
      salt: stringFromBuffer(salt)
    };
  };
  var decrypt = async (password, keystore) => {
    const iv = bufferFromString(keystore.iv);
    const salt = bufferFromString(keystore.salt);
    const secret = keyFromPassword(password, salt);
    const encryptedText = bufferFromString(keystore.data);
    const decipher = await import_crypto2.default.createDecipheriv(ALGORITHM, secret, iv);
    const decrypted = decipher.update(encryptedText);
    const deBuff = Buffer.concat([decrypted, decipher.final()]);
    const decryptedData = Buffer.from(deBuff).toString("utf-8");
    try {
      return JSON.parse(decryptedData);
    } catch {
      throw new FuelError(ErrorCode.INVALID_CREDENTIALS, "Invalid credentials.");
    }
  };
  async function encryptJsonWalletData(data, key, iv) {
    const cipher = await import_crypto5.default.createCipheriv("aes-128-ctr", key.subarray(0, 16), iv);
    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
    return new Uint8Array(encrypted);
  }
  async function decryptJsonWalletData(data, key, iv) {
    const decipher = import_crypto5.default.createDecipheriv("aes-128-ctr", key.subarray(0, 16), iv);
    const decrypted = await Buffer.concat([decipher.update(data), decipher.final()]);
    return new Uint8Array(decrypted);
  }
  function computeHmac(algorithm, _key, _data) {
    const key = arrayify(_key, "key");
    const data = arrayify(_data, "data");
    return hexlify((0, import_crypto6.createHmac)(algorithm, key).update(data).digest());
  }
  var randomUUID = () => (0, import_crypto7.randomUUID)();
  var api = {
    bufferFromString,
    stringFromBuffer,
    decrypt,
    encrypt,
    keyFromPassword,
    randomBytes: randomBytes2,
    scrypt: scrypt2,
    keccak256,
    decryptJsonWalletData,
    encryptJsonWalletData,
    computeHmac,
    pbkdf2: pbkdf22,
    ripemd160: ripemd1602,
    randomUUID
  };
  var node_default = api;
  var {
    bufferFromString: bufferFromString2,
    decrypt: decrypt2,
    encrypt: encrypt2,
    keyFromPassword: keyFromPassword2,
    randomBytes: randomBytes22,
    stringFromBuffer: stringFromBuffer2,
    scrypt: scrypt22,
    keccak256: keccak2562,
    decryptJsonWalletData: decryptJsonWalletData2,
    encryptJsonWalletData: encryptJsonWalletData2,
    computeHmac: computeHmac2,
    pbkdf2: pbkdf222,
    ripemd160: ripemd16022,
    randomUUID: randomUUID2
  } = node_default;

  // ../hasher/dist/index.mjs
  function sha2562(data) {
    return hexlify(sha256(arrayify(data)));
  }
  function hash2(data) {
    return sha2562(data);
  }
  function uint64ToBytesBE(value) {
    const bigIntValue = BigInt(value);
    const buffer = new ArrayBuffer(8);
    const dataView = new DataView(buffer);
    dataView.setBigUint64(0, bigIntValue, false);
    return new Uint8Array(dataView.buffer);
  }
  function hashMessage(msg) {
    return hash2(bufferFromString2(msg, "utf-8"));
  }

  // ../abi-coder/dist/index.mjs
  var __defProp7 = Object.defineProperty;
  var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField7 = (obj, key, value) => {
    __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var Coder = class {
    name;
    type;
    encodedLength;
    constructor(name, type3, encodedLength) {
      this.name = name;
      this.type = type3;
      this.encodedLength = encodedLength;
    }
  };
  var U8_CODER_TYPE = "u8";
  var U16_CODER_TYPE = "u16";
  var U32_CODER_TYPE = "u32";
  var U64_CODER_TYPE = "u64";
  var U256_CODER_TYPE = "u256";
  var RAW_PTR_CODER_TYPE = "raw untyped ptr";
  var RAW_SLICE_CODER_TYPE = "raw untyped slice";
  var BOOL_CODER_TYPE = "bool";
  var B256_CODER_TYPE = "b256";
  var B512_CODER_TYPE = "struct std::b512::B512";
  var OPTION_CODER_TYPE = "enum std::option::Option";
  var VEC_CODER_TYPE = "struct std::vec::Vec";
  var BYTES_CODER_TYPE = "struct std::bytes::Bytes";
  var STD_STRING_CODER_TYPE = "struct std::string::String";
  var STR_SLICE_CODER_TYPE = "str";
  var VOID_TYPE = "()";
  var optionRegEx = /^enum (std::option::)?Option$/m;
  var stringRegEx = /^str\[(?<length>[0-9]+)\]/;
  var arrayRegEx = /^\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/;
  var structRegEx = /^struct.+/;
  var enumRegEx = /^enum.+$/;
  var tupleRegEx = /^\((?<items>.*)\)$/;
  var genericRegEx = /^generic.+$/;
  var fullNameRegExMatch = /([^\s]+)$/m;
  var ENCODING_V1 = "1";
  var WORD_SIZE = 8;
  var BYTES_32 = 32;
  var UTXO_ID_LEN = BYTES_32 + 2;
  var ASSET_ID_LEN = BYTES_32;
  var CONTRACT_ID_LEN = BYTES_32;
  var ADDRESS_LEN = BYTES_32;
  var NONCE_LEN = BYTES_32;
  var TX_LEN = WORD_SIZE * 4;
  var TX_POINTER_LEN = WORD_SIZE * 2;
  var MAX_BYTES = 2 ** 32 - 1;
  var calculateVmTxMemory = ({ maxInputs }) => BYTES_32 + // Tx ID
  ASSET_ID_LEN + // Base asset ID
  // Asset ID/Balance coin input pairs
  maxInputs * (ASSET_ID_LEN + WORD_SIZE) + WORD_SIZE;
  var SCRIPT_FIXED_SIZE = WORD_SIZE + // Identifier
  WORD_SIZE + // Gas limit
  WORD_SIZE + // Script size
  WORD_SIZE + // Script data size
  WORD_SIZE + // Policies
  WORD_SIZE + // Inputs size
  WORD_SIZE + // Outputs size
  WORD_SIZE + // Witnesses size
  BYTES_32;
  var INPUT_COIN_FIXED_SIZE = WORD_SIZE + // Identifier
  TX_LEN + // Utxo Length
  WORD_SIZE + // Output Index
  ADDRESS_LEN + // Owner
  WORD_SIZE + // Amount
  ASSET_ID_LEN + // Asset id
  TX_POINTER_LEN + // TxPointer
  WORD_SIZE + // Witnesses index
  WORD_SIZE + // Predicate size
  WORD_SIZE + // Predicate data size
  WORD_SIZE;
  var INPUT_MESSAGE_FIXED_SIZE = WORD_SIZE + // Identifier
  ADDRESS_LEN + // Sender
  ADDRESS_LEN + // Recipient
  WORD_SIZE + // Amount
  NONCE_LEN + // Nonce
  WORD_SIZE + // witness_index
  WORD_SIZE + // Data size
  WORD_SIZE + // Predicate size
  WORD_SIZE + // Predicate data size
  WORD_SIZE;
  var isUint8Array = (value) => value instanceof Uint8Array;
  var hasNestedOption = (coders) => {
    const array2 = Array.isArray(coders) ? coders : Object.values(coders);
    for (const node2 of array2) {
      if (node2.type === OPTION_CODER_TYPE) {
        return true;
      }
      if ("coder" in node2 && node2.coder.type === OPTION_CODER_TYPE) {
        return true;
      }
      if ("coders" in node2) {
        const child = hasNestedOption(node2.coders);
        if (child) {
          return true;
        }
      }
    }
    return false;
  };
  var ArrayCoder = class extends Coder {
    coder;
    length;
    #hasNestedOption;
    constructor(coder, length) {
      super("array", `[${coder.type}; ${length}]`, length * coder.encodedLength);
      this.coder = coder;
      this.length = length;
      this.#hasNestedOption = hasNestedOption([coder]);
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      if (this.length !== value.length) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
      }
      return concat(Array.from(value).map((v) => this.coder.encode(v)));
    }
    decode(data, offset) {
      if (!this.#hasNestedOption && data.length < this.encodedLength || data.length > MAX_BYTES) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid array data size.`);
      }
      let newOffset = offset;
      const decodedValue = Array(this.length).fill(0).map(() => {
        let decoded;
        [decoded, newOffset] = this.coder.decode(data, newOffset);
        return decoded;
      });
      return [decodedValue, newOffset];
    }
  };
  var B256Coder = class extends Coder {
    constructor() {
      super("b256", "b256", WORD_SIZE * 4);
    }
    encode(value) {
      let encodedValue;
      try {
        encodedValue = arrayify(value);
      } catch (error3) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      if (encodedValue.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return encodedValue;
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 data size.`);
      }
      let bytes2 = data.slice(offset, offset + this.encodedLength);
      const decoded = bn(bytes2);
      if (decoded.isZero()) {
        bytes2 = new Uint8Array(32);
      }
      if (bytes2.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 byte data size.`);
      }
      return [toHex(bytes2, 32), offset + 32];
    }
  };
  var B512Coder = class extends Coder {
    constructor() {
      super("b512", "struct B512", WORD_SIZE * 8);
    }
    encode(value) {
      let encodedValue;
      try {
        encodedValue = arrayify(value);
      } catch (error3) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      if (encodedValue.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return encodedValue;
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 data size.`);
      }
      let bytes2 = data.slice(offset, offset + this.encodedLength);
      const decoded = bn(bytes2);
      if (decoded.isZero()) {
        bytes2 = new Uint8Array(64);
      }
      if (bytes2.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 byte data size.`);
      }
      return [toHex(bytes2, this.encodedLength), offset + this.encodedLength];
    }
  };
  var encodedLengths = {
    u64: WORD_SIZE,
    u256: WORD_SIZE * 4
  };
  var BigNumberCoder = class extends Coder {
    constructor(baseType) {
      super("bigNumber", baseType, encodedLengths[baseType]);
    }
    encode(value) {
      let bytes2;
      if (typeof value === "number" && value > Number.MAX_SAFE_INTEGER) {
        throw new FuelError(
          ErrorCode.ENCODE_ERROR,
          `Invalid ${this.type} type - number value is too large. Number can only safely handle up to 53 bits.`
        );
      }
      try {
        bytes2 = toBytes(value, this.encodedLength);
      } catch (error3) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return bytes2;
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} data size.`);
      }
      let bytes2 = data.slice(offset, offset + this.encodedLength);
      bytes2 = bytes2.slice(0, this.encodedLength);
      if (bytes2.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} byte data size.`);
      }
      return [bn(bytes2), offset + this.encodedLength];
    }
  };
  var BooleanCoder = class extends Coder {
    options;
    constructor(options = {
      padToWordSize: false
    }) {
      const encodedLength = options.padToWordSize ? WORD_SIZE : 1;
      super("boolean", "boolean", encodedLength);
      this.options = options;
    }
    encode(value) {
      const isTrueBool = value === true || value === false;
      if (!isTrueBool) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);
      }
      return toBytes(value ? 1 : 0, this.encodedLength);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);
      }
      const bytes2 = bn(data.slice(offset, offset + this.encodedLength));
      if (bytes2.isZero()) {
        return [false, offset + this.encodedLength];
      }
      if (!bytes2.eq(bn(1))) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);
      }
      return [true, offset + this.encodedLength];
    }
  };
  var ByteCoder = class extends Coder {
    constructor() {
      super("struct", "struct Bytes", WORD_SIZE);
    }
    encode(value) {
      const bytes2 = value instanceof Uint8Array ? value : new Uint8Array(value);
      const lengthBytes = new BigNumberCoder("u64").encode(bytes2.length);
      return new Uint8Array([...lengthBytes, ...bytes2]);
    }
    decode(data, offset) {
      if (data.length < WORD_SIZE) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);
      if (dataBytes.length !== length) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);
      }
      return [dataBytes, offsetAndLength + length];
    }
  };
  __publicField7(ByteCoder, "memorySize", 1);
  var EnumCoder = class extends Coder {
    name;
    coders;
    #caseIndexCoder;
    #encodedValueSize;
    #shouldValidateLength;
    constructor(name, coders) {
      const caseIndexCoder = new BigNumberCoder("u64");
      const encodedValueSize = Object.values(coders).reduce(
        (min, coder) => Math.min(min, coder.encodedLength),
        0
      );
      super(`enum ${name}`, `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);
      this.name = name;
      this.coders = coders;
      this.#caseIndexCoder = caseIndexCoder;
      this.#encodedValueSize = encodedValueSize;
      this.#shouldValidateLength = !(optionRegEx.test(this.type) || hasNestedOption(coders));
    }
    // Checks that we're handling a native enum that is of type void.
    #isNativeEnum(coder) {
      return this.type !== OPTION_CODER_TYPE && coder.type === VOID_TYPE;
    }
    #encodeNativeEnum(value) {
      const valueCoder = this.coders[value];
      const encodedValue = valueCoder.encode([]);
      const caseIndex = Object.keys(this.coders).indexOf(value);
      const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);
      return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);
    }
    encode(value) {
      if (typeof value === "string" && this.coders[value]) {
        return this.#encodeNativeEnum(value);
      }
      const [caseKey, ...empty] = Object.keys(value);
      if (!caseKey) {
        throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "A field for the case must be provided.");
      }
      if (empty.length !== 0) {
        throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "Only one field must be provided.");
      }
      const valueCoder = this.coders[caseKey];
      const caseIndex = Object.keys(this.coders).indexOf(caseKey);
      if (caseIndex === -1) {
        const validCases = Object.keys(this.coders).map((v) => `'${v}'`).join(", ");
        throw new FuelError(
          ErrorCode.INVALID_DECODE_VALUE,
          `Invalid case '${caseKey}'. Valid cases: ${validCases}.`
        );
      }
      const encodedValue = valueCoder.encode(value[caseKey]);
      return new Uint8Array([...this.#caseIndexCoder.encode(caseIndex), ...encodedValue]);
    }
    #decodeNativeEnum(caseKey, newOffset) {
      return [caseKey, newOffset];
    }
    decode(data, offset) {
      if (this.#shouldValidateLength && data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);
      }
      const caseBytes = new BigNumberCoder("u64").decode(data, offset)[0];
      const caseIndex = toNumber(caseBytes);
      const caseKey = Object.keys(this.coders)[caseIndex];
      if (!caseKey) {
        throw new FuelError(
          ErrorCode.INVALID_DECODE_VALUE,
          `Invalid caseIndex "${caseIndex}". Valid cases: ${Object.keys(this.coders)}.`
        );
      }
      const valueCoder = this.coders[caseKey];
      const offsetAndCase = offset + this.#caseIndexCoder.encodedLength;
      if (this.#shouldValidateLength && data.length < offsetAndCase + valueCoder.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);
      }
      const [decoded, newOffset] = valueCoder.decode(data, offsetAndCase);
      if (this.#isNativeEnum(this.coders[caseKey])) {
        return this.#decodeNativeEnum(caseKey, newOffset);
      }
      return [{ [caseKey]: decoded }, newOffset];
    }
  };
  var getLength = (baseType) => {
    switch (baseType) {
      case "u8":
        return 1;
      case "u16":
        return 2;
      case "u32":
        return 4;
      default:
        throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Invalid number type: ${baseType}`);
    }
  };
  var NumberCoder = class extends Coder {
    baseType;
    options;
    constructor(baseType, options = {
      padToWordSize: false
    }) {
      const length = options.padToWordSize ? WORD_SIZE : getLength(baseType);
      super("number", baseType, length);
      this.baseType = baseType;
      this.options = options;
    }
    encode(value) {
      let bytes2;
      try {
        bytes2 = toBytes(value);
      } catch (error3) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);
      }
      if (bytes2.length > this.encodedLength) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);
      }
      return toBytes(bytes2, this.encodedLength);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);
      }
      const bytes2 = data.slice(offset, offset + this.encodedLength);
      if (bytes2.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);
      }
      return [toNumber(bytes2), offset + this.encodedLength];
    }
  };
  var OptionCoder = class extends EnumCoder {
    encode(value) {
      const result = super.encode(this.toSwayOption(value));
      return result;
    }
    toSwayOption(input) {
      if (input !== void 0) {
        return { Some: input };
      }
      return { None: [] };
    }
    decode(data, offset) {
      const [decoded, newOffset] = super.decode(data, offset);
      return [this.toOption(decoded), newOffset];
    }
    toOption(output2) {
      if (output2 && "Some" in output2) {
        return output2.Some;
      }
      return void 0;
    }
  };
  var RawSliceCoder = class extends Coder {
    constructor() {
      super("raw untyped slice", "raw untyped slice", WORD_SIZE);
    }
    encode(value) {
      if (!Array.isArray(value)) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const internalCoder = new ArrayCoder(new NumberCoder("u8"), value.length);
      const bytes2 = internalCoder.encode(value);
      const lengthBytes = new BigNumberCoder("u64").encode(bytes2.length);
      return new Uint8Array([...lengthBytes, ...bytes2]);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);
      if (dataBytes.length !== length) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice byte data size.`);
      }
      const internalCoder = new ArrayCoder(new NumberCoder("u8"), length);
      const [decodedValue] = internalCoder.decode(dataBytes, 0);
      return [decodedValue, offsetAndLength + length];
    }
  };
  var StdStringCoder = class extends Coder {
    constructor() {
      super("struct", "struct String", WORD_SIZE);
    }
    encode(value) {
      const bytes2 = toUtf8Bytes(value);
      const lengthBytes = new BigNumberCoder("u64").encode(value.length);
      return new Uint8Array([...lengthBytes, ...bytes2]);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);
      if (dataBytes.length !== length) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);
      }
      return [toUtf8String(dataBytes), offsetAndLength + length];
    }
  };
  __publicField7(StdStringCoder, "memorySize", 1);
  var StrSliceCoder = class extends Coder {
    constructor() {
      super("strSlice", "str", WORD_SIZE);
    }
    encode(value) {
      const bytes2 = toUtf8Bytes(value);
      const lengthBytes = new BigNumberCoder("u64").encode(value.length);
      return new Uint8Array([...lengthBytes, ...bytes2]);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string slice data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const bytes2 = data.slice(offsetAndLength, offsetAndLength + length);
      if (bytes2.length !== length) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string slice byte data size.`);
      }
      return [toUtf8String(bytes2), offsetAndLength + length];
    }
  };
  __publicField7(StrSliceCoder, "memorySize", 1);
  var StringCoder = class extends Coder {
    constructor(length) {
      super("string", `str[${length}]`, length);
    }
    encode(value) {
      if (value.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);
      }
      return toUtf8Bytes(value);
    }
    decode(data, offset) {
      if (data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);
      }
      const bytes2 = data.slice(offset, offset + this.encodedLength);
      if (bytes2.length !== this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);
      }
      return [toUtf8String(bytes2), offset + this.encodedLength];
    }
  };
  var StructCoder = class extends Coder {
    name;
    coders;
    #hasNestedOption;
    constructor(name, coders) {
      const encodedLength = Object.values(coders).reduce(
        (acc, coder) => acc + coder.encodedLength,
        0
      );
      super("struct", `struct ${name}`, encodedLength);
      this.name = name;
      this.coders = coders;
      this.#hasNestedOption = hasNestedOption(coders);
    }
    encode(value) {
      return concatBytes(
        Object.keys(this.coders).map((fieldName) => {
          const fieldCoder = this.coders[fieldName];
          const fieldValue = value[fieldName];
          if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {
            throw new FuelError(
              ErrorCode.ENCODE_ERROR,
              `Invalid ${this.type}. Field "${fieldName}" not present.`
            );
          }
          return fieldCoder.encode(fieldValue);
        })
      );
    }
    decode(data, offset) {
      if (!this.#hasNestedOption && data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);
      }
      let newOffset = offset;
      const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {
        const fieldCoder = this.coders[fieldName];
        let decoded;
        [decoded, newOffset] = fieldCoder.decode(data, newOffset);
        obj[fieldName] = decoded;
        return obj;
      }, {});
      return [decodedValue, newOffset];
    }
  };
  var TupleCoder = class extends Coder {
    coders;
    #hasNestedOption;
    constructor(coders) {
      const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);
      super("tuple", `(${coders.map((coder) => coder.type).join(", ")})`, encodedLength);
      this.coders = coders;
      this.#hasNestedOption = hasNestedOption(coders);
    }
    encode(value) {
      if (this.coders.length !== value.length) {
        throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
      }
      return concatBytes(this.coders.map((coder, i) => coder.encode(value[i])));
    }
    decode(data, offset) {
      if (!this.#hasNestedOption && data.length < this.encodedLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);
      }
      let newOffset = offset;
      const decodedValue = this.coders.map((coder) => {
        let decoded;
        [decoded, newOffset] = coder.decode(data, newOffset);
        return decoded;
      });
      return [decodedValue, newOffset];
    }
  };
  var VecCoder = class extends Coder {
    coder;
    #hasNestedOption;
    constructor(coder) {
      super("struct", `struct Vec`, WORD_SIZE);
      this.coder = coder;
      this.#hasNestedOption = hasNestedOption([coder]);
    }
    encode(value) {
      if (!Array.isArray(value) && !isUint8Array(value)) {
        throw new FuelError(
          ErrorCode.ENCODE_ERROR,
          `Expected array value, or a Uint8Array. You can use arrayify to convert a value to a Uint8Array.`
        );
      }
      const lengthCoder = new BigNumberCoder("u64");
      if (isUint8Array(value)) {
        return new Uint8Array([...lengthCoder.encode(value.length), ...value]);
      }
      const bytes2 = value.map((v) => this.coder.encode(v));
      const lengthBytes = lengthCoder.encode(value.length);
      return new Uint8Array([...lengthBytes, ...concatBytes(bytes2)]);
    }
    decode(data, offset) {
      if (!this.#hasNestedOption && data.length < this.encodedLength || data.length > MAX_BYTES) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);
      }
      const offsetAndLength = offset + WORD_SIZE;
      const lengthBytes = data.slice(offset, offsetAndLength);
      const length = bn(new BigNumberCoder("u64").decode(lengthBytes, 0)[0]).toNumber();
      const dataLength = length * this.coder.encodedLength;
      const dataBytes = data.slice(offsetAndLength, offsetAndLength + dataLength);
      if (!this.#hasNestedOption && dataBytes.length !== dataLength) {
        throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);
      }
      let newOffset = offsetAndLength;
      const chunks = [];
      for (let i = 0; i < length; i++) {
        const [decoded, optionOffset] = this.coder.decode(data, newOffset);
        chunks.push(decoded);
        newOffset = optionOffset;
      }
      return [chunks, newOffset];
    }
  };
  var getEncodingVersion = (encoding) => {
    switch (encoding) {
      case void 0:
      case ENCODING_V1:
        return ENCODING_V1;
      default:
        throw new FuelError(
          ErrorCode.UNSUPPORTED_ENCODING_VERSION,
          `Encoding version '${encoding}' is unsupported.`
        );
    }
  };
  var findTypeById = (abi2, typeId) => {
    const type3 = abi2.types.find((t) => t.typeId === typeId);
    if (!type3) {
      throw new FuelError(
        ErrorCode.TYPE_NOT_FOUND,
        `Type with typeId '${typeId}' doesn't exist in the ABI.`
      );
    }
    return type3;
  };
  var findNonVoidInputs = (abi2, inputs) => inputs.filter((input) => findTypeById(abi2, input.type).type !== VOID_TYPE);
  var findVectorBufferArgument = (components) => {
    const bufferComponent = components.find((c) => c.name === "buf");
    const bufferTypeArgument = bufferComponent?.originalTypeArguments?.[0];
    if (!bufferComponent || !bufferTypeArgument) {
      throw new FuelError(
        ErrorCode.INVALID_COMPONENT,
        `The Vec type provided is missing or has a malformed 'buf' component.`
      );
    }
    return bufferTypeArgument;
  };
  var ResolvedAbiType = class {
    abi;
    name;
    type;
    originalTypeArguments;
    components;
    constructor(abi2, argument) {
      this.abi = abi2;
      this.name = argument.name;
      const jsonABIType = findTypeById(abi2, argument.type);
      if (jsonABIType.type.length > 256) {
        throw new FuelError(
          ErrorCode.INVALID_COMPONENT,
          `The provided ABI type is too long: ${jsonABIType.type}.`
        );
      }
      this.type = jsonABIType.type;
      this.originalTypeArguments = argument.typeArguments;
      this.components = ResolvedAbiType.getResolvedGenericComponents(
        abi2,
        argument,
        jsonABIType.components,
        jsonABIType.typeParameters ?? ResolvedAbiType.getImplicitGenericTypeParameters(abi2, jsonABIType.components)
      );
    }
    static getResolvedGenericComponents(abi2, arg, components, typeParameters) {
      if (components === null) {
        return null;
      }
      if (typeParameters === null || typeParameters.length === 0) {
        return components.map((c) => new ResolvedAbiType(abi2, c));
      }
      const typeParametersAndArgsMap = typeParameters.reduce(
        (obj, typeParameter, typeParameterIndex) => {
          const o = { ...obj };
          o[typeParameter] = structuredClone(
            arg.typeArguments?.[typeParameterIndex]
          );
          return o;
        },
        {}
      );
      const resolvedComponents = this.resolveGenericArgTypes(
        abi2,
        components,
        typeParametersAndArgsMap
      );
      return resolvedComponents.map((c) => new ResolvedAbiType(abi2, c));
    }
    static resolveGenericArgTypes(abi2, args, typeParametersAndArgsMap) {
      return args.map((arg) => {
        if (typeParametersAndArgsMap[arg.type] !== void 0) {
          return {
            ...typeParametersAndArgsMap[arg.type],
            name: arg.name
          };
        }
        if (arg.typeArguments) {
          return {
            ...structuredClone(arg),
            typeArguments: this.resolveGenericArgTypes(
              abi2,
              arg.typeArguments,
              typeParametersAndArgsMap
            )
          };
        }
        const argType = findTypeById(abi2, arg.type);
        const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi2, argType.components);
        if (implicitTypeParameters && implicitTypeParameters.length > 0) {
          return {
            ...structuredClone(arg),
            typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp])
          };
        }
        return arg;
      });
    }
    static getImplicitGenericTypeParameters(abi2, args, implicitGenericParametersParam) {
      if (!Array.isArray(args)) {
        return null;
      }
      const implicitGenericParameters = implicitGenericParametersParam ?? [];
      args.forEach((a) => {
        const argType = findTypeById(abi2, a.type);
        if (genericRegEx.test(argType.type)) {
          implicitGenericParameters.push(argType.typeId);
          return;
        }
        if (!Array.isArray(a.typeArguments)) {
          return;
        }
        this.getImplicitGenericTypeParameters(abi2, a.typeArguments, implicitGenericParameters);
      });
      return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;
    }
    getSignature() {
      const prefix = this.getArgSignaturePrefix();
      const content = this.getArgSignatureContent();
      return `${prefix}${content}`;
    }
    getArgSignaturePrefix() {
      const structMatch = structRegEx.test(this.type);
      if (structMatch) {
        return "s";
      }
      const arrayMatch = arrayRegEx.test(this.type);
      if (arrayMatch) {
        return "a";
      }
      const enumMatch = enumRegEx.test(this.type);
      if (enumMatch) {
        return "e";
      }
      return "";
    }
    getArgSignatureContent() {
      if (this.type === "raw untyped ptr") {
        return "rawptr";
      }
      if (this.type === "raw untyped slice") {
        return "rawslice";
      }
      const strMatch = stringRegEx.exec(this.type)?.groups;
      if (strMatch) {
        return `str[${strMatch.length}]`;
      }
      if (this.components === null) {
        return this.type;
      }
      const arrayMatch = arrayRegEx.exec(this.type)?.groups;
      if (arrayMatch) {
        return `[${this.components[0].getSignature()};${arrayMatch.length}]`;
      }
      const typeArgumentsSignature = this.originalTypeArguments !== null ? `<${this.originalTypeArguments.map((a) => new ResolvedAbiType(this.abi, a).getSignature()).join(",")}>` : "";
      const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(",")})`;
      return `${typeArgumentsSignature}${componentsSignature}`;
    }
  };
  var VoidCoder = class extends Coder {
    constructor() {
      super("void", VOID_TYPE, 0);
    }
    encode(_value) {
      return new Uint8Array([]);
    }
    decode(_data, offset) {
      return [void 0, offset];
    }
  };
  function getCoders(components, options) {
    const { getCoder: getCoder2 } = options;
    return components.reduce((obj, component) => {
      const o = obj;
      o[component.name] = getCoder2(component, options);
      return o;
    }, {});
  }
  var getCoder = (resolvedAbiType, _options2) => {
    switch (resolvedAbiType.type) {
      case U8_CODER_TYPE:
      case U16_CODER_TYPE:
      case U32_CODER_TYPE:
        return new NumberCoder(resolvedAbiType.type);
      case U64_CODER_TYPE:
      case RAW_PTR_CODER_TYPE:
        return new BigNumberCoder("u64");
      case U256_CODER_TYPE:
        return new BigNumberCoder("u256");
      case RAW_SLICE_CODER_TYPE:
        return new RawSliceCoder();
      case BOOL_CODER_TYPE:
        return new BooleanCoder();
      case B256_CODER_TYPE:
        return new B256Coder();
      case B512_CODER_TYPE:
        return new B512Coder();
      case BYTES_CODER_TYPE:
        return new ByteCoder();
      case STD_STRING_CODER_TYPE:
        return new StdStringCoder();
      case STR_SLICE_CODER_TYPE:
        return new StrSliceCoder();
      case VOID_TYPE:
        return new VoidCoder();
      default:
        break;
    }
    const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;
    if (stringMatch) {
      const length = parseInt(stringMatch.length, 10);
      return new StringCoder(length);
    }
    const components = resolvedAbiType.components;
    const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;
    if (arrayMatch) {
      const length = parseInt(arrayMatch.length, 10);
      const arg = components[0];
      if (!arg) {
        throw new FuelError(
          ErrorCode.INVALID_COMPONENT,
          `The provided Array type is missing an item of 'component'.`
        );
      }
      const arrayElementCoder = getCoder(arg);
      return new ArrayCoder(arrayElementCoder, length);
    }
    if (resolvedAbiType.type === VEC_CODER_TYPE) {
      const arg = findVectorBufferArgument(components);
      const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);
      const itemCoder = getCoder(argType, { encoding: ENCODING_V1 });
      return new VecCoder(itemCoder);
    }
    const coderName = resolvedAbiType.type.match(fullNameRegExMatch)?.[0];
    const structMatch = structRegEx.test(resolvedAbiType.type);
    if (structMatch && coderName) {
      const coders = getCoders(components, { getCoder });
      return new StructCoder(coderName, coders);
    }
    const enumMatch = enumRegEx.test(resolvedAbiType.type);
    if (enumMatch && coderName) {
      const coders = getCoders(components, { getCoder });
      const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;
      if (isOptionEnum) {
        return new OptionCoder(coderName, coders);
      }
      return new EnumCoder(coderName, coders);
    }
    const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;
    if (tupleMatch) {
      const coders = components.map((component) => getCoder(component, { encoding: ENCODING_V1 }));
      return new TupleCoder(coders);
    }
    throw new FuelError(
      ErrorCode.CODER_NOT_FOUND,
      `Coder not found: ${JSON.stringify(resolvedAbiType)}.`
    );
  };
  function getCoderForEncoding(encoding = ENCODING_V1) {
    switch (encoding) {
      case ENCODING_V1:
        return getCoder;
      default:
        throw new FuelError(
          ErrorCode.UNSUPPORTED_ENCODING_VERSION,
          `Encoding version ${encoding} is unsupported.`
        );
    }
  }
  var AbiCoder = class {
    static getCoder(abi2, argument, options = {
      padToWordSize: false
    }) {
      const resolvedAbiType = new ResolvedAbiType(abi2, argument);
      return getCoderForEncoding(options.encoding)(resolvedAbiType, options);
    }
    static encode(abi2, argument, value, options) {
      return this.getCoder(abi2, argument, options).encode(value);
    }
    static decode(abi2, argument, data, offset, options) {
      return this.getCoder(abi2, argument, options).decode(data, offset);
    }
  };
  var getFunctionInputs3 = (params) => {
    const { jsonAbi, inputs } = params;
    let isMandatory = false;
    return inputs.reduceRight((result, input) => {
      const type3 = findTypeById(jsonAbi, input.type);
      isMandatory = isMandatory || type3.type !== VOID_TYPE && !optionRegEx.test(type3.type);
      return [{ ...input, isOptional: !isMandatory }, ...result];
    }, []);
  };
  var padValuesWithUndefined = (values, inputs) => {
    if (values.length >= inputs.length) {
      return values;
    }
    const paddedValues = values.slice();
    paddedValues.length = inputs.length;
    paddedValues.fill(void 0, values.length);
    return paddedValues;
  };
  var FunctionFragment = class {
    signature;
    selector;
    selectorBytes;
    encoding;
    name;
    jsonFn;
    attributes;
    jsonAbiOld;
    jsonFnOld;
    constructor(jsonAbi, fn) {
      this.jsonFn = fn;
      this.jsonAbiOld = jsonAbi;
      this.jsonFnOld = jsonAbi.functions.find((f2) => f2.name === fn.name);
      this.name = fn.name;
      this.signature = FunctionFragment.getSignature(this.jsonAbiOld, this.jsonFnOld);
      this.selector = FunctionFragment.getFunctionSelector(this.signature);
      this.selectorBytes = new StdStringCoder().encode(this.name);
      this.encoding = getEncodingVersion(jsonAbi.encoding);
      this.attributes = this.jsonFn.attributes ?? [];
    }
    static getSignature(abi2, fn) {
      const inputsSignatures = fn.inputs.map(
        (input) => new ResolvedAbiType(abi2, input).getSignature()
      );
      return `${fn.name}(${inputsSignatures.join(",")})`;
    }
    static getFunctionSelector(functionSignature) {
      const hashedFunctionSignature = sha2562(bufferFromString2(functionSignature, "utf-8"));
      return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);
    }
    encodeArguments(values) {
      const inputs = getFunctionInputs3({ jsonAbi: this.jsonAbiOld, inputs: this.jsonFnOld.inputs });
      const mandatoryInputLength = inputs.filter((i) => !i.isOptional).length;
      if (values.length < mandatoryInputLength) {
        throw new FuelError(
          ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH,
          `Invalid number of arguments. Expected a minimum of ${mandatoryInputLength} arguments, received ${values.length}`
        );
      }
      const coders = this.jsonFnOld.inputs.map(
        (t) => AbiCoder.getCoder(this.jsonAbiOld, t, {
          encoding: this.encoding
        })
      );
      const argumentValues = padValuesWithUndefined(values, this.jsonFn.inputs);
      return new TupleCoder(coders).encode(argumentValues);
    }
    decodeArguments(data) {
      const bytes2 = arrayify(data);
      const nonVoidInputs = findNonVoidInputs(this.jsonAbiOld, this.jsonFnOld.inputs);
      if (nonVoidInputs.length === 0) {
        if (bytes2.length === 0) {
          return void 0;
        }
        throw new FuelError(
          ErrorCode.DECODE_ERROR,
          `Types/values length mismatch during decode. ${JSON.stringify({
            count: {
              types: this.jsonFn.inputs.length,
              nonVoidInputs: nonVoidInputs.length,
              values: bytes2.length
            },
            value: {
              args: this.jsonFn.inputs,
              nonVoidInputs,
              values: bytes2
            }
          })}`
        );
      }
      const result = this.jsonFnOld.inputs.reduce(
        (obj, input) => {
          const coder = AbiCoder.getCoder(this.jsonAbiOld, input, { encoding: this.encoding });
          const [decodedValue, decodedValueByteSize] = coder.decode(bytes2, obj.offset);
          return {
            decoded: [...obj.decoded, decodedValue],
            offset: obj.offset + decodedValueByteSize
          };
        },
        { decoded: [], offset: 0 }
      );
      return result.decoded;
    }
    decodeOutput(data) {
      const bytes2 = arrayify(data);
      const coder = AbiCoder.getCoder(this.jsonAbiOld, this.jsonFnOld.output, {
        encoding: this.encoding
      });
      return coder.decode(bytes2, 0);
    }
    /**
     * Checks if the function is read-only i.e. it only reads from storage, does not write to it.
     *
     * @returns True if the function is read-only or pure, false otherwise.
     */
    isReadOnly() {
      const storageAttribute = this.attributes.find((attr) => attr.name === "storage");
      return !storageAttribute?.arguments?.includes("write");
    }
  };
  var findTypeByConcreteId3 = (types2, id) => types2.find((x) => x.concreteTypeId === id);
  var findConcreteTypeById3 = (abi2, id) => abi2.concreteTypes.find((x) => x.concreteTypeId === id);
  function finsertTypeIdByConcreteTypeId3(abi2, types2, id) {
    const concreteType = findConcreteTypeById3(abi2, id);
    if (concreteType.metadataTypeId !== void 0) {
      return concreteType.metadataTypeId;
    }
    const type3 = findTypeByConcreteId3(types2, id);
    if (type3) {
      return type3.typeId;
    }
    types2.push({
      typeId: types2.length,
      type: concreteType.type,
      components: parseComponents3(concreteType.components),
      concreteTypeId: id,
      typeParameters: concreteType.typeParameters ?? null,
      originalConcreteTypeId: concreteType?.concreteTypeId
    });
    return types2.length - 1;
  }
  function parseFunctionTypeArguments3(abi2, types2, concreteType) {
    return concreteType.typeArguments?.map((cTypeId) => {
      const self2 = findConcreteTypeById3(abi2, cTypeId);
      const type3 = !isNaN(cTypeId) ? cTypeId : finsertTypeIdByConcreteTypeId3(abi2, types2, cTypeId);
      return {
        name: "",
        type: type3,
        // originalTypeId: cTypeId,
        typeArguments: parseFunctionTypeArguments3(abi2, types2, self2)
      };
    }) ?? null;
  }
  function parseConcreteType3(abi2, types2, concreteTypeId, name) {
    const type3 = finsertTypeIdByConcreteTypeId3(abi2, types2, concreteTypeId);
    const concrete = findConcreteTypeById3(abi2, concreteTypeId);
    return {
      name: name ?? "",
      type: type3,
      // concreteTypeId,
      typeArguments: parseFunctionTypeArguments3(abi2, types2, concrete)
    };
  }
  function parseComponents3(abi2, types2, components) {
    return components?.map((component) => {
      const { typeId, name, typeArguments } = component;
      const type3 = !isNaN(typeId) ? typeId : finsertTypeIdByConcreteTypeId3(abi2, types2, typeId);
      return {
        name,
        type: type3,
        // originalTypeId: typeId,
        typeArguments: parseComponents3(abi2, types2, typeArguments)
      };
    }) ?? null;
  }
  function transpileAbi3(abi2) {
    if (!abi2.specVersion) {
      return abi2;
    }
    const types2 = [];
    abi2.metadataTypes.forEach((m) => {
      const t = {
        typeId: m.metadataTypeId,
        type: m.type,
        components: m.components ?? (m.type === "()" ? [] : null),
        typeParameters: m.typeParameters ?? null
      };
      types2.push(t);
    });
    types2.forEach((t) => {
      t.components = parseComponents3(abi2, types2, t.components);
    });
    const functions = abi2.functions.map((fn) => {
      const inputs = fn.inputs.map(
        ({ concreteTypeId, name }) => parseConcreteType3(abi2, types2, concreteTypeId, name)
      );
      const output2 = parseConcreteType3(abi2, types2, fn.output, "");
      return { ...fn, inputs, output: output2 };
    });
    const configurables = abi2.configurables.map((conf) => ({
      name: conf.name,
      configurableType: parseConcreteType3(abi2, types2, conf.concreteTypeId),
      offset: conf.offset
    }));
    const loggedTypes = abi2.loggedTypes.map((log4) => ({
      logId: log4.logId,
      loggedType: parseConcreteType3(abi2, types2, log4.concreteTypeId)
    }));
    const transpiled = {
      encoding: abi2.encodingVersion,
      types: types2,
      functions,
      loggedTypes,
      messagesTypes: abi2.messagesTypes,
      configurables
    };
    return transpiled;
  }
  var Interface = class {
    functions;
    configurables;
    jsonAbi;
    encoding;
    jsonAbiOld;
    constructor(jsonAbi) {
      this.jsonAbi = jsonAbi;
      this.encoding = getEncodingVersion(jsonAbi.encodingVersion);
      this.jsonAbiOld = transpileAbi3(jsonAbi);
      this.functions = Object.fromEntries(
        this.jsonAbi.functions.map((fn) => [fn.name, new FunctionFragment(this.jsonAbiOld, fn)])
      );
      this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));
    }
    /**
     * Returns function fragment for a dynamic input.
     * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment
     */
    getFunction(nameOrSignatureOrSelector) {
      const fn = Object.values(this.functions).find(
        (f2) => f2.name === nameOrSignatureOrSelector || f2.signature === nameOrSignatureOrSelector || f2.selector === nameOrSignatureOrSelector
      );
      if (fn !== void 0) {
        return fn;
      }
      throw new FuelError(
        ErrorCode.FUNCTION_NOT_FOUND,
        `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`
      );
    }
    // Decode the result of a function call
    decodeFunctionResult(functionFragment, data) {
      const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
      return fragment.decodeOutput(data);
    }
    decodeLog(data, logId) {
      const loggedType = this.jsonAbiOld.loggedTypes.find((type3) => type3.logId === logId);
      if (!loggedType) {
        throw new FuelError(
          ErrorCode.LOG_TYPE_NOT_FOUND,
          `Log type with logId '${logId}' doesn't exist in the ABI.`
        );
      }
      return AbiCoder.decode(this.jsonAbiOld, loggedType.loggedType, arrayify(data), 0, {
        encoding: this.encoding
      });
    }
    encodeConfigurable(name, value) {
      const configurable = this.jsonAbiOld.configurables.find((c) => c.name === name);
      if (!configurable) {
        throw new FuelError(
          ErrorCode.CONFIGURABLE_NOT_FOUND,
          `A configurable with the '${name}' was not found in the ABI.`
        );
      }
      return AbiCoder.encode(this.jsonAbiOld, configurable.configurableType, value, {
        encoding: this.encoding
      });
    }
    encodeType(concreteTypeId, value) {
      const typeArg = parseConcreteType3(
        this.jsonAbi,
        this.jsonAbiOld.types,
        concreteTypeId,
        ""
      );
      return AbiCoder.encode(this.jsonAbiOld, typeArg, value, {
        encoding: this.encoding
      });
    }
    decodeType(concreteTypeId, data) {
      const typeArg = parseConcreteType3(
        this.jsonAbi,
        this.jsonAbiOld.types,
        concreteTypeId,
        ""
      );
      return AbiCoder.decode(this.jsonAbiOld, typeArg, data, 0, { encoding: this.encoding });
    }
  };

  // ../address/dist/index.mjs
  function isB256(address) {
    return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);
  }
  function isPublicKey(address) {
    return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);
  }
  function isEvmAddress(address) {
    return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);
  }
  function normalizeB256(address) {
    return address.toLowerCase();
  }
  function isAddress(address) {
    return "b256Address" in address;
  }
  var addressify = (addressLike) => {
    if (isAddress(addressLike)) {
      return addressLike;
    }
    if ("address" in addressLike && isAddress(addressLike.address)) {
      return addressLike.address;
    }
    if ("id" in addressLike && isAddress(addressLike.id)) {
      return addressLike.id;
    }
    throw new FuelError(FuelError.CODES.INVALID_ADDRESS, "Invalid address");
  };
  var getRandomB256 = () => hexlify(randomBytes22(32));
  var toB256AddressEvm = (b256) => {
    try {
      if (!isB256(b256)) {
        throw new FuelError(FuelError.CODES.INVALID_B256_ADDRESS, `Invalid B256 Address: ${b256}.`);
      }
      const evmBytes = arrayify(b256).slice(12);
      const paddedBytes = new Uint8Array(12).fill(0);
      return hexlify(concat([paddedBytes, evmBytes]));
    } catch (error3) {
      throw new FuelError(
        FuelError.CODES.PARSE_FAILED,
        `Cannot generate EVM Address B256 from: ${b256}.`
      );
    }
  };
  var padFirst12BytesOfEvmAddress = (address) => {
    if (!isEvmAddress(address)) {
      throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
    }
    return address.replace("0x", "0x000000000000000000000000");
  };
  var Address = class {
    // #region address-2
    b256Address;
    // #endregion address-2
    /**
     * @param address - A B256 address
     */
    constructor(address) {
      if (!isB256(address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_B256_ADDRESS,
          `Invalid B256 Address: ${address}.`
        );
      }
      this.b256Address = normalizeB256(address);
    }
    /**
     * Takes an B256 Address and returns back an checksum address.
     * The implementation follows the ERC-55 https://github.com/ethereum/ercs/blob/master/ERCS/erc-55.md.
     *
     * @returns A new `ChecksumAddress` instance
     */
    toChecksum() {
      return Address.toChecksum(this.b256Address);
    }
    /**
     * Returns the `b256Address` property
     */
    toAddress() {
      return this.b256Address;
    }
    /**
     * Returns the B256 hash address as a string
     *
     * @returns The B256 address
     */
    toB256() {
      return this.b256Address;
    }
    /**
     * Returns the B256 hash address as a Uint8Array
     *
     * @returns The B256 address as a Uint8Array
     */
    toBytes() {
      return arrayify(this.b256Address);
    }
    /**
     * Returns the B256 hash address as a string
     *
     * @returns The B256 address
     */
    toHexString() {
      return this.toB256();
    }
    /**
     * returns the address `checksum` as a string
     *
     * @returns The `b256Address` property as a string
     */
    toString() {
      return this.toChecksum();
    }
    /**
     * Converts and returns the `b256Address` property as a string
     * @returns The `b256Address` property as a JSON string
     */
    toJSON() {
      return this.b256Address;
    }
    /**
     * Converts to an EVM address
     *
     * @returns an {@link EvmAddress | `EvmAddress`} representation of the address
     */
    toEvmAddress() {
      return {
        bits: toB256AddressEvm(this.b256Address)
      };
    }
    /**
     * Wraps the B256 property and returns as an `AssetId`.
     * @returns The B256 property as an {@link AssetId | `AssetId`}
     */
    toAssetId() {
      return {
        bits: this.b256Address
      };
    }
    /**
     * Wraps the B256 address `checksum` and returns it as a string
     * @returns The B256 address `checksum` as a string
     */
    valueOf() {
      return this.toChecksum();
    }
    /**
     * Compares this the `b256Address` property to another for direct equality
     * @param other - Another address to compare against
     * @returns The equality of the comparison
     */
    equals(other) {
      return this.toChecksum() === other.toChecksum();
    }
    /**
     * Takes a Public Key, hashes it, and creates an `Address`
     *
     * @param publicKey - A wallets public key
     * @returns A new `Address` instance
     */
    static fromPublicKey(publicKey) {
      if (!isPublicKey(publicKey)) {
        throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);
      }
      const b256Address = hexlify(sha256(arrayify(publicKey)));
      return new Address(b256Address);
    }
    /**
     * Takes a B256 Address and creates an `Address`
     *
     * @param b256Address - A b256 hash
     * @returns A new `Address` instance
     */
    static fromB256(b256Address) {
      if (!isB256(b256Address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_B256_ADDRESS,
          `Invalid B256 Address: ${b256Address}.`
        );
      }
      return new Address(b256Address);
    }
    /**
     * Creates an `Address` with a randomized `b256Address` property
     *
     * @returns A new `Address` instance
     */
    static fromRandom() {
      return this.fromB256(getRandomB256());
    }
    /**
     * Takes an ambiguous string and attempts to create an `Address`
     *
     * @param address - An ambiguous string
     * @returns A new `Address` instance
     */
    static fromString(address) {
      return this.fromB256(address);
    }
    /**
     * Takes an ambiguous string or address and creates an `Address`
     *
     * @returns a new `Address` instance
     */
    static fromAddressOrString(address) {
      return typeof address === "string" ? this.fromString(address) : address;
    }
    /**
     * Takes a dynamic string or `Address` and creates an `Address`
     *
     * @param addressId - A string containing B256, or Public Key
     * @throws Error - Unknown address if the format is not recognised
     * @returns A new `Address` instance
     */
    static fromDynamicInput(address) {
      if (typeof address !== "string" && "toB256" in address) {
        return Address.fromB256(address.toB256());
      }
      if (isPublicKey(address)) {
        return Address.fromPublicKey(address);
      }
      if (isB256(address)) {
        return Address.fromB256(address);
      }
      if (isEvmAddress(address)) {
        return Address.fromEvmAddress(address);
      }
      throw new FuelError(
        FuelError.CODES.PARSE_FAILED,
        `Unknown address format: only 'B256', or 'Public Key (512)' are supported.`
      );
    }
    /**
     * Takes an Evm Address and returns back an `Address`
     *
     * @returns A new `Address` instance
     */
    static fromEvmAddress(evmAddress) {
      if (!isEvmAddress(evmAddress)) {
        throw new FuelError(
          FuelError.CODES.INVALID_EVM_ADDRESS,
          `Invalid Evm Address: ${evmAddress}.`
        );
      }
      const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);
      return new Address(paddedAddress);
    }
    /**
     * Takes an ChecksumAddress and validates if it is a valid checksum address.
     *
     * @returns A `boolean` instance indicating if the address is valid.
     */
    static isChecksumValid(address) {
      let addressParsed = address;
      if (!address.startsWith("0x")) {
        addressParsed = `0x${address}`;
      }
      if (addressParsed.trim().length !== 66) {
        return false;
      }
      return Address.toChecksum(hexlify(addressParsed)) === addressParsed;
    }
    /** @hidden */
    static toChecksum(address) {
      if (!isB256(address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_B256_ADDRESS,
          `Invalid B256 Address: ${address}.`
        );
      }
      const addressHex = hexlify(address).toLowerCase().slice(2);
      const checksum = sha256(addressHex);
      let ret4 = "0x";
      for (let i = 0; i < 32; ++i) {
        const byte = checksum[i];
        const ha = addressHex.charAt(i * 2);
        const hb = addressHex.charAt(i * 2 + 1);
        ret4 += (byte & 240) >= 128 ? ha.toUpperCase() : ha;
        ret4 += (byte & 15) >= 8 ? hb.toUpperCase() : hb;
      }
      return ret4;
    }
  };

  // ../transactions/dist/index.mjs
  var ByteArrayCoder = class extends Coder {
    length;
    #paddingLength;
    constructor(length) {
      const paddingLength = (8 - length % 8) % 8;
      const encodedLength = length + paddingLength;
      super(
        "ByteArray",
        // While this might sound like a [u8; N] coder it's actually not.
        // A [u8; N] coder would pad every u8 to 8 bytes which would
        // make every u8 have the same size as a u64.
        // We are packing four u8s into u64s here, avoiding this padding.
        `[u64; ${encodedLength / 4}]`,
        encodedLength
      );
      this.length = length;
      this.#paddingLength = paddingLength;
    }
    encode(value) {
      const parts = [];
      const data = arrayify(value);
      parts.push(data);
      if (this.#paddingLength) {
        parts.push(new Uint8Array(this.#paddingLength));
      }
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = [hexlify(data.slice(o, o + this.length)), o + this.length];
      const value = decoded;
      if (this.#paddingLength) {
        [decoded, o] = [null, o + this.#paddingLength];
      }
      return [value, o];
    }
  };
  var TxPointerCoder = class extends StructCoder {
    constructor() {
      super("TxPointer", {
        blockHeight: new NumberCoder("u32", { padToWordSize: true }),
        txIndex: new NumberCoder("u16", { padToWordSize: true })
      });
    }
    static decodeFromGqlScalar(value) {
      if (value.length !== 12) {
        throw new FuelError(
          ErrorCode.DECODE_ERROR,
          `Invalid TxPointer scalar string length ${value.length}. It must have length 12.`
        );
      }
      const [blockHeight, txIndex] = [value.substring(0, 8), value.substring(8)];
      return {
        blockHeight: parseInt(blockHeight, 16),
        txIndex: parseInt(txIndex, 16)
      };
    }
  };
  var InputType = /* @__PURE__ */ ((InputType2) => {
    InputType2[InputType2["Coin"] = 0] = "Coin";
    InputType2[InputType2["Contract"] = 1] = "Contract";
    InputType2[InputType2["Message"] = 2] = "Message";
    return InputType2;
  })(InputType || {});
  var InputCoinCoder = class extends Coder {
    constructor() {
      super("InputCoin", "struct InputCoin", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.txID));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.outputIndex));
      parts.push(new B256Coder().encode(value.owner));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessIndex));
      parts.push(new BigNumberCoder("u64").encode(value.predicateGasUsed));
      parts.push(new BigNumberCoder("u64").encode(value.predicateLength));
      parts.push(new BigNumberCoder("u64").encode(value.predicateDataLength));
      parts.push(new ByteArrayCoder(value.predicateLength.toNumber()).encode(value.predicate));
      parts.push(
        new ByteArrayCoder(value.predicateDataLength.toNumber()).encode(value.predicateData)
      );
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const txID = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const outputIndex = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const owner = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessIndex = Number(decoded);
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const predicateGasUsed = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const predicateLength = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const predicateDataLength = decoded;
      [decoded, o] = new ByteArrayCoder(predicateLength.toNumber()).decode(data, o);
      const predicate = decoded;
      [decoded, o] = new ByteArrayCoder(predicateDataLength.toNumber()).decode(data, o);
      const predicateData = decoded;
      return [
        {
          type: 0,
          txID,
          outputIndex,
          owner,
          amount,
          assetId,
          txPointer,
          witnessIndex,
          predicateGasUsed,
          predicateLength,
          predicateDataLength,
          predicate,
          predicateData
        },
        o
      ];
    }
  };
  var InputContractCoder = class extends Coder {
    constructor() {
      super("InputContract", "struct InputContract", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.txID));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.outputIndex));
      parts.push(new B256Coder().encode(value.balanceRoot));
      parts.push(new B256Coder().encode(value.stateRoot));
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new B256Coder().encode(value.contractID));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const txID = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const outputIndex = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const balanceRoot = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractID = decoded;
      return [
        {
          type: 1,
          txID,
          outputIndex,
          balanceRoot,
          stateRoot,
          txPointer,
          contractID
        },
        o
      ];
    }
  };
  var InputMessageCoder = class extends Coder {
    constructor() {
      super("InputMessage", "struct InputMessage", 0);
    }
    static getMessageId(value) {
      const parts = [];
      parts.push(new ByteArrayCoder(32).encode(value.sender));
      parts.push(new ByteArrayCoder(32).encode(value.recipient));
      parts.push(new ByteArrayCoder(32).encode(value.nonce));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(arrayify(value.data || "0x"));
      return sha2562(concat(parts));
    }
    static encodeData(messageData) {
      const bytes2 = arrayify(messageData || "0x");
      const dataLength = bytes2.length;
      return new ByteArrayCoder(dataLength).encode(bytes2);
    }
    encode(value) {
      const parts = [];
      const data = InputMessageCoder.encodeData(value.data);
      parts.push(new ByteArrayCoder(32).encode(value.sender));
      parts.push(new ByteArrayCoder(32).encode(value.recipient));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new ByteArrayCoder(32).encode(value.nonce));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessIndex));
      parts.push(new BigNumberCoder("u64").encode(value.predicateGasUsed));
      parts.push(new BigNumberCoder("u64").encode(data.length));
      parts.push(new BigNumberCoder("u64").encode(value.predicateLength));
      parts.push(new BigNumberCoder("u64").encode(value.predicateDataLength));
      parts.push(new ByteArrayCoder(data.length).encode(data));
      parts.push(new ByteArrayCoder(value.predicateLength.toNumber()).encode(value.predicate));
      parts.push(
        new ByteArrayCoder(value.predicateDataLength.toNumber()).encode(value.predicateData)
      );
      return concat(parts);
    }
    static decodeData(messageData) {
      const bytes2 = arrayify(messageData);
      const dataLength = bytes2.length;
      const [data] = new ByteArrayCoder(dataLength).decode(bytes2, 0);
      return arrayify(data);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const sender = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const recipient = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const nonce = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessIndex = Number(decoded);
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const predicateGasUsed = decoded;
      [decoded, o] = new NumberCoder("u32", { padToWordSize: true }).decode(data, o);
      const dataLength = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const predicateLength = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const predicateDataLength = decoded;
      [decoded, o] = new ByteArrayCoder(dataLength).decode(data, o);
      const messageData = decoded;
      [decoded, o] = new ByteArrayCoder(predicateLength.toNumber()).decode(data, o);
      const predicate = decoded;
      [decoded, o] = new ByteArrayCoder(predicateDataLength.toNumber()).decode(data, o);
      const predicateData = decoded;
      return [
        {
          type: 2,
          sender,
          recipient,
          amount,
          witnessIndex,
          nonce,
          predicateGasUsed,
          dataLength,
          predicateLength,
          predicateDataLength,
          data: messageData,
          predicate,
          predicateData
        },
        o
      ];
    }
  };
  var InputCoder = class extends Coder {
    constructor() {
      super("Input", "struct Input", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8", { padToWordSize: true }).encode(value.type));
      const { type: type3 } = value;
      switch (type3) {
        case 0: {
          parts.push(new InputCoinCoder().encode(value));
          break;
        }
        case 1: {
          parts.push(new InputContractCoder().encode(value));
          break;
        }
        case 2: {
          parts.push(new InputMessageCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_INPUT,
            `Invalid transaction input type: ${type3}.`
          );
        }
      }
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8", { padToWordSize: true }).decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new InputCoinCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new InputContractCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new InputMessageCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_INPUT,
            `Invalid transaction input type: ${type3}.`
          );
        }
      }
    }
  };
  var OutputType = /* @__PURE__ */ ((OutputType2) => {
    OutputType2[OutputType2["Coin"] = 0] = "Coin";
    OutputType2[OutputType2["Contract"] = 1] = "Contract";
    OutputType2[OutputType2["Change"] = 2] = "Change";
    OutputType2[OutputType2["Variable"] = 3] = "Variable";
    OutputType2[OutputType2["ContractCreated"] = 4] = "ContractCreated";
    return OutputType2;
  })(OutputType || {});
  var OutputCoinCoder = class extends Coder {
    constructor() {
      super("OutputCoin", "struct OutputCoin", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 0,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputContractCoder = class extends Coder {
    constructor() {
      super("OutputContract", "struct OutputContract", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8", { padToWordSize: true }).encode(value.inputIndex));
      parts.push(new B256Coder().encode(value.balanceRoot));
      parts.push(new B256Coder().encode(value.stateRoot));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8", { padToWordSize: true }).decode(data, o);
      const inputIndex = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const balanceRoot = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      return [
        {
          type: 1,
          inputIndex,
          balanceRoot,
          stateRoot
        },
        o
      ];
    }
  };
  var OutputChangeCoder = class extends Coder {
    constructor() {
      super("OutputChange", "struct OutputChange", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 2,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputVariableCoder = class extends Coder {
    constructor() {
      super("OutputVariable", "struct OutputVariable", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new BigNumberCoder("u64").encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 3,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputContractCreatedCoder = class extends Coder {
    constructor() {
      super("OutputContractCreated", "struct OutputContractCreated", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.contractId));
      parts.push(new B256Coder().encode(value.stateRoot));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractId = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      return [
        {
          type: 4,
          contractId,
          stateRoot
        },
        o
      ];
    }
  };
  var OutputCoder = class extends Coder {
    constructor() {
      super("Output", " struct Output", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8", { padToWordSize: true }).encode(value.type));
      const { type: type3 } = value;
      switch (type3) {
        case 0: {
          parts.push(new OutputCoinCoder().encode(value));
          break;
        }
        case 1: {
          parts.push(new OutputContractCoder().encode(value));
          break;
        }
        case 2: {
          parts.push(new OutputChangeCoder().encode(value));
          break;
        }
        case 3: {
          parts.push(new OutputVariableCoder().encode(value));
          break;
        }
        case 4: {
          parts.push(new OutputContractCreatedCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_OUTPUT,
            `Invalid transaction output type: ${type3}.`
          );
        }
      }
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8", { padToWordSize: true }).decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new OutputCoinCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new OutputContractCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new OutputChangeCoder().decode(data, o);
          return [decoded, o];
        }
        case 3: {
          [decoded, o] = new OutputVariableCoder().decode(data, o);
          return [decoded, o];
        }
        case 4: {
          [decoded, o] = new OutputContractCreatedCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_OUTPUT,
            `Invalid transaction output type: ${type3}.`
          );
        }
      }
    }
  };
  var PolicyType = /* @__PURE__ */ ((PolicyType2) => {
    PolicyType2[PolicyType2["Tip"] = 1] = "Tip";
    PolicyType2[PolicyType2["WitnessLimit"] = 2] = "WitnessLimit";
    PolicyType2[PolicyType2["Maturity"] = 4] = "Maturity";
    PolicyType2[PolicyType2["MaxFee"] = 8] = "MaxFee";
    return PolicyType2;
  })(PolicyType || {});
  var sortPolicies = (policies) => policies.sort((a, b) => a.type - b.type);
  function validateDuplicatedPolicies(policies) {
    const seenTypes = /* @__PURE__ */ new Set();
    policies.forEach((policy) => {
      if (seenTypes.has(policy.type)) {
        throw new FuelError(
          ErrorCode.DUPLICATED_POLICY,
          `Duplicate policy type found: ${8}`
        );
      }
      seenTypes.add(policy.type);
    });
  }
  var PoliciesCoder = class extends Coder {
    constructor() {
      super("Policies", "array Policy", 0);
    }
    encode(policies) {
      validateDuplicatedPolicies(policies);
      const sortedPolicies = sortPolicies(policies);
      const parts = [];
      sortedPolicies.forEach(({ data, type: type3 }) => {
        switch (type3) {
          case 8:
          case 1:
          case 2:
            parts.push(new BigNumberCoder("u64").encode(data));
            break;
          case 4:
            parts.push(new NumberCoder("u32", { padToWordSize: true }).encode(data));
            break;
          default: {
            throw new FuelError(ErrorCode.INVALID_POLICY_TYPE, `Invalid policy type: ${type3}`);
          }
        }
      });
      return concat(parts);
    }
    decode(data, offset, policyTypes) {
      let o = offset;
      const policies = [];
      if (policyTypes & 1) {
        const [tip, nextOffset] = new BigNumberCoder("u64").decode(data, o);
        o = nextOffset;
        policies.push({ type: 1, data: tip });
      }
      if (policyTypes & 2) {
        const [witnessLimit, nextOffset] = new BigNumberCoder("u64").decode(data, o);
        o = nextOffset;
        policies.push({ type: 2, data: witnessLimit });
      }
      if (policyTypes & 4) {
        const [maturity, nextOffset] = new NumberCoder("u32", { padToWordSize: true }).decode(
          data,
          o
        );
        o = nextOffset;
        policies.push({ type: 4, data: maturity });
      }
      if (policyTypes & 8) {
        const [maxFee, nextOffset] = new BigNumberCoder("u64").decode(data, o);
        o = nextOffset;
        policies.push({ type: 8, data: maxFee });
      }
      return [policies, o];
    }
  };
  var ReceiptType = /* @__PURE__ */ ((ReceiptType2) => {
    ReceiptType2[ReceiptType2["Call"] = 0] = "Call";
    ReceiptType2[ReceiptType2["Return"] = 1] = "Return";
    ReceiptType2[ReceiptType2["ReturnData"] = 2] = "ReturnData";
    ReceiptType2[ReceiptType2["Panic"] = 3] = "Panic";
    ReceiptType2[ReceiptType2["Revert"] = 4] = "Revert";
    ReceiptType2[ReceiptType2["Log"] = 5] = "Log";
    ReceiptType2[ReceiptType2["LogData"] = 6] = "LogData";
    ReceiptType2[ReceiptType2["Transfer"] = 7] = "Transfer";
    ReceiptType2[ReceiptType2["TransferOut"] = 8] = "TransferOut";
    ReceiptType2[ReceiptType2["ScriptResult"] = 9] = "ScriptResult";
    ReceiptType2[ReceiptType2["MessageOut"] = 10] = "MessageOut";
    ReceiptType2[ReceiptType2["Mint"] = 11] = "Mint";
    ReceiptType2[ReceiptType2["Burn"] = 12] = "Burn";
    return ReceiptType2;
  })(ReceiptType || {});
  var getMintedAssetId = (contractId, subId) => {
    const contractIdBytes = arrayify(contractId);
    const subIdBytes = arrayify(subId);
    return sha2562(concat([contractIdBytes, subIdBytes]));
  };
  var StorageSlotCoder = class extends StructCoder {
    constructor() {
      super("StorageSlot", {
        key: new B256Coder(),
        value: new B256Coder()
      });
    }
  };
  var UpgradePurposeTypeEnum = /* @__PURE__ */ ((UpgradePurposeTypeEnum2) => {
    UpgradePurposeTypeEnum2[UpgradePurposeTypeEnum2["ConsensusParameters"] = 0] = "ConsensusParameters";
    UpgradePurposeTypeEnum2[UpgradePurposeTypeEnum2["StateTransition"] = 1] = "StateTransition";
    return UpgradePurposeTypeEnum2;
  })(UpgradePurposeTypeEnum || {});
  var UpgradePurposeCoder = class extends Coder {
    constructor() {
      super("UpgradePurpose", "UpgradePurpose", 0);
    }
    encode(upgradePurposeType) {
      const parts = [];
      const { type: type3 } = upgradePurposeType;
      parts.push(new NumberCoder("u8", { padToWordSize: true }).encode(type3));
      switch (type3) {
        case 0: {
          const data = upgradePurposeType.data;
          parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(data.witnessIndex));
          parts.push(new B256Coder().encode(data.checksum));
          break;
        }
        case 1: {
          const data = upgradePurposeType.data;
          parts.push(new B256Coder().encode(data.bytecodeRoot));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
            `Unsupported transaction type: ${type3}`
          );
        }
      }
      return concat(parts);
    }
    decode(data, offset) {
      let o = offset;
      let decoded;
      [decoded, o] = new NumberCoder("u8", { padToWordSize: true }).decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
          const witnessIndex = decoded;
          [decoded, o] = new B256Coder().decode(data, o);
          const checksum = decoded;
          return [{ type: type3, data: { witnessIndex, checksum } }, o];
        }
        case 1: {
          [decoded, o] = new B256Coder().decode(data, o);
          const bytecodeRoot = decoded;
          return [{ type: type3, data: { bytecodeRoot } }, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
            `Unsupported transaction type: ${type3}`
          );
        }
      }
    }
  };
  var WitnessCoder = class extends Coder {
    constructor() {
      super(
        "Witness",
        // Types of dynamic length are not supported in the ABI
        "unknown",
        0
      );
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u32", { padToWordSize: true }).encode(value.dataLength));
      parts.push(new ByteArrayCoder(value.dataLength).encode(value.data));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u32", { padToWordSize: true }).decode(data, o);
      const dataLength = decoded;
      [decoded, o] = new ByteArrayCoder(dataLength).decode(data, o);
      const witnessData = decoded;
      return [
        {
          dataLength,
          data: witnessData
        },
        o
      ];
    }
  };
  var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
    TransactionType2[TransactionType2["Script"] = 0] = "Script";
    TransactionType2[TransactionType2["Create"] = 1] = "Create";
    TransactionType2[TransactionType2["Mint"] = 2] = "Mint";
    TransactionType2[TransactionType2["Upgrade"] = 3] = "Upgrade";
    TransactionType2[TransactionType2["Upload"] = 4] = "Upload";
    TransactionType2[TransactionType2["Blob"] = 5] = "Blob";
    return TransactionType2;
  })(TransactionType || {});
  var TransactionScriptCoder = class extends Coder {
    constructor() {
      super("TransactionScript", "struct TransactionScript", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new BigNumberCoder("u64").encode(value.scriptGasLimit));
      parts.push(new B256Coder().encode(value.receiptsRoot));
      parts.push(new BigNumberCoder("u64").encode(value.scriptLength));
      parts.push(new BigNumberCoder("u64").encode(value.scriptDataLength));
      parts.push(new NumberCoder("u32", { padToWordSize: true }).encode(value.policyTypes));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.inputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.outputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessesCount));
      parts.push(new ByteArrayCoder(value.scriptLength.toNumber()).encode(value.script));
      parts.push(new ByteArrayCoder(value.scriptDataLength.toNumber()).encode(value.scriptData));
      parts.push(new PoliciesCoder().encode(value.policies));
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const scriptGasLimit = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const receiptsRoot = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const scriptLength = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const scriptDataLength = decoded;
      [decoded, o] = new NumberCoder("u32", { padToWordSize: true }).decode(data, o);
      const policyTypes = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new ByteArrayCoder(scriptLength.toNumber()).decode(data, o);
      const script = decoded;
      [decoded, o] = new ByteArrayCoder(scriptDataLength.toNumber()).decode(data, o);
      const scriptData = decoded;
      [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);
      const policies = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 0,
          scriptGasLimit,
          scriptLength,
          scriptDataLength,
          policyTypes,
          inputsCount,
          outputsCount,
          witnessesCount,
          receiptsRoot,
          script,
          scriptData,
          policies,
          inputs,
          outputs,
          witnesses
        },
        o
      ];
    }
  };
  var TransactionCreateCoder = class extends Coder {
    constructor() {
      super("TransactionCreate", "struct TransactionCreate", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.bytecodeWitnessIndex));
      parts.push(new B256Coder().encode(value.salt));
      parts.push(new BigNumberCoder("u64").encode(value.storageSlotsCount));
      parts.push(new NumberCoder("u32", { padToWordSize: true }).encode(value.policyTypes));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.inputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.outputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessesCount));
      parts.push(
        new ArrayCoder(new StorageSlotCoder(), value.storageSlotsCount.toNumber()).encode(
          value.storageSlots
        )
      );
      parts.push(new PoliciesCoder().encode(value.policies));
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const bytecodeWitnessIndex = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const salt = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const storageSlotsCount = decoded;
      [decoded, o] = new NumberCoder("u32", { padToWordSize: true }).decode(data, o);
      const policyTypes = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new ArrayCoder(new StorageSlotCoder(), storageSlotsCount.toNumber()).decode(
        data,
        o
      );
      const storageSlots2 = decoded;
      [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);
      const policies = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 1,
          bytecodeWitnessIndex,
          policyTypes,
          storageSlotsCount,
          inputsCount,
          outputsCount,
          witnessesCount,
          salt,
          policies,
          storageSlots: storageSlots2,
          inputs,
          outputs,
          witnesses
        },
        o
      ];
    }
  };
  var TransactionMintCoder = class extends Coder {
    constructor() {
      super("TransactionMint", "struct TransactionMint", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new InputContractCoder().encode(value.inputContract));
      parts.push(new OutputContractCoder().encode(value.outputContract));
      parts.push(new BigNumberCoder("u64").encode(value.mintAmount));
      parts.push(new B256Coder().encode(value.mintAssetId));
      parts.push(new BigNumberCoder("u64").encode(value.gasPrice));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new InputContractCoder().decode(data, o);
      const inputContract = decoded;
      [decoded, o] = new OutputContractCoder().decode(data, o);
      const outputContract = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const mintAmount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const mintAssetId = decoded;
      [decoded, o] = new BigNumberCoder("u64").decode(data, o);
      const gasPrice = decoded;
      return [
        {
          type: 2,
          txPointer,
          inputContract,
          outputContract,
          mintAmount,
          mintAssetId,
          gasPrice
        },
        o
      ];
    }
  };
  var TransactionUpgradeCoder = class extends Coder {
    constructor() {
      super("TransactionUpgrade", "struct TransactionUpgrade", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new UpgradePurposeCoder().encode(value.upgradePurpose));
      parts.push(new NumberCoder("u32", { padToWordSize: true }).encode(value.policyTypes));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.inputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.outputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessesCount));
      parts.push(new PoliciesCoder().encode(value.policies));
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new UpgradePurposeCoder().decode(data, o);
      const upgradePurpose = decoded;
      [decoded, o] = new NumberCoder("u32", { padToWordSize: true }).decode(data, o);
      const policyTypes = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);
      const policies = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 3,
          upgradePurpose,
          policyTypes,
          inputsCount,
          outputsCount,
          witnessesCount,
          policies,
          inputs,
          outputs,
          witnesses
        },
        o
      ];
    }
  };
  var TransactionUploadCoder = class extends Coder {
    constructor() {
      super("TransactionUpload", "struct TransactionUpload", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.root));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessIndex));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.subsectionIndex));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.subsectionsNumber));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.proofSetCount));
      parts.push(new NumberCoder("u32", { padToWordSize: true }).encode(value.policyTypes));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.inputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.outputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessesCount));
      parts.push(new ArrayCoder(new B256Coder(), value.proofSetCount).encode(value.proofSet));
      parts.push(new PoliciesCoder().encode(value.policies));
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const root = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessIndex = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const subsectionIndex = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const subsectionsNumber = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const proofSetCount = decoded;
      [decoded, o] = new NumberCoder("u32", { padToWordSize: true }).decode(data, o);
      const policyTypes = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new ArrayCoder(new B256Coder(), proofSetCount).decode(data, o);
      const proofSet = decoded;
      [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);
      const policies = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 4,
          root,
          witnessIndex,
          subsectionIndex,
          subsectionsNumber,
          proofSetCount,
          policyTypes,
          inputsCount,
          outputsCount,
          witnessesCount,
          proofSet,
          policies,
          inputs,
          outputs,
          witnesses
        },
        o
      ];
    }
  };
  var TransactionBlobCoder = class extends Coder {
    constructor() {
      super("TransactionBlob", "struct TransactionBlob", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.blobId));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessIndex));
      parts.push(new NumberCoder("u32", { padToWordSize: true }).encode(value.policyTypes));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.inputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.outputsCount));
      parts.push(new NumberCoder("u16", { padToWordSize: true }).encode(value.witnessesCount));
      parts.push(new PoliciesCoder().encode(value.policies));
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const blobId = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessIndex = decoded;
      [decoded, o] = new NumberCoder("u32", { padToWordSize: true }).decode(data, o);
      const policyTypes = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u16", { padToWordSize: true }).decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);
      const policies = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 5,
          blobId,
          witnessIndex,
          policyTypes,
          inputsCount,
          outputsCount,
          witnessesCount,
          policies,
          inputs,
          outputs,
          witnesses
        },
        o
      ];
    }
  };
  var TransactionCoder = class extends Coder {
    constructor() {
      super("Transaction", "struct Transaction", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8", { padToWordSize: true }).encode(value.type));
      const { type: type3 } = value;
      switch (value.type) {
        case 0: {
          parts.push(
            new TransactionScriptCoder().encode(value)
          );
          break;
        }
        case 1: {
          parts.push(
            new TransactionCreateCoder().encode(value)
          );
          break;
        }
        case 2: {
          parts.push(new TransactionMintCoder().encode(value));
          break;
        }
        case 3: {
          parts.push(
            new TransactionUpgradeCoder().encode(value)
          );
          break;
        }
        case 4: {
          parts.push(
            new TransactionUploadCoder().encode(value)
          );
          break;
        }
        case 5: {
          parts.push(new TransactionBlobCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
            `Unsupported transaction type: ${type3}`
          );
        }
      }
      return concat(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8", { padToWordSize: true }).decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new TransactionScriptCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new TransactionCreateCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new TransactionMintCoder().decode(data, o);
          return [decoded, o];
        }
        case 3: {
          [decoded, o] = new TransactionUpgradeCoder().decode(data, o);
          return [decoded, o];
        }
        case 4: {
          [decoded, o] = new TransactionUploadCoder().decode(data, o);
          return [decoded, o];
        }
        case 5: {
          [decoded, o] = new TransactionBlobCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
            `Unsupported transaction type: ${type3}`
          );
        }
      }
    }
  };

  // ../../node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    aInRange: () => aInRange,
    abool: () => abool,
    abytes: () => abytes,
    bitGet: () => bitGet,
    bitLen: () => bitLen,
    bitMask: () => bitMask,
    bitSet: () => bitSet,
    bytesToHex: () => bytesToHex,
    bytesToNumberBE: () => bytesToNumberBE,
    bytesToNumberLE: () => bytesToNumberLE,
    concatBytes: () => concatBytes3,
    createHmacDrbg: () => createHmacDrbg,
    ensureBytes: () => ensureBytes,
    equalBytes: () => equalBytes,
    hexToBytes: () => hexToBytes,
    hexToNumber: () => hexToNumber,
    inRange: () => inRange,
    isBytes: () => isBytes2,
    memoized: () => memoized,
    notImplemented: () => notImplemented,
    numberToBytesBE: () => numberToBytesBE,
    numberToBytesLE: () => numberToBytesLE,
    numberToHexUnpadded: () => numberToHexUnpadded,
    numberToVarBytesBE: () => numberToVarBytesBE,
    utf8ToBytes: () => utf8ToBytes2,
    validateObject: () => validateObject
  });
  var _0n2 = /* @__PURE__ */ BigInt(0);
  var _1n2 = /* @__PURE__ */ BigInt(1);
  var _2n2 = /* @__PURE__ */ BigInt(2);
  function isBytes2(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  function abytes(item) {
    if (!isBytes2(item))
      throw new Error("Uint8Array expected");
  }
  function abool(title, value) {
    if (typeof value !== "boolean")
      throw new Error(`${title} must be valid boolean, got "${value}".`);
  }
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes2) {
    abytes(bytes2);
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes[bytes2[i]];
    }
    return hex;
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
      return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
      return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
      return char - (asciis._a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array2 = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array2[ai] = n1 * 16 + n2;
    }
    return array2;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    abytes(bytes2);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (isBytes2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes3(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  var isPosBig = (n) => typeof n === "bigint" && _0n2 <= n;
  function inRange(n, min, max2) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max2) && min <= n && n < max2;
  }
  function aInRange(title, n, min, max2) {
    if (!inRange(n, min, max2))
      throw new Error(`expected valid ${title}: ${min} <= n < ${max2}, got ${typeof n} ${n}`);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n2; n >>= _1n2, len += 1)
      ;
    return len;
  }
  function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n2;
  }
  function bitSet(n, pos, value) {
    return n | (value ? _1n2 : _0n2) << BigInt(pos);
  }
  var bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;
  var u8n = (data) => new Uint8Array(data);
  var u8fr = (arr) => Uint8Array.from(arr);
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n()) => {
      k = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8fr([1]), seed);
      v = h();
    };
    const gen2 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes3(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object2) => object2.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object2, validators, optValidators = {}) {
    const checkField = (fieldName, type3, isOptional) => {
      const checkVal = validatorFns[type3];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type3}", expected function`);
      const val = object2[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object2)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type3}`);
      }
    };
    for (const [fieldName, type3] of Object.entries(validators))
      checkField(fieldName, type3, false);
    for (const [fieldName, type3] of Object.entries(optValidators))
      checkField(fieldName, type3, true);
    return object2;
  }
  var notImplemented = () => {
    throw new Error("not implemented");
  };
  function memoized(fn) {
    const map2 = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map2.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map2.set(arg, computed);
      return computed;
    };
  }

  // ../../node_modules/.pnpm/graphql-request@6.1.0_graphql@16.9.0/node_modules/graphql-request/build/esm/defaultJsonSerializer.js
  var defaultJsonSerializer = JSON;

  // ../../node_modules/.pnpm/graphql-request@6.1.0_graphql@16.9.0/node_modules/graphql-request/build/esm/helpers.js
  var uppercase = (str) => str.toUpperCase();
  var HeadersInstanceToPlainObject = (headers) => {
    const o = {};
    headers.forEach((v, k) => {
      o[k] = v;
    });
    return o;
  };

  // ../../node_modules/.pnpm/graphql-request@6.1.0_graphql@16.9.0/node_modules/graphql-request/build/esm/parseArgs.js
  var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
    return documentOrOptions.document ? documentOrOptions : {
      document: documentOrOptions,
      variables,
      requestHeaders,
      signal: void 0
    };
  };
  var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
    return queryOrOptions.query ? queryOrOptions : {
      query: queryOrOptions,
      variables,
      requestHeaders,
      signal: void 0
    };
  };
  var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
    return documentsOrOptions.documents ? documentsOrOptions : {
      documents: documentsOrOptions,
      requestHeaders,
      signal: void 0
    };
  };

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/jsutils/devAssert.mjs
  function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message);
    }
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/jsutils/isObjectLike.mjs
  function isObjectLike(value) {
    return typeof value == "object" && value !== null;
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/jsutils/invariant.mjs
  function invariant(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(
        message != null ? message : "Unexpected invariant triggered."
      );
    }
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/location.mjs
  var LineRegExp = /\r\n|[\n\r]/g;
  function getLocation(source, position) {
    let lastLineStart = 0;
    let line = 1;
    for (const match3 of source.body.matchAll(LineRegExp)) {
      typeof match3.index === "number" || invariant(false);
      if (match3.index >= position) {
        break;
      }
      lastLineStart = match3.index + match3[0].length;
      line += 1;
    }
    return {
      line,
      column: position + 1 - lastLineStart
    };
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/printLocation.mjs
  function printLocation(location) {
    return printSourceLocation(
      location.source,
      getLocation(location.source, location.start)
    );
  }
  function printSourceLocation(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i = 0; i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      // Lines specified like this: ["prefix", "string"],
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_, line]) => line !== void 0);
    const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
    return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/error/GraphQLError.mjs
  function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  }
  var GraphQLError = class extends Error {
    /**
     * An array of `{ line, column }` locations within the source GraphQL document
     * which correspond to this error.
     *
     * Errors during validation often contain multiple locations, for example to
     * point out two things with the same name. Errors during execution include a
     * single location, the field which produced the error.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     */
    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     */
    /**
     * An array of character offsets within the source GraphQL document
     * which correspond to this error.
     */
    /**
     * The original error thrown from a field resolver during execution.
     */
    /**
     * Extension fields to add to the formatted error.
     */
    /**
     * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
     */
    constructor(message, ...rawArgs) {
      var _this$nodes, _nodeLocations$, _ref;
      const { nodes, source, positions, path: path6, originalError, extensions } = toNormalizedOptions(rawArgs);
      super(message);
      this.name = "GraphQLError";
      this.path = path6 !== null && path6 !== void 0 ? path6 : void 0;
      this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
      this.nodes = undefinedIfEmpty(
        Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
      );
      const nodeLocations = undefinedIfEmpty(
        (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node2) => node2.loc).filter((loc) => loc != null)
      );
      this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
      this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
      this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
      const originalExtensions = isObjectLike(
        originalError === null || originalError === void 0 ? void 0 : originalError.extensions
      ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
      this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
      Object.defineProperties(this, {
        message: {
          writable: true,
          enumerable: true
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== void 0 && originalError.stack) {
        Object.defineProperty(this, "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, GraphQLError);
      } else {
        Object.defineProperty(this, "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let output2 = this.message;
      if (this.nodes) {
        for (const node2 of this.nodes) {
          if (node2.loc) {
            output2 += "\n\n" + printLocation(node2.loc);
          }
        }
      } else if (this.source && this.locations) {
        for (const location of this.locations) {
          output2 += "\n\n" + printSourceLocation(this.source, location);
        }
      }
      return output2;
    }
    toJSON() {
      const formattedError = {
        message: this.message
      };
      if (this.locations != null) {
        formattedError.locations = this.locations;
      }
      if (this.path != null) {
        formattedError.path = this.path;
      }
      if (this.extensions != null && Object.keys(this.extensions).length > 0) {
        formattedError.extensions = this.extensions;
      }
      return formattedError;
    }
  };
  function undefinedIfEmpty(array2) {
    return array2 === void 0 || array2.length === 0 ? void 0 : array2;
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/error/syntaxError.mjs
  function syntaxError(source, position, description) {
    return new GraphQLError(`Syntax Error: ${description}`, {
      source,
      positions: [position]
    });
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/ast.mjs
  var Location = class {
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The Token at which this Node begins.
     */
    /**
     * The Token at which this Node ends.
     */
    /**
     * The Source document the AST represents.
     */
    constructor(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  };
  var Token = class {
    /**
     * The kind of Token.
     */
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The 1-indexed line number on which this Token appears.
     */
    /**
     * The 1-indexed column number at which this Token begins.
     */
    /**
     * For non-punctuation tokens, represents the interpreted value of the token.
     *
     * Note: is undefined for punctuation tokens, but typed as string for
     * convenience in the parser.
     */
    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     */
    constructor(kind, start, end, line, column, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = null;
      this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  };
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  var kindValues = new Set(Object.keys(QueryDocumentKeys));
  function isNode(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
  }
  var OperationTypeNode;
  (function(OperationTypeNode2) {
    OperationTypeNode2["QUERY"] = "query";
    OperationTypeNode2["MUTATION"] = "mutation";
    OperationTypeNode2["SUBSCRIPTION"] = "subscription";
  })(OperationTypeNode || (OperationTypeNode = {}));

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/directiveLocation.mjs
  var DirectiveLocation;
  (function(DirectiveLocation2) {
    DirectiveLocation2["QUERY"] = "QUERY";
    DirectiveLocation2["MUTATION"] = "MUTATION";
    DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation2["FIELD"] = "FIELD";
    DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation2["SCHEMA"] = "SCHEMA";
    DirectiveLocation2["SCALAR"] = "SCALAR";
    DirectiveLocation2["OBJECT"] = "OBJECT";
    DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation2["INTERFACE"] = "INTERFACE";
    DirectiveLocation2["UNION"] = "UNION";
    DirectiveLocation2["ENUM"] = "ENUM";
    DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
  })(DirectiveLocation || (DirectiveLocation = {}));

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/kinds.mjs
  var Kind;
  (function(Kind2) {
    Kind2["NAME"] = "Name";
    Kind2["DOCUMENT"] = "Document";
    Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind2["SELECTION_SET"] = "SelectionSet";
    Kind2["FIELD"] = "Field";
    Kind2["ARGUMENT"] = "Argument";
    Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind2["INLINE_FRAGMENT"] = "InlineFragment";
    Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind2["VARIABLE"] = "Variable";
    Kind2["INT"] = "IntValue";
    Kind2["FLOAT"] = "FloatValue";
    Kind2["STRING"] = "StringValue";
    Kind2["BOOLEAN"] = "BooleanValue";
    Kind2["NULL"] = "NullValue";
    Kind2["ENUM"] = "EnumValue";
    Kind2["LIST"] = "ListValue";
    Kind2["OBJECT"] = "ObjectValue";
    Kind2["OBJECT_FIELD"] = "ObjectField";
    Kind2["DIRECTIVE"] = "Directive";
    Kind2["NAMED_TYPE"] = "NamedType";
    Kind2["LIST_TYPE"] = "ListType";
    Kind2["NON_NULL_TYPE"] = "NonNullType";
    Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind2["FIELD_DEFINITION"] = "FieldDefinition";
    Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
  })(Kind || (Kind = {}));

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/characterClasses.mjs
  function isWhiteSpace(code) {
    return code === 9 || code === 32;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isLetter(code) {
    return code >= 97 && code <= 122 || // A-Z
    code >= 65 && code <= 90;
  }
  function isNameStart(code) {
    return isLetter(code) || code === 95;
  }
  function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/blockString.mjs
  function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i = 0; i < lines.length; ++i) {
      var _firstNonEmptyLine;
      const line = lines[i];
      const indent2 = leadingWhitespace(line);
      if (indent2 === line.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
      lastNonEmptyLine = i;
      if (i !== 0 && indent2 < commonIndent) {
        commonIndent = indent2;
      }
    }
    return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
      (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
      lastNonEmptyLine + 1
    );
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
      ++i;
    }
    return i;
  }
  function printBlockString(value, options) {
    const escapedValue = value.replace(/"""/g, '\\"""');
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1;
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
    (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result = "";
    const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
      result += "\n";
    }
    result += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
      result += "\n";
    }
    return '"""' + result + '"""';
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/tokenKind.mjs
  var TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind || (TokenKind = {}));

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/lexer.mjs
  var Lexer = class {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     */
    /**
     * The character offset at which the current line begins.
     */
    constructor(source) {
      const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
      this.source = source;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      this.lastToken = this.token;
      const token = this.token = this.lookahead();
      return token;
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the state of Lexer.
     */
    lookahead() {
      let token = this.token;
      if (token.kind !== TokenKind.EOF) {
        do {
          if (token.next) {
            token = token.next;
          } else {
            const nextToken = readNextToken(this, token.end);
            token.next = nextToken;
            nextToken.prev = token;
            token = nextToken;
          }
        } while (token.kind === TokenKind.COMMENT);
      }
      return token;
    }
  };
  function isPunctuatorTokenKind(kind) {
    return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
  }
  function isUnicodeScalarValue(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  }
  function isSupplementaryCodePoint(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
  }
  function isLeadingSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailingSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function printCodePointAt(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === void 0) {
      return TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char = String.fromCodePoint(code);
      return char === '"' ? `'"'` : `"${char}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  }
  function createToken(lexer, kind, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new Token(kind, start, end, line, col, value);
  }
  function readNextToken(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      switch (code) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++position;
          continue;
        case 10:
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 13:
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 35:
          return readComment(lexer, position);
        case 33:
          return createToken(lexer, TokenKind.BANG, position, position + 1);
        case 36:
          return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
        case 38:
          return createToken(lexer, TokenKind.AMP, position, position + 1);
        case 40:
          return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
        case 41:
          return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
        case 46:
          if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
            return createToken(lexer, TokenKind.SPREAD, position, position + 3);
          }
          break;
        case 58:
          return createToken(lexer, TokenKind.COLON, position, position + 1);
        case 61:
          return createToken(lexer, TokenKind.EQUALS, position, position + 1);
        case 64:
          return createToken(lexer, TokenKind.AT, position, position + 1);
        case 91:
          return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
        case 93:
          return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
        case 123:
          return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
        case 124:
          return createToken(lexer, TokenKind.PIPE, position, position + 1);
        case 125:
          return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
        case 34:
          if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            return readBlockString(lexer, position);
          }
          return readString(lexer, position);
      }
      if (isDigit(code) || code === 45) {
        return readNumber(lexer, position, code);
      }
      if (isNameStart(code)) {
        return readName(lexer, position);
      }
      throw syntaxError(
        lexer.source,
        position,
        code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
      );
    }
    return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
  }
  function readComment(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.COMMENT,
      start,
      position,
      body.slice(start + 1, position)
    );
  }
  function readNumber(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position = start;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position);
    }
    if (code === 48) {
      code = body.charCodeAt(++position);
      if (isDigit(code)) {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid number, unexpected digit after 0: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    } else {
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position);
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position);
      }
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46 || isNameStart(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
    return createToken(
      lexer,
      isFloat ? TokenKind.FLOAT : TokenKind.INT,
      start,
      position,
      body.slice(start, position)
    );
  }
  function readDigits(lexer, start, firstCode) {
    if (!isDigit(firstCode)) {
      throw syntaxError(
        lexer.source,
        start,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          start
        )}.`
      );
    }
    const body = lexer.source.body;
    let position = start + 1;
    while (isDigit(body.charCodeAt(position))) {
      ++position;
    }
    return position;
  }
  function readString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    let chunkStart = position;
    let value = "";
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34) {
        value += body.slice(chunkStart, position);
        return createToken(lexer, TokenKind.STRING, start, position + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position);
        const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
        value += escape2.value;
        position += escape2.size;
        chunkStart = position;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readEscapedUnicodeVariableWidth(lexer, position) {
    const body = lexer.source.body;
    let point = 0;
    let size = 3;
    while (size < 12) {
      const code = body.charCodeAt(position + size++);
      if (code === 125) {
        if (size < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(
        position,
        position + size
      )}".`
    );
  }
  function readEscapedUnicodeFixedWidth(lexer, position) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
    );
  }
  function read16BitHexCode(body, position) {
    return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
  }
  function readHexDigit(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  }
  function readEscapedCharacter(lexer, position) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: "\n",
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid character escape sequence: "${body.slice(
        position,
        position + 2
      )}".`
    );
  }
  function readBlockString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position = start + 3;
    let chunkStart = position;
    let currentLine = "";
    const blockLines = [];
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        const token = createToken(
          lexer,
          TokenKind.BLOCK_STRING,
          start,
          position + 3,
          // Return a string of the lines joined with U+000A.
          dedentBlockStringLines(blockLines).join("\n")
        );
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token;
      }
      if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
        currentLine += body.slice(chunkStart, position);
        chunkStart = position + 1;
        position += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        currentLine = "";
        chunkStart = position;
        lineStart = position;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readName(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (isNameContinue(code)) {
        ++position;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.NAME,
      start,
      position,
      body.slice(start, position)
    );
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/jsutils/inspect.mjs
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect2(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object2, seenValues) {
    const entries = Object.entries(object2);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object2) + "]";
    }
    const properties = entries.map(
      ([key, value]) => key + ": " + formatValue(value, seenValues)
    );
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array2, seenValues) {
    if (array2.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
    const remaining = array2.length - len;
    const items = [];
    for (let i = 0; i < len; ++i) {
      items.push(formatValue(array2[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object2) {
    const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object2.constructor === "function") {
      const name = object2.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/jsutils/instanceOf.mjs
  var isProduction = globalThis.process && // eslint-disable-next-line no-undef
  process.env.NODE_ENV === "production";
  var instanceOf = (
    /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    isProduction ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect2(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    }
  );

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/source.mjs
  var Source = class {
    constructor(body, name = "GraphQL request", locationOffset = {
      line: 1,
      column: 1
    }) {
      typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect2(body)}.`);
      this.body = body;
      this.name = name;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || devAssert(
        false,
        "line in locationOffset is 1-indexed and must be positive."
      );
      this.locationOffset.column > 0 || devAssert(
        false,
        "column in locationOffset is 1-indexed and must be positive."
      );
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  };
  function isSource(source) {
    return instanceOf(source, Source);
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/parser.mjs
  function parse7(source, options) {
    const parser = new Parser(source, options);
    return parser.parseDocument();
  }
  var Parser = class {
    constructor(source, options = {}) {
      const sourceObj = isSource(source) ? source : new Source(source);
      this._lexer = new Lexer(sourceObj);
      this._options = options;
      this._tokenCounter = 0;
    }
    /**
     * Converts a name lex token into a name parse node.
     */
    parseName() {
      const token = this.expectToken(TokenKind.NAME);
      return this.node(token, {
        kind: Kind.NAME,
        value: token.value
      });
    }
    // Implements the parsing rules in the Document section.
    /**
     * Document : Definition+
     */
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: Kind.DOCUMENT,
        definitions: this.many(
          TokenKind.SOF,
          this.parseDefinition,
          TokenKind.EOF
        )
      });
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     *
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     *
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */
    parseDefinition() {
      if (this.peek(TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      }
      const hasDescription = this.peekDescription();
      const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (hasDescription) {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            "Unexpected description, descriptions are supported only on type definitions."
          );
        }
        switch (keywordToken.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    // Implements the parsing rules in the Operations section.
    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */
    parseOperationDefinition() {
      const start = this._lexer.token;
      if (this.peek(TokenKind.BRACE_L)) {
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation: OperationTypeNode.QUERY,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      }
      const operation = this.parseOperationType();
      let name;
      if (this.peek(TokenKind.NAME)) {
        name = this.parseName();
      }
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * OperationType : one of query mutation subscription
     */
    parseOperationType() {
      const operationToken = this.expectToken(TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return OperationTypeNode.QUERY;
        case "mutation":
          return OperationTypeNode.MUTATION;
        case "subscription":
          return OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(operationToken);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */
    parseVariableDefinitions() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseVariableDefinition,
        TokenKind.PAREN_R
      );
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    /**
     * Variable : $ Name
     */
    parseVariable() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.DOLLAR);
      return this.node(start, {
        kind: Kind.VARIABLE,
        name: this.parseName()
      });
    }
    /**
     * ```
     * SelectionSet : { Selection+ }
     * ```
     */
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: Kind.SELECTION_SET,
        selections: this.many(
          TokenKind.BRACE_L,
          this.parseSelection,
          TokenKind.BRACE_R
        )
      });
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    parseSelection() {
      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */
    parseField() {
      const start = this._lexer.token;
      const nameOrAlias = this.parseName();
      let alias;
      let name;
      if (this.expectOptionalToken(TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return this.node(start, {
        kind: Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */
    parseArguments(isConst) {
      const item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */
    parseArgument(isConst = false) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseConstArgument() {
      return this.parseArgument(true);
    }
    // Implements the parsing rules in the Fragments section.
    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */
    parseFragment() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.SPREAD);
      const hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
        return this.node(start, {
          kind: Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false)
        });
      }
      return this.node(start, {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */
    parseFragmentDefinition() {
      const start = this._lexer.token;
      this.expectKeyword("fragment");
      if (this._options.allowLegacyFragmentVariables === true) {
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentName : Name but not `on`
     */
    parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    }
    // Implements the parsing rules in the Values section.
    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseValueLiteral(isConst) {
      const token = this._lexer.token;
      switch (token.kind) {
        case TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case TokenKind.INT:
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.INT,
            value: token.value
          });
        case TokenKind.FLOAT:
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.FLOAT,
            value: token.value
          });
        case TokenKind.STRING:
        case TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case TokenKind.NAME:
          this.advanceLexer();
          switch (token.value) {
            case "true":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: true
              });
            case "false":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: false
              });
            case "null":
              return this.node(token, {
                kind: Kind.NULL
              });
            default:
              return this.node(token, {
                kind: Kind.ENUM,
                value: token.value
              });
          }
        case TokenKind.DOLLAR:
          if (isConst) {
            this.expectToken(TokenKind.DOLLAR);
            if (this._lexer.token.kind === TokenKind.NAME) {
              const varName = this._lexer.token.value;
              throw syntaxError(
                this._lexer.source,
                token.start,
                `Unexpected variable "$${varName}" in constant value.`
              );
            } else {
              throw this.unexpected(token);
            }
          }
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
      const token = this._lexer.token;
      this.advanceLexer();
      return this.node(token, {
        kind: Kind.STRING,
        value: token.value,
        block: token.kind === TokenKind.BLOCK_STRING
      });
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */
    parseList(isConst) {
      const item = () => this.parseValueLiteral(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.LIST,
        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
      });
    }
    /**
     * ```
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     * ```
     */
    parseObject(isConst) {
      const item = () => this.parseObjectField(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.OBJECT,
        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
      });
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */
    parseObjectField(isConst) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    // Implements the parsing rules in the Directives section.
    /**
     * Directives[Const] : Directive[?Const]+
     */
    parseDirectives(isConst) {
      const directives = [];
      while (this.peek(TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    }
    parseConstDirectives() {
      return this.parseDirectives(true);
    }
    /**
     * ```
     * Directive[Const] : @ Name Arguments[?Const]?
     * ```
     */
    parseDirective(isConst) {
      const start = this._lexer.token;
      this.expectToken(TokenKind.AT);
      return this.node(start, {
        kind: Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst)
      });
    }
    // Implements the parsing rules in the Types section.
    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */
    parseTypeReference() {
      const start = this._lexer.token;
      let type3;
      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
        const innerType = this.parseTypeReference();
        this.expectToken(TokenKind.BRACKET_R);
        type3 = this.node(start, {
          kind: Kind.LIST_TYPE,
          type: innerType
        });
      } else {
        type3 = this.parseNamedType();
      }
      if (this.expectOptionalToken(TokenKind.BANG)) {
        return this.node(start, {
          kind: Kind.NON_NULL_TYPE,
          type: type3
        });
      }
      return type3;
    }
    /**
     * NamedType : Name
     */
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    // Implements the parsing rules in the Type Definition section.
    peekDescription() {
      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */
    parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    }
    /**
     * ```
     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
     * ```
     */
    parseSchemaDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.many(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      return this.node(start, {
        kind: Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes
      });
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */
    parseOperationTypeDefinition() {
      const start = this._lexer.token;
      const operation = this.parseOperationType();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseNamedType();
      return this.node(start, {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type: type3
      });
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */
    parseScalarTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives
      });
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */
    parseObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
     * ```
     * FieldsDefinition : { FieldDefinition+ }
     * ```
     */
    parseFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseFieldDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */
    parseFieldDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseTypeReference();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args,
        type: type3,
        directives
      });
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */
    parseArgumentDefs() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseInputValueDef,
        TokenKind.PAREN_R
      );
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */
    parseInputValueDef() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseTypeReference();
      let defaultValue;
      if (this.expectOptionalToken(TokenKind.EQUALS)) {
        defaultValue = this.parseConstValueLiteral();
      }
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type: type3,
        defaultValue,
        directives
      });
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */
    parseInterfaceTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */
    parseUnionTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types2 = this.parseUnionMemberTypes();
      return this.node(start, {
        kind: Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types: types2
      });
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    parseUnionMemberTypes() {
      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */
    parseEnumTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      return this.node(start, {
        kind: Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values
      });
    }
    /**
     * ```
     * EnumValuesDefinition : { EnumValueDefinition+ }
     * ```
     */
    parseEnumValuesDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseEnumValueDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     */
    parseEnumValueDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseEnumValueName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives
      });
    }
    /**
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          `${getTokenDesc(
            this._lexer.token
          )} is reserved and cannot be used for an enum value.`
        );
      }
      return this.parseName();
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */
    parseInputObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields
      });
    }
    /**
     * ```
     * InputFieldsDefinition : { InputValueDefinition+ }
     * ```
     */
    parseInputFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseInputValueDef,
        TokenKind.BRACE_R
      );
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */
    parseTypeSystemExtension() {
      const keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    /**
     * ```
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     * ```
     */
    parseSchemaExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.optionalMany(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes
      });
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */
    parseScalarTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives
      });
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */
    parseObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * InterfaceTypeExtension :
     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend interface Name ImplementsInterfaces? Directives[Const]
     *  - extend interface Name ImplementsInterfaces
     */
    parseInterfaceTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */
    parseUnionTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types2 = this.parseUnionMemberTypes();
      if (directives.length === 0 && types2.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types: types2
      });
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */
    parseEnumTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values
      });
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */
    parseInputObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields
      });
    }
    /**
     * ```
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     * ```
     */
    parseDirectiveDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(TokenKind.AT);
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      const repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const locations = this.parseDirectiveLocations();
      return this.node(start, {
        kind: Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args,
        repeatable,
        locations
      });
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */
    parseDirectiveLocations() {
      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */
    parseDirectiveLocation() {
      const start = this._lexer.token;
      const name = this.parseName();
      if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
        return name;
      }
      throw this.unexpected(start);
    }
    // Core parsing utility functions
    /**
     * Returns a node that, if configured to do so, sets a "loc" field as a
     * location object, used to identify the place in the source that created a
     * given parsed object.
     */
    node(startToken, node2) {
      if (this._options.noLocation !== true) {
        node2.loc = new Location(
          startToken,
          this._lexer.lastToken,
          this._lexer.source
        );
      }
      return node2;
    }
    /**
     * Determines if the next token is of a given kind
     */
    peek(kind) {
      return this._lexer.token.kind === kind;
    }
    /**
     * If the next token is of the given kind, return that token after advancing the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return token;
      }
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
      );
    }
    /**
     * If the next token is of the given kind, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this.advanceLexer();
      } else {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected "${value}", found ${getTokenDesc(token)}.`
        );
      }
    }
    /**
     * If the next token is a given keyword, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token is encountered.
     */
    unexpected(atToken) {
      const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
      return syntaxError(
        this._lexer.source,
        token.start,
        `Unexpected ${getTokenDesc(token)}.`
      );
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    }
    /**
     * Returns a list of parse nodes, determined by the parseFn.
     * It can be empty only if open token is missing otherwise it will always return non-empty list
     * that begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
     * Advances the parser to the next lex token after last item in the list.
     */
    delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    }
    advanceLexer() {
      const { maxTokens } = this._options;
      const token = this._lexer.advance();
      if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
        ++this._tokenCounter;
        if (this._tokenCounter > maxTokens) {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Document contains more that ${maxTokens} tokens. Parsing aborted.`
          );
        }
      }
    }
  };
  function getTokenDesc(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
  }
  function getTokenKindDesc(kind) {
    return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/printString.mjs
  function printString(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
  }
  var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function escapedReplacer(str) {
    return escapeSequences[str.charCodeAt(0)];
  }
  var escapeSequences = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 2F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 3F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 4F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    // 5F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 6F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/visitor.mjs
  var BREAK = Object.freeze({});
  function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
    const enterLeaveMap = /* @__PURE__ */ new Map();
    for (const kind of Object.values(Kind)) {
      enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
    }
    let stack = void 0;
    let inArray = Array.isArray(root);
    let keys4 = [root];
    let index = -1;
    let edits = [];
    let node2 = root;
    let key = void 0;
    let parent = void 0;
    const path6 = [];
    const ancestors = [];
    do {
      index++;
      const isLeaving = index === keys4.length;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? void 0 : path6[path6.length - 1];
        node2 = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node2 = node2.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === null) {
                node2.splice(arrayKey, 1);
                editOffset++;
              } else {
                node2[arrayKey] = editValue;
              }
            }
          } else {
            node2 = Object.defineProperties(
              {},
              Object.getOwnPropertyDescriptors(node2)
            );
            for (const [editKey, editValue] of edits) {
              node2[editKey] = editValue;
            }
          }
        }
        index = stack.index;
        keys4 = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent) {
        key = inArray ? index : keys4[index];
        node2 = parent[key];
        if (node2 === null || node2 === void 0) {
          continue;
        }
        path6.push(key);
      }
      let result;
      if (!Array.isArray(node2)) {
        var _enterLeaveMap$get, _enterLeaveMap$get2;
        isNode(node2) || devAssert(false, `Invalid AST Node: ${inspect2(node2)}.`);
        const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
        result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node2, key, parent, path6, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path6.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node2 = result;
            } else {
              path6.pop();
              continue;
            }
          }
        }
      }
      if (result === void 0 && isEdited) {
        edits.push([key, node2]);
      }
      if (isLeaving) {
        path6.pop();
      } else {
        var _node$kind;
        stack = {
          inArray,
          index,
          keys: keys4,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node2);
        keys4 = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
        index = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node2;
      }
    } while (stack !== void 0);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1];
    }
    return root;
  }
  function getEnterLeaveForKind(visitor, kind) {
    const kindVisitor = visitor[kind];
    if (typeof kindVisitor === "object") {
      return kindVisitor;
    } else if (typeof kindVisitor === "function") {
      return {
        enter: kindVisitor,
        leave: void 0
      };
    }
    return {
      enter: visitor.enter,
      leave: visitor.leave
    };
  }

  // ../../node_modules/.pnpm/graphql@16.9.0/node_modules/graphql/language/printer.mjs
  function print(ast) {
    return visit(ast, printDocASTReducer);
  }
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: {
      leave: (node2) => node2.value
    },
    Variable: {
      leave: (node2) => "$" + node2.name
    },
    // Document
    Document: {
      leave: (node2) => join7(node2.definitions, "\n\n")
    },
    OperationDefinition: {
      leave(node2) {
        const varDefs = wrap2("(", join7(node2.variableDefinitions, ", "), ")");
        const prefix = join7(
          [
            node2.operation,
            join7([node2.name, varDefs]),
            join7(node2.directives, " ")
          ],
          " "
        );
        return (prefix === "query" ? "" : prefix + " ") + node2.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type: type3, defaultValue, directives }) => variable + ": " + type3 + wrap2(" = ", defaultValue) + wrap2(" ", join7(directives, " "))
    },
    SelectionSet: {
      leave: ({ selections }) => block(selections)
    },
    Field: {
      leave({ alias, name, arguments: args, directives, selectionSet }) {
        const prefix = wrap2("", alias, ": ") + name;
        let argsLine = prefix + wrap2("(", join7(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap2("(\n", indent(join7(args, "\n")), "\n)");
        }
        return join7([argsLine, join7(directives, " "), selectionSet], " ");
      }
    },
    Argument: {
      leave: ({ name, value }) => name + ": " + value
    },
    // Fragments
    FragmentSpread: {
      leave: ({ name, directives }) => "..." + name + wrap2(" ", join7(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join7(
        [
          "...",
          wrap2("on ", typeCondition),
          join7(directives, " "),
          selectionSet
        ],
        " "
      )
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
        // or removed in the future.
        `fragment ${name}${wrap2("(", join7(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join7(directives, " "), " ")}` + selectionSet
      )
    },
    // Value
    IntValue: {
      leave: ({ value }) => value
    },
    FloatValue: {
      leave: ({ value }) => value
    },
    StringValue: {
      leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
    },
    BooleanValue: {
      leave: ({ value }) => value ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value }) => value
    },
    ListValue: {
      leave: ({ values }) => "[" + join7(values, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields }) => "{" + join7(fields, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name, value }) => name + ": " + value
    },
    // Directive
    Directive: {
      leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join7(args, ", "), ")")
    },
    // Type
    NamedType: {
      leave: ({ name }) => name
    },
    ListType: {
      leave: ({ type: type3 }) => "[" + type3 + "]"
    },
    NonNullType: {
      leave: ({ type: type3 }) => type3 + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
      leave: ({ description, directives, operationTypes }) => wrap2("", description, "\n") + join7(["schema", join7(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type: type3 }) => operation + ": " + type3
    },
    ScalarTypeDefinition: {
      leave: ({ description, name, directives }) => wrap2("", description, "\n") + join7(["scalar", name, join7(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join7(
        [
          "type",
          name,
          wrap2("implements ", join7(interfaces, " & ")),
          join7(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    FieldDefinition: {
      leave: ({ description, name, arguments: args, type: type3, directives }) => wrap2("", description, "\n") + name + (hasMultilineItems(args) ? wrap2("(\n", indent(join7(args, "\n")), "\n)") : wrap2("(", join7(args, ", "), ")")) + ": " + type3 + wrap2(" ", join7(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ description, name, type: type3, defaultValue, directives }) => wrap2("", description, "\n") + join7(
        [name + ": " + type3, wrap2("= ", defaultValue), join7(directives, " ")],
        " "
      )
    },
    InterfaceTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join7(
        [
          "interface",
          name,
          wrap2("implements ", join7(interfaces, " & ")),
          join7(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    UnionTypeDefinition: {
      leave: ({ description, name, directives, types: types2 }) => wrap2("", description, "\n") + join7(
        ["union", name, join7(directives, " "), wrap2("= ", join7(types2, " | "))],
        " "
      )
    },
    EnumTypeDefinition: {
      leave: ({ description, name, directives, values }) => wrap2("", description, "\n") + join7(["enum", name, join7(directives, " "), block(values)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description, name, directives }) => wrap2("", description, "\n") + join7([name, join7(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description, name, directives, fields }) => wrap2("", description, "\n") + join7(["input", name, join7(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description, name, arguments: args, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap2("(\n", indent(join7(args, "\n")), "\n)") : wrap2("(", join7(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join7(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join7(
        ["extend schema", join7(directives, " "), block(operationTypes)],
        " "
      )
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join7(["extend scalar", name, join7(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join7(
        [
          "extend type",
          name,
          wrap2("implements ", join7(interfaces, " & ")),
          join7(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join7(
        [
          "extend interface",
          name,
          wrap2("implements ", join7(interfaces, " & ")),
          join7(directives, " "),
          block(fields)
        ],
        " "
      )
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types: types2 }) => join7(
        [
          "extend union",
          name,
          join7(directives, " "),
          wrap2("= ", join7(types2, " | "))
        ],
        " "
      )
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values }) => join7(["extend enum", name, join7(directives, " "), block(values)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) => join7(["extend input", name, join7(directives, " "), block(fields)], " ")
    }
  };
  function join7(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
  }
  function block(array2) {
    return wrap2("{\n", indent(join7(array2, "\n")), "\n}");
  }
  function wrap2(start, maybeString, end = "") {
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  }
  function indent(str) {
    return wrap2("  ", str.replace(/\n/g, "\n  "));
  }
  function hasMultilineItems(maybeArray) {
    var _maybeArray$some;
    return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
  }

  // ../../node_modules/.pnpm/graphql-request@6.1.0_graphql@16.9.0/node_modules/graphql-request/build/esm/resolveRequestDocument.js
  var extractOperationName = (document2) => {
    let operationName = void 0;
    const operationDefinitions = document2.definitions.filter((definition) => definition.kind === `OperationDefinition`);
    if (operationDefinitions.length === 1) {
      operationName = operationDefinitions[0]?.name?.value;
    }
    return operationName;
  };
  var resolveRequestDocument = (document2) => {
    if (typeof document2 === `string`) {
      let operationName2 = void 0;
      try {
        const parsedDocument = parse7(document2);
        operationName2 = extractOperationName(parsedDocument);
      } catch (err2) {
      }
      return { query: document2, operationName: operationName2 };
    }
    const operationName = extractOperationName(document2);
    return { query: print(document2), operationName };
  };

  // ../../node_modules/.pnpm/graphql-request@6.1.0_graphql@16.9.0/node_modules/graphql-request/build/esm/types.js
  var ClientError = class extends Error {
    constructor(response, request) {
      const message = `${ClientError.extractMessage(response)}: ${JSON.stringify({
        response,
        request
      })}`;
      super(message);
      Object.setPrototypeOf(this, ClientError.prototype);
      this.response = response;
      this.request = request;
      if (typeof Error.captureStackTrace === `function`) {
        Error.captureStackTrace(this, ClientError);
      }
    }
    static extractMessage(response) {
      return response.errors?.[0]?.message ?? `GraphQL Error (Code: ${response.status})`;
    }
  };

  // ../../node_modules/.pnpm/graphql-request@6.1.0_graphql@16.9.0/node_modules/graphql-request/build/esm/index.js
  var CrossFetch = __toESM(require_node_ponyfill(), 1);

  // ../../node_modules/.pnpm/graphql-request@6.1.0_graphql@16.9.0/node_modules/graphql-request/build/esm/graphql-ws.js
  var CONNECTION_INIT = `connection_init`;
  var CONNECTION_ACK = `connection_ack`;
  var PING = `ping`;
  var PONG = `pong`;
  var SUBSCRIBE = `subscribe`;
  var NEXT = `next`;
  var ERROR2 = `error`;
  var COMPLETE = `complete`;
  var GraphQLWebSocketMessage = class {
    get type() {
      return this._type;
    }
    get id() {
      return this._id;
    }
    get payload() {
      return this._payload;
    }
    constructor(type3, payload, id) {
      this._type = type3;
      this._payload = payload;
      this._id = id;
    }
    get text() {
      const result = { type: this.type };
      if (this.id != null && this.id != void 0)
        result.id = this.id;
      if (this.payload != null && this.payload != void 0)
        result.payload = this.payload;
      return JSON.stringify(result);
    }
    static parse(data, f2) {
      const { type: type3, payload, id } = JSON.parse(data);
      return new GraphQLWebSocketMessage(type3, f2(payload), id);
    }
  };
  var GraphQLWebSocketClient = class {
    constructor(socket, { onInit, onAcknowledged, onPing, onPong }) {
      this.socketState = { acknowledged: false, lastRequestId: 0, subscriptions: {} };
      this.socket = socket;
      socket.addEventListener(`open`, async (e) => {
        this.socketState.acknowledged = false;
        this.socketState.subscriptions = {};
        socket.send(ConnectionInit(onInit ? await onInit() : null).text);
      });
      socket.addEventListener(`close`, (e) => {
        this.socketState.acknowledged = false;
        this.socketState.subscriptions = {};
      });
      socket.addEventListener(`error`, (e) => {
        console.error(e);
      });
      socket.addEventListener(`message`, (e) => {
        try {
          const message = parseMessage(e.data);
          switch (message.type) {
            case CONNECTION_ACK: {
              if (this.socketState.acknowledged) {
                console.warn(`Duplicate CONNECTION_ACK message ignored`);
              } else {
                this.socketState.acknowledged = true;
                if (onAcknowledged)
                  onAcknowledged(message.payload);
              }
              return;
            }
            case PING: {
              if (onPing)
                onPing(message.payload).then((r) => socket.send(Pong(r).text));
              else
                socket.send(Pong(null).text);
              return;
            }
            case PONG: {
              if (onPong)
                onPong(message.payload);
              return;
            }
          }
          if (!this.socketState.acknowledged) {
            return;
          }
          if (message.id === void 0 || message.id === null || !this.socketState.subscriptions[message.id]) {
            return;
          }
          const { query, variables, subscriber } = this.socketState.subscriptions[message.id];
          switch (message.type) {
            case NEXT: {
              if (!message.payload.errors && message.payload.data) {
                subscriber.next && subscriber.next(message.payload.data);
              }
              if (message.payload.errors) {
                subscriber.error && subscriber.error(new ClientError({ ...message.payload, status: 200 }, { query, variables }));
              } else {
              }
              return;
            }
            case ERROR2: {
              subscriber.error && subscriber.error(new ClientError({ errors: message.payload, status: 200 }, { query, variables }));
              return;
            }
            case COMPLETE: {
              subscriber.complete && subscriber.complete();
              delete this.socketState.subscriptions[message.id];
              return;
            }
          }
        } catch (e2) {
          console.error(e2);
          socket.close(1006);
        }
        socket.close(4400, `Unknown graphql-ws message.`);
      });
    }
    makeSubscribe(query, operationName, subscriber, variables) {
      const subscriptionId = (this.socketState.lastRequestId++).toString();
      this.socketState.subscriptions[subscriptionId] = { query, variables, subscriber };
      this.socket.send(Subscribe(subscriptionId, { query, operationName, variables }).text);
      return () => {
        this.socket.send(Complete(subscriptionId).text);
        delete this.socketState.subscriptions[subscriptionId];
      };
    }
    rawRequest(query, variables) {
      return new Promise((resolve10, reject) => {
        let result;
        this.rawSubscribe(query, {
          next: (data, extensions) => result = { data, extensions },
          error: reject,
          complete: () => resolve10(result)
        }, variables);
      });
    }
    request(document2, variables) {
      return new Promise((resolve10, reject) => {
        let result;
        this.subscribe(document2, {
          next: (data) => result = data,
          error: reject,
          complete: () => resolve10(result)
        }, variables);
      });
    }
    subscribe(document2, subscriber, variables) {
      const { query, operationName } = resolveRequestDocument(document2);
      return this.makeSubscribe(query, operationName, subscriber, variables);
    }
    rawSubscribe(query, subscriber, variables) {
      return this.makeSubscribe(query, void 0, subscriber, variables);
    }
    ping(payload) {
      this.socket.send(Ping(payload).text);
    }
    close() {
      this.socket.close(1e3);
    }
  };
  GraphQLWebSocketClient.PROTOCOL = `graphql-transport-ws`;
  function parseMessage(data, f2 = (a) => a) {
    const m = GraphQLWebSocketMessage.parse(data, f2);
    return m;
  }
  function ConnectionInit(payload) {
    return new GraphQLWebSocketMessage(CONNECTION_INIT, payload);
  }
  function Ping(payload) {
    return new GraphQLWebSocketMessage(PING, payload, void 0);
  }
  function Pong(payload) {
    return new GraphQLWebSocketMessage(PONG, payload, void 0);
  }
  function Subscribe(id, payload) {
    return new GraphQLWebSocketMessage(SUBSCRIBE, payload, id);
  }
  function Complete(id) {
    return new GraphQLWebSocketMessage(COMPLETE, void 0, id);
  }

  // ../../node_modules/.pnpm/graphql-request@6.1.0_graphql@16.9.0/node_modules/graphql-request/build/esm/index.js
  var resolveHeaders = (headers) => {
    let oHeaders = {};
    if (headers) {
      if (typeof Headers !== `undefined` && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {
        oHeaders = HeadersInstanceToPlainObject(headers);
      } else if (Array.isArray(headers)) {
        headers.forEach(([name, value]) => {
          if (name && value !== void 0) {
            oHeaders[name] = value;
          }
        });
      } else {
        oHeaders = headers;
      }
    }
    return oHeaders;
  };
  var cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
  var buildRequestConfig = (params) => {
    if (!Array.isArray(params.query)) {
      const params_2 = params;
      const search = [`query=${encodeURIComponent(cleanQuery(params_2.query))}`];
      if (params.variables) {
        search.push(`variables=${encodeURIComponent(params_2.jsonSerializer.stringify(params_2.variables))}`);
      }
      if (params_2.operationName) {
        search.push(`operationName=${encodeURIComponent(params_2.operationName)}`);
      }
      return search.join(`&`);
    }
    if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {
      throw new Error(`Cannot create query with given variable type, array expected`);
    }
    const params_ = params;
    const payload = params.query.reduce((acc, currentQuery, index) => {
      acc.push({
        query: cleanQuery(currentQuery),
        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : void 0
      });
      return acc;
    }, []);
    return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`;
  };
  var createHttpMethodFetcher = (method) => async (params) => {
    const { url, query, variables, operationName, fetch: fetch3, fetchOptions, middleware } = params;
    const headers = { ...params.headers };
    let queryParams = ``;
    let body = void 0;
    if (method === `POST`) {
      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer);
      if (typeof body === `string`) {
        headers[`Content-Type`] = `application/json`;
      }
    } else {
      queryParams = buildRequestConfig({
        query,
        variables,
        operationName,
        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer
      });
    }
    const init2 = {
      method,
      headers,
      body,
      ...fetchOptions
    };
    let urlResolved = url;
    let initResolved = init2;
    if (middleware) {
      const result = await Promise.resolve(middleware({ ...init2, url, operationName, variables }));
      const { url: urlNew, ...initNew } = result;
      urlResolved = urlNew;
      initResolved = initNew;
    }
    if (queryParams) {
      urlResolved = `${urlResolved}?${queryParams}`;
    }
    return await fetch3(urlResolved, initResolved);
  };
  var GraphQLClient = class {
    constructor(url, requestConfig = {}) {
      this.url = url;
      this.requestConfig = requestConfig;
      this.rawRequest = async (...args) => {
        const [queryOrOptions, variables, requestHeaders] = args;
        const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
        const { headers, fetch: fetch3 = CrossFetch.default, method = `POST`, requestMiddleware, responseMiddleware, ...fetchOptions } = this.requestConfig;
        const { url: url2 } = this;
        if (rawRequestOptions.signal !== void 0) {
          fetchOptions.signal = rawRequestOptions.signal;
        }
        const { operationName } = resolveRequestDocument(rawRequestOptions.query);
        return makeRequest({
          url: url2,
          query: rawRequestOptions.query,
          variables: rawRequestOptions.variables,
          headers: {
            ...resolveHeaders(callOrIdentity(headers)),
            ...resolveHeaders(rawRequestOptions.requestHeaders)
          },
          operationName,
          fetch: fetch3,
          method,
          fetchOptions,
          middleware: requestMiddleware
        }).then((response) => {
          if (responseMiddleware) {
            responseMiddleware(response);
          }
          return response;
        }).catch((error3) => {
          if (responseMiddleware) {
            responseMiddleware(error3);
          }
          throw error3;
        });
      };
    }
    async request(documentOrOptions, ...variablesAndRequestHeaders) {
      const [variables, requestHeaders] = variablesAndRequestHeaders;
      const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
      const { headers, fetch: fetch3 = CrossFetch.default, method = `POST`, requestMiddleware, responseMiddleware, ...fetchOptions } = this.requestConfig;
      const { url } = this;
      if (requestOptions.signal !== void 0) {
        fetchOptions.signal = requestOptions.signal;
      }
      const { query, operationName } = resolveRequestDocument(requestOptions.document);
      return makeRequest({
        url,
        query,
        variables: requestOptions.variables,
        headers: {
          ...resolveHeaders(callOrIdentity(headers)),
          ...resolveHeaders(requestOptions.requestHeaders)
        },
        operationName,
        fetch: fetch3,
        method,
        fetchOptions,
        middleware: requestMiddleware
      }).then((response) => {
        if (responseMiddleware) {
          responseMiddleware(response);
        }
        return response.data;
      }).catch((error3) => {
        if (responseMiddleware) {
          responseMiddleware(error3);
        }
        throw error3;
      });
    }
    // prettier-ignore
    batchRequests(documentsOrOptions, requestHeaders) {
      const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
      const { headers, ...fetchOptions } = this.requestConfig;
      if (batchRequestOptions.signal !== void 0) {
        fetchOptions.signal = batchRequestOptions.signal;
      }
      const queries = batchRequestOptions.documents.map(({ document: document2 }) => resolveRequestDocument(document2).query);
      const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
      return makeRequest({
        url: this.url,
        query: queries,
        // @ts-expect-error TODO reconcile batch variables into system.
        variables,
        headers: {
          ...resolveHeaders(callOrIdentity(headers)),
          ...resolveHeaders(batchRequestOptions.requestHeaders)
        },
        operationName: void 0,
        fetch: this.requestConfig.fetch ?? CrossFetch.default,
        method: this.requestConfig.method || `POST`,
        fetchOptions,
        middleware: this.requestConfig.requestMiddleware
      }).then((response) => {
        if (this.requestConfig.responseMiddleware) {
          this.requestConfig.responseMiddleware(response);
        }
        return response.data;
      }).catch((error3) => {
        if (this.requestConfig.responseMiddleware) {
          this.requestConfig.responseMiddleware(error3);
        }
        throw error3;
      });
    }
    setHeaders(headers) {
      this.requestConfig.headers = headers;
      return this;
    }
    /**
     * Attach a header to the client. All subsequent requests will have this header.
     */
    setHeader(key, value) {
      const { headers } = this.requestConfig;
      if (headers) {
        headers[key] = value;
      } else {
        this.requestConfig.headers = { [key]: value };
      }
      return this;
    }
    /**
     * Change the client endpoint. All subsequent requests will send to this endpoint.
     */
    setEndpoint(value) {
      this.url = value;
      return this;
    }
  };
  var makeRequest = async (params) => {
    const { query, variables, fetchOptions } = params;
    const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`));
    const isBatchingQuery = Array.isArray(params.query);
    const response = await fetcher(params);
    const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer);
    const successfullyReceivedData = Array.isArray(result) ? !result.some(({ data }) => !data) : Boolean(result.data);
    const successfullyPassedErrorPolicy = Array.isArray(result) || !result.errors || Array.isArray(result.errors) && !result.errors.length || fetchOptions.errorPolicy === `all` || fetchOptions.errorPolicy === `ignore`;
    if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {
      const { errors: _, ...rest } = Array.isArray(result) ? result : result;
      const data = fetchOptions.errorPolicy === `ignore` ? rest : result;
      const dataEnvelope = isBatchingQuery ? { data } : data;
      return {
        ...dataEnvelope,
        headers: response.headers,
        status: response.status
      };
    } else {
      const errorResult = typeof result === `string` ? {
        error: result
      } : result;
      throw new ClientError(
        // @ts-expect-error TODO
        { ...errorResult, status: response.status, headers: response.headers },
        { query, variables }
      );
    }
  };
  var createRequestBody = (query, variables, operationName, jsonSerializer) => {
    const jsonSerializer_ = jsonSerializer ?? defaultJsonSerializer;
    if (!Array.isArray(query)) {
      return jsonSerializer_.stringify({ query, variables, operationName });
    }
    if (typeof variables !== `undefined` && !Array.isArray(variables)) {
      throw new Error(`Cannot create request body with given variable type, array expected`);
    }
    const payload = query.reduce((acc, currentQuery, index) => {
      acc.push({ query: currentQuery, variables: variables ? variables[index] : void 0 });
      return acc;
    }, []);
    return jsonSerializer_.stringify(payload);
  };
  var getResult = async (response, jsonSerializer) => {
    let contentType;
    response.headers.forEach((value, key) => {
      if (key.toLowerCase() === `content-type`) {
        contentType = value;
      }
    });
    if (contentType && (contentType.toLowerCase().startsWith(`application/json`) || contentType.toLowerCase().startsWith(`application/graphql+json`) || contentType.toLowerCase().startsWith(`application/graphql-response+json`))) {
      return jsonSerializer.parse(await response.text());
    } else {
      return response.text();
    }
  };
  var callOrIdentity = (value) => {
    return typeof value === `function` ? value() : value;
  };

  // ../../node_modules/.pnpm/tslib@2.8.0/node_modules/tslib/tslib.es6.mjs
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };

  // ../../node_modules/.pnpm/graphql-tag@2.12.6_graphql@16.9.0/node_modules/graphql-tag/lib/index.js
  var docCache = /* @__PURE__ */ new Map();
  var fragmentSourceMap = /* @__PURE__ */ new Map();
  var printFragmentWarnings = true;
  var experimentalFragmentVariables = false;
  function normalize2(string2) {
    return string2.replace(/[\s,]+/g, " ").trim();
  }
  function cacheKeyFromLoc(loc) {
    return normalize2(loc.source.body.substring(loc.start, loc.end));
  }
  function processFragments(ast) {
    var seenKeys = /* @__PURE__ */ new Set();
    var definitions = [];
    ast.definitions.forEach(function(fragmentDefinition) {
      if (fragmentDefinition.kind === "FragmentDefinition") {
        var fragmentName = fragmentDefinition.name.value;
        var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
        var sourceKeySet = fragmentSourceMap.get(fragmentName);
        if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
          if (printFragmentWarnings) {
            console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
          }
        } else if (!sourceKeySet) {
          fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
        }
        sourceKeySet.add(sourceKey);
        if (!seenKeys.has(sourceKey)) {
          seenKeys.add(sourceKey);
          definitions.push(fragmentDefinition);
        }
      } else {
        definitions.push(fragmentDefinition);
      }
    });
    return __assign(__assign({}, ast), { definitions });
  }
  function stripLoc(doc) {
    var workSet = new Set(doc.definitions);
    workSet.forEach(function(node2) {
      if (node2.loc)
        delete node2.loc;
      Object.keys(node2).forEach(function(key) {
        var value = node2[key];
        if (value && typeof value === "object") {
          workSet.add(value);
        }
      });
    });
    var loc = doc.loc;
    if (loc) {
      delete loc.startToken;
      delete loc.endToken;
    }
    return doc;
  }
  function parseDocument(source) {
    var cacheKey = normalize2(source);
    if (!docCache.has(cacheKey)) {
      var parsed = parse7(source, {
        experimentalFragmentVariables,
        allowLegacyFragmentVariables: experimentalFragmentVariables
      });
      if (!parsed || parsed.kind !== "Document") {
        throw new Error("Not a valid GraphQL document.");
      }
      docCache.set(cacheKey, stripLoc(processFragments(parsed)));
    }
    return docCache.get(cacheKey);
  }
  function gql(literals) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof literals === "string") {
      literals = [literals];
    }
    var result = literals[0];
    args.forEach(function(arg, i) {
      if (arg && arg.kind === "Document") {
        result += arg.loc.source.body;
      } else {
        result += arg;
      }
      result += literals[i + 1];
    });
    return parseDocument(result);
  }
  function resetCaches() {
    docCache.clear();
    fragmentSourceMap.clear();
  }
  function disableFragmentWarnings() {
    printFragmentWarnings = false;
  }
  function enableExperimentalFragmentVariables() {
    experimentalFragmentVariables = true;
  }
  function disableExperimentalFragmentVariables() {
    experimentalFragmentVariables = false;
  }
  var extras = {
    gql,
    resetCaches,
    disableFragmentWarnings,
    enableExperimentalFragmentVariables,
    disableExperimentalFragmentVariables
  };
  (function(gql_1) {
    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
  })(gql || (gql = {}));
  gql["default"] = gql;
  var lib_default2 = gql;

  // ../address/dist/configs.mjs
  var ZeroBytes32 = "0x0000000000000000000000000000000000000000000000000000000000000000";

  // ../transactions/dist/configs.mjs
  var CONTRACT_MAX_SIZE = 16 * 1024;
  var MAX_SCRIPT_LENGTH = 1024 * 1024 * 1024;
  var MAX_SCRIPT_DATA_LENGTH = 1024 * 1024 * 1024;
  var MAX_PREDICATE_LENGTH = 1024 * 1024;
  var MAX_PREDICATE_DATA_LENGTH = 1024 * 1024;
  var FAILED_REQUIRE_SIGNAL = "0xffffffffffff0000";
  var FAILED_TRANSFER_TO_ADDRESS_SIGNAL = "0xffffffffffff0001";
  var FAILED_ASSERT_EQ_SIGNAL = "0xffffffffffff0003";
  var FAILED_ASSERT_SIGNAL = "0xffffffffffff0004";
  var FAILED_ASSERT_NE_SIGNAL = "0xffffffffffff0005";
  var PANIC_REASONS = [
    "UnknownPanicReason",
    "Revert",
    "OutOfGas",
    "TransactionValidity",
    "MemoryOverflow",
    "ArithmeticOverflow",
    "ContractNotFound",
    "MemoryOwnership",
    "NotEnoughBalance",
    "ExpectedInternalContext",
    "AssetIdNotFound",
    "InputNotFound",
    "OutputNotFound",
    "WitnessNotFound",
    "TransactionMaturity",
    "InvalidMetadataIdentifier",
    "MalformedCallStructure",
    "ReservedRegisterNotWritable",
    "InvalidFlags",
    "InvalidImmediateValue",
    "ExpectedCoinInput",
    "EcalError",
    "MemoryWriteOverlap",
    "ContractNotInInputs",
    "InternalBalanceOverflow",
    "ContractMaxSize",
    "ExpectedUnallocatedStack",
    "MaxStaticContractsReached",
    "TransferAmountCannotBeZero",
    "ExpectedOutputVariable",
    "ExpectedParentInternalContext",
    "PredicateReturnedNonOne",
    "ContractIdAlreadyDeployed",
    "ContractMismatch",
    "MessageDataTooLong",
    "ArithmeticError",
    "ContractInstructionNotAllowed",
    "TransferZeroCoins",
    "InvalidInstruction",
    "MemoryNotExecutable",
    "PolicyIsNotSet",
    "PolicyNotFound",
    "TooManyReceipts",
    "BalanceOverflow",
    "InvalidBlockHeight",
    "TooManySlots",
    "ExpectedNestedCaller",
    "MemoryGrowthOverlap",
    "UninitalizedMemoryAccess",
    "OverridingConsensusParameters",
    "UnknownStateTransactionBytecodeRoot",
    "OverridingStateTransactionBytecode",
    "BytecodeAlreadyUploaded",
    "ThePartIsNotSequentiallyConnected",
    "BlobIdAlreadyUploaded",
    "BlobNotFound",
    "GasCostNotDefined"
  ];
  var PANIC_DOC_URL = "https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html";

  // ../account/dist/index.mjs
  var asm = __toESM(require_node(), 1);

  // ../../node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js
  var _0n3 = BigInt(0);
  var _1n3 = BigInt(1);
  var _2n3 = BigInt(2);
  var _3n = BigInt(3);
  var _4n = BigInt(4);
  var _5n = BigInt(5);
  var _8n = BigInt(8);
  var _9n = BigInt(9);
  var _16n = BigInt(16);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n3 ? result : b + result;
  }
  function pow(num, power, modulo) {
    if (modulo <= _0n3 || power < _0n3)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n3)
      return _0n3;
    let res = _1n3;
    while (power > _0n3) {
      if (power & _1n3)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n3;
    }
    return res;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n3) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number3, modulo) {
    if (number3 === _0n3 || modulo <= _0n3) {
      throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
    }
    let a = mod(number3, modulo);
    let b = modulo;
    let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
    while (a !== _0n3) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n3)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function tonelliShanks(P) {
    const legendreC = (P - _1n3) / _2n3;
    let Q, S, Z;
    for (Q = P - _1n3, S = 0; Q % _2n3 === _0n3; Q /= _2n3, S++)
      ;
    for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n3) / _4n;
      return function tonelliFast(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n3) / _2n3;
    return function tonelliSlow(Fp2, n) {
      if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
      let x = Fp2.pow(n, Q1div2);
      let b = Fp2.pow(n, Q);
      while (!Fp2.eql(b, Fp2.ONE)) {
        if (Fp2.eql(b, Fp2.ZERO))
          return Fp2.ZERO;
        let m = 1;
        for (let t2 = Fp2.sqr(b); m < r; m++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge = Fp2.pow(g, _1n3 << BigInt(r - m - 1));
        g = Fp2.sqr(ge);
        x = Fp2.mul(x, ge);
        b = Fp2.mul(b, g);
        r = m;
      }
      return x;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n) {
      const p1div4 = (P + _1n3) / _4n;
      return function sqrt3mod4(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n === _5n) {
      const c1 = (P - _5n) / _8n;
      return function sqrt5mod8(Fp2, n) {
        const n2 = Fp2.mul(n, _2n3);
        const v = Fp2.pow(n2, c1);
        const nv = Fp2.mul(n, v);
        const i = Fp2.mul(Fp2.mul(nv, _2n3), v);
        const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n === _9n) {
    }
    return tonelliShanks(P);
  }
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map2, val) => {
      map2[val] = "function";
      return map2;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f2, num, power) {
    if (power < _0n3)
      throw new Error("Expected power > 0");
    if (power === _0n3)
      return f2.ONE;
    if (power === _1n3)
      return num;
    let p = f2.ONE;
    let d = num;
    while (power > _0n3) {
      if (power & _1n3)
        p = f2.mul(p, d);
      d = f2.sqr(d);
      power >>= _1n3;
    }
    return p;
  }
  function FpInvertBatch(f2, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f2.is0(num))
        return acc;
      tmp[i] = acc;
      return f2.mul(acc, num);
    }, f2.ONE);
    const inverted = f2.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f2.is0(num))
        return acc;
      tmp[i] = f2.mul(acc, tmp[i]);
      return f2.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n3)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f2 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n3,
      ONE: _1n3,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n3 <= num && num < ORDER;
      },
      is0: (num) => num === _0n3,
      isOdd: (num) => (num & _1n3) === _1n3,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f2, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f2, n)),
      invertBatch: (lst) => FpInvertBatch(f2, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f2);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE2 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
    const reduced = mod(num, fieldOrder - _1n3) + _1n3;
    return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }

  // ../../node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/curve.js
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function wNAF(c, bits2) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const validateW = (W) => {
      if (!Number.isSafeInteger(W) || W <= 0 || W > bits2)
        throw new Error(`Wrong window size=${W}, should be [1..${bits2}]`);
    };
    const opts = (W) => {
      validateW(W);
      const windows2 = Math.ceil(bits2 / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows: windows2, windowSize };
    };
    return {
      constTimeNegate,
      // non-const time multiplication ladder
      unsafeLadder(elm, n) {
        let p = c.ZERO;
        let d = elm;
        while (n > _0n4) {
          if (n & _1n4)
            p = p.add(d);
          d = d.double();
          n >>= _1n4;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows: windows2, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base2 = p;
        for (let window2 = 0; window2 < windows2; window2++) {
          base2 = p;
          points.push(base2);
          for (let i = 1; i < windowSize; i++) {
            base2 = base2.add(p);
            points.push(base2);
          }
          p = base2.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        const { windows: windows2, windowSize } = opts(W);
        let p = c.ZERO;
        let f2 = c.BASE;
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows2; window2++) {
          const offset = window2 * windowSize;
          let wbits2 = Number(n & mask);
          n >>= shiftBy;
          if (wbits2 > windowSize) {
            wbits2 -= maxNumber;
            n += _1n4;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits2) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits2 < 0;
          if (wbits2 === 0) {
            f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f: f2 };
      },
      wNAFCached(P, n, transform) {
        const W = pointWindowSizes.get(P) || 1;
        let comp = pointPrecomputes.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1)
            pointPrecomputes.set(P, transform(comp));
        }
        return this.wNAF(W, comp, n);
      },
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      setWindowSize(P, W) {
        validateW(W);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
    };
  }
  function pippenger(c, field, points, scalars) {
    if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length)
      throw new Error("arrays of points and scalars must have equal length");
    scalars.forEach((s, i) => {
      if (!field.isValid(s))
        throw new Error(`wrong scalar at index ${i}`);
    });
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error(`wrong point at index ${i}`);
    });
    const wbits2 = bitLen(BigInt(points.length));
    const windowSize = wbits2 > 12 ? wbits2 - 3 : wbits2 > 4 ? wbits2 - 2 : wbits2 ? 2 : 1;
    const MASK = (1 << windowSize) - 1;
    const buckets = new Array(MASK + 1).fill(c.ZERO);
    const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;
    let sum = c.ZERO;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(c.ZERO);
      for (let j = 0; j < scalars.length; j++) {
        const scalar = scalars[j];
        const wbits3 = Number(scalar >> BigInt(i) & BigInt(MASK));
        buckets[wbits3] = buckets[wbits3].add(points[j]);
      }
      let resI = c.ZERO;
      for (let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }

  // ../../node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validateSigVerOpts(opts) {
    if (opts.lowS !== void 0)
      abool("lowS", opts.lowS);
    if (opts.prehash !== void 0)
      abool("prehash", opts.prehash);
  }
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a } = opts;
    if (endo) {
      if (!Fp2.eql(a, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
  var DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
        return `${numberToHexUnpadded(tag)}${lenLen}${len}${data}`;
      },
      // v - value, l - left bytes (unparsed)
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong)
          length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length = length << 8 | b;
          pos += lenLen;
          if (length < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length);
        if (v.length !== length)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length) };
      }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
      encode(num) {
        const { Err: E } = DER;
        if (num < _0n5)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected assertion");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return b2n(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      abytes(data);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("Invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const seq = `${tlv.encode(2, int.encode(sig.r))}${tlv.encode(2, int.encode(sig.s))}`;
      return tlv.encode(48, seq);
    }
  };
  var _0n5 = BigInt(0);
  var _1n5 = BigInt(1);
  var _2n4 = BigInt(2);
  var _3n2 = BigInt(3);
  var _4n2 = BigInt(4);
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const Fn = Field(CURVE.n, CURVE.nBitLength);
    const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
      const a = point.toAffine();
      return concatBytes3(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return inRange(num, _1n5, CURVE.n);
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (isBytes2(key))
          key = bytesToHex(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error3) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod(num, N);
      aInRange("private key", num, _1n5, N);
      return num;
    }
    function assertPrjPoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { px: x, py: y, pz: z } = p;
      if (Fp2.eql(z, Fp2.ONE))
        return { x, y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p) => {
      if (p.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(p.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    class Point2 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
        Object.freeze(this);
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
        if (is0(x) && is0(y))
          return Point2.ZERO;
        return new Point2(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex) {
        const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // Multiscalar Multiplication
      static msm(points, scalars) {
        return pippenger(Point2, Fn, points, scalars);
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        wnaf.setWindowSize(this, windowSize);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point2(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n2);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, n, Point2.normalizeZ);
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        aInRange("scalar", sc, _0n5, CURVE.n);
        const I = Point2.ZERO;
        if (sc === _0n5)
          return I;
        if (sc === _1n5)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, sc);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n5 || k2 > _0n5) {
          if (k1 & _1n5)
            k1p = k1p.add(d);
          if (k2 & _1n5)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n5;
          k2 >>= _1n5;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo, n: N } = CURVE;
        aInRange("scalar", scalar, _1n5, N);
        let point, fake;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f: f2 } = this.wNAF(scalar);
          point = p;
          fake = f2;
        }
        return Point2.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point2.BASE;
        const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      toAffine(iz) {
        return toAffineMemo(this, iz);
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n5)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n5)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        abool("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes3(Point2, this, isCompressed);
      }
      toHex(isCompressed = true) {
        abool("isCompressed", isCompressed);
        return bytesToHex(this.toRawBytes(isCompressed));
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp2.toBytes(a.x);
        const cat = concatBytes3;
        abool("isCompressed", isCompressed);
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = bytesToNumberBE(tail);
          if (!inRange(x, _1n5, Fp2.ORDER))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp2.sqrt(y2);
          } catch (sqrtError) {
            const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("Point is not on curve" + suffix);
          }
          const isYOdd = (y & _1n5) === _1n5;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp2.neg(y);
          return { x, y };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number3) {
      const HALF = CURVE_ORDER >> _1n5;
      return number3 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
    class Signature {
      constructor(r, s, recovery) {
        this.r = r;
        this.s = s;
        this.recovery = recovery;
        this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = ensureBytes("compactSignature", hex, l * 2);
        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s } = DER.toSig(ensureBytes("DER", hex));
        return new Signature(r, s);
      }
      assertValidity() {
        aInRange("r", this.r, _1n5, CURVE_ORDER);
        aInRange("s", this.s, _1n5, CURVE_ORDER);
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point2.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h * ir);
        const u2 = modN(s * ir);
        const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error3) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const length = getMinHashLength(CURVE.n);
        return mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point = Point2.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = isBytes2(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point2)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point2.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
      aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n5, ORDER_MASK);
      return numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash3, randomBytes: randomBytes3 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      validateSigVerOpts(opts);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes3(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes3(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = modN(q.x);
        if (r === _0n5)
          return;
        const s = modN(ik * modN(m + r * d));
        if (s === _0n5)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point2.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      validateSigVerOpts(opts);
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P;
      try {
        if (typeof sg === "string" || isBytes2(sg)) {
          try {
            _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s2 } = sg;
          _sig = new Signature(r2, s2);
        } else {
          throw new Error("PARSE");
        }
        P = Point2.fromHex(publicKey);
      } catch (error3) {
        if (error3.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = invN(s);
      const u1 = modN(h * is);
      const u2 = modN(r * is);
      const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
      if (!R)
        return false;
      const v = modN(R.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point2,
      Signature,
      utils
    };
  }

  // ../../node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash3) {
    return {
      hash: hash3,
      hmac: (key, ...msgs) => hmac(hash3, key, concatBytes2(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
    return Object.freeze({ ...create(defHash), create });
  }

  // ../../node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n6 = BigInt(1);
  var _2n5 = BigInt(2);
  var divNearest = (a, b) => (a + b / _2n5) / b;
  function sqrtMod(y) {
    const P = secp256k1P;
    const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n3, P) * b3 % P;
    const b9 = pow2(b6, _3n3, P) * b3 % P;
    const b11 = pow2(b9, _2n5, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n3, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n5, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
  var secp256k1 = createCurve({
    a: BigInt(0),
    // equation params: a, b
    b: BigInt(7),
    // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp,
    // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: secp256k1N,
    // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    // Cofactor
    lowS: true,
    // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256);
  var _0n6 = BigInt(0);
  var Point = secp256k1.ProjectivePoint;

  // ../account/dist/index.mjs
  var import_events = __require2("events");
  var asm2 = __toESM(require_node(), 1);

  // ../merkle/dist/index.mjs
  var EMPTY = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  var Node = class {
    left;
    right;
    parent;
    hash;
    data;
    index;
    constructor(left, right, parent, hash5, data, index = 0) {
      this.left = left;
      this.right = right;
      this.parent = parent;
      this.hash = hash5;
      this.data = data;
      this.index = index;
    }
  };
  var node_default2 = Node;
  function hashLeaf(data) {
    return hash2("0x00".concat(data.slice(2)));
  }
  function hashNode(left, right) {
    return hash2("0x01".concat(left.slice(2)).concat(right.slice(2)));
  }
  function calcRoot(data) {
    if (!data.length) {
      return EMPTY;
    }
    const nodes = [];
    for (let i = 0; i < data.length; i += 1) {
      const hashed = hashLeaf(data[i]);
      nodes.push(new node_default2(-1, -1, -1, hashed, data[i]));
    }
    let pNodes = nodes;
    let size = nodes.length + 1 >> 1;
    let odd = nodes.length & 1;
    while (true) {
      let i = 0;
      for (; i < size - odd; i += 1) {
        const j = i << 1;
        const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);
        nodes[i] = new node_default2(pNodes[j].index, pNodes[j + 1].index, -1, hashed, "");
      }
      if (odd === 1) {
        nodes[i] = pNodes[i << 1];
      }
      if (size === 1) {
        break;
      }
      odd = size & 1;
      size = size + 1 >> 1;
      pNodes = nodes;
    }
    return nodes[0].hash;
  }
  var leafPrefix = "0x00";
  var nodePrefix = "0x01";
  function hashLeaf2(key, data) {
    const value = "0x00".concat(key.slice(2)).concat(hash2(data).slice(2));
    return [hash2(value), value];
  }
  function hashNode2(left, right) {
    const value = "0x01".concat(left.slice(2)).concat(right.slice(2));
    return [hash2(value), value];
  }
  function parseLeaf(data) {
    const len = nodePrefix.length;
    return ["0x".concat(data.slice(len, len + 64)), "0x".concat(data.slice(len + 64))];
  }
  function parseNode(data) {
    const len = nodePrefix.length;
    return ["0x".concat(data.slice(len, len + 64)), "0x".concat(data.slice(len + 64))];
  }
  function isLeaf(data) {
    return data.slice(0, 4) === leafPrefix;
  }
  var SparseCompactMerkleProof = class {
    SideNodes;
    NonMembershipLeafData;
    BitMask;
    NumSideNodes;
    SiblingData;
    constructor(SideNodes, NonMembershipLeafData, Bitmask, NumSideNodes, SiblingData) {
      this.SideNodes = SideNodes;
      this.NonMembershipLeafData = NonMembershipLeafData;
      this.BitMask = Bitmask;
      this.NumSideNodes = NumSideNodes;
      this.SiblingData = SiblingData;
    }
  };
  var sparseCompactMerkleProof_default = SparseCompactMerkleProof;
  var SparseMerkleProof = class {
    SideNodes;
    NonMembershipLeafData;
    SiblingData;
    constructor(sideNodes, NonMembershipLeafData, SiblingData) {
      this.SideNodes = sideNodes;
      this.NonMembershipLeafData = NonMembershipLeafData;
      this.SiblingData = SiblingData;
    }
  };
  var sparseMerkleProof_default = SparseMerkleProof;
  var ZERO = "0x0000000000000000000000000000000000000000000000000000000000000000";
  var MAX_HEIGHT = 256;
  function getBitAtFromMSB(data, position) {
    const slicedData = data.slice(2);
    const byte = "0x".concat(
      slicedData.slice(Math.floor(position / 8) * 2, Math.floor(position / 8) * 2 + 2)
    );
    const bits2 = Number(byte) & 1 << 8 - 1 - position % 8;
    if (bits2 > 0) {
      return 1;
    }
    return 0;
  }
  function reverseSideNodes(sideNodes) {
    let left = 0;
    let right = sideNodes.length - 1;
    const reversedSideNodes = sideNodes;
    while (left < right) {
      [reversedSideNodes[left], reversedSideNodes[right]] = [
        reversedSideNodes[right],
        reversedSideNodes[left]
      ];
      left += 1;
      right -= 1;
    }
    return reversedSideNodes;
  }
  function countCommonPrefix(data1, data2) {
    let count = 0;
    for (let i = 0; i < MAX_HEIGHT; i += 1) {
      if (getBitAtFromMSB(data1, i) === getBitAtFromMSB(data2, i)) {
        count += 1;
      } else {
        break;
      }
    }
    return count;
  }
  function compactProof(proof) {
    const bitMask2 = [];
    const compactedSideNodes = [];
    let node2;
    for (let i = 0; i < proof.SideNodes.length; i += 1) {
      node2 = proof.SideNodes[i];
      if (node2 === ZERO) {
        bitMask2.push(0);
      } else {
        compactedSideNodes.push(node2);
        bitMask2.push(1);
      }
    }
    const compactedProof = new sparseCompactMerkleProof_default(
      compactedSideNodes,
      proof.NonMembershipLeafData,
      bitMask2,
      proof.SideNodes.length,
      proof.SiblingData
    );
    return compactedProof;
  }
  var SparseMerkleTree = class {
    ms;
    root;
    constructor() {
      const ms = {};
      this.ms = ms;
      this.root = ZERO;
      this.ms[this.root] = ZERO;
    }
    get(key) {
      return this.ms[key];
    }
    set(key, value) {
      this.ms[key] = value;
    }
    setRoot(root) {
      this.root = root;
    }
    sideNodesForRoot(key, root) {
      const sideNodes = [];
      if (root === ZERO) {
        return [sideNodes, ZERO, "", ""];
      }
      let currentData = this.get(root);
      if (isLeaf(currentData)) {
        return [sideNodes, root, currentData, ""];
      }
      let leftNode;
      let rightNode;
      let nodeHash = "";
      let sideNode = "";
      for (let i = 0; i < MAX_HEIGHT; i += 1) {
        [leftNode, rightNode] = parseNode(currentData);
        if (getBitAtFromMSB(key, i) === 1) {
          sideNode = leftNode;
          nodeHash = rightNode;
        } else {
          sideNode = rightNode;
          nodeHash = leftNode;
        }
        sideNodes.push(sideNode);
        if (nodeHash === ZERO) {
          currentData = "";
          break;
        }
        currentData = this.get(nodeHash);
        if (isLeaf(currentData)) {
          break;
        }
      }
      const siblingData = this.get(sideNode);
      return [reverseSideNodes(sideNodes), nodeHash, currentData, siblingData];
    }
    deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData) {
      if (oldLeafHash === ZERO) {
        return this.root;
      }
      const [actualPath] = parseLeaf(oldLeafData);
      if (actualPath !== key) {
        return this.root;
      }
      let currentHash = "";
      let currentData = "";
      let sideNode = "";
      let sideNodeValue = "";
      let nonPlaceholderReached = false;
      for (let i = 0; i < sideNodes.length; i += 1) {
        if (sideNodes[i] === "") {
          continue;
        }
        sideNode = sideNodes[i];
        if (currentData === "") {
          sideNodeValue = this.get(sideNode);
          if (isLeaf(sideNodeValue)) {
            currentHash = sideNode;
            currentData = sideNode;
            continue;
          } else {
            currentData = ZERO;
            nonPlaceholderReached = true;
          }
        }
        if (!nonPlaceholderReached && sideNode === ZERO) {
          continue;
        } else if (!nonPlaceholderReached) {
          nonPlaceholderReached = true;
        }
        if (getBitAtFromMSB(key, sideNodes.length - 1 - i) === 1) {
          [currentHash, currentData] = hashNode2(sideNode, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, sideNode);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      if (currentHash === "") {
        currentHash = ZERO;
      }
      return currentHash;
    }
    updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData) {
      let currentHash;
      let currentData;
      this.set(hash2(value), value);
      [currentHash, currentData] = hashLeaf2(key, value);
      this.set(currentHash, currentData);
      currentData = currentHash;
      let commonPrefixCount;
      if (oldLeafHash === ZERO) {
        commonPrefixCount = MAX_HEIGHT;
      } else {
        const [actualPath] = parseLeaf(oldLeafData);
        commonPrefixCount = countCommonPrefix(key, actualPath);
      }
      if (commonPrefixCount !== MAX_HEIGHT) {
        if (getBitAtFromMSB(key, commonPrefixCount) === 1) {
          [currentHash, currentData] = hashNode2(oldLeafHash, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, oldLeafHash);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      for (let i = 0; i < MAX_HEIGHT; i += 1) {
        let sideNode;
        const offsetOfSideNodes = MAX_HEIGHT - sideNodes.length;
        if (i - offsetOfSideNodes < 0 || sideNodes[i - offsetOfSideNodes] === "") {
          if (commonPrefixCount !== MAX_HEIGHT && commonPrefixCount > MAX_HEIGHT - 1 - i) {
            sideNode = ZERO;
          } else {
            continue;
          }
        } else {
          sideNode = sideNodes[i - offsetOfSideNodes];
        }
        if (getBitAtFromMSB(key, MAX_HEIGHT - 1 - i) === 1) {
          [currentHash, currentData] = hashNode2(sideNode, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, sideNode);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      return currentHash;
    }
    update(key, value) {
      const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
      const newRoot = this.updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData);
      this.setRoot(newRoot);
    }
    delete(key) {
      const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
      const newRoot = this.deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData);
      this.setRoot(newRoot);
    }
    prove(key) {
      const [sideNodes, leafHash, leafData, siblingData] = this.sideNodesForRoot(key, this.root);
      const nonEmptySideNodes = [];
      for (let i = 0; i < sideNodes.length; i += 1) {
        if (sideNodes[i] !== "") {
          nonEmptySideNodes.push(sideNodes[i]);
        }
      }
      let nonMembershipLeafData = "";
      if (leafHash !== ZERO) {
        const [actualPath] = parseLeaf(leafData);
        if (actualPath !== key) {
          nonMembershipLeafData = leafData;
        }
      }
      const proof = new sparseMerkleProof_default(nonEmptySideNodes, nonMembershipLeafData, siblingData);
      return proof;
    }
    proveCompacted(key) {
      const proof = this.prove(key);
      const compactedProof = compactProof(proof);
      return compactedProof;
    }
  };

  // ../account/dist/index.mjs
  var import_events2 = __require2("events");
  var __defProp8 = Object.defineProperty;
  var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField8 = (obj, key, value) => {
    __defNormalProp8(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck2 = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet2 = (obj, member, getter2) => {
    __accessCheck2(obj, member, "read from private field");
    return getter2 ? getter2.call(obj) : member.get(obj);
  };
  var __privateAdd2 = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet2 = (obj, member, value, setter) => {
    __accessCheck2(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod2 = (obj, member, method) => {
    __accessCheck2(obj, member, "access private method");
    return method;
  };
  var coinQuantityfy = (coinQuantityLike) => {
    let assetId;
    let amount;
    let max2;
    if (Array.isArray(coinQuantityLike)) {
      amount = coinQuantityLike[0];
      assetId = coinQuantityLike[1];
      max2 = coinQuantityLike[2] ?? void 0;
    } else {
      amount = coinQuantityLike.amount;
      assetId = coinQuantityLike.assetId;
      max2 = coinQuantityLike.max ?? void 0;
    }
    const bnAmount = bn(amount);
    return {
      assetId: hexlify(assetId),
      amount: bnAmount.lt(1) ? bn(1) : bnAmount,
      max: max2 ? bn(max2) : void 0
    };
  };
  var addAmountToCoinQuantities = (params) => {
    const { amount, assetId } = params;
    const coinQuantities = [...params.coinQuantities];
    const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
    if (assetIdx !== -1) {
      coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
    } else {
      coinQuantities.push({ assetId, amount });
    }
    return coinQuantities;
  };
  var SubmittedStatusFragmentDoc = lib_default2`
    fragment SubmittedStatusFragment on SubmittedStatus {
  type: __typename
  time
}
    `;
  var ReceiptFragmentDoc = lib_default2`
    fragment receiptFragment on Receipt {
  id
  pc
  is
  to
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
  var SuccessStatusFragmentDoc = lib_default2`
    fragment SuccessStatusFragment on SuccessStatus {
  type: __typename
  time
  programState {
    returnType
    data
  }
  receipts {
    ...receiptFragment
  }
  totalGas
  totalFee
}
    ${ReceiptFragmentDoc}`;
  var SuccessStatusWithBlockIdFragmentDoc = lib_default2`
    fragment SuccessStatusWithBlockIdFragment on SuccessStatus {
  ...SuccessStatusFragment
  block {
    id
  }
}
    ${SuccessStatusFragmentDoc}`;
  var MalleableTransactionFieldsFragmentDoc = lib_default2`
    fragment malleableTransactionFieldsFragment on Transaction {
  receiptsRoot
  inputs {
    type: __typename
    ... on InputCoin {
      txPointer
    }
    ... on InputContract {
      txPointer
    }
  }
  outputs {
    type: __typename
    ... on CoinOutput {
      to
      amount
      assetId
    }
    ... on ContractOutput {
      inputIndex
      balanceRoot
      stateRoot
    }
    ... on ChangeOutput {
      to
      amount
      assetId
    }
    ... on VariableOutput {
      to
      amount
      assetId
    }
    ... on ContractCreated {
      contract
      stateRoot
    }
  }
}
    `;
  var FailureStatusFragmentDoc = lib_default2`
    fragment FailureStatusFragment on FailureStatus {
  type: __typename
  totalGas
  totalFee
  time
  reason
  receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc}`;
  var FailureStatusWithBlockIdFragmentDoc = lib_default2`
    fragment FailureStatusWithBlockIdFragment on FailureStatus {
  ...FailureStatusFragment
  block {
    id
  }
}
    ${FailureStatusFragmentDoc}`;
  var SqueezedOutStatusFragmentDoc = lib_default2`
    fragment SqueezedOutStatusFragment on SqueezedOutStatus {
  type: __typename
  reason
}
    `;
  var TransactionStatusSubscriptionFragmentDoc = lib_default2`
    fragment transactionStatusSubscriptionFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on FailureStatus {
    ...FailureStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusWithBlockIdFragmentDoc}
${MalleableTransactionFieldsFragmentDoc}
${FailureStatusWithBlockIdFragmentDoc}
${SqueezedOutStatusFragmentDoc}`;
  var TransactionStatusFragmentDoc = lib_default2`
    fragment transactionStatusFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusFragment
  }
  ... on FailureStatus {
    ...FailureStatusFragment
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusFragmentDoc}
${FailureStatusFragmentDoc}
${SqueezedOutStatusFragmentDoc}`;
  var TransactionFragmentDoc = lib_default2`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  status {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentDoc}`;
  var TransactionRawPayloadFragmentDoc = lib_default2`
    fragment transactionRawPayloadFragment on Transaction {
  id
  rawPayload
}
    `;
  var InputEstimatePredicatesFragmentDoc = lib_default2`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
  var TransactionEstimatePredicatesFragmentDoc = lib_default2`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentDoc}`;
  var DryRunFailureStatusFragmentDoc = lib_default2`
    fragment dryRunFailureStatusFragment on DryRunFailureStatus {
  type: __typename
  totalGas
  totalFee
  reason
  programState {
    returnType
    data
  }
}
    `;
  var DryRunSuccessStatusFragmentDoc = lib_default2`
    fragment dryRunSuccessStatusFragment on DryRunSuccessStatus {
  type: __typename
  totalGas
  totalFee
  programState {
    returnType
    data
  }
}
    `;
  var DryRunTransactionStatusFragmentDoc = lib_default2`
    fragment dryRunTransactionStatusFragment on DryRunTransactionStatus {
  ... on DryRunFailureStatus {
    ...dryRunFailureStatusFragment
  }
  ... on DryRunSuccessStatus {
    ...dryRunSuccessStatusFragment
  }
}
    ${DryRunFailureStatusFragmentDoc}
${DryRunSuccessStatusFragmentDoc}`;
  var DryRunTransactionExecutionStatusFragmentDoc = lib_default2`
    fragment dryRunTransactionExecutionStatusFragment on DryRunTransactionExecutionStatus {
  id
  status {
    ...dryRunTransactionStatusFragment
  }
  receipts {
    ...receiptFragment
  }
}
    ${DryRunTransactionStatusFragmentDoc}
${ReceiptFragmentDoc}`;
  var BlockFragmentDoc = lib_default2`
    fragment blockFragment on Block {
  id
  height
  header {
    time
    daHeight
    stateTransitionBytecodeVersion
    transactionsCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    prevRoot
    applicationHash
  }
  transactions {
    id
  }
}
    `;
  var CoinFragmentDoc = lib_default2`
    fragment coinFragment on Coin {
  type: __typename
  utxoId
  amount
  assetId
  blockCreated
  txCreatedIdx
}
    `;
  var MessageCoinFragmentDoc = lib_default2`
    fragment messageCoinFragment on MessageCoin {
  type: __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
  var MessageFragmentDoc = lib_default2`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  daHeight
}
    `;
  var GetMessageFragmentDoc = lib_default2`
    fragment getMessageFragment on Message {
  ...messageFragment
  nonce
}
    ${MessageFragmentDoc}`;
  var MessageProofFragmentDoc = lib_default2`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  commitBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  sender
  recipient
  amount
  data
}
    `;
  var TxParametersFragmentDoc = lib_default2`
    fragment TxParametersFragment on TxParameters {
  version
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
  maxBytecodeSubsections
}
    `;
  var PredicateParametersFragmentDoc = lib_default2`
    fragment PredicateParametersFragment on PredicateParameters {
  version
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
  var ScriptParametersFragmentDoc = lib_default2`
    fragment ScriptParametersFragment on ScriptParameters {
  version
  maxScriptLength
  maxScriptDataLength
}
    `;
  var ContractParametersFragmentDoc = lib_default2`
    fragment ContractParametersFragment on ContractParameters {
  version
  contractMaxSize
  maxStorageSlots
}
    `;
  var FeeParametersFragmentDoc = lib_default2`
    fragment FeeParametersFragment on FeeParameters {
  version
  gasPriceFactor
  gasPerByte
}
    `;
  var DependentCostFragmentDoc = lib_default2`
    fragment DependentCostFragment on DependentCost {
  ... on LightOperation {
    type: __typename
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    type: __typename
    base
    gasPerUnit
  }
}
    `;
  var GasCostsFragmentDoc = lib_default2`
    fragment GasCostsFragment on GasCosts {
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  ecr1
  newStoragePerByte
}
    ${DependentCostFragmentDoc}`;
  var ConsensusParametersFragmentDoc = lib_default2`
    fragment consensusParametersFragment on ConsensusParameters {
  version
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentDoc}
${PredicateParametersFragmentDoc}
${ScriptParametersFragmentDoc}
${ContractParametersFragmentDoc}
${FeeParametersFragmentDoc}
${GasCostsFragmentDoc}`;
  var ChainInfoFragmentDoc = lib_default2`
    fragment chainInfoFragment on ChainInfo {
  name
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${ConsensusParametersFragmentDoc}`;
  var ContractBalanceFragmentDoc = lib_default2`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
  var PageInfoFragmentDoc = lib_default2`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
  var NodeInfoFragmentDoc = lib_default2`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  maxTx
  maxDepth
  nodeVersion
}
    `;
  var RelayedTransactionStatusFragmentDoc = lib_default2`
    fragment relayedTransactionStatusFragment on RelayedTransactionStatus {
  ... on RelayedTransactionFailed {
    blockHeight
    failure
  }
}
    `;
  var GetVersionDocument = lib_default2`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
  var GetNodeInfoDocument = lib_default2`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentDoc}`;
  var GetChainDocument = lib_default2`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentDoc}`;
  var GetChainAndNodeInfoDocument = lib_default2`
    query getChainAndNodeInfo {
  chain {
    ...chainInfoFragment
  }
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${ChainInfoFragmentDoc}
${NodeInfoFragmentDoc}`;
  var GetTransactionDocument = lib_default2`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentDoc}`;
  var GetTransactionWithReceiptsDocument = lib_default2`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    id
    rawPayload
    status {
      ... on SubmittedStatus {
        ...SubmittedStatusFragment
      }
      ... on SuccessStatus {
        ...SuccessStatusWithBlockIdFragment
      }
      ... on FailureStatus {
        ...FailureStatusWithBlockIdFragment
      }
      ... on SqueezedOutStatus {
        ...SqueezedOutStatusFragment
      }
    }
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusWithBlockIdFragmentDoc}
${FailureStatusWithBlockIdFragmentDoc}
${SqueezedOutStatusFragmentDoc}`;
  var GetTransactionsDocument = lib_default2`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        rawPayload
      }
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${PageInfoFragmentDoc}`;
  var GetTransactionsByOwnerDocument = lib_default2`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${TransactionFragmentDoc}`;
  var EstimatePredicatesDocument = lib_default2`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentDoc}`;
  var GetLatestBlockDocument = lib_default2`
    query getLatestBlock {
  chain {
    latestBlock {
      ...blockFragment
    }
  }
}
    ${BlockFragmentDoc}`;
  var GetLatestBlockHeightDocument = lib_default2`
    query getLatestBlockHeight {
  chain {
    latestBlock {
      height
    }
  }
}
    `;
  var GetBlockDocument = lib_default2`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentDoc}`;
  var GetBlockWithTransactionsDocument = lib_default2`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionRawPayloadFragment
    }
  }
}
    ${BlockFragmentDoc}
${TransactionRawPayloadFragmentDoc}`;
  var GetBlocksDocument = lib_default2`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${BlockFragmentDoc}`;
  var GetCoinDocument = lib_default2`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
    owner
  }
}
    ${CoinFragmentDoc}`;
  var GetCoinsDocument = lib_default2`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${CoinFragmentDoc}`;
  var GetCoinsToSpendDocument = lib_default2`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentDoc}
${MessageCoinFragmentDoc}`;
  var GetContractDocument = lib_default2`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
  var GetContractBalanceDocument = lib_default2`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentDoc}`;
  var GetBalanceDocument = lib_default2`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amount
  }
}
    `;
  var GetLatestGasPriceDocument = lib_default2`
    query getLatestGasPrice {
  latestGasPrice {
    gasPrice
  }
}
    `;
  var EstimateGasPriceDocument = lib_default2`
    query estimateGasPrice($blockHorizon: U32!) {
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    `;
  var GetBalancesDocument = lib_default2`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        assetId
        amount
      }
    }
  }
}
    ${PageInfoFragmentDoc}`;
  var GetMessagesDocument = lib_default2`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...getMessageFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${GetMessageFragmentDoc}`;
  var GetMessageProofDocument = lib_default2`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentDoc}`;
  var GetMessageStatusDocument = lib_default2`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
  var GetRelayedTransactionStatusDocument = lib_default2`
    query getRelayedTransactionStatus($relayedTransactionId: RelayedTransactionId!) {
  relayedTransactionStatus(id: $relayedTransactionId) {
    ...relayedTransactionStatusFragment
  }
}
    ${RelayedTransactionStatusFragmentDoc}`;
  var DryRunDocument = lib_default2`
    mutation dryRun($encodedTransactions: [HexString!]!, $utxoValidation: Boolean, $gasPrice: U64) {
  dryRun(
    txs: $encodedTransactions
    utxoValidation: $utxoValidation
    gasPrice: $gasPrice
  ) {
    ...dryRunTransactionExecutionStatusFragment
  }
}
    ${DryRunTransactionExecutionStatusFragmentDoc}`;
  var SubmitDocument = lib_default2`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
  var ProduceBlocksDocument = lib_default2`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
  var GetMessageByNonceDocument = lib_default2`
    query getMessageByNonce($nonce: Nonce!) {
  message(nonce: $nonce) {
    ...messageFragment
  }
}
    ${MessageFragmentDoc}`;
  var IsUserAccountDocument = lib_default2`
    query isUserAccount($blobId: BlobId!, $contractId: ContractId!, $transactionId: TransactionId!) {
  blob(id: $blobId) {
    id
  }
  contract(id: $contractId) {
    id
  }
  transaction(id: $transactionId) {
    id
  }
}
    `;
  var GetConsensusParametersVersionDocument = lib_default2`
    query getConsensusParametersVersion {
  chain {
    latestBlock {
      header {
        consensusParametersVersion
      }
    }
  }
}
    `;
  var SubmitAndAwaitStatusDocument = lib_default2`
    subscription submitAndAwaitStatus($encodedTransaction: HexString!) {
  submitAndAwaitStatus(tx: $encodedTransaction) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc}`;
  var StatusChangeDocument = lib_default2`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc}`;
  function getSdk(requester) {
    return {
      getVersion(variables, options) {
        return requester(GetVersionDocument, variables, options);
      },
      getNodeInfo(variables, options) {
        return requester(GetNodeInfoDocument, variables, options);
      },
      getChain(variables, options) {
        return requester(GetChainDocument, variables, options);
      },
      getChainAndNodeInfo(variables, options) {
        return requester(GetChainAndNodeInfoDocument, variables, options);
      },
      getTransaction(variables, options) {
        return requester(GetTransactionDocument, variables, options);
      },
      getTransactionWithReceipts(variables, options) {
        return requester(GetTransactionWithReceiptsDocument, variables, options);
      },
      getTransactions(variables, options) {
        return requester(GetTransactionsDocument, variables, options);
      },
      getTransactionsByOwner(variables, options) {
        return requester(GetTransactionsByOwnerDocument, variables, options);
      },
      estimatePredicates(variables, options) {
        return requester(EstimatePredicatesDocument, variables, options);
      },
      getLatestBlock(variables, options) {
        return requester(GetLatestBlockDocument, variables, options);
      },
      getLatestBlockHeight(variables, options) {
        return requester(GetLatestBlockHeightDocument, variables, options);
      },
      getBlock(variables, options) {
        return requester(GetBlockDocument, variables, options);
      },
      getBlockWithTransactions(variables, options) {
        return requester(GetBlockWithTransactionsDocument, variables, options);
      },
      getBlocks(variables, options) {
        return requester(GetBlocksDocument, variables, options);
      },
      getCoin(variables, options) {
        return requester(GetCoinDocument, variables, options);
      },
      getCoins(variables, options) {
        return requester(GetCoinsDocument, variables, options);
      },
      getCoinsToSpend(variables, options) {
        return requester(GetCoinsToSpendDocument, variables, options);
      },
      getContract(variables, options) {
        return requester(GetContractDocument, variables, options);
      },
      getContractBalance(variables, options) {
        return requester(GetContractBalanceDocument, variables, options);
      },
      getBalance(variables, options) {
        return requester(GetBalanceDocument, variables, options);
      },
      getLatestGasPrice(variables, options) {
        return requester(GetLatestGasPriceDocument, variables, options);
      },
      estimateGasPrice(variables, options) {
        return requester(EstimateGasPriceDocument, variables, options);
      },
      getBalances(variables, options) {
        return requester(GetBalancesDocument, variables, options);
      },
      getMessages(variables, options) {
        return requester(GetMessagesDocument, variables, options);
      },
      getMessageProof(variables, options) {
        return requester(GetMessageProofDocument, variables, options);
      },
      getMessageStatus(variables, options) {
        return requester(GetMessageStatusDocument, variables, options);
      },
      getRelayedTransactionStatus(variables, options) {
        return requester(GetRelayedTransactionStatusDocument, variables, options);
      },
      dryRun(variables, options) {
        return requester(DryRunDocument, variables, options);
      },
      submit(variables, options) {
        return requester(SubmitDocument, variables, options);
      },
      produceBlocks(variables, options) {
        return requester(ProduceBlocksDocument, variables, options);
      },
      getMessageByNonce(variables, options) {
        return requester(GetMessageByNonceDocument, variables, options);
      },
      isUserAccount(variables, options) {
        return requester(IsUserAccountDocument, variables, options);
      },
      getConsensusParametersVersion(variables, options) {
        return requester(GetConsensusParametersVersionDocument, variables, options);
      },
      submitAndAwaitStatus(variables, options) {
        return requester(SubmitAndAwaitStatusDocument, variables, options);
      },
      statusChange(variables, options) {
        return requester(StatusChangeDocument, variables, options);
      }
    };
  }
  var _FuelGraphqlSubscriber = class {
    constructor(stream2) {
      this.stream = stream2;
    }
    static async create(options) {
      const { url, query, variables, fetchFn } = options;
      const response = await fetchFn(`${url}-sub`, {
        method: "POST",
        body: JSON.stringify({
          query: print(query),
          variables
        }),
        headers: {
          "Content-Type": "application/json",
          Accept: "text/event-stream"
        }
      });
      const [errorReader, resultReader] = response.body.tee().map((stream2) => stream2.getReader());
      await new _FuelGraphqlSubscriber(errorReader).next();
      return new _FuelGraphqlSubscriber(resultReader);
    }
    events = [];
    parsingLeftover = "";
    async next() {
      while (true) {
        if (this.events.length > 0) {
          const { data, errors: errors2 } = this.events.shift();
          if (Array.isArray(errors2)) {
            throw new FuelError(
              FuelError.CODES.INVALID_REQUEST,
              errors2.map((err2) => err2.message).join("\n\n")
            );
          }
          return { value: data, done: false };
        }
        const { value, done } = await this.stream.read();
        if (done) {
          return { value, done };
        }
        const decoded = _FuelGraphqlSubscriber.textDecoder.decode(value).replace(":keep-alive-text\n\n", "");
        if (decoded === "") {
          continue;
        }
        const text = `${this.parsingLeftover}${decoded}`;
        const regex = /data:.*\n\n/g;
        const matches = [...text.matchAll(regex)].flatMap((match3) => match3);
        matches.forEach((match3) => {
          try {
            this.events.push(JSON.parse(match3.replace(/^data:/, "")));
          } catch (e) {
            throw new FuelError(
              ErrorCode.STREAM_PARSING_ERROR,
              `Error while parsing stream data response: ${text}`
            );
          }
        });
        this.parsingLeftover = text.replace(matches.join(), "");
      }
    }
    /**
     * Gets called when `break` is called in a `for-await-of` loop.
     */
    return() {
      return Promise.resolve({ done: true, value: void 0 });
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  var FuelGraphqlSubscriber = _FuelGraphqlSubscriber;
  __publicField8(FuelGraphqlSubscriber, "textDecoder", new TextDecoder());
  var cache = /* @__PURE__ */ new Map();
  var ResourceCache = class {
    ttl;
    constructor(ttl) {
      this.ttl = ttl;
      if (typeof ttl !== "number" || this.ttl <= 0) {
        throw new FuelError(
          ErrorCode.INVALID_TTL,
          `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
        );
      }
    }
    // Add resources to the cache
    set(transactionId, resources) {
      const currentTime = Date.now();
      const existingResources = cache.get(transactionId) || {
        utxos: /* @__PURE__ */ new Set(),
        messages: /* @__PURE__ */ new Set(),
        timestamp: currentTime
      };
      resources.utxos.forEach((utxo) => existingResources.utxos.add(hexlify(utxo)));
      resources.messages.forEach((message) => existingResources.messages.add(hexlify(message)));
      cache.set(transactionId, existingResources);
    }
    // Remove resources from the cache for a given transaction ID
    unset(transactionId) {
      cache.delete(transactionId);
    }
    // Get all cached resources and remove expired ones
    getActiveData() {
      const allResources = { utxos: [], messages: [] };
      const currentTime = Date.now();
      cache.forEach((resource, transactionId) => {
        if (currentTime - resource.timestamp < this.ttl) {
          allResources.utxos.push(...resource.utxos);
          allResources.messages.push(...resource.messages);
        } else {
          cache.delete(transactionId);
        }
      });
      return allResources;
    }
    // Check if a UTXO ID or message nonce is already cached and not expired
    isCached(key) {
      const currentTime = Date.now();
      for (const [transactionId, resourceData] of cache.entries()) {
        if (currentTime - resourceData.timestamp > this.ttl) {
          cache.delete(transactionId);
        } else if (resourceData.utxos.has(key) || resourceData.messages.has(key)) {
          return true;
        }
      }
      return false;
    }
    clear() {
      cache.clear();
    }
  };
  var inputify = (value) => {
    const { type: type3 } = value;
    switch (value.type) {
      case InputType.Coin: {
        const predicate = arrayify(value.predicate ?? "0x");
        const predicateData = arrayify(value.predicateData ?? "0x");
        return {
          type: InputType.Coin,
          txID: hexlify(arrayify(value.id).slice(0, BYTES_32)),
          outputIndex: toNumber(arrayify(value.id).slice(BYTES_32, UTXO_ID_LEN)),
          owner: hexlify(value.owner),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId),
          txPointer: {
            blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),
            txIndex: toNumber(arrayify(value.txPointer).slice(8, 16))
          },
          witnessIndex: value.witnessIndex,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: bn(predicate.length),
          predicateDataLength: bn(predicateData.length),
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData)
        };
      }
      case InputType.Contract: {
        return {
          type: InputType.Contract,
          txID: ZeroBytes32,
          outputIndex: 0,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32,
          txPointer: {
            blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),
            txIndex: toNumber(arrayify(value.txPointer).slice(8, 16))
          },
          contractID: hexlify(value.contractId)
        };
      }
      case InputType.Message: {
        const predicate = arrayify(value.predicate ?? "0x");
        const predicateData = arrayify(value.predicateData ?? "0x");
        const data = arrayify(value.data ?? "0x");
        return {
          type: InputType.Message,
          sender: hexlify(value.sender),
          recipient: hexlify(value.recipient),
          amount: bn(value.amount),
          nonce: hexlify(value.nonce),
          witnessIndex: value.witnessIndex,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: bn(predicate.length),
          predicateDataLength: bn(predicateData.length),
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData),
          data: hexlify(data),
          dataLength: data.length
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${type3}.`
        );
      }
    }
  };
  var outputify = (value) => {
    const { type: type3 } = value;
    switch (type3) {
      case OutputType.Coin: {
        return {
          type: OutputType.Coin,
          to: hexlify(value.to),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Contract: {
        return {
          type: OutputType.Contract,
          inputIndex: value.inputIndex,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32
        };
      }
      case OutputType.Change: {
        return {
          type: OutputType.Change,
          to: hexlify(value.to),
          amount: bn(0),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Variable: {
        return {
          type: OutputType.Variable,
          to: ZeroBytes32,
          amount: bn(0),
          assetId: ZeroBytes32
        };
      }
      case OutputType.ContractCreated: {
        return {
          type: OutputType.ContractCreated,
          contractId: hexlify(value.contractId),
          stateRoot: hexlify(value.stateRoot)
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction output type: ${type3}.`
        );
      }
    }
  };
  var isMessageCoin = (message) => !("data" in message);
  var isCoin = (resource) => "id" in resource;
  var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === ReceiptType.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
  var doesReceiptHaveMissingContractId = (receipt) => receipt.type === ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
  var getReceiptsWithMissingData = (receipts) => receipts.reduce(
    (memo, receipt) => {
      if (doesReceiptHaveMissingOutputVariables(receipt)) {
        memo.missingOutputVariables.push(receipt);
      }
      if (doesReceiptHaveMissingContractId(receipt)) {
        memo.missingOutputContractIds.push(receipt);
      }
      return memo;
    },
    {
      missingOutputVariables: [],
      missingOutputContractIds: []
    }
  );
  var hexOrZero = (hex) => hex || ZeroBytes32;
  function assembleReceiptByType(receipt) {
    const { receiptType } = receipt;
    switch (receiptType) {
      case "CALL": {
        const id = hexOrZero(receipt.id || receipt.contractId);
        const callReceipt = {
          type: ReceiptType.Call,
          id,
          to: hexOrZero(receipt?.to),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          gas: bn(receipt.gas),
          param1: bn(receipt.param1),
          param2: bn(receipt.param2),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return callReceipt;
      }
      case "RETURN": {
        const returnReceipt = {
          type: ReceiptType.Return,
          id: hexOrZero(receipt.id || receipt.contractId),
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return returnReceipt;
      }
      case "RETURN_DATA": {
        const returnDataReceipt = {
          type: ReceiptType.ReturnData,
          id: hexOrZero(receipt.id || receipt.contractId),
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero(receipt.digest),
          pc: bn(receipt.pc),
          data: hexOrZero(receipt.data),
          is: bn(receipt.is)
        };
        return returnDataReceipt;
      }
      case "PANIC": {
        const panicReceipt = {
          type: ReceiptType.Panic,
          id: hexOrZero(receipt.id),
          reason: bn(receipt.reason),
          pc: bn(receipt.pc),
          is: bn(receipt.is),
          contractId: hexOrZero(receipt.contractId)
        };
        return panicReceipt;
      }
      case "REVERT": {
        const revertReceipt = {
          type: ReceiptType.Revert,
          id: hexOrZero(receipt.id || receipt.contractId),
          val: bn(receipt.ra),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return revertReceipt;
      }
      case "LOG": {
        const ra = bn(receipt.ra);
        const rb = bn(receipt.rb);
        const rc = bn(receipt.rc);
        const rd = bn(receipt.rd);
        const logReceipt = {
          type: ReceiptType.Log,
          id: hexOrZero(receipt.id || receipt.contractId),
          ra,
          rb,
          rc,
          rd,
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return logReceipt;
      }
      case "LOG_DATA": {
        const ra = bn(receipt.ra);
        const rb = bn(receipt.rb);
        const logDataReceipt = {
          type: ReceiptType.LogData,
          id: hexOrZero(receipt.id || receipt.contractId),
          ra,
          rb,
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero(receipt.digest),
          pc: bn(receipt.pc),
          data: hexOrZero(receipt.data),
          is: bn(receipt.is)
        };
        return logDataReceipt;
      }
      case "TRANSFER": {
        const id = hexOrZero(receipt.id || receipt.contractId);
        const transferReceipt = {
          type: ReceiptType.Transfer,
          id,
          to: hexOrZero(receipt.toAddress || receipt?.to),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferReceipt;
      }
      case "TRANSFER_OUT": {
        const id = hexOrZero(receipt.id || receipt.contractId);
        const transferOutReceipt = {
          type: ReceiptType.TransferOut,
          id,
          to: hexOrZero(receipt.toAddress || receipt.to),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferOutReceipt;
      }
      case "SCRIPT_RESULT": {
        const scriptResultReceipt = {
          type: ReceiptType.ScriptResult,
          result: bn(receipt.result),
          gasUsed: bn(receipt.gasUsed)
        };
        return scriptResultReceipt;
      }
      case "MESSAGE_OUT": {
        const sender = hexOrZero(receipt.sender);
        const recipient = hexOrZero(receipt.recipient);
        const nonce = hexOrZero(receipt.nonce);
        const amount = bn(receipt.amount);
        const data = receipt.data ? arrayify(receipt.data) : Uint8Array.from([]);
        const digest = hexOrZero(receipt.digest);
        const len = bn(receipt.len).toNumber();
        const messageId = InputMessageCoder.getMessageId({
          sender,
          recipient,
          nonce,
          amount,
          data: hexlify(data)
        });
        const receiptMessageOut = {
          type: ReceiptType.MessageOut,
          sender,
          recipient,
          amount,
          nonce,
          len,
          data,
          digest,
          messageId
        };
        return receiptMessageOut;
      }
      case "MINT": {
        const contractId = hexOrZero(receipt.id || receipt.contractId);
        const subId = hexOrZero(receipt.subId);
        const assetId = getMintedAssetId(contractId, subId);
        const mintReceipt = {
          type: ReceiptType.Mint,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return mintReceipt;
      }
      case "BURN": {
        const contractId = hexOrZero(receipt.id || receipt.contractId);
        const subId = hexOrZero(receipt.subId);
        const assetId = getMintedAssetId(contractId, subId);
        const burnReceipt = {
          type: ReceiptType.Burn,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return burnReceipt;
      }
      default:
        throw new FuelError(ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
    }
  }
  var getGasUsedFromReceipts = (receipts) => {
    const scriptResult = receipts.filter(
      (receipt) => receipt.type === ReceiptType.ScriptResult
    );
    const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn(0));
    return gasUsed;
  };
  function resolveGasDependentCosts(byteSize, gasDependentCost) {
    const base2 = bn(gasDependentCost.base);
    let dependentValue = bn(0);
    if ("unitsPerGas" in gasDependentCost) {
      dependentValue = bn(byteSize).div(bn(gasDependentCost.unitsPerGas));
    } else {
      dependentValue = bn(byteSize).mul(bn(gasDependentCost.gasPerUnit));
    }
    return base2.add(dependentValue);
  }
  function gasUsedByInputs(inputs, txBytesSize, gasCosts) {
    const witnessCache = [];
    const chargeableInputs = inputs.filter((input) => {
      const isCoinOrMessage = "owner" in input || "sender" in input;
      if (isCoinOrMessage) {
        if ("predicate" in input && input.predicate && input.predicate !== "0x") {
          return true;
        }
        if (!witnessCache.includes(input.witnessIndex)) {
          witnessCache.push(input.witnessIndex);
          return true;
        }
      }
      return false;
    });
    const vmInitializationCost = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
    const totalGas = chargeableInputs.reduce((total, input) => {
      if ("predicate" in input && input.predicate && input.predicate !== "0x") {
        return total.add(
          vmInitializationCost.add(resolveGasDependentCosts(arrayify(input.predicate).length, gasCosts.contractRoot)).add(bn(input.predicateGasUsed))
        );
      }
      return total.add(gasCosts.ecr1);
    }, bn(0));
    return totalGas;
  }
  function getMinGas(params) {
    const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
    const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
    const bytesGas = bn(txBytesSize).mul(gasPerByte);
    const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);
    const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
    return minGas;
  }
  function getMaxGas(params) {
    const {
      gasPerByte,
      witnessesLength,
      witnessLimit,
      minGas,
      gasLimit = bn(0),
      maxGasPerTx
    } = params;
    let remainingAllowedWitnessGas = bn(0);
    if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
      remainingAllowedWitnessGas = bn(witnessLimit).sub(witnessesLength).mul(gasPerByte);
    }
    const maxGas = remainingAllowedWitnessGas.add(minGas).add(gasLimit);
    return maxGas.gte(maxGasPerTx) ? maxGasPerTx : maxGas;
  }
  function calculateMetadataGasForTxCreate({
    gasCosts,
    stateRootSize,
    txBytesSize,
    contractBytesSize
  }) {
    const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);
    const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);
    const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
    const contractIdInputSize = bn(4 + 32 + 32 + 32);
    const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);
    const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
    return metadataGas.maxU64();
  }
  function calculateMetadataGasForTxScript({
    gasCosts,
    txBytesSize
  }) {
    return resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  }
  function calculateMetadataGasForTxBlob({
    gasCosts,
    txBytesSize,
    witnessBytesSize
  }) {
    const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
    const blobLen = resolveGasDependentCosts(witnessBytesSize, gasCosts.s256);
    return txId.add(blobLen);
  }
  function calculateMetadataGasForTxUpgrade({
    gasCosts,
    txBytesSize,
    consensusSize
  }) {
    const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
    if (consensusSize) {
      const consensusLen = resolveGasDependentCosts(consensusSize, gasCosts.s256);
      txId.add(consensusLen);
    }
    return txId;
  }
  function calculateMetadataGasForTxUpload({
    gasCosts,
    txBytesSize,
    subsectionSize,
    subsectionsSize
  }) {
    const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
    const subsectionLen = resolveGasDependentCosts(subsectionSize, gasCosts.s256);
    txId.add(subsectionLen);
    const subsectionsLen = resolveGasDependentCosts(subsectionsSize, gasCosts.stateRoot);
    txId.add(subsectionsLen);
    return txId;
  }
  function calculateMinGasForTxUpload({
    gasCosts,
    baseMinGas,
    subsectionSize
  }) {
    const additionalStoragePerByte = bn(gasCosts.newStoragePerByte).mul(subsectionSize);
    return bn(baseMinGas).add(additionalStoragePerByte);
  }
  var calculateGasFee = (params) => {
    const { gas, gasPrice, priceFactor, tip } = params;
    return gas.mul(gasPrice).div(priceFactor).add(bn(tip));
  };
  function normalize3(object2) {
    Object.keys(object2).forEach((key) => {
      switch (object2[key]?.constructor.name) {
        case "Uint8Array":
          object2[key] = hexlify(object2[key]);
          break;
        case "Array":
          object2[key] = normalize3(object2[key]);
          break;
        case "BN":
          object2[key] = object2[key].toHex();
          break;
        case "Address":
          object2[key] = object2[key].toB256();
          break;
        case "Object":
          object2[key] = normalize3(object2[key]);
          break;
        default:
          break;
      }
    });
    return object2;
  }
  function normalizeJSON(root) {
    return normalize3(clone_default(root));
  }
  var assemblePanicError = (statusReason, metadata) => {
    let errorMessage = `The transaction reverted with reason: "${statusReason}".`;
    if (PANIC_REASONS.includes(statusReason)) {
      errorMessage = `${errorMessage}

You can read more about this error at:

${PANIC_DOC_URL}#variant.${statusReason}`;
    }
    return new FuelError(ErrorCode.SCRIPT_REVERTED, errorMessage, {
      ...metadata,
      reason: statusReason
    });
  };
  var stringify = (obj) => JSON.stringify(obj, null, 2);
  var assembleRevertError = (receipts, logs, metadata) => {
    let errorMessage = "The transaction reverted with an unknown reason.";
    const revertReceipt = receipts.find(({ type: type3 }) => type3 === ReceiptType.Revert);
    let reason = "";
    if (revertReceipt) {
      const reasonHex = bn(revertReceipt.val).toHex();
      const lastLog = logs[logs.length - 1];
      const lastButOneLog = logs[logs.length - 2];
      switch (reasonHex) {
        case FAILED_REQUIRE_SIGNAL: {
          reason = "require";
          errorMessage = `The transaction reverted because a "require" statement has thrown ${logs.length ? stringify(lastLog) : "an error."}.`;
          break;
        }
        case FAILED_ASSERT_EQ_SIGNAL: {
          const sufix = logs.length >= 2 ? ` comparing ${stringify(lastLog)} and ${stringify(lastButOneLog)}.` : ".";
          reason = "assert_eq";
          errorMessage = `The transaction reverted because of an "assert_eq" statement${sufix}`;
          break;
        }
        case FAILED_ASSERT_NE_SIGNAL: {
          const sufix = logs.length >= 2 ? ` comparing ${stringify(lastButOneLog)} and ${stringify(lastLog)}.` : ".";
          reason = "assert_ne";
          errorMessage = `The transaction reverted because of an "assert_ne" statement${sufix}`;
          break;
        }
        case FAILED_ASSERT_SIGNAL:
          reason = "assert";
          errorMessage = `The transaction reverted because an "assert" statement failed to evaluate to true.`;
          break;
        case FAILED_TRANSFER_TO_ADDRESS_SIGNAL:
          reason = "MissingOutputChange";
          errorMessage = `The transaction reverted because it's missing an "OutputChange".`;
          break;
        default:
          throw new FuelError(
            ErrorCode.UNKNOWN,
            `The transaction reverted with an unknown reason: ${revertReceipt.val}`,
            {
              ...metadata,
              reason: "unknown"
            }
          );
      }
    }
    return new FuelError(ErrorCode.SCRIPT_REVERTED, errorMessage, {
      ...metadata,
      reason
    });
  };
  var extractTxError = (params) => {
    const { receipts, statusReason, logs } = params;
    const isPanic = receipts.some(({ type: type3 }) => type3 === ReceiptType.Panic);
    const isRevert = receipts.some(({ type: type3 }) => type3 === ReceiptType.Revert);
    const metadata = {
      logs,
      receipts,
      panic: isPanic,
      revert: isRevert,
      reason: ""
    };
    if (isPanic) {
      return assemblePanicError(statusReason, metadata);
    }
    return assembleRevertError(receipts, logs, metadata);
  };
  var NoWitnessAtIndexError = class extends Error {
    constructor(index) {
      super();
      this.index = index;
      this.message = `Witness at index "${index}" was not found`;
    }
    name = "NoWitnessAtIndexError";
  };
  var isRequestInputCoin = (input) => input.type === InputType.Coin;
  var isRequestInputMessage = (input) => input.type === InputType.Message;
  var isRequestInputMessageWithoutData = (input) => input.type === InputType.Message && bn(input.data).isZero();
  var isRequestInputCoinOrMessage = (input) => isRequestInputCoin(input) || isRequestInputMessage(input);
  var isRequestInputResource = (input) => isRequestInputCoin(input) || isRequestInputMessageWithoutData(input);
  var getRequestInputResourceOwner = (input) => isRequestInputCoin(input) ? input.owner : input.recipient;
  var isRequestInputResourceFromOwner = (input, owner) => getRequestInputResourceOwner(input) === owner.toB256();
  var getAssetAmountInRequestInputs = (inputs, assetId, baseAsset) => inputs.filter(isRequestInputResource).reduce((acc, input) => {
    if (isRequestInputCoin(input) && input.assetId === assetId) {
      return acc.add(input.amount);
    }
    if (isRequestInputMessage(input) && assetId === baseAsset) {
      return acc.add(input.amount);
    }
    return acc;
  }, bn(0));
  var cacheRequestInputsResourcesFromOwner = (inputs, owner) => inputs.reduce(
    (acc, input) => {
      if (isRequestInputCoin(input) && input.owner === owner.toB256()) {
        acc.utxos.push(input.id);
      } else if (isRequestInputMessage(input) && input.recipient === owner.toB256()) {
        acc.messages.push(input.nonce);
      }
      return acc;
    },
    {
      utxos: [],
      messages: []
    }
  );
  var getBurnableAssetCount = (baseAssetId, transactionRequest) => {
    const { inputs, outputs } = transactionRequest;
    const coinInputs = new Set(inputs.filter(isRequestInputCoin).map((input) => input.assetId));
    if (inputs.some((i) => isRequestInputMessage(i) && bn(i.amount).gt(0))) {
      coinInputs.add(baseAssetId);
    }
    const changeOutputs = new Set(
      outputs.filter((output2) => output2.type === OutputType.Change).map((output2) => output2.assetId)
    );
    const difference = new Set([...coinInputs].filter((x) => !changeOutputs.has(x)));
    return difference.size;
  };
  var validateTransactionForAssetBurn = (baseAssetId, transactionRequest, enableAssetBurn = false) => {
    if (enableAssetBurn === true) {
      return;
    }
    if (getBurnableAssetCount(baseAssetId, transactionRequest) <= 0) {
      return;
    }
    const message = [
      "Asset burn detected.",
      "Add the relevant change outputs to the transaction to avoid burning assets.",
      "Or enable asset burn, upon sending the transaction."
    ].join("\n");
    throw new FuelError(ErrorCode.ASSET_BURN_DETECTED, message);
  };
  var witnessify = (value) => {
    const data = arrayify(value);
    return {
      data: hexlify(data),
      dataLength: data.length
    };
  };
  var BaseTransactionRequest = class {
    /** Gas price for transaction */
    tip;
    /** Block until which tx cannot be included */
    maturity;
    /** The maximum fee payable by this transaction using BASE_ASSET. */
    maxFee;
    /** The maximum amount of witness data allowed for the transaction */
    witnessLimit;
    /** List of inputs */
    inputs = [];
    /** List of outputs */
    outputs = [];
    /** List of witnesses */
    witnesses = [];
    /**
     * Constructor for initializing a base transaction request.
     *
     * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
     */
    constructor({
      tip,
      maturity,
      maxFee,
      witnessLimit,
      inputs,
      outputs,
      witnesses
    } = {}) {
      this.tip = tip ? bn(tip) : void 0;
      this.maturity = maturity && maturity > 0 ? maturity : void 0;
      this.witnessLimit = isDefined(witnessLimit) ? bn(witnessLimit) : void 0;
      this.maxFee = bn(maxFee);
      this.inputs = inputs ?? [];
      this.outputs = outputs ?? [];
      this.witnesses = witnesses ?? [];
    }
    static getPolicyMeta(req2) {
      let policyTypes = 0;
      const policies = [];
      const { tip, witnessLimit, maturity } = req2;
      if (bn(tip).gt(0)) {
        policyTypes += PolicyType.Tip;
        policies.push({ data: bn(tip), type: PolicyType.Tip });
      }
      if (isDefined(witnessLimit) && bn(witnessLimit).gte(0)) {
        policyTypes += PolicyType.WitnessLimit;
        policies.push({ data: bn(witnessLimit), type: PolicyType.WitnessLimit });
      }
      if (maturity && maturity > 0) {
        policyTypes += PolicyType.Maturity;
        policies.push({ data: maturity, type: PolicyType.Maturity });
      }
      policyTypes += PolicyType.MaxFee;
      policies.push({ data: req2.maxFee, type: PolicyType.MaxFee });
      return {
        policyTypes,
        policies
      };
    }
    /**
     * Method to obtain the base transaction details.
     *
     * @returns The base transaction details.
     */
    getBaseTransaction() {
      const inputs = this.inputs?.map(inputify) ?? [];
      const outputs = this.outputs?.map(outputify) ?? [];
      const witnesses = this.witnesses?.map(witnessify) ?? [];
      const { policyTypes, policies } = BaseTransactionRequest.getPolicyMeta(this);
      return {
        policyTypes,
        inputs,
        outputs,
        policies,
        witnesses,
        inputsCount: inputs.length,
        outputsCount: outputs.length,
        witnessesCount: witnesses.length
      };
    }
    /**
     * Converts the transaction request to a byte array.
     *
     * @returns The transaction bytes.
     */
    toTransactionBytes() {
      return new TransactionCoder().encode(this.toTransaction());
    }
    /**
     * @hidden
     *
     * Pushes an input to the list without any side effects and returns the index
     */
    pushInput(input) {
      this.inputs.push(input);
      return this.inputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes an output to the list without any side effects and returns the index
     */
    pushOutput(output2) {
      this.outputs.push(output2);
      return this.outputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes a witness to the list and returns the index
     *
     * @param signature - The signature to add to the witness.
     * @returns The index of the created witness.
     */
    addWitness(signature) {
      this.witnesses.push(signature);
      return this.witnesses.length - 1;
    }
    /**
     * @hidden
     *
     * Creates an empty witness without any side effects and returns the index
     *
     * @returns The index of the created witness.
     */
    addEmptyWitness() {
      this.addWitness(concat([ZeroBytes32, ZeroBytes32]));
      return this.witnesses.length - 1;
    }
    /**
     * Updates the witness for a given owner and signature.
     *
     * @param address - The address to get the coin input witness index for.
     * @param signature - The signature to update the witness with.
     */
    updateWitnessByOwner(address, signature) {
      const ownerAddress = Address.fromAddressOrString(address);
      const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
      if (typeof witnessIndex === "number") {
        this.updateWitness(witnessIndex, signature);
      }
    }
    /**
     * Updates an existing witness without any side effects.
     *
     * @param index - The index of the witness to update.
     * @param witness - The new witness.
     * @throws If the witness does not exist.
     */
    updateWitness(index, witness) {
      if (!this.witnesses[index]) {
        throw new NoWitnessAtIndexError(index);
      }
      this.witnesses[index] = witness;
    }
    /**
     * Helper function to add an external signature to the transaction.
     *
     * @param account - The account/s to sign to the transaction.
     * @returns The transaction with the signature witness added.
     */
    async addAccountWitnesses(account) {
      const accounts = Array.isArray(account) ? account : [account];
      await Promise.all(
        accounts.map(async (acc) => {
          this.addWitness(await acc.signTransaction(this));
        })
      );
      return this;
    }
    /**
     * Gets the coin inputs for a transaction.
     *
     * @returns The coin inputs.
     */
    getCoinInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Coin
      );
    }
    /**
     * Gets the coin outputs for a transaction.
     *
     * @returns The coin outputs.
     */
    getCoinOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.Coin
      );
    }
    /**
     * Gets the change outputs for a transaction.
     *
     * @returns The change outputs.
     */
    getChangeOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.Change
      );
    }
    /**
     * @hidden
     *
     * Returns the witnessIndex of the found CoinInput.
     */
    getCoinInputWitnessIndexByOwner(owner) {
      const ownerAddress = addressify(owner);
      const found = this.inputs.find((input) => {
        switch (input.type) {
          case InputType.Coin:
            return hexlify(input.owner) === ownerAddress.toB256();
          case InputType.Message:
            return hexlify(input.recipient) === ownerAddress.toB256();
          default:
            return false;
        }
      });
      return found?.witnessIndex;
    }
    /**
     * Adds a single coin input to the transaction and a change output for the related
     * assetId, if one it was not added yet.
     *
     * @param coin - Coin resource.
     */
    addCoinInput(coin) {
      const { assetId, owner, amount, id, predicate, predicateData } = coin;
      let witnessIndex;
      if (coin.predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.addEmptyWitness();
        }
      }
      const input = {
        id,
        type: InputType.Coin,
        owner: owner.toB256(),
        amount,
        assetId,
        txPointer: "0x00000000000000000000000000000000",
        witnessIndex,
        predicate,
        predicateData
      };
      this.pushInput(input);
      this.addChangeOutput(owner, assetId);
    }
    /**
     * Adds a single message input to the transaction and a change output for the
     * asset against the message
     *
     * @param message - Message resource.
     */
    addMessageInput(message) {
      const { recipient, sender, amount, predicate, nonce, predicateData } = message;
      let witnessIndex;
      if (message.predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.addEmptyWitness();
        }
      }
      const input = {
        nonce,
        type: InputType.Message,
        sender: sender.toB256(),
        recipient: recipient.toB256(),
        data: isMessageCoin(message) ? "0x" : message.data,
        amount,
        witnessIndex,
        predicate,
        predicateData
      };
      this.pushInput(input);
      if (isMessageCoin(message)) {
        this.addChangeOutput(recipient, message.assetId);
      }
    }
    /**
     * Adds a single resource to the transaction by adding a coin/message input and a
     * change output for the related assetId, if one it was not added yet.
     *
     * @param resource - The resource to add.
     * @returns This transaction.
     */
    addResource(resource) {
      if (isCoin(resource)) {
        this.addCoinInput(resource);
      } else {
        this.addMessageInput(resource);
      }
      return this;
    }
    /**
     * Adds multiple resources to the transaction by adding coin/message inputs and change
     * outputs from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addResources(resources) {
      resources.forEach((resource) => this.addResource(resource));
      return this;
    }
    /**
     * Adds a coin output to the transaction.
     *
     * @param to - Address of the owner.
     * @param amount - Amount of coin.
     * @param assetId - Asset ID of coin.
     */
    addCoinOutput(to, amount, assetId) {
      this.pushOutput({
        type: OutputType.Coin,
        to: addressify(to).toB256(),
        amount,
        assetId
      });
      return this;
    }
    /**
     * Adds multiple coin outputs to the transaction.
     *
     * @param to - Address of the destination.
     * @param quantities - Quantities of coins.
     */
    addCoinOutputs(to, quantities) {
      quantities.map(coinQuantityfy).forEach((quantity) => {
        this.pushOutput({
          type: OutputType.Coin,
          to: addressify(to).toB256(),
          amount: quantity.amount,
          assetId: quantity.assetId
        });
      });
      return this;
    }
    /**
     * Adds a change output to the transaction.
     *
     * @param to - Address of the owner.
     * @param assetId - Asset ID of coin.
     */
    addChangeOutput(to, assetId) {
      const changeOutput = this.getChangeOutputs().find(
        (output2) => hexlify(output2.assetId) === assetId
      );
      if (!changeOutput) {
        this.pushOutput({
          type: OutputType.Change,
          to: addressify(to).toB256(),
          assetId
        });
      }
    }
    /**
     * @hidden
     */
    byteSize() {
      return this.toTransactionBytes().length;
    }
    /**
     * @hidden
     */
    metadataGas(_gasCosts) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Not implemented");
    }
    /**
     * @hidden
     */
    calculateMinGas(chainInfo) {
      const { consensusParameters } = chainInfo;
      const {
        gasCosts,
        feeParameters: { gasPerByte }
      } = consensusParameters;
      return getMinGas({
        gasPerByte,
        gasCosts,
        inputs: this.inputs,
        txBytesSize: this.byteSize(),
        metadataGas: this.metadataGas(gasCosts)
      });
    }
    calculateMaxGas(chainInfo, minGas) {
      const { consensusParameters } = chainInfo;
      const {
        feeParameters: { gasPerByte },
        txParameters: { maxGasPerTx }
      } = consensusParameters;
      const witnessesLength = this.toTransaction().witnesses.reduce(
        (acc, wit) => acc + wit.dataLength,
        0
      );
      return getMaxGas({
        gasPerByte,
        minGas,
        witnessesLength,
        witnessLimit: this.witnessLimit,
        maxGasPerTx
      });
    }
    /**
     * Funds the transaction with fake UTXOs for each assetId and amount in the
     * quantities array.
     *
     * @param quantities - CoinQuantity Array.
     * @param baseAssetId - The base asset to fund the transaction.
     * @deprecated - This method is deprecated and will be removed in future versions.
     * Please use `Account.generateFakeResources` along with `this.addResources` instead.
     */
    fundWithFakeUtxos(quantities, baseAssetId, resourcesOwner) {
      const findAssetInput = (assetId) => this.inputs.find((input) => {
        if ("assetId" in input) {
          return input.assetId === assetId;
        }
        return false;
      });
      const updateAssetInput = (assetId, quantity) => {
        const assetInput = findAssetInput(assetId);
        let usedQuantity = quantity;
        if (assetId === baseAssetId) {
          usedQuantity = bn("1000000000000000000");
        }
        if (assetInput && "assetId" in assetInput) {
          assetInput.id = hexlify(randomBytes22(UTXO_ID_LEN));
          assetInput.amount = usedQuantity;
        } else {
          this.addResources([
            {
              id: hexlify(randomBytes22(UTXO_ID_LEN)),
              amount: usedQuantity,
              assetId,
              owner: resourcesOwner || Address.fromRandom(),
              blockCreated: bn(1),
              txCreatedIdx: bn(1)
            }
          ]);
        }
      };
      updateAssetInput(baseAssetId, bn(1e11));
      quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
      return this;
    }
    /**
     * Retrieves an array of CoinQuantity for each coin output present in the transaction.
     * a transaction.
     *
     * @returns  CoinQuantity array.
     */
    getCoinOutputsQuantities() {
      const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
        amount: bn(amount),
        assetId: assetId.toString()
      }));
      return coinsQuantities;
    }
    /**
     * Return the minimum amount in native coins required to create
     * a transaction.
     *
     * @returns The transaction as a JSON object.
     */
    toJSON() {
      return normalizeJSON(this);
    }
    removeWitness(index) {
      this.witnesses.splice(index, 1);
      this.adjustWitnessIndexes(index);
    }
    adjustWitnessIndexes(removedIndex) {
      this.inputs.filter(isRequestInputResource).forEach((input) => {
        if (input.witnessIndex > removedIndex) {
          input.witnessIndex -= 1;
        }
      });
    }
    updatePredicateGasUsed(inputs) {
      const inputsToExtractGasUsed = inputs.filter(isRequestInputCoinOrMessage);
      this.inputs.filter(isRequestInputResource).forEach((i) => {
        const owner = getRequestInputResourceOwner(i);
        const correspondingInput = inputsToExtractGasUsed.find(
          (x) => isRequestInputResourceFromOwner(x, Address.fromString(String(owner)))
        );
        if (correspondingInput && "predicateGasUsed" in correspondingInput && bn(correspondingInput.predicateGasUsed).gt(0)) {
          i.predicateGasUsed = correspondingInput.predicateGasUsed;
        }
      });
    }
    byteLength() {
      return this.toTransactionBytes().byteLength;
    }
  };
  function hashTransaction(transactionRequest, chainId) {
    const transaction = transactionRequest.toTransaction();
    if (transaction.type === TransactionType.Script) {
      transaction.receiptsRoot = ZeroBytes32;
    }
    transaction.inputs = transaction.inputs.map((input) => {
      const inputClone = clone_default(input);
      switch (inputClone.type) {
        case InputType.Coin: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Message: {
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Contract: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.txID = ZeroBytes32;
          inputClone.outputIndex = 0;
          inputClone.balanceRoot = ZeroBytes32;
          inputClone.stateRoot = ZeroBytes32;
          return inputClone;
        }
        default:
          return inputClone;
      }
    });
    transaction.outputs = transaction.outputs.map((output2) => {
      const outputClone = clone_default(output2);
      switch (outputClone.type) {
        case OutputType.Contract: {
          outputClone.balanceRoot = ZeroBytes32;
          outputClone.stateRoot = ZeroBytes32;
          return outputClone;
        }
        case OutputType.Change: {
          outputClone.amount = bn(0);
          return outputClone;
        }
        case OutputType.Variable: {
          outputClone.to = ZeroBytes32;
          outputClone.amount = bn(0);
          outputClone.assetId = ZeroBytes32;
          return outputClone;
        }
        default:
          return outputClone;
      }
    });
    transaction.witnessesCount = 0;
    transaction.witnesses = [];
    const chainIdBytes = uint64ToBytesBE(chainId);
    const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);
    return sha2562(concatenatedData);
  }
  var BlobTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      return new this(clone_default(obj));
    }
    /** Type of the transaction */
    type = TransactionType.Blob;
    /** Blob ID */
    blobId;
    /** Witness index of the bytecode to create */
    witnessIndex;
    /**
     * Creates an instance `BlobTransactionRequest`.
     *
     * @param blobTransactionRequestLike - The initial values for the instance
     */
    constructor({ witnessIndex, blobId, ...rest }) {
      super(rest);
      this.blobId = blobId;
      this.witnessIndex = witnessIndex ?? 0;
    }
    /**
     * Converts the transaction request to a `TransactionBlob`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const { witnessIndex, blobId } = this;
      return {
        type: TransactionType.Blob,
        ...baseTransaction,
        blobId,
        witnessIndex
      };
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction(this, chainId);
    }
    /**
     * Calculates the metadata gas cost for a blob transaction.
     *
     * @param gasCosts - gas costs passed from the chain.
     * @returns metadata gas cost for the blob transaction.
     */
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxBlob({
        gasCosts,
        txBytesSize: this.byteSize(),
        witnessBytesSize: this.witnesses[this.witnessIndex].length
      });
    }
  };
  var getStorageValue = (value) => {
    const v = new Uint8Array(32);
    v.set(arrayify(value));
    return v;
  };
  var storageSlotify = (storageSlot) => {
    let key;
    let value;
    if (Array.isArray(storageSlot)) {
      key = storageSlot[0];
      value = storageSlot[1];
    } else {
      key = storageSlot.key;
      value = storageSlot.value;
    }
    return {
      key: hexlify(key),
      value: hexlify(getStorageValue(value))
    };
  };
  var CreateTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      return new this(clone_default(obj));
    }
    /** Type of the transaction */
    type = TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex;
    /** Salt */
    salt;
    /** List of storage slots to initialize */
    storageSlots;
    /**
     * Creates an instance `CreateTransactionRequest`.
     *
     * @param createTransactionRequestLike - The initial values for the instance
     */
    constructor({ bytecodeWitnessIndex, salt, storageSlots: storageSlots2, ...rest }) {
      super(rest);
      this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
      this.salt = hexlify(salt ?? ZeroBytes32);
      this.storageSlots = [...storageSlots2 ?? []];
    }
    /**
     * Converts the transaction request to a `TransactionCreate`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
      const storageSlots2 = this.storageSlots?.map(storageSlotify) ?? [];
      return {
        type: TransactionType.Create,
        ...baseTransaction,
        bytecodeWitnessIndex,
        storageSlotsCount: bn(storageSlots2.length),
        salt: this.salt ? hexlify(this.salt) : ZeroBytes32,
        storageSlots: storageSlots2
      };
    }
    /**
     * Get contract created outputs for the transaction.
     *
     * @returns An array of contract created transaction request outputs.
     */
    getContractCreatedOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.ContractCreated
      );
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction(this, chainId);
    }
    /**
     * Adds a contract created output to the transaction request.
     *
     * @param contractId - The contract ID.
     * @param stateRoot - The state root.
     */
    addContractCreatedOutput(contractId, stateRoot) {
      this.pushOutput({
        type: OutputType.ContractCreated,
        contractId,
        stateRoot
      });
    }
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxCreate({
        contractBytesSize: bn(arrayify(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
        gasCosts,
        stateRootSize: this.storageSlots.length,
        txBytesSize: this.byteSize()
      });
    }
  };
  var returnZeroScript = {
    /*
        Opcode::RET(REG_ZERO)
        Opcode::NOOP
      */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: arrayify("0x24000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var withdrawScript = {
    /*
            The following code loads some basic values into registers and calls SMO to create an output message
            5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
            5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
            4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
            24000000	- RET                [return 0]
            00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
            00000000 00000000 [amount value]
        */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: arrayify("0x5040C0105D44C0064C40001124000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var ScriptTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      return new this(clone_default(obj));
    }
    /** Type of the transaction */
    type = TransactionType.Script;
    /** Gas limit for transaction */
    gasLimit;
    /** Script to execute */
    script;
    /** Script input data (parameters) */
    scriptData;
    abis;
    /**
     * Constructor for `ScriptTransactionRequest`.
     *
     * @param scriptTransactionRequestLike - The initial values for the instance.
     */
    constructor({ script, scriptData, gasLimit, ...rest } = {}) {
      super(rest);
      this.gasLimit = bn(gasLimit);
      this.script = arrayify(script ?? returnZeroScript.bytes);
      this.scriptData = arrayify(scriptData ?? returnZeroScript.encodeScriptData());
      this.abis = rest.abis;
    }
    /**
     * Helper function to estimate and fund the transaction request with a specified account.
     *
     * @param account - The account to fund the transaction.
     * @param params - The parameters for the transaction cost.
     * @returns The current instance of the `ScriptTransactionRequest` funded.
     */
    async estimateAndFund(account, { signatureCallback, quantities = [] } = {}) {
      const txCost = await account.getTransactionCost(this, { signatureCallback, quantities });
      this.maxFee = txCost.maxFee;
      this.gasLimit = txCost.gasUsed;
      await account.fund(this, txCost);
      return this;
    }
    /**
     * Converts the transaction request to a `TransactionScript`.
     *
     * @returns The transaction script object.
     */
    toTransaction() {
      const script = arrayify(this.script ?? "0x");
      const scriptData = arrayify(this.scriptData ?? "0x");
      return {
        type: TransactionType.Script,
        scriptGasLimit: this.gasLimit,
        ...super.getBaseTransaction(),
        scriptLength: bn(script.length),
        scriptDataLength: bn(scriptData.length),
        receiptsRoot: ZeroBytes32,
        script: hexlify(script),
        scriptData: hexlify(scriptData)
      };
    }
    /**
     * Get contract inputs for the transaction.
     *
     * @returns An array of contract transaction request inputs.
     */
    getContractInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Contract
      );
    }
    /**
     * Get contract outputs for the transaction.
     *
     * @returns An array of contract transaction request outputs.
     */
    getContractOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.Contract
      );
    }
    /**
     * Get variable outputs for the transaction.
     *
     * @returns An array of variable transaction request outputs.
     */
    getVariableOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.Variable
      );
    }
    /**
     * Set the script and its data.
     *
     * @param script - The abstract script request.
     * @param data - The script data.
     */
    setScript(script, data) {
      this.scriptData = script.encodeScriptData(data);
      this.script = script.bytes;
    }
    /**
     * Adds variable outputs to the transaction request.
     *
     * @param numberOfVariables - The number of variables to add.
     * @returns The new length of the outputs array.
     */
    addVariableOutputs(numberOfVariables = 1) {
      let outputsNumber = numberOfVariables;
      while (outputsNumber) {
        this.pushOutput({
          type: OutputType.Variable
        });
        outputsNumber -= 1;
      }
      return this.outputs.length - 1;
    }
    /**
     * Calculates the maximum gas for the transaction.
     *
     * @param chainInfo - The chain information.
     * @param minGas - The minimum gas.
     * @returns the maximum gas.
     */
    calculateMaxGas(chainInfo, minGas) {
      const { consensusParameters } = chainInfo;
      const {
        feeParameters: { gasPerByte },
        txParameters: { maxGasPerTx }
      } = consensusParameters;
      const witnessesLength = this.toTransaction().witnesses.reduce(
        (acc, wit) => acc + wit.dataLength,
        0
      );
      return getMaxGas({
        gasPerByte,
        minGas,
        witnessesLength,
        witnessLimit: this.witnessLimit,
        gasLimit: this.gasLimit,
        maxGasPerTx
      });
    }
    /**
     * Adds a contract input and output to the transaction request.
     *
     * @param contract - The contract ID.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    addContractInputAndOutput(contract) {
      const contractAddress = addressify(contract);
      if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
        return this;
      }
      const inputIndex = super.pushInput({
        type: InputType.Contract,
        contractId: contractAddress.toB256(),
        txPointer: "0x00000000000000000000000000000000"
      });
      this.pushOutput({
        type: OutputType.Contract,
        inputIndex
      });
      return this;
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction(this, chainId);
    }
    /**
     * Sets the data for the transaction request.
     *
     * @param abi - Script JSON ABI.
     * @param args - The input arguments.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    setData(abi2, args) {
      const abiInterface = new Interface(abi2);
      this.scriptData = abiInterface.functions.main.encodeArguments(args);
      return this;
    }
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxScript({
        gasCosts,
        txBytesSize: this.byteSize()
      });
    }
  };
  var UpgradeTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      if (obj instanceof UpgradeTransactionRequest) {
        return obj;
      }
      return new this(clone_default(obj));
    }
    /** The type of transaction */
    type = TransactionType.Upgrade;
    /** The upgrade purpose */
    upgradePurpose;
    /** Witness index of consensus */
    bytecodeWitnessIndex;
    /**
     * Creates an instance `UpgradeTransactionRequest`.
     *
     * @param upgradeTransactionRequestLike - The initial values for the instance
     */
    constructor({
      upgradePurpose,
      bytecodeWitnessIndex,
      ...rest
    } = {}) {
      super(rest);
      this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
      this.upgradePurpose = upgradePurpose ?? {
        type: UpgradePurposeTypeEnum.ConsensusParameters,
        checksum: "0x"
      };
    }
    /**
     * Adds a consensus parameters upgrade purpose.
     *
     * @param consensus - The consensus bytecode.
     *
     * @returns - The current instance of `UpgradeTransactionRequest`.
     */
    addConsensusParametersUpgradePurpose(consensus) {
      this.bytecodeWitnessIndex = this.addWitness(consensus);
      this.upgradePurpose = {
        type: UpgradePurposeTypeEnum.ConsensusParameters,
        checksum: hash2(consensus)
      };
      return this;
    }
    /**
     * Adds a state transition upgrade purpose.
     *
     * @param bytecodeRoot - The Merkle root of the state transition.
     *
     * @returns - The current instance of `UpgradeTransactionRequest`.
     */
    addStateTransitionUpgradePurpose(bytecodeRoot) {
      this.upgradePurpose = {
        type: UpgradePurposeTypeEnum.StateTransition,
        data: hexlify(bytecodeRoot)
      };
      return this;
    }
    /**
     * Adds an upgrade purpose.
     *
     * @param type - The upgrade purpose type.
     * @param data - The bytecode or merkle root of upgrade purpose
     *
     * @returns - The current instance of `UpgradeTransactionRequest`.
     */
    addUpgradePurpose(type3, data) {
      if (type3 === UpgradePurposeTypeEnum.ConsensusParameters) {
        this.addConsensusParametersUpgradePurpose(data);
      }
      if (type3 === UpgradePurposeTypeEnum.StateTransition) {
        this.addStateTransitionUpgradePurpose(data);
      }
      return this;
    }
    /**
     * Converts the transaction request to a `TransactionUpgrade`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      let upgradePurpose;
      if (this.upgradePurpose.type === UpgradePurposeTypeEnum.ConsensusParameters) {
        upgradePurpose = {
          type: UpgradePurposeTypeEnum.ConsensusParameters,
          data: {
            witnessIndex: this.bytecodeWitnessIndex,
            checksum: this.upgradePurpose.checksum
          }
        };
      } else if (this.upgradePurpose.type === UpgradePurposeTypeEnum.StateTransition) {
        upgradePurpose = {
          type: UpgradePurposeTypeEnum.StateTransition,
          data: {
            bytecodeRoot: hexlify(this.upgradePurpose.data)
          }
        };
      } else {
        throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
      }
      return {
        type: TransactionType.Upgrade,
        ...super.getBaseTransaction(),
        upgradePurpose
      };
    }
    /**
     * Gets the Transaction ID by hashing the transaction
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction(this, chainId);
    }
    /**
     * Calculates the metadata gas cost for an upgrade transaction.
     *
     * @param gasCosts - gas costs passed from the chain.
     *
     * @returns metadata gas cost for the upgrade transaction.
     */
    metadataGas(gasCosts) {
      const txBytesSize = this.byteSize();
      if (this.upgradePurpose.type === UpgradePurposeTypeEnum.ConsensusParameters) {
        const witnessIndex = this.bytecodeWitnessIndex;
        const consensusSize = this.witnesses[witnessIndex].length;
        return calculateMetadataGasForTxUpgrade({
          gasCosts,
          txBytesSize,
          consensusSize
        });
      }
      if (this.upgradePurpose.type === UpgradePurposeTypeEnum.StateTransition) {
        return calculateMetadataGasForTxUpgrade({
          gasCosts,
          txBytesSize
        });
      }
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
    }
  };
  var UploadTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      if (obj instanceof UploadTransactionRequest) {
        return obj;
      }
      return new this(clone_default(obj));
    }
    /** Type of the transaction */
    type = TransactionType.Upload;
    /** The witness index of the subsection of the bytecode. */
    witnessIndex;
    /** The subsection data. */
    subsection;
    /**
     * Creates an instance `UploadTransactionRequest`.
     *
     * @param uploadTransactionRequestLike - The initial values for the instance
     */
    constructor({ witnessIndex, subsection, ...rest } = {}) {
      super(rest);
      this.witnessIndex = witnessIndex ?? 0;
      this.subsection = subsection ?? {
        proofSet: [],
        root: ZeroBytes32,
        subsectionIndex: 0,
        subsectionsNumber: 0
      };
    }
    /**
     * Adds the subsection.
     *
     * @param subsection - The subsection data.
     */
    addSubsection(subsection) {
      const { subsection: subsectionBytecode, ...rest } = subsection;
      this.subsection = rest;
      this.witnessIndex = this.addWitness(subsectionBytecode);
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction(this, chainId);
    }
    /**
     * Converts the transaction request to a `TransactionUpload`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const { subsectionIndex, subsectionsNumber, root, proofSet } = this.subsection;
      return {
        type: TransactionType.Upload,
        ...baseTransaction,
        subsectionIndex,
        subsectionsNumber,
        root: hexlify(root),
        proofSet: proofSet.map(hexlify),
        witnessIndex: this.witnessIndex,
        proofSetCount: proofSet.length
      };
    }
    /**
     * Calculates the metadata gas cost for an upload transaction.
     *
     * @param gasCosts - gas costs passed from the chain.
     *
     * @returns metadata gas cost for the upload transaction.
     */
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxUpload({
        gasCosts,
        txBytesSize: this.byteSize(),
        subsectionSize: arrayify(this.witnesses[this.witnessIndex]).length,
        subsectionsSize: this.subsection.subsectionsNumber
      });
    }
    /**
     * Calculates the minimum gas for an upload transaction.
     *
     * @param chainInfo - The chain information.
     *
     * @returns the minimum gas for the upload transaction
     */
    calculateMinGas(chainInfo) {
      const minGas = super.calculateMinGas(chainInfo);
      const { gasCosts } = chainInfo.consensusParameters;
      const bytecode2 = this.witnesses[this.witnessIndex] ?? ZeroBytes32;
      return calculateMinGasForTxUpload({
        gasCosts,
        baseMinGas: minGas.toNumber(),
        subsectionSize: arrayify(bytecode2).length
      });
    }
  };
  var transactionRequestify = (obj) => {
    if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest || obj instanceof BlobTransactionRequest || obj instanceof UpgradeTransactionRequest || obj instanceof UploadTransactionRequest) {
      return obj;
    }
    const { type: type3 } = obj;
    switch (obj.type) {
      case TransactionType.Script: {
        return ScriptTransactionRequest.from(obj);
      }
      case TransactionType.Create: {
        return CreateTransactionRequest.from(obj);
      }
      case TransactionType.Blob: {
        return BlobTransactionRequest.from(obj);
      }
      case TransactionType.Upgrade: {
        return UpgradeTransactionRequest.from(obj);
      }
      case TransactionType.Upload: {
        return UploadTransactionRequest.from(obj);
      }
      default: {
        throw new FuelError(
          ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${type3}.`
        );
      }
    }
  };
  var isTransactionTypeScript = (request) => request.type === TransactionType.Script;
  var isTransactionTypeCreate = (request) => request.type === TransactionType.Create;
  var calculateTXFeeForSummary = (params) => {
    const {
      gasPrice,
      rawPayload,
      tip,
      consensusParameters: { gasCosts, feeParams, maxGasPerTx }
    } = params;
    const gasPerByte = bn(feeParams.gasPerByte);
    const gasPriceFactor = bn(feeParams.gasPriceFactor);
    const transactionBytes = arrayify(rawPayload);
    const [transaction] = new TransactionCoder().decode(transactionBytes, 0);
    const { type: type3, witnesses, inputs, policies } = transaction;
    let metadataGas = bn(0);
    let gasLimit = bn(0);
    if (type3 !== TransactionType.Create && type3 !== TransactionType.Script) {
      return bn(0);
    }
    if (type3 === TransactionType.Create) {
      const { bytecodeWitnessIndex, storageSlots: storageSlots2 } = transaction;
      const contractBytesSize = bn(arrayify(witnesses[bytecodeWitnessIndex].data).length);
      metadataGas = calculateMetadataGasForTxCreate({
        contractBytesSize,
        gasCosts,
        stateRootSize: storageSlots2.length || 0,
        txBytesSize: transactionBytes.length
      });
    } else {
      const { scriptGasLimit } = transaction;
      if (scriptGasLimit) {
        gasLimit = scriptGasLimit;
      }
      metadataGas = calculateMetadataGasForTxScript({
        gasCosts,
        txBytesSize: transactionBytes.length
      });
    }
    const minGas = getMinGas({
      gasCosts,
      gasPerByte: bn(gasPerByte),
      inputs,
      metadataGas,
      txBytesSize: transactionBytes.length
    });
    const witnessLimit = policies.find((policy) => policy.type === PolicyType.WitnessLimit)?.data;
    const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
    const maxGas = getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      gasLimit,
      witnessLimit,
      maxGasPerTx
    });
    const maxFee = calculateGasFee({
      gasPrice,
      gas: maxGas,
      priceFactor: gasPriceFactor,
      tip
    });
    return maxFee;
  };
  var getFunctionCall = ({ abi: abi2, receipt }) => {
    const abiInterface = new Interface(abi2);
    const callFunctionSelector = receipt.param1.toHex(8);
    const functionFragment = abiInterface.getFunction(callFunctionSelector);
    const inputs = functionFragment.jsonFn.inputs;
    const encodedArgs = receipt.param2.toHex();
    let argumentsProvided;
    const data = functionFragment.decodeArguments(encodedArgs);
    if (data) {
      argumentsProvided = inputs.reduce((prev, input, index) => {
        const value = data[index];
        const name = input.name;
        if (name) {
          return {
            ...prev,
            // reparse to remove bn
            [name]: JSON.parse(JSON.stringify(value))
          };
        }
        return prev;
      }, {});
    }
    const call2 = {
      functionSignature: functionFragment.signature,
      functionName: functionFragment.name,
      argumentsProvided,
      ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
    };
    return call2;
  };
  function getInputsByTypes(inputs, types2) {
    return inputs.filter((i) => types2.includes(i.type));
  }
  function getInputsByType(inputs, type3) {
    return inputs.filter((i) => i.type === type3);
  }
  function getInputsCoin(inputs) {
    return getInputsByType(inputs, InputType.Coin);
  }
  function getInputsMessage(inputs) {
    return getInputsByType(inputs, InputType.Message);
  }
  function getInputsCoinAndMessage(inputs) {
    return getInputsByTypes(inputs, [InputType.Coin, InputType.Message]);
  }
  function isInputCoin(input) {
    return input.type === InputType.Coin;
  }
  function getInputsContract(inputs) {
    return getInputsByType(inputs, InputType.Contract);
  }
  function findCoinInput(inputs, assetId) {
    const coinInputs = getInputsCoin(inputs);
    return coinInputs.find((i) => i.assetId === assetId);
  }
  function aggregateInputsAmountsByAssetAndOwner(inputs, baseAssetId) {
    const aggregated = /* @__PURE__ */ new Map();
    getInputsCoinAndMessage(inputs).forEach((input) => {
      const assetId = isInputCoin(input) ? input.assetId : baseAssetId;
      const owner = isInputCoin(input) ? input.owner : input.recipient;
      let ownersMap = aggregated.get(assetId);
      if (!ownersMap) {
        ownersMap = /* @__PURE__ */ new Map();
        aggregated.set(assetId, ownersMap);
      }
      let ownerBalance = ownersMap.get(owner);
      if (!ownerBalance) {
        ownerBalance = new BN(0);
        ownersMap.set(owner, ownerBalance);
      }
      ownersMap.set(owner, ownerBalance.add(input.amount));
    });
    return aggregated;
  }
  function findMessageInput(inputs) {
    return getInputsMessage(inputs)?.[0];
  }
  function getInputFromAssetId(inputs, assetId, isBaseAsset = false) {
    const coinInput = findCoinInput(inputs, assetId);
    if (coinInput) {
      return coinInput;
    }
    if (isBaseAsset) {
      return findMessageInput(inputs);
    }
    return void 0;
  }
  function getInputContractFromIndex(inputs, inputIndex) {
    if (inputIndex == null) {
      return void 0;
    }
    const contractInput = inputs?.[inputIndex];
    if (!contractInput) {
      return void 0;
    }
    if (contractInput.type !== InputType.Contract) {
      throw new FuelError(
        ErrorCode.INVALID_TRANSACTION_INPUT,
        `Contract input should be of type 'contract'.`
      );
    }
    return contractInput;
  }
  function getInputAccountAddress(input) {
    if (input.type === InputType.Coin) {
      return input.owner.toString();
    }
    if (input.type === InputType.Message) {
      return input.recipient.toString();
    }
    return "";
  }
  function getOutputsByType(outputs, type3) {
    return outputs.filter((o) => o.type === type3);
  }
  function getOutputsContractCreated(outputs) {
    return getOutputsByType(outputs, OutputType.ContractCreated);
  }
  function getOutputsCoin(outputs) {
    return getOutputsByType(outputs, OutputType.Coin);
  }
  function getOutputsChange(outputs) {
    return getOutputsByType(outputs, OutputType.Change);
  }
  function getOutputsContract(outputs) {
    return getOutputsByType(outputs, OutputType.Contract);
  }
  var TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
    TransactionStatus2["submitted"] = "submitted";
    TransactionStatus2["success"] = "success";
    TransactionStatus2["squeezedout"] = "squeezedout";
    TransactionStatus2["failure"] = "failure";
    return TransactionStatus2;
  })(TransactionStatus || {});
  function getReceiptsByType(receipts, type3) {
    return (receipts ?? []).filter((r) => r.type === type3);
  }
  function getTransactionTypeName(transactionType) {
    switch (transactionType) {
      case TransactionType.Mint:
        return "Mint";
      case TransactionType.Create:
        return "Create";
      case TransactionType.Script:
        return "Script";
      case TransactionType.Blob:
        return "Blob";
      case TransactionType.Upgrade:
        return "Upgrade";
      case TransactionType.Upload:
        return "Upload";
      default:
        throw new FuelError(
          ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${transactionType}.`
        );
    }
  }
  function isType(transactionType, type3) {
    const txType = getTransactionTypeName(transactionType);
    return txType === type3;
  }
  function isTypeMint(transactionType) {
    return isType(
      transactionType,
      "Mint"
      /* Mint */
    );
  }
  function isTypeCreate(transactionType) {
    return isType(
      transactionType,
      "Create"
      /* Create */
    );
  }
  function isTypeScript(transactionType) {
    return isType(
      transactionType,
      "Script"
      /* Script */
    );
  }
  function isTypeUpgrade(transactionType) {
    return isType(
      transactionType,
      "Upgrade"
      /* Upgrade */
    );
  }
  function isTypeUpload(transactionType) {
    return isType(
      transactionType,
      "Upload"
      /* Upload */
    );
  }
  function isTypeBlob(transactionType) {
    return isType(
      transactionType,
      "Blob"
      /* Blob */
    );
  }
  function getReceiptsCall(receipts) {
    return getReceiptsByType(receipts, ReceiptType.Call);
  }
  function getReceiptsMessageOut(receipts) {
    return getReceiptsByType(receipts, ReceiptType.MessageOut);
  }
  function mergeAssets(op1, op2) {
    const assets1 = op1.assetsSent || [];
    const assets22 = op2.assetsSent || [];
    const assetMap = /* @__PURE__ */ new Map();
    assets1.forEach((asset) => {
      assetMap.set(asset.assetId, { ...asset });
    });
    assets22.forEach((asset) => {
      const existingAsset = assetMap.get(asset.assetId);
      if (existingAsset) {
        existingAsset.amount = bn(existingAsset.amount).add(asset.amount);
      } else {
        assetMap.set(asset.assetId, { ...asset });
      }
    });
    return Array.from(assetMap.values());
  }
  function isSameOperation(a, b) {
    return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
  }
  function mergeAssetsSent(existing, toAdd) {
    if (!toAdd.assetsSent?.length) {
      return existing.assetsSent;
    }
    return existing.assetsSent?.length ? mergeAssets(existing, toAdd) : toAdd.assetsSent;
  }
  function mergeCalls(existing, toAdd) {
    if (!toAdd.calls?.length) {
      return existing.calls;
    }
    return [...existing.calls || [], ...toAdd.calls];
  }
  function mergeOperations(existing, toAdd) {
    return {
      ...existing,
      assetsSent: mergeAssetsSent(existing, toAdd),
      calls: mergeCalls(existing, toAdd)
    };
  }
  function addOperation(operations, toAdd) {
    const existingIndex = operations.findIndex((op) => isSameOperation(op, toAdd));
    if (existingIndex === -1) {
      return [...operations, toAdd];
    }
    return operations.map((op, index) => index === existingIndex ? mergeOperations(op, toAdd) : op);
  }
  function getWithdrawFromFuelOperations({
    inputs,
    receipts,
    baseAssetId
  }) {
    const messageOutReceipts = getReceiptsMessageOut(receipts);
    const withdrawFromFuelOperations = messageOutReceipts.reduce(
      (prevWithdrawFromFuelOps, receipt) => {
        const input = getInputFromAssetId(inputs, baseAssetId, true);
        if (input) {
          const inputAddress = getInputAccountAddress(input);
          const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
            name: "Withdraw from Fuel",
            from: {
              type: 1,
              address: inputAddress
            },
            to: {
              type: 1,
              address: receipt.recipient.toString(),
              chain: "ethereum"
              /* ethereum */
            },
            assetsSent: [
              {
                amount: receipt.amount,
                assetId: baseAssetId
              }
            ]
          });
          return newWithdrawFromFuelOps;
        }
        return prevWithdrawFromFuelOps;
      },
      []
    );
    return withdrawFromFuelOperations;
  }
  function getContractCalls(contractInput, abiMap, receipt, rawPayload, maxInputs) {
    const abi2 = abiMap?.[contractInput.contractID];
    if (!abi2) {
      return [];
    }
    return [
      getFunctionCall({
        abi: abi2,
        receipt,
        rawPayload,
        maxInputs
      })
    ];
  }
  function getAssetsSent(receipt) {
    return receipt.amount?.isZero() ? void 0 : [
      {
        amount: receipt.amount,
        assetId: receipt.assetId
      }
    ];
  }
  function processCallReceipt(receipt, contractInput, inputs, abiMap, rawPayload, maxInputs, baseAssetId) {
    const assetId = receipt.assetId === ZeroBytes32 ? baseAssetId : receipt.assetId;
    const input = getInputFromAssetId(inputs, assetId, assetId === baseAssetId);
    if (!input) {
      return [];
    }
    const inputAddress = getInputAccountAddress(input);
    const calls = getContractCalls(contractInput, abiMap, receipt, rawPayload, maxInputs);
    return [
      {
        name: "Contract call",
        from: {
          type: 1,
          address: inputAddress
        },
        to: {
          type: 0,
          address: receipt.to
        },
        assetsSent: getAssetsSent(receipt),
        calls
      }
    ];
  }
  function getContractCallOperations({
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs,
    baseAssetId
  }) {
    const contractCallReceipts = getReceiptsCall(receipts);
    const contractOutputs = getOutputsContract(outputs);
    return contractOutputs.flatMap((output2) => {
      const contractInput = getInputContractFromIndex(inputs, output2.inputIndex);
      if (!contractInput) {
        return [];
      }
      return contractCallReceipts.filter((receipt) => receipt.to === contractInput.contractID).flatMap(
        (receipt) => processCallReceipt(
          receipt,
          contractInput,
          inputs,
          abiMap,
          rawPayload,
          maxInputs,
          baseAssetId
        )
      );
    });
  }
  function extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs) {
    const { to: toAddress, assetId, amount } = receipt;
    let { id: fromAddress } = receipt;
    const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 : 1;
    if (ZeroBytes32 === fromAddress) {
      const change = changeOutputs.find((output2) => output2.assetId === assetId);
      fromAddress = change?.to || fromAddress;
    }
    const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 : 1;
    return {
      name: "Transfer asset",
      from: {
        type: fromType,
        address: fromAddress
      },
      to: {
        type: toType,
        address: toAddress
      },
      assetsSent: [
        {
          assetId: assetId.toString(),
          amount
        }
      ]
    };
  }
  function getTransferOperations({
    inputs,
    outputs,
    receipts,
    baseAssetId
  }) {
    let operations = [];
    const coinOutputs = getOutputsCoin(outputs);
    const contractInputs = getInputsContract(inputs);
    const changeOutputs = getOutputsChange(outputs);
    const aggregated = aggregateInputsAmountsByAssetAndOwner(inputs, baseAssetId);
    coinOutputs.forEach(({ amount, assetId, to }) => {
      const txPayers = aggregated.get(assetId) || /* @__PURE__ */ new Map();
      let selectedPayer;
      let fallbackPayer;
      for (const [address, payedAmount] of txPayers) {
        if (!fallbackPayer) {
          fallbackPayer = address;
        }
        if (payedAmount.gte(amount)) {
          selectedPayer = address;
          break;
        }
      }
      selectedPayer = selectedPayer || fallbackPayer;
      if (selectedPayer) {
        operations = addOperation(operations, {
          name: "Transfer asset",
          from: {
            type: 1,
            address: selectedPayer
          },
          to: {
            type: 1,
            address: to
          },
          assetsSent: [{ assetId, amount }]
        });
      }
    });
    const transferReceipts = getReceiptsByType(
      receipts,
      ReceiptType.Transfer
    );
    const transferOutReceipts = getReceiptsByType(
      receipts,
      ReceiptType.TransferOut
    );
    [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
      const operation = extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs);
      operations = addOperation(operations, operation);
    });
    return operations;
  }
  function getPayProducerOperations(outputs) {
    const coinOutputs = getOutputsCoin(outputs);
    const payProducerOperations = coinOutputs.reduce((prev, output2) => {
      const operations = addOperation(prev, {
        name: "Pay network fee to block producer",
        from: {
          type: 1,
          address: "Network"
        },
        to: {
          type: 1,
          address: output2.to.toString()
        },
        assetsSent: [
          {
            assetId: output2.assetId.toString(),
            amount: output2.amount
          }
        ]
      });
      return operations;
    }, []);
    return payProducerOperations;
  }
  function getContractCreatedOperations({ inputs, outputs }) {
    const contractCreatedOutputs = getOutputsContractCreated(outputs);
    const input = getInputsCoinAndMessage(inputs)[0];
    const fromAddress = getInputAccountAddress(input);
    const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
      const operations = addOperation(prev, {
        name: "Contract created",
        from: {
          type: 1,
          address: fromAddress
        },
        to: {
          type: 0,
          address: contractCreatedOutput?.contractId || ""
        }
      });
      return operations;
    }, []);
    return contractCreatedOperations;
  }
  function getOperations({
    transactionType,
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs,
    baseAssetId
  }) {
    if (isTypeCreate(transactionType)) {
      return [...getContractCreatedOperations({ inputs, outputs })];
    }
    if (isTypeScript(transactionType)) {
      return [
        ...getTransferOperations({ inputs, outputs, receipts, baseAssetId }),
        ...getContractCallOperations({
          inputs,
          outputs,
          receipts,
          abiMap,
          rawPayload,
          maxInputs,
          baseAssetId
        }),
        ...getWithdrawFromFuelOperations({ inputs, receipts, baseAssetId })
      ];
    }
    return [...getPayProducerOperations(outputs)];
  }
  var processGqlReceipt = (gqlReceipt) => assembleReceiptByType(gqlReceipt);
  var extractMintedAssetsFromReceipts = (receipts) => {
    const mintedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Mint) {
        mintedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return mintedAssets;
  };
  var extractBurnedAssetsFromReceipts = (receipts) => {
    const burnedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Burn) {
        burnedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return burnedAssets;
  };
  var getTransactionStatusName = (gqlStatus) => {
    switch (gqlStatus) {
      case "FailureStatus":
        return "failure";
      case "SuccessStatus":
        return "success";
      case "SubmittedStatus":
        return "submitted";
      case "SqueezedOutStatus":
        return "squeezedout";
      default:
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_STATUS,
          `Invalid transaction status: ${gqlStatus}.`
        );
    }
  };
  var processGraphqlStatus = (gqlTransactionStatus) => {
    let time;
    let blockId;
    let status;
    let totalFee;
    let totalGas;
    let isStatusFailure = false;
    let isStatusSuccess = false;
    let isStatusPending = false;
    if (gqlTransactionStatus?.type) {
      status = getTransactionStatusName(gqlTransactionStatus.type);
      switch (gqlTransactionStatus.type) {
        case "SuccessStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block?.id;
          isStatusSuccess = true;
          totalFee = bn(gqlTransactionStatus.totalFee);
          totalGas = bn(gqlTransactionStatus.totalGas);
          break;
        case "FailureStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block?.id;
          isStatusFailure = true;
          totalFee = bn(gqlTransactionStatus.totalFee);
          totalGas = bn(gqlTransactionStatus.totalGas);
          break;
        case "SubmittedStatus":
          time = gqlTransactionStatus.time;
          isStatusPending = true;
          break;
        default:
      }
    }
    const processedGraphqlStatus = {
      time,
      blockId,
      status,
      totalFee,
      totalGas,
      isStatusFailure,
      isStatusSuccess,
      isStatusPending
    };
    return processedGraphqlStatus;
  };
  var getTotalFeeFromStatus = (status) => status && "totalFee" in status ? bn(status.totalFee) : void 0;
  function assembleTransactionSummary(params) {
    const {
      id,
      receipts,
      gasPerByte,
      gasPriceFactor,
      transaction,
      transactionBytes,
      gqlTransactionStatus,
      abiMap = {},
      maxInputs,
      gasCosts,
      maxGasPerTx,
      gasPrice,
      baseAssetId
    } = params;
    const gasUsed = getGasUsedFromReceipts(receipts);
    const rawPayload = hexlify(transactionBytes);
    const operations = getOperations({
      transactionType: transaction.type,
      inputs: transaction.inputs || [],
      outputs: transaction.outputs || [],
      receipts,
      rawPayload,
      abiMap,
      maxInputs,
      baseAssetId
    });
    const typeName = getTransactionTypeName(transaction.type);
    const tip = bn(transaction.policies?.find((policy) => policy.type === PolicyType.Tip)?.data);
    const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time, totalFee } = processGraphqlStatus(gqlTransactionStatus);
    const fee = totalFee ?? calculateTXFeeForSummary({
      gasPrice,
      rawPayload,
      tip,
      consensusParameters: {
        gasCosts,
        maxGasPerTx,
        feeParams: {
          gasPerByte,
          gasPriceFactor
        }
      }
    });
    const mintedAssets = extractMintedAssetsFromReceipts(receipts);
    const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
    let date2;
    if (time) {
      date2 = DateTime.fromTai64(time);
    }
    const transactionSummary = {
      id,
      tip,
      fee,
      gasUsed,
      operations,
      type: typeName,
      blockId,
      time,
      status,
      receipts,
      mintedAssets,
      burnedAssets,
      isTypeMint: isTypeMint(transaction.type),
      isTypeCreate: isTypeCreate(transaction.type),
      isTypeScript: isTypeScript(transaction.type),
      isTypeUpgrade: isTypeUpgrade(transaction.type),
      isTypeUpload: isTypeUpload(transaction.type),
      isTypeBlob: isTypeBlob(transaction.type),
      isStatusFailure,
      isStatusSuccess,
      isStatusPending,
      date: date2,
      transaction
    };
    return transactionSummary;
  }
  function getDecodedLogs(receipts, mainAbi, externalAbis = {}) {
    return receipts.reduce((logs, receipt) => {
      if (receipt.type === ReceiptType.LogData || receipt.type === ReceiptType.Log) {
        const interfaceToUse = new Interface(externalAbis[receipt.id] || mainAbi);
        const data = receipt.type === ReceiptType.Log ? new BigNumberCoder("u64").encode(receipt.ra) : receipt.data;
        const [decodedLog] = interfaceToUse.decodeLog(data, receipt.rb.toString());
        logs.push(decodedLog);
      }
      return logs;
    }, []);
  }
  function mapGqlOutputsToTxOutputs(outputs) {
    return outputs.map((o) => {
      const obj = "amount" in o ? { ...o, amount: bn(o.amount) } : o;
      switch (obj.type) {
        case "CoinOutput":
          return { ...obj, type: OutputType.Coin };
        case "ContractOutput":
          return {
            ...obj,
            type: OutputType.Contract,
            inputIndex: parseInt(obj.inputIndex, 10)
          };
        case "ChangeOutput":
          return {
            ...obj,
            type: OutputType.Change
          };
        case "VariableOutput":
          return { ...obj, type: OutputType.Variable };
        case "ContractCreated":
          return {
            ...obj,
            type: OutputType.ContractCreated,
            contractId: obj.contract
          };
        default:
          return assertUnreachable(obj);
      }
    });
  }
  var TransactionResponse = class {
    /**
     * Constructor for `TransactionResponse`.
     *
     * @param tx - The transaction ID or TransactionRequest.
     * @param provider - The provider.
     */
    constructor(tx, provider, chainId, abis, submitTxSubscription) {
      this.submitTxSubscription = submitTxSubscription;
      this.id = typeof tx === "string" ? tx : tx.getTransactionId(chainId);
      this.provider = provider;
      this.abis = abis;
      this.request = typeof tx === "string" ? void 0 : tx;
    }
    /** Transaction ID */
    id;
    /** Current provider */
    provider;
    /** Gas used on the transaction */
    gasUsed = bn(0);
    /** The graphql Transaction with receipts object. */
    gqlTransaction;
    request;
    status;
    abis;
    /**
     * Async constructor for `TransactionResponse`. This method can be used to create
     * an instance of `TransactionResponse` and wait for the transaction to be fetched
     * from the chain, ensuring that the `gqlTransaction` property is set.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    static async create(id, provider, abis) {
      const chainId = await provider.getChainId();
      const response = new TransactionResponse(id, provider, chainId, abis);
      await response.fetch();
      return response;
    }
    applyMalleableSubscriptionFields(transaction) {
      const status = this.status;
      if (!status) {
        return;
      }
      const tx = transaction;
      if (status.type === "SuccessStatus" || status.type === "FailureStatus") {
        tx.inputs = tx.inputs.map((input, idx) => {
          if ("txPointer" in input) {
            const correspondingInput = status.transaction.inputs?.[idx];
            return {
              ...input,
              txPointer: TxPointerCoder.decodeFromGqlScalar(correspondingInput.txPointer)
            };
          }
          return input;
        });
        tx.outputs = mapGqlOutputsToTxOutputs(status.transaction.outputs);
        if ("receiptsRoot" in status.transaction) {
          tx.receiptsRoot = status.transaction.receiptsRoot;
        }
      }
    }
    async getTransaction() {
      if (this.request) {
        const tx = this.request.toTransaction();
        this.applyMalleableSubscriptionFields(tx);
        return {
          tx,
          bytes: this.request.toTransactionBytes()
        };
      }
      const gqlTransaction = this.gqlTransaction ?? await this.fetch();
      return {
        tx: this.decodeTransaction(gqlTransaction),
        bytes: arrayify(gqlTransaction.rawPayload)
      };
    }
    getReceipts() {
      const status = this.status ?? this.gqlTransaction?.status;
      switch (status?.type) {
        case "SuccessStatus":
        case "FailureStatus":
          return status.receipts.map(processGqlReceipt);
        default:
          return [];
      }
    }
    /**
     * Fetch the transaction with receipts from the provider.
     *
     * @returns Transaction with receipts query result.
     */
    async fetch() {
      const response = await this.provider.operations.getTransactionWithReceipts({
        transactionId: this.id
      });
      if (!response.transaction) {
        const subscription = await this.provider.operations.statusChange({
          transactionId: this.id
        });
        for await (const { statusChange } of subscription) {
          if (statusChange) {
            this.status = statusChange;
            break;
          }
        }
        return this.fetch();
      }
      this.gqlTransaction = response.transaction;
      return response.transaction;
    }
    /**
     * Decode the raw payload of the transaction.
     *
     * @param transactionWithReceipts - The transaction with receipts object.
     * @returns The decoded transaction.
     */
    decodeTransaction(transactionWithReceipts) {
      return new TransactionCoder().decode(
        arrayify(transactionWithReceipts.rawPayload),
        0
      )?.[0];
    }
    /**
     * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
     * fetch it from the provider
     *
     * @param contractsAbiMap - The contracts ABI map.
     * @returns
     */
    async getTransactionSummary(contractsAbiMap) {
      const { tx: transaction, bytes: transactionBytes } = await this.getTransaction();
      const { gasPerByte, gasPriceFactor, gasCosts, maxGasPerTx } = await this.provider.getGasConfig();
      const totalFee = getTotalFeeFromStatus(this.status ?? this.gqlTransaction?.status);
      const gasPrice = totalFee ? bn(0) : await this.provider.getLatestGasPrice();
      const maxInputs = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs;
      const baseAssetId = await this.provider.getBaseAssetId();
      const transactionSummary = assembleTransactionSummary({
        id: this.id,
        receipts: this.getReceipts(),
        transaction,
        transactionBytes,
        gqlTransactionStatus: this.status ?? this.gqlTransaction?.status,
        gasPerByte,
        gasPriceFactor,
        abiMap: contractsAbiMap,
        maxInputs,
        gasCosts,
        maxGasPerTx,
        gasPrice,
        baseAssetId
      });
      return transactionSummary;
    }
    async waitForStatusChange() {
      const status = this.gqlTransaction?.status?.type;
      if (status && status !== "SubmittedStatus") {
        return;
      }
      const subscription = this.submitTxSubscription ?? await this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const sub22 of subscription) {
        const statusChange = "statusChange" in sub22 ? sub22.statusChange : sub22.submitAndAwaitStatus;
        this.status = statusChange;
        if (statusChange.type === "SqueezedOutStatus") {
          this.unsetResourceCache();
          throw new FuelError(
            ErrorCode.TRANSACTION_SQUEEZED_OUT,
            `Transaction Squeezed Out with reason: ${statusChange.reason}`
          );
        }
        if (statusChange.type !== "SubmittedStatus") {
          break;
        }
      }
    }
    /**
     * Assembles the result of a transaction by retrieving the transaction summary,
     * decoding logs (if available), and handling transaction failure.
     *
     * This method can be used to obtain the result of a transaction that has just
     * been submitted or one that has already been processed.
     *
     * @template TTransactionType - The type of the transaction.
     * @param contractsAbiMap - The map of contract ABIs.
     * @returns - The assembled transaction result.
     * @throws If the transaction status is a failure.
     */
    async assembleResult(contractsAbiMap) {
      const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
      const transactionResult = {
        ...transactionSummary
      };
      let logs = [];
      if (this.abis) {
        logs = getDecodedLogs(
          transactionSummary.receipts,
          this.abis.main,
          this.abis.otherContractsAbis
        );
        transactionResult.logs = logs;
      }
      const { receipts } = transactionResult;
      const status = this.status ?? this.gqlTransaction?.status;
      if (status?.type === "FailureStatus") {
        this.unsetResourceCache();
        const { reason } = status;
        throw extractTxError({
          receipts,
          statusReason: reason,
          logs
        });
      }
      return transactionResult;
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @returns The completed transaction result
     */
    async waitForResult(contractsAbiMap) {
      await this.waitForStatusChange();
      return this.assembleResult(contractsAbiMap);
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @param contractsAbiMap - The contracts ABI map.
     */
    async wait(contractsAbiMap) {
      return this.waitForResult(contractsAbiMap);
    }
    unsetResourceCache() {
      this.provider.cache?.unset(this.id);
    }
  };
  function getWaitDelay(options, retryAttemptNum) {
    const duration = options.baseDelay ?? 150;
    switch (options.backoff) {
      case "linear":
        return duration * retryAttemptNum;
      case "fixed":
        return duration;
      case "exponential":
      default:
        return 2 ** (retryAttemptNum - 1) * duration;
    }
  }
  function autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {
    if (options === void 0) {
      return fetchFn;
    }
    return async (...args) => {
      try {
        return await fetchFn(...args);
      } catch (_error) {
        const error3 = _error;
        if (error3.cause?.code !== "ECONNREFUSED") {
          throw error3;
        }
        const retryNum = retryAttemptNum + 1;
        if (retryNum > options.maxRetries) {
          throw error3;
        }
        const delay = getWaitDelay(options, retryNum);
        await sleep(delay);
        return autoRetryFetch(fetchFn, options, retryNum)(...args);
      }
    };
  }
  var handleGqlErrorMessage = (errorMessage, rawError) => {
    switch (errorMessage) {
      case "not enough coins to fit the target":
        throw new FuelError(
          ErrorCode.NOT_ENOUGH_FUNDS,
          `The account(s) sending the transaction don't have enough funds to cover the transaction.`,
          {},
          rawError
        );
      case "max number of coins is reached while trying to fit the target":
        throw new FuelError(
          ErrorCode.MAX_COINS_REACHED,
          "The account retrieving coins has exceeded the maximum number of coins per asset. Please consider combining your coins into a single UTXO.",
          {},
          rawError
        );
      default:
        throw new FuelError(ErrorCode.INVALID_REQUEST, errorMessage);
    }
  };
  var validatePaginationArgs = (params) => {
    const { paginationLimit, inputArgs = {} } = params;
    const { first, last, after, before } = inputArgs;
    if (after && before) {
      throw new FuelError(
        ErrorCode.INVALID_INPUT_PARAMETERS,
        'Pagination arguments "after" and "before" cannot be used together'
      );
    }
    if ((first || 0) > paginationLimit || (last || 0) > paginationLimit) {
      throw new FuelError(
        ErrorCode.INVALID_INPUT_PARAMETERS,
        `Pagination limit for this query cannot exceed ${paginationLimit} items`
      );
    }
    if (first && before) {
      throw new FuelError(
        ErrorCode.INVALID_INPUT_PARAMETERS,
        'The use of pagination argument "first" with "before" is not supported'
      );
    }
    if (last && after) {
      throw new FuelError(
        ErrorCode.INVALID_INPUT_PARAMETERS,
        'The use of pagination argument "last" with "after" is not supported'
      );
    }
    if (!first && !last) {
      inputArgs.first = paginationLimit;
    }
    return inputArgs;
  };
  var MAX_RETRIES = 10;
  var RESOURCES_PAGE_SIZE_LIMIT = 512;
  var TRANSACTIONS_PAGE_SIZE_LIMIT = 60;
  var BLOCKS_PAGE_SIZE_LIMIT = 5;
  var DEFAULT_RESOURCE_CACHE_TTL = 2e4;
  var GAS_USED_MODIFIER = 1.2;
  var processGqlChain = (chain) => {
    const { name, daHeight, consensusParameters } = chain;
    const {
      contractParams,
      feeParams,
      predicateParams,
      scriptParams,
      txParams,
      gasCosts,
      baseAssetId,
      chainId,
      version: version3
    } = consensusParameters;
    return {
      name,
      baseChainHeight: bn(daHeight),
      consensusParameters: {
        version: version3,
        chainId: bn(chainId),
        baseAssetId,
        feeParameters: {
          version: feeParams.version,
          gasPerByte: bn(feeParams.gasPerByte),
          gasPriceFactor: bn(feeParams.gasPriceFactor)
        },
        contractParameters: {
          version: contractParams.version,
          contractMaxSize: bn(contractParams.contractMaxSize),
          maxStorageSlots: bn(contractParams.maxStorageSlots)
        },
        txParameters: {
          version: txParams.version,
          maxInputs: bn(txParams.maxInputs),
          maxOutputs: bn(txParams.maxOutputs),
          maxWitnesses: bn(txParams.maxWitnesses),
          maxGasPerTx: bn(txParams.maxGasPerTx),
          maxSize: bn(txParams.maxSize),
          maxBytecodeSubsections: bn(txParams.maxBytecodeSubsections)
        },
        predicateParameters: {
          version: predicateParams.version,
          maxPredicateLength: bn(predicateParams.maxPredicateLength),
          maxPredicateDataLength: bn(predicateParams.maxPredicateDataLength),
          maxGasPerPredicate: bn(predicateParams.maxGasPerPredicate),
          maxMessageDataLength: bn(predicateParams.maxMessageDataLength)
        },
        scriptParameters: {
          version: scriptParams.version,
          maxScriptLength: bn(scriptParams.maxScriptLength),
          maxScriptDataLength: bn(scriptParams.maxScriptDataLength)
        },
        gasCosts
      }
    };
  };
  var _cacheInputs;
  var cacheInputs_fn;
  var _Provider = class {
    /**
     * Constructor to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     * @hidden
     */
    constructor(url, options = {}) {
      __privateAdd2(this, _cacheInputs);
      __publicField8(this, "operations");
      __publicField8(this, "cache");
      __publicField8(this, "url");
      __publicField8(this, "urlWithoutAuth");
      __publicField8(this, "consensusParametersTimestamp");
      __publicField8(this, "options", {
        timeout: void 0,
        resourceCacheTTL: void 0,
        fetch: void 0,
        retryOptions: void 0,
        headers: void 0
      });
      const { url: rawUrl, urlWithoutAuth, headers: authHeaders } = _Provider.extractBasicAuth(url);
      this.url = rawUrl;
      this.urlWithoutAuth = urlWithoutAuth;
      this.url = url;
      const { FUELS } = versions;
      const headers = { ...authHeaders, ...options.headers, Source: `ts-sdk-${FUELS}` };
      this.options = {
        ...this.options,
        ...options,
        headers
      };
      this.operations = this.createOperations();
      const { resourceCacheTTL } = this.options;
      if (isDefined(resourceCacheTTL)) {
        if (resourceCacheTTL !== -1) {
          this.cache = new ResourceCache(resourceCacheTTL);
        } else {
          this.cache = void 0;
        }
      } else {
        this.cache = new ResourceCache(DEFAULT_RESOURCE_CACHE_TTL);
      }
    }
    /** @hidden */
    static clearChainAndNodeCaches() {
      _Provider.nodeInfoCache = {};
      _Provider.chainInfoCache = {};
    }
    /**
     * @hidden
     */
    static getFetchFn(options) {
      const { retryOptions, timeout, headers } = options;
      return autoRetryFetch(async (...args) => {
        const url = args[0];
        const request = args[1];
        const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
        let fullRequest = {
          ...request,
          signal,
          headers: { ...request?.headers, ...headers }
        };
        if (options.requestMiddleware) {
          fullRequest = await options.requestMiddleware(fullRequest);
        }
        return options.fetch ? options.fetch(url, fullRequest, options) : fetch(url, fullRequest);
      }, retryOptions);
    }
    static extractBasicAuth(url) {
      let parsedUrl;
      try {
        parsedUrl = new URL(url);
      } catch (error3) {
        throw new FuelError(FuelError.CODES.INVALID_URL, "Invalid URL provided.", { url }, error3);
      }
      const username = parsedUrl.username;
      const password = parsedUrl.password;
      const urlWithoutAuth = `${parsedUrl.origin}${parsedUrl.pathname}`;
      if (!(username && password)) {
        return { url, urlWithoutAuth: url, headers: void 0 };
      }
      return {
        url,
        urlWithoutAuth,
        headers: { Authorization: `Basic ${btoa(`${username}:${password}`)}` }
      };
    }
    /**
     * Initialize Provider async stuff
     */
    async init() {
      await this.fetchChainAndNodeInfo();
      return this;
    }
    /**
     * Returns the `chainInfo` for the current network.
     *
     * @returns the chain information configuration.
     */
    async getChain() {
      await this.init();
      return _Provider.chainInfoCache[this.urlWithoutAuth];
    }
    /**
     * Returns the `nodeInfo` for the current network.
     *
     * @returns the node information configuration.
     */
    async getNode() {
      await this.init();
      return _Provider.nodeInfoCache[this.urlWithoutAuth];
    }
    /**
     * Returns some helpful parameters related to gas fees.
     */
    async getGasConfig() {
      const {
        txParameters: { maxGasPerTx },
        predicateParameters: { maxGasPerPredicate },
        feeParameters: { gasPriceFactor, gasPerByte },
        gasCosts
      } = (await this.getChain()).consensusParameters;
      return {
        maxGasPerTx,
        maxGasPerPredicate,
        gasPriceFactor,
        gasPerByte,
        gasCosts
      };
    }
    /**
     * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
     *
     * @param url - The URL to connect to.
     * @param options - Additional options for the provider.
     */
    async connect(url, options) {
      const { url: rawUrl, urlWithoutAuth, headers } = _Provider.extractBasicAuth(url);
      this.url = rawUrl;
      this.urlWithoutAuth = urlWithoutAuth;
      this.options = options ?? this.options;
      this.options = { ...this.options, headers: { ...this.options.headers, ...headers } };
      this.operations = this.createOperations();
      await this.init();
    }
    /**
     * Return the chain and node information.
     * @param ignoreCache - If true, ignores the cache and re-fetch configs.
     * @returns A promise that resolves to the Chain and NodeInfo.
     */
    async fetchChainAndNodeInfo(ignoreCache = false) {
      let nodeInfo;
      let chain;
      try {
        nodeInfo = _Provider.nodeInfoCache[this.urlWithoutAuth];
        chain = _Provider.chainInfoCache[this.urlWithoutAuth];
        const noCache = !nodeInfo || !chain;
        if (ignoreCache || noCache) {
          throw new Error(`Jumps to the catch block and re-fetch`);
        }
      } catch (_err) {
        const data = await this.operations.getChainAndNodeInfo();
        nodeInfo = {
          maxDepth: bn(data.nodeInfo.maxDepth),
          maxTx: bn(data.nodeInfo.maxTx),
          nodeVersion: data.nodeInfo.nodeVersion,
          utxoValidation: data.nodeInfo.utxoValidation,
          vmBacktrace: data.nodeInfo.vmBacktrace
        };
        _Provider.ensureClientVersionIsSupported(nodeInfo);
        chain = processGqlChain(data.chain);
        _Provider.chainInfoCache[this.urlWithoutAuth] = chain;
        _Provider.nodeInfoCache[this.urlWithoutAuth] = nodeInfo;
        this.consensusParametersTimestamp = Date.now();
      }
      return {
        chain,
        nodeInfo
      };
    }
    /**
     * @hidden
     */
    static ensureClientVersionIsSupported(nodeInfo) {
      const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
      if (!isMajorSupported || !isMinorSupported) {
        console.warn(
          `The Fuel Node that you are trying to connect to is using fuel-core version ${nodeInfo.nodeVersion},
which is not supported by the version of the TS SDK that you are using.
Things may not work as expected.
Supported fuel-core version: ${supportedVersion}.`
        );
      }
    }
    /**
     * Create GraphQL client and set operations.
     *
     * @returns The operation SDK object
     * @hidden
     */
    createOperations() {
      const fetchFn = _Provider.getFetchFn(this.options);
      const gqlClient = new GraphQLClient(this.urlWithoutAuth, {
        fetch: (input, requestInit) => fetchFn(input.toString(), requestInit || {}, this.options),
        responseMiddleware: (response) => {
          if ("response" in response) {
            const graphQlResponse = response.response;
            if (Array.isArray(graphQlResponse?.errors)) {
              for (const error3 of graphQlResponse.errors) {
                handleGqlErrorMessage(error3.message, error3);
              }
            }
          }
        }
      });
      const executeQuery = (query, vars) => {
        const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
        const isSubscription = opDefinition?.operation === "subscription";
        if (isSubscription) {
          return FuelGraphqlSubscriber.create({
            url: this.urlWithoutAuth,
            query,
            fetchFn: (url, requestInit) => fetchFn(url, requestInit, this.options),
            variables: vars
          });
        }
        return gqlClient.request(query, vars);
      };
      const customOperations = (requester) => ({
        getBlobs(variables) {
          const queryParams = variables.blobIds.map((_, i) => `$blobId${i}: BlobId!`).join(", ");
          const blobParams = variables.blobIds.map((_, i) => `blob${i}: blob(id: $blobId${i}) { id }`).join("\n");
          const updatedVariables = variables.blobIds.reduce(
            (acc, blobId, i) => {
              acc[`blobId${i}`] = blobId;
              return acc;
            },
            {}
          );
          const document2 = lib_default2`
          query getBlobs(${queryParams}) {
            ${blobParams}
          }
        `;
          return requester(document2, updatedVariables);
        }
      });
      return { ...getSdk(executeQuery), ...customOperations(executeQuery) };
    }
    /**
     * Returns the version of the connected node.
     *
     * @returns A promise that resolves to the version string.
     */
    async getVersion() {
      const {
        nodeInfo: { nodeVersion }
      } = await this.operations.getVersion();
      return nodeVersion;
    }
    /**
     * Returns the latest block number.
     *
     * @returns A promise that resolves to the latest block number.
     */
    async getBlockNumber() {
      const {
        chain: {
          latestBlock: { height }
        }
      } = await this.operations.getLatestBlockHeight();
      return bn(height);
    }
    /**
     * Returns the node information for the current provider network.
     *
     * @returns a promise that resolves to the node information.
     */
    async fetchNode() {
      const { nodeInfo } = await this.operations.getNodeInfo();
      const processedNodeInfo = {
        maxDepth: bn(nodeInfo.maxDepth),
        maxTx: bn(nodeInfo.maxTx),
        nodeVersion: nodeInfo.nodeVersion,
        utxoValidation: nodeInfo.utxoValidation,
        vmBacktrace: nodeInfo.vmBacktrace
      };
      _Provider.nodeInfoCache[this.urlWithoutAuth] = processedNodeInfo;
      return processedNodeInfo;
    }
    /**
     * Returns the chain information for the current provider network.
     *
     * @returns a promise that resolves to the chain information.
     */
    async fetchChain() {
      const { chain } = await this.operations.getChain();
      const processedChain = processGqlChain(chain);
      _Provider.chainInfoCache[this.urlWithoutAuth] = processedChain;
      return processedChain;
    }
    /**
     * Returns the chain ID for the current provider network.
     *
     * @returns A promise that resolves to the chain ID number.
     */
    async getChainId() {
      const {
        consensusParameters: { chainId }
      } = await this.getChain();
      return chainId.toNumber();
    }
    /**
     * Returns the base asset ID for the current provider network.
     *
     * @returns the base asset ID.
     */
    async getBaseAssetId() {
      const all = await this.getChain();
      const {
        consensusParameters: { baseAssetId }
      } = all;
      return baseAssetId;
    }
    /**
     * @hidden
     */
    async validateTransaction(tx) {
      const {
        consensusParameters: {
          txParameters: { maxInputs, maxOutputs }
        }
      } = await this.getChain();
      if (bn(tx.inputs.length).gt(maxInputs)) {
        throw new FuelError(
          ErrorCode.MAX_INPUTS_EXCEEDED,
          `The transaction exceeds the maximum allowed number of inputs. Tx inputs: ${tx.inputs.length}, max inputs: ${maxInputs}`
        );
      }
      if (bn(tx.outputs.length).gt(maxOutputs)) {
        throw new FuelError(
          ErrorCode.MAX_OUTPUTS_EXCEEDED,
          `The transaction exceeds the maximum allowed number of outputs. Tx outputs: ${tx.outputs.length}, max outputs: ${maxOutputs}`
        );
      }
    }
    /**
     * Submits a transaction to the chain to be executed.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider send transaction parameters (optional).
     * @returns A promise that resolves to the transaction response object.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, enableAssetBurn } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      validateTransactionForAssetBurn(
        await this.getBaseAssetId(),
        transactionRequest,
        enableAssetBurn
      );
      if (estimateTxDependencies) {
        await this.estimateTxDependencies(transactionRequest);
      }
      await this.validateTransaction(transactionRequest);
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      let abis;
      if (isTransactionTypeScript(transactionRequest)) {
        abis = transactionRequest.abis;
      }
      const subscription = await this.operations.submitAndAwaitStatus({ encodedTransaction });
      __privateMethod2(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs, transactionRequest.getTransactionId(await this.getChainId()));
      const chainId = await this.getChainId();
      return new TransactionResponse(transactionRequest, this, chainId, abis, subscription);
    }
    /**
     * Executes a transaction without actually submitting it to the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider call parameters (optional).
     * @returns A promise that resolves to the call result object.
     */
    async dryRun(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        return this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { dryRun: dryRunStatuses } = await this.operations.dryRun({
        encodedTransactions: encodedTransaction,
        utxoValidation: utxoValidation || false
      });
      const [{ receipts: rawReceipts, status: dryRunStatus }] = dryRunStatuses;
      const receipts = rawReceipts.map(processGqlReceipt);
      return { receipts, dryRunStatus };
    }
    /**
     * Verifies whether enough gas is available to complete transaction.
     *
     * @template T - The type of the transaction request object.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimated transaction request object.
     */
    async estimatePredicates(transactionRequest) {
      const shouldEstimatePredicates = Boolean(
        transactionRequest.inputs.find(
          (input) => "predicate" in input && input.predicate && !equalBytes(arrayify(input.predicate), arrayify("0x")) && new BN(input.predicateGasUsed).isZero()
        )
      );
      if (!shouldEstimatePredicates) {
        return transactionRequest;
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const response = await this.operations.estimatePredicates({
        encodedTransaction
      });
      const {
        estimatePredicates: { inputs }
      } = response;
      if (inputs) {
        inputs.forEach((input, index) => {
          if ("predicateGasUsed" in input && bn(input.predicateGasUsed).gt(0)) {
            transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
          }
        });
      }
      return transactionRequest;
    }
    /**
     * Will dryRun a transaction and check for missing dependencies.
     *
     * If there are missing variable outputs,
     * `addVariableOutputs` is called on the transaction.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimate transaction dependencies.
     */
    async estimateTxDependencies(transactionRequest) {
      if (isTransactionTypeCreate(transactionRequest)) {
        return {
          receipts: [],
          outputVariables: 0,
          missingContractIds: []
        };
      }
      let receipts = [];
      const missingContractIds = [];
      let outputVariables = 0;
      let dryRunStatus;
      await this.validateTransaction(transactionRequest);
      for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        const {
          dryRun: [{ receipts: rawReceipts, status }]
        } = await this.operations.dryRun({
          encodedTransactions: [hexlify(transactionRequest.toTransactionBytes())],
          utxoValidation: false,
          gasPrice: "0"
        });
        receipts = rawReceipts.map(processGqlReceipt);
        dryRunStatus = status;
        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
        const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
        if (hasMissingOutputs && isTransactionTypeScript(transactionRequest)) {
          outputVariables += missingOutputVariables.length;
          transactionRequest.addVariableOutputs(missingOutputVariables.length);
          missingOutputContractIds.forEach(({ contractId }) => {
            transactionRequest.addContractInputAndOutput(Address.fromString(contractId));
            missingContractIds.push(contractId);
          });
          const { maxFee } = await this.estimateTxGasAndFee({
            transactionRequest,
            gasPrice: bn(0)
          });
          transactionRequest.maxFee = maxFee;
        } else {
          break;
        }
      }
      return {
        receipts,
        outputVariables,
        missingContractIds,
        dryRunStatus
      };
    }
    /**
     * Dry runs multiple transactions and checks for missing dependencies in batches.
     *
     * Transactions are dry run in batches. After each dry run, transactions requiring
     * further modifications are identified. The method iteratively updates these transactions
     * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @returns A promise that resolves to an array of results for each transaction.
     */
    async estimateMultipleTxDependencies(transactionRequests) {
      const results = transactionRequests.map(() => ({
        receipts: [],
        outputVariables: 0,
        missingContractIds: [],
        dryRunStatus: void 0
      }));
      const allRequests = clone_default(transactionRequests);
      const serializedTransactionsMap = /* @__PURE__ */ new Map();
      allRequests.forEach((req2, index) => {
        if (isTransactionTypeScript(req2)) {
          serializedTransactionsMap.set(index, hexlify(req2.toTransactionBytes()));
        }
      });
      let transactionsToProcess = Array.from(serializedTransactionsMap.keys());
      let attempt = 0;
      while (transactionsToProcess.length > 0 && attempt < MAX_RETRIES) {
        const encodedTransactions = transactionsToProcess.map(
          (index) => serializedTransactionsMap.get(index)
        );
        const dryRunResults = await this.operations.dryRun({
          encodedTransactions,
          utxoValidation: false
        });
        const nextRoundTransactions = [];
        for (let i = 0; i < dryRunResults.dryRun.length; i++) {
          const requestIdx = transactionsToProcess[i];
          const { receipts: rawReceipts, status } = dryRunResults.dryRun[i];
          const result = results[requestIdx];
          result.receipts = rawReceipts.map(processGqlReceipt);
          result.dryRunStatus = status;
          const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(
            result.receipts
          );
          const hasMissingOutputs = missingOutputVariables.length > 0 || missingOutputContractIds.length > 0;
          const request = allRequests[requestIdx];
          if (hasMissingOutputs && isTransactionTypeScript(request)) {
            result.outputVariables += missingOutputVariables.length;
            request.addVariableOutputs(missingOutputVariables.length);
            missingOutputContractIds.forEach(({ contractId }) => {
              request.addContractInputAndOutput(Address.fromString(contractId));
              result.missingContractIds.push(contractId);
            });
            const { maxFee } = await this.estimateTxGasAndFee({
              transactionRequest: request
            });
            request.maxFee = maxFee;
            serializedTransactionsMap.set(requestIdx, hexlify(request.toTransactionBytes()));
            nextRoundTransactions.push(requestIdx);
          }
        }
        transactionsToProcess = nextRoundTransactions;
        attempt += 1;
      }
      return results;
    }
    /**
     * Dry runs multiple transactions.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @param sendTransactionParams - The provider call parameters (optional).
     *
     * @returns A promise that resolves to an array of results for each transaction call.
     */
    async dryRunMultipleTransactions(transactionRequests, { utxoValidation, estimateTxDependencies = true } = {}) {
      if (estimateTxDependencies) {
        return this.estimateMultipleTxDependencies(transactionRequests);
      }
      const encodedTransactions = transactionRequests.map((tx) => hexlify(tx.toTransactionBytes()));
      const { dryRun: dryRunStatuses } = await this.operations.dryRun({
        encodedTransactions,
        utxoValidation: utxoValidation || false
      });
      const results = dryRunStatuses.map(({ receipts: rawReceipts, status }) => {
        const receipts = rawReceipts.map(processGqlReceipt);
        return { receipts, dryRunStatus: status };
      });
      return results;
    }
    async autoRefetchConfigs() {
      const now = Date.now();
      const diff = now - (this.consensusParametersTimestamp ?? 0);
      if (diff < 6e4) {
        return;
      }
      if (!_Provider.chainInfoCache?.[this.urlWithoutAuth]) {
        await this.fetchChainAndNodeInfo(true);
        return;
      }
      const chainInfo = _Provider.chainInfoCache[this.urlWithoutAuth];
      const {
        consensusParameters: { version: previous }
      } = chainInfo;
      const {
        chain: {
          latestBlock: {
            header: { consensusParametersVersion: current }
          }
        }
      } = await this.operations.getConsensusParametersVersion();
      if (previous !== current) {
        await this.fetchChainAndNodeInfo(true);
      }
    }
    /**
     * Estimates the transaction gas and fee based on the provided transaction request.
     * @param transactionRequest - The transaction request object.
     * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
     */
    async estimateTxGasAndFee(params) {
      const { transactionRequest } = params;
      let { gasPrice } = params;
      await this.autoRefetchConfigs();
      const chainInfo = await this.getChain();
      const { gasPriceFactor, maxGasPerTx } = await this.getGasConfig();
      const minGas = transactionRequest.calculateMinGas(chainInfo);
      if (!isDefined(gasPrice)) {
        gasPrice = await this.estimateGasPrice(10);
      }
      const minFee = calculateGasFee({
        gasPrice: bn(gasPrice),
        gas: minGas,
        priceFactor: gasPriceFactor,
        tip: transactionRequest.tip
      }).add(1);
      let gasLimit = bn(0);
      if (isTransactionTypeScript(transactionRequest)) {
        gasLimit = transactionRequest.gasLimit;
        if (transactionRequest.gasLimit.eq(0)) {
          transactionRequest.gasLimit = minGas;
          transactionRequest.gasLimit = maxGasPerTx.sub(
            transactionRequest.calculateMaxGas(chainInfo, minGas)
          );
          gasLimit = transactionRequest.gasLimit;
        }
      }
      const maxGas = transactionRequest.calculateMaxGas(chainInfo, minGas);
      const maxFee = calculateGasFee({
        gasPrice: bn(gasPrice),
        gas: maxGas,
        priceFactor: gasPriceFactor,
        tip: transactionRequest.tip
      }).add(1);
      return {
        minGas,
        minFee,
        maxGas,
        maxFee,
        gasPrice,
        gasLimit
      };
    }
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added
     *
     * @param transactionRequestLike - The transaction request object.
     * @param estimateTxParams - The estimate transaction params (optional).
     * @returns A promise that resolves to the call result object.
     */
    async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        return this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransactions = [hexlify(transactionRequest.toTransactionBytes())];
      const { dryRun: dryRunStatuses } = await this.operations.dryRun({
        encodedTransactions,
        utxoValidation: true
      });
      const callResult = dryRunStatuses.map((dryRunStatus) => {
        const { id, receipts, status } = dryRunStatus;
        const processedReceipts = receipts.map(processGqlReceipt);
        return { id, receipts: processedReceipts, status };
      });
      return { receipts: callResult[0].receipts };
    }
    /**
     * @hidden
     *
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the transaction.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param transactionCostParams - The transaction cost parameters (optional).
     *
     * @returns A promise that resolves to the transaction cost object.
     */
    async getTransactionCost(transactionRequestLike, { signatureCallback } = {}) {
      const txRequestClone = clone_default(transactionRequestify(transactionRequestLike));
      const updateMaxFee = txRequestClone.maxFee.eq(0);
      const isScriptTransaction = isTransactionTypeScript(txRequestClone);
      if (isScriptTransaction) {
        txRequestClone.gasLimit = bn(0);
      }
      const signedRequest = clone_default(txRequestClone);
      let addedSignatures = 0;
      if (signatureCallback && isTransactionTypeScript(signedRequest)) {
        const lengthBefore = signedRequest.witnesses.length;
        await signatureCallback(signedRequest);
        addedSignatures = signedRequest.witnesses.length - lengthBefore;
      }
      await this.estimatePredicates(signedRequest);
      txRequestClone.updatePredicateGasUsed(signedRequest.inputs);
      let { maxFee, maxGas, minFee, minGas, gasPrice, gasLimit } = await this.estimateTxGasAndFee({
        transactionRequest: signedRequest
      });
      let receipts = [];
      let dryRunStatus;
      let missingContractIds = [];
      let outputVariables = 0;
      let gasUsed = bn(0);
      txRequestClone.maxFee = maxFee;
      if (isScriptTransaction) {
        txRequestClone.gasLimit = gasLimit;
        if (signatureCallback) {
          await signatureCallback(txRequestClone);
        }
        ({ receipts, missingContractIds, outputVariables, dryRunStatus } = await this.estimateTxDependencies(txRequestClone));
        if (dryRunStatus && "reason" in dryRunStatus) {
          throw this.extractDryRunError(txRequestClone, receipts, dryRunStatus);
        }
        const { maxGasPerTx } = await this.getGasConfig();
        const pristineGasUsed = getGasUsedFromReceipts(receipts);
        gasUsed = bn(pristineGasUsed.muln(GAS_USED_MODIFIER)).max(maxGasPerTx.sub(minGas));
        txRequestClone.gasLimit = gasUsed;
        ({ maxFee, maxGas, minFee, minGas, gasPrice } = await this.estimateTxGasAndFee({
          transactionRequest: txRequestClone,
          gasPrice
        }));
      }
      return {
        receipts,
        gasUsed,
        gasPrice,
        minGas,
        maxGas,
        minFee,
        maxFee,
        outputVariables,
        missingContractIds,
        addedSignatures,
        estimatedPredicates: txRequestClone.inputs,
        dryRunStatus,
        updateMaxFee
      };
    }
    /**
     * Returns coins for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get (optional).
     * @param paginationArgs - Pagination arguments (optional).
     *
     * @returns A promise that resolves to the coins.
     */
    async getCoins(owner, assetId, paginationArgs) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const {
        coins: { edges, pageInfo }
      } = await this.operations.getCoins({
        ...validatePaginationArgs({
          paginationLimit: RESOURCES_PAGE_SIZE_LIMIT,
          inputArgs: paginationArgs
        }),
        filter: { owner: ownerAddress.toB256(), assetId: assetId && hexlify(assetId) }
      });
      const coins = edges.map(({ node: node2 }) => ({
        id: node2.utxoId,
        assetId: node2.assetId,
        amount: bn(node2.amount),
        owner: ownerAddress,
        blockCreated: bn(node2.blockCreated),
        txCreatedIdx: bn(node2.txCreatedIdx)
      }));
      return {
        coins,
        pageInfo
      };
    }
    /**
     * Returns resources for the given owner satisfying the spend query.
     *
     * @param owner - The address to get resources for.
     * @param quantities - The coin quantities to get.
     * @param excludedIds - IDs of excluded resources from the selection (optional).
     * @returns A promise that resolves to the resources.
     */
    async getResourcesToSpend(owner, quantities, excludedIds) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const excludeInput = {
        messages: excludedIds?.messages?.map((nonce) => hexlify(nonce)) || [],
        utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || []
      };
      if (this.cache) {
        const cached = this.cache.getActiveData();
        excludeInput.messages.push(...cached.messages);
        excludeInput.utxos.push(...cached.utxos);
      }
      const coinsQuery = {
        owner: ownerAddress.toB256(),
        queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
          assetId: hexlify(assetId),
          amount: amount.toString(10),
          max: maxPerAsset ? maxPerAsset.toString(10) : void 0
        })),
        excludedIds: excludeInput
      };
      const result = await this.operations.getCoinsToSpend(coinsQuery);
      const coins = result.coinsToSpend.flat().map((coin) => {
        switch (coin.type) {
          case "MessageCoin":
            return {
              amount: bn(coin.amount),
              assetId: coin.assetId,
              daHeight: bn(coin.daHeight),
              sender: Address.fromAddressOrString(coin.sender),
              recipient: Address.fromAddressOrString(coin.recipient),
              nonce: coin.nonce
            };
          case "Coin":
            return {
              id: coin.utxoId,
              amount: bn(coin.amount),
              assetId: coin.assetId,
              owner: ownerAddress,
              blockCreated: bn(coin.blockCreated),
              txCreatedIdx: bn(coin.txCreatedIdx)
            };
          default:
            return null;
        }
      }).filter((v) => !!v);
      return coins;
    }
    /**
     * Returns an array of blobIds that exist on chain, for a given array of blobIds.
     *
     * @param blobIds - blobIds to check.
     * @returns - A promise that resolves to an array of blobIds that exist on chain.
     */
    async getBlobs(blobIds) {
      const res = await this.operations.getBlobs({ blobIds });
      const blobs = [];
      Object.keys(res).forEach((key) => {
        const val = res[key];
        blobs.push(val?.id ?? null);
      });
      return blobs.filter((v) => v);
    }
    /**
     * Returns block matching the given ID or height.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block or null.
     */
    async getBlock(idOrHeight) {
      let block2;
      if (idOrHeight === "latest") {
        const {
          chain: { latestBlock }
        } = await this.operations.getLatestBlock();
        block2 = latestBlock;
      } else {
        const isblockId = typeof idOrHeight === "string" && idOrHeight.length === 66;
        const variables = isblockId ? { blockId: idOrHeight } : { height: bn(idOrHeight).toString(10) };
        const response = await this.operations.getBlock(variables);
        block2 = response.block;
      }
      if (!block2) {
        return null;
      }
      const { header, height, id, transactions } = block2;
      return {
        id,
        height: bn(height),
        time: header.time,
        header: {
          applicationHash: header.applicationHash,
          daHeight: bn(header.daHeight),
          eventInboxRoot: header.eventInboxRoot,
          messageOutboxRoot: header.messageOutboxRoot,
          prevRoot: header.prevRoot,
          stateTransitionBytecodeVersion: header.stateTransitionBytecodeVersion,
          transactionsCount: header.transactionsCount,
          transactionsRoot: header.transactionsRoot
        },
        transactionIds: transactions.map((tx) => tx.id)
      };
    }
    /**
     * Returns all the blocks matching the given parameters.
     *
     * @param params - The parameters to query blocks.
     * @returns A promise that resolves to the blocks.
     */
    async getBlocks(params) {
      const {
        blocks: { edges, pageInfo }
      } = await this.operations.getBlocks({
        ...validatePaginationArgs({
          paginationLimit: BLOCKS_PAGE_SIZE_LIMIT,
          inputArgs: params
        })
      });
      const blocks = edges.map(({ node: block2 }) => ({
        id: block2.id,
        height: bn(block2.height),
        time: block2.header.time,
        header: {
          applicationHash: block2.header.applicationHash,
          daHeight: bn(block2.header.daHeight),
          eventInboxRoot: block2.header.eventInboxRoot,
          messageOutboxRoot: block2.header.messageOutboxRoot,
          prevRoot: block2.header.prevRoot,
          stateTransitionBytecodeVersion: block2.header.stateTransitionBytecodeVersion,
          transactionsCount: block2.header.transactionsCount,
          transactionsRoot: block2.header.transactionsRoot
        },
        transactionIds: block2.transactions.map((tx) => tx.id)
      }));
      return { blocks, pageInfo };
    }
    /**
     * Returns block matching the given ID or type, including transaction data.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    async getBlockWithTransactions(idOrHeight) {
      let variables;
      if (typeof idOrHeight === "number") {
        variables = { blockHeight: bn(idOrHeight).toString(10) };
      } else if (idOrHeight === "latest") {
        variables = { blockHeight: (await this.getBlockNumber()).toString() };
      } else {
        variables = { blockId: idOrHeight };
      }
      const { block: block2 } = await this.operations.getBlockWithTransactions(variables);
      if (!block2) {
        return null;
      }
      return {
        id: block2.id,
        height: bn(block2.height, 10),
        time: block2.header.time,
        header: {
          applicationHash: block2.header.applicationHash,
          daHeight: bn(block2.header.daHeight),
          eventInboxRoot: block2.header.eventInboxRoot,
          messageOutboxRoot: block2.header.messageOutboxRoot,
          prevRoot: block2.header.prevRoot,
          stateTransitionBytecodeVersion: block2.header.stateTransitionBytecodeVersion,
          transactionsCount: block2.header.transactionsCount,
          transactionsRoot: block2.header.transactionsRoot
        },
        transactionIds: block2.transactions.map((tx) => tx.id),
        transactions: block2.transactions.map(
          (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]
        )
      };
    }
    /**
     * Get transaction with the given ID.
     *
     * @param transactionId - ID of the transaction.
     * @returns A promise that resolves to the transaction.
     */
    async getTransaction(transactionId) {
      const { transaction } = await this.operations.getTransaction({ transactionId });
      if (!transaction) {
        return null;
      }
      try {
        return new TransactionCoder().decode(
          arrayify(transaction.rawPayload),
          0
        )?.[0];
      } catch (error3) {
        if (error3 instanceof FuelError && error3.code === ErrorCode.UNSUPPORTED_TRANSACTION_TYPE) {
          console.warn("Unsupported transaction type encountered");
          return null;
        }
        throw error3;
      }
    }
    /**
     * Retrieves transactions based on the provided pagination arguments.
     * @param paginationArgs - The pagination arguments for retrieving transactions.
     * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.
     */
    async getTransactions(paginationArgs) {
      const {
        transactions: { edges, pageInfo }
      } = await this.operations.getTransactions({
        ...validatePaginationArgs({
          inputArgs: paginationArgs,
          paginationLimit: TRANSACTIONS_PAGE_SIZE_LIMIT
        })
      });
      const coder = new TransactionCoder();
      const transactions = edges.map(({ node: { rawPayload } }) => {
        try {
          return coder.decode(arrayify(rawPayload), 0)[0];
        } catch (error3) {
          if (error3 instanceof FuelError && error3.code === ErrorCode.UNSUPPORTED_TRANSACTION_TYPE) {
            console.warn("Unsupported transaction type encountered");
            return null;
          }
          throw error3;
        }
      }).filter((tx) => tx !== null);
      return { transactions, pageInfo };
    }
    /**
     * Get deployed contract with the given ID.
     *
     * @param contractId - ID of the contract.
     * @returns A promise that resolves to the contract.
     */
    async getContract(contractId) {
      const { contract } = await this.operations.getContract({ contractId });
      if (!contract) {
        return null;
      }
      return contract;
    }
    /**
     * Returns the balance for the given contract for the given asset ID.
     *
     * @param contractId - The contract ID to get the balance for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getContractBalance(contractId, assetId) {
      const { contractBalance } = await this.operations.getContractBalance({
        contract: Address.fromAddressOrString(contractId).toB256(),
        asset: hexlify(assetId)
      });
      return bn(contractBalance.amount, 10);
    }
    /**
     * Returns the balance for the given owner for the given asset ID.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getBalance(owner, assetId) {
      const { balance } = await this.operations.getBalance({
        owner: Address.fromAddressOrString(owner).toB256(),
        assetId: hexlify(assetId)
      });
      return bn(balance.amount, 10);
    }
    /**
     * Returns balances for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the balances.
     */
    async getBalances(owner) {
      const {
        balances: { edges }
      } = await this.operations.getBalances({
        /**
         * The query parameters for this method were designed to support pagination,
         * but the current Fuel-Core implementation does not support pagination yet.
         */
        first: 1e4,
        filter: { owner: Address.fromAddressOrString(owner).toB256() }
      });
      const balances = edges.map(({ node: node2 }) => ({
        assetId: node2.assetId,
        amount: bn(node2.amount)
      }));
      return { balances };
    }
    /**
     * Returns message for the given address.
     *
     * @param address - The address to get message from.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the messages.
     */
    async getMessages(address, paginationArgs) {
      const {
        messages: { edges, pageInfo }
      } = await this.operations.getMessages({
        ...validatePaginationArgs({
          inputArgs: paginationArgs,
          paginationLimit: RESOURCES_PAGE_SIZE_LIMIT
        }),
        owner: Address.fromAddressOrString(address).toB256()
      });
      const messages = edges.map(({ node: node2 }) => ({
        messageId: InputMessageCoder.getMessageId({
          sender: node2.sender,
          recipient: node2.recipient,
          nonce: node2.nonce,
          amount: bn(node2.amount),
          data: node2.data
        }),
        sender: Address.fromAddressOrString(node2.sender),
        recipient: Address.fromAddressOrString(node2.recipient),
        nonce: node2.nonce,
        amount: bn(node2.amount),
        data: InputMessageCoder.decodeData(node2.data),
        daHeight: bn(node2.daHeight)
      }));
      return {
        messages,
        pageInfo
      };
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param transactionId - The transaction to get message from.
     * @param messageId - The message id from MessageOut receipt.
     * @param commitBlockId - The commit block id (optional).
     * @param commitBlockHeight - The commit block height (optional).
     * @returns A promise that resolves to the message proof.
     */
    async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
      let inputObject = {
        transactionId,
        nonce
      };
      if (commitBlockId && commitBlockHeight) {
        throw new FuelError(
          ErrorCode.INVALID_INPUT_PARAMETERS,
          "commitBlockId and commitBlockHeight cannot be used together"
        );
      }
      if (commitBlockId) {
        inputObject = {
          ...inputObject,
          commitBlockId
        };
      }
      if (commitBlockHeight) {
        inputObject = {
          ...inputObject,
          // Conver BN into a number string required on the query
          // This should problably be fixed on the fuel client side
          commitBlockHeight: commitBlockHeight.toNumber().toString()
        };
      }
      const result = await this.operations.getMessageProof(inputObject);
      if (!result.messageProof) {
        return null;
      }
      const {
        messageProof,
        messageBlockHeader,
        commitBlockHeader,
        blockProof,
        sender,
        recipient,
        amount,
        data
      } = result.messageProof;
      return {
        messageProof: {
          proofIndex: bn(messageProof.proofIndex),
          proofSet: messageProof.proofSet
        },
        blockProof: {
          proofIndex: bn(blockProof.proofIndex),
          proofSet: blockProof.proofSet
        },
        messageBlockHeader: {
          id: messageBlockHeader.id,
          daHeight: bn(messageBlockHeader.daHeight),
          transactionsCount: Number(messageBlockHeader.transactionsCount),
          transactionsRoot: messageBlockHeader.transactionsRoot,
          height: bn(messageBlockHeader.height),
          prevRoot: messageBlockHeader.prevRoot,
          time: messageBlockHeader.time,
          applicationHash: messageBlockHeader.applicationHash,
          messageReceiptCount: Number(messageBlockHeader.messageReceiptCount),
          messageOutboxRoot: messageBlockHeader.messageOutboxRoot,
          consensusParametersVersion: Number(messageBlockHeader.consensusParametersVersion),
          eventInboxRoot: messageBlockHeader.eventInboxRoot,
          stateTransitionBytecodeVersion: Number(messageBlockHeader.stateTransitionBytecodeVersion)
        },
        commitBlockHeader: {
          id: commitBlockHeader.id,
          daHeight: bn(commitBlockHeader.daHeight),
          transactionsCount: Number(commitBlockHeader.transactionsCount),
          transactionsRoot: commitBlockHeader.transactionsRoot,
          height: bn(commitBlockHeader.height),
          prevRoot: commitBlockHeader.prevRoot,
          time: commitBlockHeader.time,
          applicationHash: commitBlockHeader.applicationHash,
          messageReceiptCount: Number(commitBlockHeader.messageReceiptCount),
          messageOutboxRoot: commitBlockHeader.messageOutboxRoot,
          consensusParametersVersion: Number(commitBlockHeader.consensusParametersVersion),
          eventInboxRoot: commitBlockHeader.eventInboxRoot,
          stateTransitionBytecodeVersion: Number(commitBlockHeader.stateTransitionBytecodeVersion)
        },
        sender: Address.fromAddressOrString(sender),
        recipient: Address.fromAddressOrString(recipient),
        nonce,
        amount: bn(amount),
        data
      };
    }
    /**
     * Get the latest gas price from the node.
     *
     * @returns A promise that resolves to the latest gas price.
     */
    async getLatestGasPrice() {
      const { latestGasPrice } = await this.operations.getLatestGasPrice();
      return bn(latestGasPrice.gasPrice);
    }
    /**
     * Returns the estimate gas price for the given block horizon.
     *
     * @param blockHorizon - The block horizon to estimate gas price for.
     * @returns A promise that resolves to the estimated gas price.
     */
    async estimateGasPrice(blockHorizon) {
      const { estimateGasPrice } = await this.operations.estimateGasPrice({
        blockHorizon: String(blockHorizon)
      });
      return bn(estimateGasPrice.gasPrice);
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param nonce - The nonce of the message to get status from.
     * @returns A promise that resolves to the message status
     */
    async getMessageStatus(nonce) {
      const result = await this.operations.getMessageStatus({ nonce });
      return result.messageStatus;
    }
    /**
     * Lets you produce blocks with custom timestamps and the block number of the last block produced.
     *
     * @param amount - The amount of blocks to produce.
     * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
     * @returns A promise that resolves to the block number of the last produced block.
     */
    async produceBlocks(amount, startTime) {
      const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
        blocksToProduce: bn(amount).toString(10),
        startTimestamp: startTime ? DateTime.fromUnixMilliseconds(startTime).toTai64() : void 0
      });
      return bn(latestBlockHeight);
    }
    /**
     * Check if the given ID is an account.
     *
     * @param id - The ID to check.
     * @returns A promise that resolves to the result of the check.
     */
    async isUserAccount(id) {
      const { contract, blob, transaction } = await this.operations.isUserAccount({
        blobId: id,
        contractId: id,
        transactionId: id
      });
      if (contract || blob || transaction) {
        return false;
      }
      return true;
    }
    async getAddressType(id) {
      const { contract, blob, transaction } = await this.operations.isUserAccount({
        blobId: id,
        contractId: id,
        transactionId: id
      });
      if (contract) {
        return "Contract";
      }
      if (blob) {
        return "Blob";
      }
      if (transaction) {
        return "Transaction";
      }
      return "Account";
    }
    /**
     * Get the transaction response for the given transaction ID.
     *
     * @param transactionId - The transaction ID to get the response for.
     * @returns A promise that resolves to the transaction response.
     */
    async getTransactionResponse(transactionId) {
      const chainId = await this.getChainId();
      return new TransactionResponse(transactionId, this, chainId);
    }
    /**
     * Returns Message for given nonce.
     *
     * @param nonce - The nonce of the message to retrieve.
     * @returns A promise that resolves to the Message object or null.
     */
    async getMessageByNonce(nonce) {
      const { message: rawMessage } = await this.operations.getMessageByNonce({ nonce });
      if (!rawMessage) {
        return null;
      }
      const message = {
        messageId: InputMessageCoder.getMessageId({
          sender: rawMessage.sender,
          recipient: rawMessage.recipient,
          nonce,
          amount: bn(rawMessage.amount),
          data: rawMessage.data
        }),
        sender: Address.fromAddressOrString(rawMessage.sender),
        recipient: Address.fromAddressOrString(rawMessage.recipient),
        nonce,
        amount: bn(rawMessage.amount),
        data: InputMessageCoder.decodeData(rawMessage.data),
        daHeight: bn(rawMessage.daHeight)
      };
      return message;
    }
    /**
     * Get the relayed transaction for the given transaction ID.
     *
     * @param relayedTransactionId - The relayed transaction ID to get the response for.
     * @returns A promise that resolves to the relayed transaction.
     */
    async getRelayedTransactionStatus(relayedTransactionId) {
      const { relayedTransactionStatus } = await this.operations.getRelayedTransactionStatus({
        relayedTransactionId
      });
      if (!relayedTransactionStatus) {
        return null;
      }
      return relayedTransactionStatus;
    }
    /**
     * @hidden
     */
    extractDryRunError(transactionRequest, receipts, dryRunStatus) {
      const status = dryRunStatus;
      let logs = [];
      if (transactionRequest.abis) {
        logs = getDecodedLogs(
          receipts,
          transactionRequest.abis.main,
          transactionRequest.abis.otherContractsAbis
        );
      }
      return extractTxError({
        logs,
        receipts,
        statusReason: status.reason
      });
    }
  };
  var Provider = _Provider;
  _cacheInputs = /* @__PURE__ */ new WeakSet();
  cacheInputs_fn = function(inputs, transactionId) {
    if (!this.cache) {
      return;
    }
    const inputsToCache = inputs.reduce(
      (acc, input) => {
        if (input.type === InputType.Coin) {
          acc.utxos.push(input.id);
        } else if (input.type === InputType.Message) {
          acc.messages.push(input.nonce);
        }
        return acc;
      },
      { utxos: [], messages: [] }
    );
    this.cache.set(transactionId, inputsToCache);
  };
  __publicField8(Provider, "chainInfoCache", {});
  __publicField8(Provider, "nodeInfoCache", {});
  var CHAIN_IDS = {
    eth: {
      mainnet: 1,
      sepolia: 11155111,
      foundry: 31337
    },
    fuel: {
      devnet: 0,
      testnet: 0,
      mainnet: 9889
    }
  };
  var DELIMITER_PATH = "/";
  var trimRegex = /^\/|\/$/g;
  var trimPath = (path6 = "") => path6.replace(trimRegex, "");
  function urlJoin(baseUrl, ...paths) {
    const hasBaseUrl = baseUrl !== null && baseUrl !== void 0;
    const rootPath = baseUrl?.[0] === "/" && baseUrl.length > 1;
    const allPaths = [baseUrl, ...paths].filter(Boolean).map(trimPath);
    if (rootPath && hasBaseUrl) {
      allPaths.unshift("");
    }
    return allPaths.join(DELIMITER_PATH);
  }
  function resolveIconPaths(assets22, basePath = "./") {
    return assets22.map((asset) => ({
      ...asset,
      icon: urlJoin(basePath, asset.icon)
    }));
  }
  var fuelAssetsBaseUrl = "https://cdn.fuel.network/assets/";
  var rawAssets = [
    {
      name: "Ethereum",
      symbol: "ETH",
      icon: "eth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.sepolia,
          decimals: 18
        },
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.foundry,
          decimals: 18
        },
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.devnet,
          decimals: 9,
          assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.testnet,
          decimals: 9,
          assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          decimals: 9,
          assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
        }
      ]
    },
    {
      name: "WETH",
      symbol: "WETH",
      icon: "weth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xa38a5a8beeb08d95744bc7f58528073f4052b254def59eba20c99c202b5acaa3",
          decimals: 9
        }
      ]
    },
    {
      name: "weETH",
      symbol: "weETH",
      icon: "weETH.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x239ed6e12b7ce4089ee245244e3bf906999a6429c2a9a445a1e1faf56914a4ab",
          decimals: 9
        }
      ]
    },
    {
      name: "rsETH",
      symbol: "rsETH",
      icon: "rsETH.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xbae80f7fb8aa6b90d9b01ef726ec847cc4f59419c4d5f2ea88fec785d1b0e849",
          decimals: 9
        }
      ]
    },
    {
      name: "rETH",
      symbol: "rETH",
      icon: "reth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xae78736cd615f374d3085123a210448e74fc6393",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xf3f9a0ed0ce8eac5f89d6b83e41b3848212d5b5f56108c54a205bb228ca30c16",
          decimals: 9
        }
      ]
    },
    {
      name: "wbETH",
      symbol: "wbETH",
      icon: "wbeth.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xa2E3356610840701BDf5611a53974510Ae27E2e1",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x7843c74bef935e837f2bcf67b5d64ecb46dd53ff86375530b0caf3699e8ffafe",
          decimals: 9
        }
      ]
    },
    {
      name: "rstETH",
      symbol: "rstETH",
      icon: "rstETH.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x7a4EffD87C2f3C55CA251080b1343b605f327E3a",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x962792286fbc9b1d5860b4551362a12249362c21594c77abf4b3fe2bbe8d977a",
          decimals: 9
        }
      ]
    },
    {
      name: "amphrETH",
      symbol: "amphrETH",
      icon: "amphrETH.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x5fD13359Ba15A84B76f7F87568309040176167cd",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x05fc623e57bd7bc1258efa8e4f62b05af5471d73df6f2c2dc11ecc81134c4f36",
          decimals: 9
        }
      ]
    },
    {
      name: "Manta mBTC",
      symbol: "Manta mBTC",
      icon: "manta-mbtc.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x4041381e947CFD3D483d67a25C6aa9Dc924250c5",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xaf3111a248ff7a3238cdeea845bb2d43cf3835f1f6b8c9d28360728b55b9ce5b",
          decimals: 9
        }
      ]
    },
    {
      name: "Manta mETH",
      symbol: "Manta mETH",
      icon: "manta-meth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x8CdF550C04Bc9B9F10938368349C9c8051A772b6",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xafd219f513317b1750783c6581f55530d6cf189a5863fd18bd1b3ffcec1714b4",
          decimals: 9
        }
      ]
    },
    {
      name: "Manta mUSD",
      symbol: "Manta mUSD",
      icon: "manta-musd.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x3f24E1d7a973867fC2A03fE199E5502514E0e11E",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x89cb9401e55d49c3269654dd1cdfb0e80e57823a4a7db98ba8fc5953b120fef4",
          decimals: 9
        }
      ]
    },
    {
      name: "pumpBTC",
      symbol: "pumpBTC",
      icon: "pumpbtc.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xf469fbd2abcd6b9de8e169d128226c0fc90a012e",
          decimals: 8
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x0aa5eb2bb97ca915288b653a2529355d4dc66de2b37533213f0e4aeee3d3421f",
          decimals: 8
        }
      ]
    },
    {
      name: "FBTC",
      symbol: "FBTC",
      icon: "fbtc.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xc96de26018a54d51c097160568752c4e3bd6c364",
          decimals: 8
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xb5ecb0a1e08e2abbabf624ffea089df933376855f468ade35c6375b00c33996a",
          decimals: 8
        }
      ]
    },
    {
      name: "SolvBTC",
      symbol: "SolvBTC",
      icon: "solvBTC.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x7a56e1c57c7475ccf742a1832b028f0456652f97",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x1186afea9affb88809c210e13e2330b5258c2cef04bb8fff5eff372b7bd3f40f",
          decimals: 9
        }
      ]
    },
    {
      name: "SolvBTC.BBN",
      symbol: "SolvBTC.BBN",
      icon: "SolvBTC.BBN.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xd9d920aa40f578ab794426f5c90f6c731d159def",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x7a4f087c957d30218223c2baaaa365355c9ca81b6ea49004cfb1590a5399216f",
          decimals: 9
        }
      ]
    },
    {
      name: "Mantle mETH",
      symbol: "Mantle mETH",
      icon: "mantle-meth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xd5F7838F5C461fefF7FE49ea5ebaF7728bB0ADfa",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x642a5db59ec323c2f846d4d4cf3e58d78aff64accf4f8f6455ba0aa3ef000a3b",
          decimals: 9
        }
      ]
    },
    {
      name: "sDAI",
      symbol: "sDAI",
      icon: "sdai.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x83f20f44975d03b1b09e64809b757c47f942beea",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x9e46f919fbf978f3cad7cd34cca982d5613af63ff8aab6c379e4faa179552958",
          decimals: 9
        }
      ]
    },
    {
      name: "USDT",
      symbol: "USDT",
      icon: "usdt.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
          decimals: 6
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xa0265fb5c32f6e8db3197af3c7eb05c48ae373605b8165b6f4a51c5b0ba4812e",
          decimals: 6
        }
      ]
    },
    {
      name: "USDC",
      symbol: "USDC",
      icon: "usdc.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
          decimals: 6
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x286c479da40dc953bddc3bb4c453b608bba2e0ac483b077bd475174115395e6b",
          decimals: 6
        }
      ]
    },
    {
      name: "USDe",
      symbol: "USDe",
      icon: "USDe.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x4c9edd5852cd905f086c759e8383e09bff1e68b3",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xb6133b2ef9f6153eb869125d23dcf20d1e735331b5e41b15a6a7a6cec70e8651",
          decimals: 9
        }
      ]
    },
    {
      name: "sUSDe",
      symbol: "sUSDe",
      icon: "sUSDe.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x9d39a5de30e57443bff2a8307a4256c8797a3497",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xd05563025104fc36496c15c7021ad6b31034b0e89a356f4f818045d1f48808bc",
          decimals: 9
        }
      ]
    },
    {
      name: "rsUSDe",
      symbol: "rsUSDe",
      icon: "rsUSDe.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x82f5104b23FF2FA54C2345F821dAc9369e9E0B26",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x78d4522ec607f6e8efb66ea49439d1ee48623cf763f9688a8eada025def033d9",
          decimals: 9
        }
      ]
    },
    {
      name: "wstETH",
      symbol: "wstETH",
      icon: "wsteth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x1a7815cc9f75db5c24a5b0814bfb706bb9fe485333e98254015de8f48f84c67b",
          decimals: 9
        }
      ]
    },
    {
      name: "ezETH",
      symbol: "ezETH",
      icon: "ezeth.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xbf5495Efe5DB9ce00f80364C8B423567e58d2110",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x91b3559edb2619cde8ffb2aa7b3c3be97efd794ea46700db7092abeee62281b0",
          decimals: 9
        }
      ]
    },
    {
      name: "pzETH",
      symbol: "pzETH",
      icon: "pzETH.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x8c9532a60e0e7c6bbd2b2c1303f63ace1c3e9811",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x1493d4ec82124de8f9b625682de69dcccda79e882b89a55a8c737b12de67bd68",
          decimals: 9
        }
      ]
    },
    {
      name: "Re7LRT",
      symbol: "Re7LRT",
      icon: "Re7LRT.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0x84631c0d0081FDe56DeB72F6DE77abBbF6A9f93a",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xf2fc648c23a5db24610a1cf696acc4f0f6d9a7d6028dd9944964ab23f6e35995",
          decimals: 9
        }
      ]
    },
    {
      name: "steakLRT",
      symbol: "steakLRT",
      icon: "steakLRT.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS.eth.mainnet,
          address: "0xBEEF69Ac7870777598A04B2bd4771c71212E6aBc",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x4fc8ac9f101df07e2c2dec4a53c8c42c439bdbe5e36ea2d863a61ff60afafc30",
          decimals: 9
        }
      ]
    }
  ];
  var assets = resolveIconPaths(rawAssets, fuelAssetsBaseUrl);
  var mergeQuantities = (...coinQuantities) => {
    const resultMap = {};
    function addToMap({ amount, assetId }) {
      if (resultMap[assetId]) {
        resultMap[assetId] = resultMap[assetId].add(amount);
      } else {
        resultMap[assetId] = amount;
      }
    }
    coinQuantities.forEach((arr) => arr.forEach(addToMap));
    return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
  };
  var AbstractAccount = class {
  };
  var formatTransferToContractScriptData = (transferParams) => {
    const numberCoder = new BigNumberCoder("u64");
    return transferParams.reduce((acc, transferParam) => {
      const { assetId, amount, contractId } = transferParam;
      const encoded = numberCoder.encode(amount);
      const scriptData = concat([
        Address.fromAddressOrString(contractId).toBytes(),
        encoded,
        arrayify(assetId)
      ]);
      return concat([acc, scriptData]);
    }, new Uint8Array());
  };
  var assembleTransferToContractScript = async (transferParams) => {
    const scriptData = formatTransferToContractScriptData(transferParams);
    await asm.initWasm();
    let script = new Uint8Array();
    transferParams.forEach((_, i) => {
      const offset = (CONTRACT_ID_LEN + WORD_SIZE + ASSET_ID_LEN) * i;
      script = concat([
        script,
        // Load ScriptData into register 0x10.
        asm.gtf(16, 0, asm.GTFArgs.ScriptData).to_bytes(),
        // Add the offset to 0x10 so it will point to the current contract ID, store in 0x11.
        asm.addi(17, 16, offset).to_bytes(),
        // Add CONTRACT_ID_LEN to 0x11 to point to the amount in the ScriptData, store in 0x12.
        asm.addi(18, 17, CONTRACT_ID_LEN).to_bytes(),
        // Load word to the amount at 0x12 into register 0x13.
        asm.lw(19, 18, 0).to_bytes(),
        // Add WORD_SIZE to 0x12 to point to the asset ID in the ScriptData, store in 0x14.
        asm.addi(20, 18, WORD_SIZE).to_bytes(),
        // Perform the transfer using contract ID in 0x11, amount in 0x13, and asset ID in 0x14.
        asm.tr(17, 19, 20).to_bytes()
      ]);
    });
    script = concat([script, asm.ret(1).to_bytes()]);
    return { script, scriptData };
  };
  var MAX_FUNDING_ATTEMPTS = 5;
  var Account = class extends AbstractAccount {
    /**
     * The address associated with the account.
     */
    address;
    /**
     * The provider used to interact with the network.
     */
    _provider;
    /**
     * The connector for use with external wallets
     */
    _connector;
    /**
     * Creates a new Account instance.
     *
     * @param address - The address of the account.
     * @param provider - A Provider instance  (optional).
     * @param connector - A FuelConnector instance (optional).
     */
    constructor(address, provider, connector) {
      super();
      this._provider = provider;
      this._connector = connector;
      this.address = Address.fromDynamicInput(address);
    }
    /**
     * The provider used to interact with the network.
     *
     * @returns A Provider instance.
     *
     * @throws `FuelError` if the provider is not set.
     */
    get provider() {
      if (!this._provider) {
        throw new FuelError(ErrorCode.MISSING_PROVIDER, "Provider not set");
      }
      return this._provider;
    }
    /**
     * Sets the provider for the account.
     *
     * @param provider - A Provider instance.
     */
    set provider(provider) {
      this._provider = provider;
    }
    /**
     * Changes the provider connection for the account.
     *
     * @param provider - A Provider instance.
     * @returns The updated Provider instance.
     */
    connect(provider) {
      this._provider = provider;
      return this.provider;
    }
    /**
     * Retrieves resources satisfying the spend query for the account.
     *
     * @param quantities - Quantities of resources to be obtained.
     * @param excludedIds - IDs of resources to be excluded from the query (optional).
     * @returns A promise that resolves to an array of Resources.
     */
    async getResourcesToSpend(quantities, excludedIds) {
      return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
    }
    /**
     * Retrieves coins owned by the account.
     *
     * @param assetId - The asset ID of the coins to retrieve (optional).
     * @returns A promise that resolves to an array of Coins.
     */
    async getCoins(assetId, paginationArgs) {
      return this.provider.getCoins(this.address, assetId, paginationArgs);
    }
    /**
     * Retrieves messages owned by the account.
     *
     * @returns A promise that resolves to an array of Messages.
     */
    async getMessages(paginationArgs) {
      return this.provider.getMessages(this.address, paginationArgs);
    }
    /**
     * Retrieves the balance of the account for the given asset.
     *
     * @param assetId - The asset ID to check the balance for (optional).
     * @returns A promise that resolves to the balance amount.
     */
    async getBalance(assetId) {
      const assetIdToFetch = assetId ?? await this.provider.getBaseAssetId();
      const amount = await this.provider.getBalance(this.address, assetIdToFetch);
      return amount;
    }
    /**
     * Retrieves all the balances for the account.
     *
     * @returns A promise that resolves to an array of Coins and their quantities.
     */
    async getBalances() {
      return this.provider.getBalances(this.address);
    }
    /**
     * Funds a transaction request by adding the necessary resources.
     *
     * @typeParam T - The type of the TransactionRequest.
     * @param request - The transaction request to fund.
     * @param params - The estimated transaction parameters.
     * @returns A promise that resolves to the funded transaction request.
     */
    async fund(request, params) {
      const { addedSignatures, estimatedPredicates, requiredQuantities, updateMaxFee, gasPrice } = params;
      const fee = request.maxFee;
      const baseAssetId = await this.provider.getBaseAssetId();
      const requiredInBaseAsset = requiredQuantities.find((quantity) => quantity.assetId === baseAssetId)?.amount || bn(0);
      const requiredQuantitiesWithFee = addAmountToCoinQuantities({
        amount: bn(fee),
        assetId: baseAssetId,
        coinQuantities: requiredQuantities
      });
      const quantitiesDict = {};
      requiredQuantitiesWithFee.forEach(({ amount, assetId }) => {
        quantitiesDict[assetId] = {
          required: amount,
          owned: bn(0)
        };
      });
      request.inputs.filter(isRequestInputResource).forEach((input) => {
        const isCoin22 = isRequestInputCoin(input);
        const assetId = isCoin22 ? String(input.assetId) : baseAssetId;
        if (quantitiesDict[assetId]) {
          quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(input.amount);
        }
      });
      let missingQuantities = [];
      Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
        if (owned.lt(required)) {
          missingQuantities.push({
            assetId,
            amount: required.sub(owned)
          });
        }
      });
      let needsToBeFunded = missingQuantities.length > 0;
      let fundingAttempts = 0;
      while (needsToBeFunded && fundingAttempts < MAX_FUNDING_ATTEMPTS) {
        const resources = await this.getResourcesToSpend(
          missingQuantities,
          cacheRequestInputsResourcesFromOwner(request.inputs, this.address)
        );
        request.addResources(resources);
        request.updatePredicateGasUsed(estimatedPredicates);
        const requestToReestimate2 = clone_default(request);
        if (addedSignatures) {
          Array.from({ length: addedSignatures }).forEach(
            () => requestToReestimate2.addEmptyWitness()
          );
        }
        if (!updateMaxFee) {
          needsToBeFunded = false;
          break;
        }
        const { maxFee: newFee } = await this.provider.estimateTxGasAndFee({
          transactionRequest: requestToReestimate2,
          gasPrice
        });
        const totalBaseAssetOnInputs = getAssetAmountInRequestInputs(
          request.inputs.filter(isRequestInputResource),
          baseAssetId,
          baseAssetId
        );
        const totalBaseAssetRequiredWithFee = requiredInBaseAsset.add(newFee);
        if (totalBaseAssetOnInputs.gt(totalBaseAssetRequiredWithFee)) {
          needsToBeFunded = false;
        } else {
          missingQuantities = [
            {
              amount: totalBaseAssetRequiredWithFee.sub(totalBaseAssetOnInputs),
              assetId: baseAssetId
            }
          ];
        }
        fundingAttempts += 1;
      }
      if (needsToBeFunded) {
        throw new FuelError(
          ErrorCode.NOT_ENOUGH_FUNDS,
          `The account ${this.address} does not have enough base asset funds to cover the transaction execution.`
        );
      }
      await this.provider.validateTransaction(request);
      request.updatePredicateGasUsed(estimatedPredicates);
      const requestToReestimate = clone_default(request);
      if (addedSignatures) {
        Array.from({ length: addedSignatures }).forEach(() => requestToReestimate.addEmptyWitness());
      }
      if (!updateMaxFee) {
        return request;
      }
      const { maxFee } = await this.provider.estimateTxGasAndFee({
        transactionRequest: requestToReestimate,
        gasPrice
      });
      request.maxFee = maxFee;
      return request;
    }
    /**
     * A helper that creates a transfer transaction request and returns it.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer (optional).
     * @param txParams - The transaction parameters (optional).
     * @returns A promise that resolves to the prepared transaction request.
     */
    async createTransfer(destination, amount, assetId, txParams = {}) {
      let request = new ScriptTransactionRequest(txParams);
      request = this.addTransfer(request, {
        destination,
        amount,
        assetId: assetId || await this.provider.getBaseAssetId()
      });
      request = await this.estimateAndFundTransaction(request, txParams);
      return request;
    }
    /**
     * Transfers coins to a destination address.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer (optional).
     * @param txParams - The transaction parameters (optional).
     * @returns A promise that resolves to the transaction response.
     */
    async transfer(destination, amount, assetId, txParams = {}) {
      const request = await this.createTransfer(destination, amount, assetId, txParams);
      return this.sendTransaction(request, { estimateTxDependencies: false });
    }
    /**
     * Transfers multiple amounts of a token to multiple recipients.
     *
     * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
     * @param txParams - Optional transaction parameters.
     * @returns A promise that resolves to a `TransactionResponse` object representing the transaction result.
     */
    async batchTransfer(transferParams, txParams = {}) {
      let request = new ScriptTransactionRequest(txParams);
      request = this.addBatchTransfer(request, transferParams);
      request = await this.estimateAndFundTransaction(request, txParams);
      return this.sendTransaction(request, { estimateTxDependencies: false });
    }
    /**
     * Adds a transfer to the given transaction request.
     *
     * @param request - The script transaction request to add transfers to.
     * @param transferParams - The object representing the transfer to be made.
     * @returns The updated transaction request with the added transfer.
     */
    addTransfer(request, transferParams) {
      const { destination, amount, assetId } = transferParams;
      this.validateTransferAmount(amount);
      request.addCoinOutput(Address.fromAddressOrString(destination), amount, assetId);
      return request;
    }
    /**
     * Adds multiple transfers to a script transaction request.
     *
     * @param request - The script transaction request to add transfers to.
     * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
     * @returns The updated script transaction request.
     */
    addBatchTransfer(request, transferParams) {
      transferParams.forEach(({ destination, amount, assetId }) => {
        this.addTransfer(request, {
          destination,
          amount,
          assetId
        });
      });
      return request;
    }
    /**
     * Transfers coins to a contract address.
     *
     * @param contractId - The address of the contract.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer (optional).
     * @param txParams - The transaction parameters (optional).
     * @returns A promise that resolves to the transaction response.
     */
    async transferToContract(contractId, amount, assetId, txParams = {}) {
      return this.batchTransferToContracts([{ amount, assetId, contractId }], txParams);
    }
    async batchTransferToContracts(contractTransferParams, txParams = {}) {
      let request = new ScriptTransactionRequest({
        ...txParams
      });
      const quantities = [];
      const defaultAssetId = await this.provider.getBaseAssetId();
      const transferParams = contractTransferParams.map((transferParam) => {
        const amount = bn(transferParam.amount);
        const contractAddress = Address.fromAddressOrString(transferParam.contractId);
        const assetId = transferParam.assetId ? hexlify(transferParam.assetId) : defaultAssetId;
        if (amount.lte(0)) {
          throw new FuelError(
            ErrorCode.INVALID_TRANSFER_AMOUNT,
            "Transfer amount must be a positive number."
          );
        }
        request.addContractInputAndOutput(contractAddress);
        quantities.push({ amount, assetId });
        return {
          amount,
          contractId: contractAddress.toB256(),
          assetId
        };
      });
      const { script, scriptData } = await assembleTransferToContractScript(transferParams);
      request.script = script;
      request.scriptData = scriptData;
      request = await this.estimateAndFundTransaction(request, txParams, { quantities });
      return this.sendTransaction(request);
    }
    /**
     * Withdraws an amount of the base asset to the base chain.
     *
     * @param recipient - Address of the recipient on the base chain.
     * @param amount - Amount of base asset.
     * @param txParams - The transaction parameters (optional).
     * @returns A promise that resolves to the transaction response.
     */
    async withdrawToBaseLayer(recipient, amount, txParams = {}) {
      const recipientAddress = Address.fromAddressOrString(recipient);
      const recipientDataArray = arrayify(
        "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
      );
      const amountDataArray = arrayify(
        "0x".concat(bn(amount).toHex().substring(2).padStart(16, "0"))
      );
      const script = new Uint8Array([
        ...arrayify(withdrawScript.bytes),
        ...recipientDataArray,
        ...amountDataArray
      ]);
      const params = { script, ...txParams };
      const baseAssetId = await this.provider.getBaseAssetId();
      let request = new ScriptTransactionRequest(params);
      const quantities = [{ amount: bn(amount), assetId: baseAssetId }];
      const txCost = await this.getTransactionCost(request, { quantities });
      request = this.validateGasLimitAndMaxFee({
        transactionRequest: request,
        gasUsed: txCost.gasUsed,
        maxFee: txCost.maxFee,
        txParams
      });
      await this.fund(request, txCost);
      return this.sendTransaction(request);
    }
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the transaction.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param transactionCostParams - The transaction cost parameters (optional).
     *
     * @returns A promise that resolves to the transaction cost object.
     */
    async getTransactionCost(transactionRequestLike, { signatureCallback, quantities = [] } = {}) {
      const txRequestClone = clone_default(transactionRequestify(transactionRequestLike));
      const baseAssetId = await this.provider.getBaseAssetId();
      const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
      const requiredQuantities = mergeQuantities(coinOutputsQuantities, quantities);
      const transactionFeeForDryRun = [{ assetId: baseAssetId, amount: bn("100000000000000000") }];
      const findAssetInput = (assetId) => txRequestClone.inputs.find((input) => {
        if (input.type === InputType.Coin) {
          return input.assetId === assetId;
        }
        if (isRequestInputMessageWithoutData(input)) {
          return baseAssetId === assetId;
        }
        return false;
      });
      const updateAssetInput = (assetId, quantity) => {
        const assetInput = findAssetInput(assetId);
        const usedQuantity = quantity;
        if (assetInput && "amount" in assetInput) {
          assetInput.amount = usedQuantity;
        } else {
          txRequestClone.addResources(
            this.generateFakeResources([
              {
                amount: quantity,
                assetId
              }
            ])
          );
        }
      };
      mergeQuantities(requiredQuantities, transactionFeeForDryRun).forEach(
        ({ amount, assetId }) => updateAssetInput(assetId, amount)
      );
      const txCost = await this.provider.getTransactionCost(txRequestClone, {
        signatureCallback
      });
      return {
        ...txCost,
        requiredQuantities
      };
    }
    /**
     * Sign a message from the account via the connector.
     *
     * @param message - the message to sign.
     * @returns a promise that resolves to the signature.
     *
     * @hidden
     */
    async signMessage(message) {
      if (!this._connector) {
        throw new FuelError(ErrorCode.MISSING_CONNECTOR, "A connector is required to sign messages.");
      }
      return this._connector.signMessage(this.address.toString(), message);
    }
    /**
     * Signs a transaction from the account via the connector..
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature of the transaction.
     */
    async signTransaction(transactionRequestLike) {
      if (!this._connector) {
        throw new FuelError(
          ErrorCode.MISSING_CONNECTOR,
          "A connector is required to sign transactions."
        );
      }
      return this._connector.signTransaction(this.address.toString(), transactionRequestLike);
    }
    /**
     * Sends a transaction to the network.
     *
     * @param transactionRequestLike - The transaction request to be sent.
     * @param sendTransactionParams - The provider send transaction parameters (optional).
     * @returns A promise that resolves to the transaction response.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, onBeforeSend, skipCustomFee = false } = {}) {
      if (this._connector) {
        return this.provider.getTransactionResponse(
          await this._connector.sendTransaction(this.address.toString(), transactionRequestLike, {
            onBeforeSend,
            skipCustomFee
          })
        );
      }
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.sendTransaction(transactionRequest, {
        estimateTxDependencies: false
      });
    }
    /**
     * Simulates a transaction.
     *
     * @param transactionRequestLike - The transaction request to be simulated.
     * @param estimateTxParams - The estimate transaction params (optional).
     * @returns A promise that resolves to the call result.
     */
    async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
    }
    /**
     * Generates an array of fake resources based on the provided coins.
     *
     * @param coins - An array of `FakeResources` objects representing the coins.
     * @returns An array of `Resource` objects with generated properties.
     */
    generateFakeResources(coins) {
      return coins.map((coin) => ({
        id: hexlify(randomBytes22(UTXO_ID_LEN)),
        owner: this.address,
        blockCreated: bn(1),
        txCreatedIdx: bn(1),
        ...coin
      }));
    }
    /** @hidden * */
    validateTransferAmount(amount) {
      if (bn(amount).lte(0)) {
        throw new FuelError(
          ErrorCode.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      }
    }
    /** @hidden * */
    async estimateAndFundTransaction(transactionRequest, txParams, costParams) {
      let request = transactionRequest;
      const txCost = await this.getTransactionCost(request, costParams);
      request = this.validateGasLimitAndMaxFee({
        transactionRequest: request,
        gasUsed: txCost.gasUsed,
        maxFee: txCost.maxFee,
        txParams
      });
      request = await this.fund(request, txCost);
      return request;
    }
    /** @hidden * */
    validateGasLimitAndMaxFee({
      gasUsed,
      maxFee,
      transactionRequest,
      txParams: { gasLimit: setGasLimit, maxFee: setMaxFee }
    }) {
      const request = transactionRequestify(transactionRequest);
      if (!isDefined(setGasLimit)) {
        request.gasLimit = gasUsed;
      } else if (gasUsed.gt(setGasLimit)) {
        throw new FuelError(
          ErrorCode.GAS_LIMIT_TOO_LOW,
          `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`
        );
      }
      if (!isDefined(setMaxFee)) {
        request.maxFee = maxFee;
      } else if (maxFee.gt(setMaxFee)) {
        throw new FuelError(
          ErrorCode.MAX_FEE_TOO_LOW,
          `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`
        );
      }
      return request;
    }
  };
  var Signer = class {
    address;
    publicKey;
    compressedPublicKey;
    privateKey;
    /**
     * Create a Signer instance from a given private key
     *
     * @param privateKey - The private key to use for signing
     * @returns A new Signer instance
     */
    constructor(privateKey) {
      if (typeof privateKey === "string") {
        if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
          privateKey = `0x${privateKey}`;
        }
      }
      const privateKeyBytes = toBytes(privateKey, 32);
      this.privateKey = hexlify(privateKeyBytes);
      this.publicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
      this.compressedPublicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, true));
      this.address = Address.fromPublicKey(this.publicKey);
    }
    /**
     * Sign data using the Signer instance
     *
     * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
     * @ignore
     * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
     *
     * @param data - The data to be sign
     * @returns hashed signature
     */
    sign(data) {
      const signature = secp256k1.sign(arrayify(data), arrayify(this.privateKey));
      const r = toBytes(`0x${signature.r.toString(16)}`, 32);
      const s = toBytes(`0x${signature.s.toString(16)}`, 32);
      s[0] |= (signature.recovery || 0) << 7;
      return hexlify(concat([r, s]));
    }
    /**
     * Add point on the current elliptic curve
     *
     * @param point - Point to add on the curve
     * @returns compressed point on the curve
     */
    addPoint(point) {
      const p0 = secp256k1.ProjectivePoint.fromHex(arrayify(this.compressedPublicKey));
      const p1 = secp256k1.ProjectivePoint.fromHex(arrayify(point));
      const result = p0.add(p1);
      return `0x${result.toHex(true)}`;
    }
    /**
     * Recover the public key from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - hashed signature
     * @returns public key from signature from the
     */
    static recoverPublicKey(data, signature) {
      const signedMessageBytes = arrayify(signature);
      const r = signedMessageBytes.slice(0, 32);
      const s = signedMessageBytes.slice(32, 64);
      const recoveryParam = (s[0] & 128) >> 7;
      s[0] &= 127;
      const sig = new secp256k1.Signature(BigInt(hexlify(r)), BigInt(hexlify(s))).addRecoveryBit(
        recoveryParam
      );
      const publicKey = sig.recoverPublicKey(arrayify(data)).toRawBytes(false).slice(1);
      return hexlify(publicKey);
    }
    /**
     * Recover the address from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - Signature
     * @returns Address from signature
     */
    static recoverAddress(data, signature) {
      return Address.fromPublicKey(Signer.recoverPublicKey(data, signature));
    }
    /**
     * Generate a random privateKey
     *
     * @param entropy - Adds extra entropy to generate the privateKey
     * @returns random 32-byte hashed
     */
    static generatePrivateKey(entropy) {
      return entropy ? hash2(concat([randomBytes22(32), arrayify(entropy)])) : randomBytes22(32);
    }
    /**
     * Extended publicKey from a compact publicKey
     *
     * @param publicKey - Compact publicKey
     * @returns extended publicKey
     */
    static extendPublicKey(publicKey) {
      const point = secp256k1.ProjectivePoint.fromHex(arrayify(publicKey));
      return hexlify(point.toRawBytes(false).slice(1));
    }
  };
  var DEFAULT_KDF_PARAMS_LOG_N = 13;
  var DEFAULT_KDF_PARAMS_R = 8;
  var DEFAULT_KDF_PARAMS_P = 1;
  var DEFAULT_KEY_SIZE = 32;
  var DEFAULT_IV_SIZE = 16;
  var removeHexPrefix = (hexString) => {
    if (/^0x/.test(hexString)) {
      return hexString.slice(2);
    }
    return hexString;
  };
  async function encryptKeystoreWallet(privateKey, address, password) {
    const privateKeyBuffer = bufferFromString2(removeHexPrefix(privateKey), "hex");
    const ownerAddress = Address.fromAddressOrString(address);
    const salt = randomBytes22(DEFAULT_KEY_SIZE);
    const key = scrypt22({
      password: bufferFromString2(password),
      salt,
      dklen: DEFAULT_KEY_SIZE,
      n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
      r: DEFAULT_KDF_PARAMS_R,
      p: DEFAULT_KDF_PARAMS_P
    });
    const iv = randomBytes22(DEFAULT_IV_SIZE);
    const ciphertext = await encryptJsonWalletData2(privateKeyBuffer, key, iv);
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
    const macHashUint8Array = keccak2562(data);
    const mac = stringFromBuffer2(macHashUint8Array, "hex");
    const keystore = {
      id: randomUUID2(),
      version: 3,
      address: removeHexPrefix(ownerAddress.toHexString()),
      crypto: {
        cipher: "aes-128-ctr",
        mac,
        cipherparams: { iv: stringFromBuffer2(iv, "hex") },
        ciphertext: stringFromBuffer2(ciphertext, "hex"),
        kdf: "scrypt",
        kdfparams: {
          dklen: DEFAULT_KEY_SIZE,
          n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
          p: DEFAULT_KDF_PARAMS_P,
          r: DEFAULT_KDF_PARAMS_R,
          salt: stringFromBuffer2(salt, "hex")
        }
      }
    };
    return JSON.stringify(keystore);
  }
  async function decryptKeystoreWallet(jsonWallet, password) {
    const keystoreWallet = JSON.parse(jsonWallet);
    const {
      crypto: {
        mac,
        ciphertext,
        cipherparams: { iv },
        kdfparams: { dklen, n, r, p, salt }
      }
    } = keystoreWallet;
    const ciphertextBuffer = bufferFromString2(ciphertext, "hex");
    const ivBuffer = bufferFromString2(iv, "hex");
    const saltBuffer = bufferFromString2(salt, "hex");
    const passwordBuffer = bufferFromString2(password);
    const key = scrypt22({
      password: passwordBuffer,
      salt: saltBuffer,
      n,
      p,
      r,
      dklen
    });
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
    const macHashUint8Array = keccak2562(data);
    const macHash = stringFromBuffer2(macHashUint8Array, "hex");
    if (mac !== macHash) {
      throw new FuelError(
        ErrorCode.INVALID_PASSWORD,
        "Failed to decrypt the keystore wallet, the provided password is incorrect."
      );
    }
    const buffer = await decryptJsonWalletData2(ciphertextBuffer, key, ivBuffer);
    const privateKey = hexlify(buffer);
    return privateKey;
  }
  var BaseWalletUnlocked = class extends Account {
    /**
     * A function that returns the wallet's signer.
     */
    signer;
    /**
     * Creates a new BaseWalletUnlocked instance.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance (optional).
     */
    constructor(privateKey, provider) {
      const signer = new Signer(privateKey);
      super(signer.address, provider);
      this.signer = () => signer;
    }
    /**
     * Gets the private key of the wallet.
     *
     * @returns The private key of the wallet.
     */
    get privateKey() {
      return this.signer().privateKey;
    }
    /**
     * Gets the public key of the wallet.
     *
     * @returns
     */
    get publicKey() {
      return this.signer().publicKey;
    }
    /**
     * Signs a message with the wallet's private key.
     *
     * @param message - The message to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signMessage(message) {
      const signedMessage = await this.signer().sign(hashMessage(message));
      return hexlify(signedMessage);
    }
    /**
     * Signs a transaction with the wallet's private key.
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      const chainId = await this.provider.getChainId();
      const hashedTransaction = transactionRequest.getTransactionId(chainId);
      const signature = await this.signer().sign(hashedTransaction);
      return hexlify(signature);
    }
    /**
     * Populates a transaction with the witnesses signature.
     *
     * @param transactionRequestLike - The transaction request to populate.
     * @returns The populated transaction request.
     */
    async populateTransactionWitnessesSignature(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      const signedTransaction = await this.signTransaction(transactionRequest);
      transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
      return transactionRequest;
    }
    /**
     * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequestLike - The transaction request to send.
     * @param estimateTxDependencies - Whether to estimate the transaction dependencies.
     * @returns A promise that resolves to the TransactionResponse object.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = false, enableAssetBurn } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      validateTransactionForAssetBurn(
        await this.provider.getBaseAssetId(),
        transactionRequest,
        enableAssetBurn
      );
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.sendTransaction(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        { estimateTxDependencies: false, enableAssetBurn }
      );
    }
    /**
     * Populates the witness signature for a transaction and sends a call to the network using `provider.dryRun`.
     *
     * @param transactionRequestLike - The transaction request to simulate.
     * @returns A promise that resolves to the CallResult object.
     */
    async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.dryRun(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        {
          utxoValidation: true,
          estimateTxDependencies: false
        }
      );
    }
    /**
     * Encrypts an unlocked wallet with a password.
     *
     * @param password - the password to encrypt the wallet with.
     * @returns - the encrypted wallet.
     */
    async encrypt(password) {
      return encryptKeystoreWallet(this.privateKey, this.address, password);
    }
  };
  __publicField8(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");
  var english = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  function getLowerMask(bits2) {
    return (1 << bits2) - 1;
  }
  function getUpperMask(bits2) {
    return (1 << bits2) - 1 << 8 - bits2;
  }
  function getWords(mnemonic) {
    if (!Array.isArray(mnemonic)) {
      return mnemonic.split(/\s+/);
    }
    return mnemonic;
  }
  function getPhrase(mnemonic) {
    if (Array.isArray(mnemonic)) {
      return mnemonic.join(" ");
    }
    return mnemonic;
  }
  function entropyToMnemonicIndices(entropy) {
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i += 1) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        indices.push(entropy[i] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
      }
    }
    const checksumBits = entropy.length / 4;
    const checksum = arrayify(sha2562(entropy))[0] & getUpperMask(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return indices;
  }
  function mnemonicWordsToEntropy(words, wordlist) {
    const size = Math.ceil(11 * words.length / 8);
    const entropy = arrayify(new Uint8Array(size));
    let offset = 0;
    for (let i = 0; i < words.length; i += 1) {
      const index = wordlist.indexOf(words[i].normalize("NFKD"));
      if (index === -1) {
        throw new FuelError(
          ErrorCode.INVALID_MNEMONIC,
          `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
        );
      }
      for (let bit = 0; bit < 11; bit += 1) {
        if (index & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset += 1;
      }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = arrayify(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
      throw new FuelError(
        ErrorCode.INVALID_CHECKSUM,
        "Checksum validation failed for the provided mnemonic."
      );
    }
    return entropy.slice(0, entropyBits / 8);
  }
  var MasterSecret = toUtf8Bytes("Bitcoin seed");
  var MainnetPRV = "0x0488ade4";
  var TestnetPRV = "0x04358394";
  var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
  function assertWordList(wordlist) {
    if (wordlist.length !== 2048) {
      throw new FuelError(
        ErrorCode.INVALID_WORD_LIST,
        `Expected word list length of 2048, but got ${wordlist.length}.`
      );
    }
  }
  function assertEntropy(entropy) {
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
      throw new FuelError(
        ErrorCode.INVALID_ENTROPY,
        `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
      );
    }
  }
  function assertMnemonic(words) {
    if (!MNEMONIC_SIZES.includes(words.length)) {
      const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
        ", "
      )}] words, but got ${words.length}.`;
      throw new FuelError(ErrorCode.INVALID_MNEMONIC, errorMsg);
    }
  }
  var Mnemonic = class {
    wordlist;
    /**
     *
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic instance
     */
    constructor(wordlist = english) {
      this.wordlist = wordlist;
      assertWordList(this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns Entropy hash
     */
    mnemonicToEntropy(phrase) {
      return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
    }
    /**
     *
     * @param entropy - Entropy source to the mnemonic phrase.
     * @returns Mnemonic phrase
     */
    entropyToMnemonic(entropy) {
      return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic phrase
     */
    static mnemonicToEntropy(phrase, wordlist = english) {
      const words = getWords(phrase);
      assertMnemonic(words);
      return hexlify(mnemonicWordsToEntropy(words, wordlist));
    }
    /**
     * @param entropy - Entropy source to the mnemonic phrase.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static entropyToMnemonic(entropy, wordlist = english) {
      const entropyBytes = arrayify(entropy);
      assertWordList(wordlist);
      assertEntropy(entropyBytes);
      return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToSeed(phrase, passphrase = "") {
      assertMnemonic(getWords(phrase));
      const phraseBytes = toUtf8Bytes(getPhrase(phrase));
      const salt = toUtf8Bytes(`mnemonic${passphrase}`);
      return pbkdf222(phraseBytes, salt, 2048, 64, "sha512");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToMasterKeys(phrase, passphrase = "") {
      const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);
      return Mnemonic.masterKeysFromSeed(seed);
    }
    /**
     * Validates if given mnemonic is  valid
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns true if phrase is a valid mnemonic
     */
    static isMnemonicValid(phrase) {
      const words = getWords(phrase);
      let i = 0;
      try {
        assertMnemonic(words);
      } catch {
        return false;
      }
      while (i < words.length) {
        if (Mnemonic.binarySearch(words[i]) === false) {
          return false;
        }
        i += 1;
      }
      return true;
    }
    static binarySearch(target) {
      const words = english;
      let left = 0;
      let right = words.length - 1;
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (words[mid] === target) {
          return true;
        }
        if (target < words[mid]) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
      return false;
    }
    /**
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static masterKeysFromSeed(seed) {
      const seedArray = arrayify(seed);
      if (seedArray.length < 16 || seedArray.length > 64) {
        throw new FuelError(
          ErrorCode.INVALID_SEED,
          `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
        );
      }
      return arrayify(computeHmac2("sha512", MasterSecret, seedArray));
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    static seedToExtendedKey(seed, testnet = false) {
      const masterKey = Mnemonic.masterKeysFromSeed(seed);
      const prefix = arrayify(testnet ? TestnetPRV : MainnetPRV);
      const depth = "0x00";
      const fingerprint = "0x00000000";
      const index = "0x00000000";
      const chainCode = masterKey.slice(32);
      const privateKey = masterKey.slice(0, 32);
      const extendedKey = concat([
        prefix,
        depth,
        fingerprint,
        index,
        chainCode,
        concat(["0x00", privateKey])
      ]);
      const checksum = dataSlice(sha2562(sha2562(extendedKey)), 0, 4);
      return encodeBase58(concat([extendedKey, checksum]));
    }
    /**
     *  Create a new mnemonic using a randomly generated number as entropy.
     *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
     *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
     *  If not provided, the default entropy length will be set to 256 bits.
     *  The return is a list of words that encodes the generated entropy.
     *
     *
     * @param size - Number of bytes used as an entropy
     * @param extraEntropy - Optional extra entropy to increase randomness
     * @returns A randomly generated mnemonic
     */
    static generate(size = 32, extraEntropy = "") {
      const entropy = extraEntropy ? sha2562(concat([randomBytes22(size), arrayify(extraEntropy)])) : randomBytes22(size);
      return Mnemonic.entropyToMnemonic(entropy);
    }
  };
  var mnemonic_default = Mnemonic;
  var HARDENED_INDEX = 2147483648;
  var MainnetPRV2 = hexlify("0x0488ade4");
  var MainnetPUB = hexlify("0x0488b21e");
  var TestnetPRV2 = hexlify("0x04358394");
  var TestnetPUB = hexlify("0x043587cf");
  function base58check(data) {
    return encodeBase58(concat([data, dataSlice(sha2562(sha2562(data)), 0, 4)]));
  }
  function getExtendedKeyPrefix(isPublic = false, testnet = false) {
    if (isPublic) {
      return testnet ? TestnetPUB : MainnetPUB;
    }
    return testnet ? TestnetPRV2 : MainnetPRV2;
  }
  function isPublicExtendedKey(extendedKey) {
    return [MainnetPUB, TestnetPUB].includes(hexlify(extendedKey.slice(0, 4)));
  }
  function isValidExtendedKey(extendedKey) {
    return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
      hexlify(extendedKey.slice(0, 4))
    );
  }
  function parsePath(path6, depth = 0) {
    const components = path6.split("/");
    if (components.length === 0 || components[0] === "m" && depth !== 0) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, `invalid path - ${path6}`);
    }
    if (components[0] === "m") {
      components.shift();
    }
    return components.map(
      (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
    );
  }
  var HDWallet = class {
    depth = 0;
    index = 0;
    fingerprint = hexlify("0x00000000");
    parentFingerprint = hexlify("0x00000000");
    privateKey;
    publicKey;
    chainCode;
    /**
     * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
     *
     * @param config - Wallet configurations
     */
    constructor(config) {
      if (config.privateKey) {
        const signer = new Signer(config.privateKey);
        this.publicKey = hexlify(signer.compressedPublicKey);
        this.privateKey = hexlify(config.privateKey);
      } else {
        if (!config.publicKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Both public and private Key cannot be missing. At least one should be provided."
          );
        }
        this.publicKey = hexlify(config.publicKey);
      }
      this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
      this.fingerprint = dataSlice(ripemd16022(sha2562(this.publicKey)), 0, 4);
      this.depth = config.depth || this.depth;
      this.index = config.index || this.index;
      this.chainCode = config.chainCode;
    }
    get extendedKey() {
      return this.toExtendedKey();
    }
    /**
     * Derive the current HDWallet instance navigating only on the index.
     * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param index - Index of the child HDWallet.
     * @returns A new instance of HDWallet on the derived index
     */
    deriveIndex(index) {
      const privateKey = this.privateKey && arrayify(this.privateKey);
      const publicKey = arrayify(this.publicKey);
      const chainCode = arrayify(this.chainCode);
      const data = new Uint8Array(37);
      if (index & HARDENED_INDEX) {
        if (!privateKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Cannot derive a hardened index without a private Key."
          );
        }
        data.set(privateKey, 1);
      } else {
        data.set(arrayify(this.publicKey));
      }
      data.set(toBytes(index, 4), 33);
      const bytes2 = arrayify(computeHmac2("sha512", chainCode, data));
      const IL = bytes2.slice(0, 32);
      const IR = bytes2.slice(32);
      if (privateKey) {
        const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
        const ki = bn(IL).add(privateKey).mod(N).toBytes(32);
        return new HDWallet({
          privateKey: ki,
          chainCode: IR,
          index,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint
        });
      }
      const signer = new Signer(hexlify(IL));
      const Ki = signer.addPoint(publicKey);
      return new HDWallet({
        publicKey: Ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    /**
     * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
     * @returns A new instance of HDWallet on the derived path
     */
    derivePath(path6) {
      const paths = parsePath(path6, this.depth);
      return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    toExtendedKey(isPublic = false, testnet = false) {
      if (this.depth >= 256) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          `Exceeded max depth of 255. Current depth: ${this.depth}.`
        );
      }
      const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
      const depth = hexlify(Uint8Array.from([this.depth]));
      const parentFingerprint = this.parentFingerprint;
      const index = toHex(this.index, 4);
      const chainCode = this.chainCode;
      const key = this.privateKey != null && !isPublic ? concat(["0x00", this.privateKey]) : this.publicKey;
      const extendedKey = arrayify(concat([prefix, depth, parentFingerprint, index, chainCode, key]));
      return base58check(extendedKey);
    }
    /**
     * Create HDWallet instance from seed
     *
     * @param seed - Seed
     * @returns A new instance of HDWallet
     */
    static fromSeed(seed) {
      const masterKey = mnemonic_default.masterKeysFromSeed(seed);
      return new HDWallet({
        chainCode: arrayify(masterKey.slice(32)),
        privateKey: arrayify(masterKey.slice(0, 32))
      });
    }
    static fromExtendedKey(extendedKey) {
      const decoded = hexlify(toBytes(decodeBase58(extendedKey)));
      const bytes2 = arrayify(decoded);
      const validChecksum = base58check(bytes2.slice(0, 78)) === extendedKey;
      if (bytes2.length !== 82 || !isValidExtendedKey(bytes2)) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
      }
      if (!validChecksum) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
      }
      const depth = bytes2[4];
      const parentFingerprint = hexlify(bytes2.slice(5, 9));
      const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
      const chainCode = hexlify(bytes2.slice(13, 45));
      const key = bytes2.slice(45, 78);
      if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
        );
      }
      if (isPublicExtendedKey(bytes2)) {
        if (key[0] !== 3) {
          throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
        }
        return new HDWallet({
          publicKey: key,
          chainCode,
          index,
          depth,
          parentFingerprint
        });
      }
      if (key[0] !== 0) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
      }
      return new HDWallet({
        privateKey: key.slice(1),
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
  };
  var hdwallet_default = HDWallet;
  var WalletLocked = class extends Account {
    /**
     * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
     *
     * @param privateKey - The private key used to unlock the wallet.
     * @returns An instance of WalletUnlocked.
     */
    unlock(privateKey) {
      return new WalletUnlocked(privateKey, this._provider);
    }
  };
  var WalletUnlocked = class extends BaseWalletUnlocked {
    /**
     * Locks the wallet and returns an instance of WalletLocked.
     *
     * @returns An instance of WalletLocked.
     */
    lock() {
      this.signer = () => new Signer("0x00");
      return new WalletLocked(this.address, this._provider);
    }
    /**
     * Generate a new Wallet Unlocked with a random key pair.
     *
     * @param generateOptions - Options to customize the generation process (optional).
     * @returns An instance of WalletUnlocked.
     */
    static generate(generateOptions) {
      const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);
      return new WalletUnlocked(privateKey, generateOptions?.provider);
    }
    /**
     * Create a Wallet Unlocked from a seed.
     *
     * @param seed - The seed phrase.
     * @param provider - A Provider instance (optional).
     * @param path - The derivation path (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromSeed(seed, path6, provider) {
      const hdWallet = hdwallet_default.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path6 || WalletUnlocked.defaultPath);
      return new WalletUnlocked(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from a mnemonic phrase.
     *
     * @param mnemonic - The mnemonic phrase.
     * @param provider - A Provider instance (optional).
     * @param path - The derivation path (optional).
     * @param passphrase - The passphrase for the mnemonic (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromMnemonic(mnemonic, path6, passphrase, provider) {
      const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
      const hdWallet = hdwallet_default.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path6 || WalletUnlocked.defaultPath);
      return new WalletUnlocked(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an extended key.
     *
     * @param extendedKey - The extended key.
     * @param provider - A Provider instance (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromExtendedKey(extendedKey, provider) {
      const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
      return new WalletUnlocked(hdWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an encrypted JSON.
     *
     * @param jsonWallet - The encrypted JSON keystore.
     * @param password - The password to decrypt the JSON.
     * @param provider - A Provider instance (optional).
     * @returns An unlocked wallet instance.
     */
    static async fromEncryptedJson(jsonWallet, password, provider) {
      const privateKey = await decryptKeystoreWallet(jsonWallet, password);
      return new WalletUnlocked(privateKey, provider);
    }
  };
  var Wallet = class {
    /**
     * Creates a locked wallet instance from an address and a provider.
     *
     * @param address - The address of the wallet.
     * @param provider - A Provider instance (optional).
     * @returns A locked wallet instance.
     */
    static fromAddress(address, provider) {
      return new WalletLocked(address, provider);
    }
    /**
     * Creates an unlocked wallet instance from a private key and a provider.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance (optional).
     * @returns An unlocked wallet instance.
     */
    static fromPrivateKey(privateKey, provider) {
      return new WalletUnlocked(privateKey, provider);
    }
  };
  __publicField8(Wallet, "generate", WalletUnlocked.generate);
  __publicField8(Wallet, "fromSeed", WalletUnlocked.fromSeed);
  __publicField8(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
  __publicField8(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
  __publicField8(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);
  var MemoryStorage = class {
    storage = /* @__PURE__ */ new Map();
    async getItem(key) {
      const item = await this.storage.get(key);
      return item;
    }
    async setItem(key, value) {
      await this.storage.set(key, value);
    }
    async removeItem(key) {
      await this.storage.delete(key);
    }
    async clear() {
      await this.storage.clear();
    }
  };
  var _secret;
  var MnemonicVault = class {
    constructor(options) {
      __privateAdd2(this, _secret, void 0);
      __publicField8(this, "pathKey", "{}");
      __publicField8(this, "rootPath", `m/44'/1179993420'/${this.pathKey}'/0/0`);
      __publicField8(this, "numberOfAccounts", 0);
      __privateSet2(this, _secret, options.secret || mnemonic_default.generate());
      this.rootPath = options.rootPath || this.rootPath;
      this.numberOfAccounts = options.numberOfAccounts || 1;
    }
    getDerivePath(index) {
      if (this.rootPath.includes(this.pathKey)) {
        return this.rootPath.replace(this.pathKey, String(index));
      }
      return `${this.rootPath}/${index}`;
    }
    serialize() {
      return {
        secret: __privateGet2(this, _secret),
        rootPath: this.rootPath,
        numberOfAccounts: this.numberOfAccounts
      };
    }
    getAccounts() {
      const accounts = [];
      let numberOfAccounts = 0;
      do {
        const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(numberOfAccounts));
        accounts.push({
          publicKey: wallet.publicKey,
          address: wallet.address
        });
        numberOfAccounts += 1;
      } while (numberOfAccounts < this.numberOfAccounts);
      return accounts;
    }
    addAccount() {
      this.numberOfAccounts += 1;
      const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(this.numberOfAccounts - 1));
      return {
        publicKey: wallet.publicKey,
        address: wallet.address
      };
    }
    exportAccount(address) {
      let numberOfAccounts = 0;
      const ownerAddress = Address.fromAddressOrString(address);
      do {
        const wallet = Wallet.fromMnemonic(__privateGet2(this, _secret), this.getDerivePath(numberOfAccounts));
        if (wallet.address.equals(ownerAddress)) {
          return wallet.privateKey;
        }
        numberOfAccounts += 1;
      } while (numberOfAccounts < this.numberOfAccounts);
      throw new FuelError(
        ErrorCode.WALLET_MANAGER_ERROR,
        `Account with address '${address}' not found in derived wallets.`
      );
    }
    getWallet(address) {
      const privateKey = this.exportAccount(address);
      return Wallet.fromPrivateKey(privateKey);
    }
  };
  _secret = /* @__PURE__ */ new WeakMap();
  __publicField8(MnemonicVault, "type", "mnemonic");
  var _privateKeys;
  var PrivateKeyVault = class {
    /**
     * If privateKey vault is initialized with a secretKey, it creates
     * one account with the fallowing secret
     */
    constructor(options = {}) {
      __privateAdd2(this, _privateKeys, []);
      if (options.secret) {
        __privateSet2(this, _privateKeys, [options.secret]);
      } else {
        __privateSet2(this, _privateKeys, options.accounts || [Wallet.generate().privateKey]);
      }
    }
    serialize() {
      return {
        accounts: __privateGet2(this, _privateKeys)
      };
    }
    getPublicAccount(privateKey) {
      const wallet = Wallet.fromPrivateKey(privateKey);
      return {
        address: wallet.address,
        publicKey: wallet.publicKey
      };
    }
    getAccounts() {
      return __privateGet2(this, _privateKeys).map((pk) => this.getPublicAccount(pk));
    }
    addAccount() {
      const wallet = Wallet.generate();
      __privateGet2(this, _privateKeys).push(wallet.privateKey);
      return this.getPublicAccount(wallet.privateKey);
    }
    exportAccount(address) {
      const ownerAddress = Address.fromAddressOrString(address);
      const privateKey = __privateGet2(this, _privateKeys).find(
        (pk) => Wallet.fromPrivateKey(pk).address.equals(ownerAddress)
      );
      if (!privateKey) {
        throw new FuelError(
          ErrorCode.WALLET_MANAGER_ERROR,
          `No private key found for address '${address}'.`
        );
      }
      return privateKey;
    }
    getWallet(address) {
      const privateKey = this.exportAccount(address);
      return Wallet.fromPrivateKey(privateKey);
    }
  };
  _privateKeys = /* @__PURE__ */ new WeakMap();
  __publicField8(PrivateKeyVault, "type", "privateKey");
  var ERROR_MESSAGES = {
    invalid_vault_type: "The provided Vault type is invalid.",
    address_not_found: "No private key found for address the specified wallet address.",
    vault_not_found: "The specified vault was not found.",
    wallet_not_unlocked: "The wallet is currently locked.",
    passphrase_not_match: "The provided passphrase did not match the expected value."
  };
  function assert(condition, message) {
    if (!condition) {
      throw new FuelError(ErrorCode.WALLET_MANAGER_ERROR, message);
    }
  }
  var _vaults;
  var _passphrase;
  var _isLocked;
  var _serializeVaults;
  var serializeVaults_fn;
  var _deserializeVaults;
  var deserializeVaults_fn;
  var _WalletManager = class extends import_events.EventEmitter {
    constructor(options) {
      super();
      __privateAdd2(this, _serializeVaults);
      __privateAdd2(this, _deserializeVaults);
      __publicField8(this, "storage", new MemoryStorage());
      __publicField8(this, "STORAGE_KEY", "WalletManager");
      __privateAdd2(this, _vaults, []);
      __privateAdd2(this, _passphrase, "");
      __privateAdd2(this, _isLocked, true);
      this.storage = options?.storage || this.storage;
    }
    get isLocked() {
      return __privateGet2(this, _isLocked);
    }
    /**
     * Return the vault serialized object containing all the privateKeys,
     * the format of the return depends on the Vault type.
     */
    exportVault(vaultId) {
      assert(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
      const vaultState = __privateGet2(this, _vaults).find((_, idx) => idx === vaultId);
      assert(vaultState, ERROR_MESSAGES.vault_not_found);
      return vaultState.vault.serialize();
    }
    /**
     * List all vaults on the Wallet Manager, this function not return secret's
     */
    getVaults() {
      return __privateGet2(this, _vaults).map((v, idx) => ({
        title: v.title,
        type: v.type,
        vaultId: idx
      }));
    }
    /**
     * List all accounts on the Wallet Manager not vault information is revealed
     */
    getAccounts() {
      return __privateGet2(this, _vaults).flatMap(
        (vaultState, vaultId) => vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))
      );
    }
    /**
     * Create a Wallet instance for the specific account
     */
    getWallet(address) {
      const ownerAddress = Address.fromAddressOrString(address);
      const vaultState = __privateGet2(this, _vaults).find(
        (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))
      );
      assert(vaultState, ERROR_MESSAGES.address_not_found);
      return vaultState.vault.getWallet(ownerAddress);
    }
    /**
     * Export specific account privateKey
     */
    exportPrivateKey(address) {
      const ownerAddress = Address.fromAddressOrString(address);
      assert(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
      const vaultState = __privateGet2(this, _vaults).find(
        (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))
      );
      assert(vaultState, ERROR_MESSAGES.address_not_found);
      return vaultState.vault.exportAccount(ownerAddress);
    }
    /**
     * Add account to a selected vault or on the first vault as default.
     * If not vaults are adds it will return error
     */
    async addAccount(options) {
      await this.loadState();
      const vaultState = __privateGet2(this, _vaults)[options?.vaultId || 0];
      await assert(vaultState, ERROR_MESSAGES.vault_not_found);
      const account = vaultState.vault.addAccount();
      await this.saveState();
      return account;
    }
    /**
     * Remove vault by index, by remove the vault you also remove all accounts
     * created by the vault.
     */
    async removeVault(index) {
      __privateGet2(this, _vaults).splice(index, 1);
      await this.saveState();
    }
    /**
     * Add Vault, the `vaultConfig.type` will look for the Vaults supported if
     * didn't found it will throw.
     */
    async addVault(vaultConfig) {
      await this.loadState();
      const Vault2 = this.getVaultClass(vaultConfig.type);
      const vault = new Vault2(vaultConfig);
      __privateSet2(this, _vaults, __privateGet2(this, _vaults).concat({
        title: vaultConfig.title,
        type: vaultConfig.type,
        vault
      }));
      await this.saveState();
    }
    /**
     * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and
     * secrets.
     */
    lock() {
      __privateSet2(this, _isLocked, true);
      __privateSet2(this, _vaults, []);
      __privateSet2(this, _passphrase, "");
      this.emit("lock");
    }
    /**
     * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.
     * Vaults with secrets are not unlocked or instantiated on this moment.
     */
    async unlock(passphrase) {
      __privateSet2(this, _passphrase, passphrase);
      __privateSet2(this, _isLocked, false);
      try {
        await this.loadState();
        this.emit("unlock");
      } catch (err2) {
        await this.lock();
        throw err2;
      }
    }
    /**
     * Update WalletManager encryption passphrase
     */
    async updatePassphrase(oldpass, newpass) {
      const isLocked = __privateGet2(this, _isLocked);
      await this.unlock(oldpass);
      __privateSet2(this, _passphrase, newpass);
      await this.saveState();
      await this.loadState();
      if (isLocked) {
        await this.lock();
      }
    }
    /**
     * Retrieve and decrypt WalletManager state from storage
     */
    async loadState() {
      await assert(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
      const data = await this.storage.getItem(this.STORAGE_KEY);
      if (data) {
        const state = await decrypt2(__privateGet2(this, _passphrase), JSON.parse(data));
        __privateSet2(this, _vaults, __privateMethod2(this, _deserializeVaults, deserializeVaults_fn).call(this, state.vaults));
      }
    }
    /**
     * Store encrypted WalletManager state on storage
     */
    async saveState() {
      await assert(!__privateGet2(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
      const encryptedData = await encrypt2(__privateGet2(this, _passphrase), {
        vaults: __privateMethod2(this, _serializeVaults, serializeVaults_fn).call(this, __privateGet2(this, _vaults))
      });
      await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));
      this.emit("update");
    }
    /**
     * Return a instantiable Class reference from `WalletManager.Vaults` supported list.
     */
    getVaultClass(type3) {
      const VaultClass = _WalletManager.Vaults.find((v) => v.type === type3);
      assert(VaultClass, ERROR_MESSAGES.invalid_vault_type);
      return VaultClass;
    }
  };
  var WalletManager = _WalletManager;
  _vaults = /* @__PURE__ */ new WeakMap();
  _passphrase = /* @__PURE__ */ new WeakMap();
  _isLocked = /* @__PURE__ */ new WeakMap();
  _serializeVaults = /* @__PURE__ */ new WeakSet();
  serializeVaults_fn = function(vaults) {
    return vaults.map(({ title, type: type3, vault }) => ({
      title,
      type: type3,
      data: vault.serialize()
    }));
  };
  _deserializeVaults = /* @__PURE__ */ new WeakSet();
  deserializeVaults_fn = function(vaults) {
    return vaults.map(({ title, type: type3, data: vaultConfig }) => {
      const VaultClass = this.getVaultClass(type3);
      return {
        title,
        type: type3,
        vault: new VaultClass(vaultConfig)
      };
    });
  };
  __publicField8(WalletManager, "Vaults", [MnemonicVault, PrivateKeyVault]);
  var Vault = class {
    constructor(_options2) {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    serialize() {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    getAccounts() {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    addAccount() {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    exportAccount(_address) {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
    getWallet(_address) {
      throw new FuelError(ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
    }
  };
  __publicField8(Vault, "type");
  var BLOB_ID_SIZE = 32;
  var REG_ADDRESS_OF_DATA_AFTER_CODE = 16;
  var REG_START_OF_LOADED_CODE = 17;
  var REG_GENERAL_USE = 18;
  var WORD_SIZE2 = 8;
  function getDataOffset(binary) {
    const OFFSET_INDEX = 8;
    const dataView = new DataView(binary.buffer, OFFSET_INDEX, 8);
    const dataOffset = dataView.getBigUint64(0, false);
    return Number(dataOffset);
  }
  function getPredicateScriptLoaderInstructions(originalBinary, blobId) {
    const { RegId: RegId2, Instruction: Instruction2 } = asm2;
    const REG_PC = RegId2.pc().to_u8();
    const REG_SP = RegId2.sp().to_u8();
    const REG_IS = RegId2.is().to_u8();
    const getInstructions2 = (numOfInstructions2) => [
      // 1. Load the blob content into memory
      // Find the start of the hardcoded blob ID, which is located after the loader code ends.
      asm2.move_(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_PC),
      // hold the address of the blob ID.
      asm2.addi(
        REG_ADDRESS_OF_DATA_AFTER_CODE,
        REG_ADDRESS_OF_DATA_AFTER_CODE,
        numOfInstructions2 * Instruction2.size()
      ),
      // The code is going to be loaded from the current value of SP onwards, save
      // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.
      asm2.move_(REG_START_OF_LOADED_CODE, REG_SP),
      // REG_GENERAL_USE to hold the size of the blob.
      asm2.bsiz(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE),
      // Push the blob contents onto the stack.
      asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 1),
      // Move on to the data section length
      asm2.addi(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_ADDRESS_OF_DATA_AFTER_CODE, BLOB_ID_SIZE),
      // load the size of the data section into REG_GENERAL_USE
      asm2.lw(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE, 0),
      // after we have read the length of the data section, we move the pointer to the actual
      // data by skipping WORD_SIZE bytes.
      asm2.addi(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_ADDRESS_OF_DATA_AFTER_CODE, WORD_SIZE2),
      // load the data section of the executable
      asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 2),
      // Jump into the memory where the contract is loaded.
      // What follows is called _jmp_mem by the sway compiler.
      // Subtract the address contained in IS because jmp will add it back.
      asm2.sub(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, REG_IS),
      // jmp will multiply by 4, so we need to divide to cancel that out.
      asm2.divi(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, 4),
      // Jump to the start of the contract we loaded.
      asm2.jmp(REG_START_OF_LOADED_CODE)
    ];
    const getInstructionsNoDataSection = (numOfInstructions2) => [
      // 1. Load the blob content into memory
      // Find the start of the hardcoded blob ID, which is located after the loader code ends.
      // 1. Load the blob content into memory
      // Find the start of the hardcoded blob ID, which is located after the loader code ends.
      asm2.move_(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_PC),
      // hold the address of the blob ID.
      asm2.addi(
        REG_ADDRESS_OF_DATA_AFTER_CODE,
        REG_ADDRESS_OF_DATA_AFTER_CODE,
        numOfInstructions2 * Instruction2.size()
      ),
      // The code is going to be loaded from the current value of SP onwards, save
      // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.
      asm2.move_(REG_START_OF_LOADED_CODE, REG_SP),
      // REG_GENERAL_USE to hold the size of the blob.
      asm2.bsiz(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE),
      // Push the blob contents onto the stack.
      asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 1),
      // Jump into the memory where the contract is loaded.
      // What follows is called _jmp_mem by the sway compiler.
      // Subtract the address contained in IS because jmp will add it back.
      asm2.sub(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, REG_IS),
      // jmp will multiply by 4, so we need to divide to cancel that out.
      asm2.divi(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, 4),
      // Jump to the start of the contract we loaded.
      asm2.jmp(REG_START_OF_LOADED_CODE)
    ];
    const offset = getDataOffset(originalBinary);
    if (originalBinary.length < offset) {
      throw new Error(
        `Data section offset is out of bounds, offset: ${offset}, binary length: ${originalBinary.length}`
      );
    }
    const dataSection = originalBinary.slice(offset);
    if (dataSection.length > 0) {
      const numOfInstructions2 = getInstructions2(0).length;
      if (numOfInstructions2 > 65535) {
        throw new Error("Too many instructions, exceeding u16::MAX.");
      }
      const instructionBytes2 = new Uint8Array(
        getInstructions2(numOfInstructions2).flatMap(
          (instruction) => Array.from(instruction.to_bytes())
        )
      );
      const blobBytes2 = new Uint8Array(blobId);
      const dataSectionLenBytes = new Uint8Array(8);
      const dataView = new DataView(dataSectionLenBytes.buffer);
      dataView.setBigUint64(0, BigInt(dataSection.length), false);
      const loaderBytecode2 = new Uint8Array([
        ...instructionBytes2,
        ...blobBytes2,
        ...dataSectionLenBytes
      ]);
      return {
        loaderBytecode: concat([loaderBytecode2, dataSection]),
        blobOffset: loaderBytecode2.length
      };
    }
    const numOfInstructions = getInstructionsNoDataSection(0).length;
    if (numOfInstructions > 65535) {
      throw new Error("Too many instructions, exceeding u16::MAX.");
    }
    const instructionBytes = new Uint8Array(
      getInstructionsNoDataSection(numOfInstructions).flatMap(
        (instruction) => Array.from(instruction.to_bytes())
      )
    );
    const blobBytes = new Uint8Array(blobId);
    const loaderBytecode = new Uint8Array([...instructionBytes, ...blobBytes]);
    return { loaderBytecode };
  }
  async function fundBlobTx(deployer, blobTxRequest) {
    let totalCost = bn(0);
    const chainInfo = await deployer.provider.getChain();
    const gasPrice = await deployer.provider.estimateGasPrice(10);
    const priceFactor = chainInfo.consensusParameters.feeParameters.gasPriceFactor;
    const minGas = blobTxRequest.calculateMinGas(chainInfo);
    const minFee = calculateGasFee({
      gasPrice,
      gas: minGas,
      priceFactor,
      tip: blobTxRequest.tip
    }).add(1);
    totalCost = totalCost.add(minFee);
    if (totalCost.gt(await deployer.getBalance())) {
      throw new FuelError(ErrorCode.FUNDS_TOO_LOW, "Insufficient balance to deploy predicate.");
    }
    const txCost = await deployer.getTransactionCost(blobTxRequest);
    blobTxRequest.maxFee = txCost.maxFee;
    return deployer.fund(blobTxRequest, txCost);
  }
  function adjustConfigurableOffsets(jsonAbi, configurableOffsetDiff) {
    const { configurables: readOnlyConfigurables } = jsonAbi;
    const configurables = [];
    readOnlyConfigurables.forEach((config) => {
      configurables.push({ ...config, offset: config.offset - configurableOffsetDiff });
    });
    return { ...jsonAbi, configurables };
  }
  async function deployScriptOrPredicate({
    deployer,
    bytecode: bytecode2,
    abi: abi2,
    loaderInstanceCallback
  }) {
    const dataSectionOffset = getDataOffset(arrayify(bytecode2));
    const byteCodeWithoutDataSection = bytecode2.slice(0, dataSectionOffset);
    const blobId = hash2(byteCodeWithoutDataSection);
    const blobTxRequest = new BlobTransactionRequest({
      blobId,
      witnessIndex: 0,
      witnesses: [byteCodeWithoutDataSection]
    });
    const { loaderBytecode, blobOffset } = getPredicateScriptLoaderInstructions(
      arrayify(bytecode2),
      arrayify(blobId)
    );
    const configurableOffsetDiff = byteCodeWithoutDataSection.length - (blobOffset || 0);
    const newAbi = adjustConfigurableOffsets(abi2, configurableOffsetDiff);
    const blobExists = (await deployer.provider.getBlobs([blobId])).length > 0;
    const loaderInstance = loaderInstanceCallback(loaderBytecode, newAbi);
    if (blobExists) {
      return {
        waitForResult: () => Promise.resolve(loaderInstance),
        blobId
      };
    }
    const fundedBlobRequest = await fundBlobTx(deployer, blobTxRequest);
    const waitForResult = async () => {
      try {
        const blobTx = await deployer.sendTransaction(fundedBlobRequest);
        const result = await blobTx.waitForResult();
        if (result.status !== "success") {
          throw new Error();
        }
      } catch (err2) {
        throw new FuelError(ErrorCode.TRANSACTION_FAILED, "Failed to deploy predicate chunk");
      }
      return loaderInstance;
    };
    return {
      waitForResult,
      blobId
    };
  }
  var getPredicateRoot = (bytecode2) => {
    const chunkSize = 16 * 1024;
    const bytes2 = arrayify(bytecode2);
    const chunks = chunkAndPadBytes(bytes2, chunkSize);
    const codeRoot = calcRoot(chunks.map((c) => hexlify(c)));
    const predicateRoot = hash2(concat(["0x4655454C", codeRoot]));
    return predicateRoot;
  };
  var Predicate = class extends Account {
    bytes;
    predicateData = [];
    interface;
    initialBytecode;
    configurableConstants;
    /**
     * Creates an instance of the Predicate class.
     *
     * @param bytecode - The bytecode of the predicate.
     * @param abi - The JSON ABI of the predicate.
     * @param provider - The provider used to interact with the blockchain.
     * @param data - The predicate input data (optional).
     * @param configurableConstants - Optional configurable constants for the predicate.
     */
    constructor({
      bytecode: bytecode2,
      abi: abi2,
      provider,
      data,
      configurableConstants
    }) {
      const { predicateBytes, predicateInterface } = Predicate.processPredicateData(
        bytecode2,
        abi2,
        configurableConstants
      );
      const address = Address.fromB256(getPredicateRoot(predicateBytes));
      super(address, provider);
      this.initialBytecode = arrayify(bytecode2);
      this.bytes = predicateBytes;
      this.interface = predicateInterface;
      this.configurableConstants = configurableConstants;
      if (data !== void 0 && data.length > 0) {
        this.predicateData = data;
      }
    }
    /**
     * Populates the transaction data with predicate data.
     *
     * @param transactionRequestLike - The transaction request-like object.
     * @returns The transaction request with predicate data.
     */
    populateTransactionPredicateData(transactionRequestLike) {
      const request = transactionRequestify(transactionRequestLike);
      const placeholderIndex = this.getIndexFromPlaceholderWitness(request);
      if (placeholderIndex !== -1) {
        request.removeWitness(placeholderIndex);
      }
      request.inputs.filter(isRequestInputCoinOrMessage).forEach((input) => {
        if (isRequestInputResourceFromOwner(input, this.address)) {
          input.predicate = hexlify(this.bytes);
          input.predicateData = hexlify(this.getPredicateData());
          input.witnessIndex = 0;
        }
      });
      return request;
    }
    /**
     * Sends a transaction with the populated predicate data.
     *
     * @param transactionRequestLike - The transaction request-like object.
     * @returns A promise that resolves to the transaction response.
     */
    sendTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      return super.sendTransaction(transactionRequest, { estimateTxDependencies: false });
    }
    /**
     * Simulates a transaction with the populated predicate data.
     *
     * @param transactionRequestLike - The transaction request-like object.
     * @returns A promise that resolves to the call result.
     */
    simulateTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      return super.simulateTransaction(transactionRequest, { estimateTxDependencies: false });
    }
    getPredicateData() {
      if (!this.predicateData.length) {
        return new Uint8Array();
      }
      const mainFn = this.interface?.functions.main;
      return mainFn?.encodeArguments(this.predicateData) || new Uint8Array();
    }
    /**
     * Creates a new Predicate instance from an existing Predicate instance.
     * @param overrides - The data and configurable constants to override.
     * @returns A new Predicate instance with the same bytecode, ABI and provider but with the ability to set the data and configurable constants.
     */
    toNewInstance(overrides = {}) {
      return new Predicate({
        bytecode: this.initialBytecode,
        abi: this.interface.jsonAbi,
        provider: this.provider,
        data: overrides.data ?? this.predicateData,
        configurableConstants: overrides.configurableConstants ?? this.configurableConstants
      });
    }
    /**
     * Processes the predicate data and returns the altered bytecode and interface.
     *
     * @param bytes - The bytes of the predicate.
     * @param jsonAbi - The JSON ABI of the predicate.
     * @param configurableConstants - Optional configurable constants for the predicate.
     * @returns An object containing the new predicate bytes and interface.
     */
    static processPredicateData(bytes2, jsonAbi, configurableConstants) {
      let predicateBytes = arrayify(bytes2);
      const abiInterface = new Interface(jsonAbi);
      if (abiInterface.functions.main === void 0) {
        throw new FuelError(
          ErrorCode.ABI_MAIN_METHOD_MISSING,
          'Cannot use ABI without "main" function.'
        );
      }
      if (configurableConstants && Object.keys(configurableConstants).length) {
        predicateBytes = Predicate.setConfigurableConstants(
          predicateBytes,
          configurableConstants,
          abiInterface
        );
      }
      return {
        predicateBytes,
        predicateInterface: abiInterface
      };
    }
    /**
     * Retrieves resources satisfying the spend query for the account.
     *
     * @param quantities - IDs of coins to exclude.
     * @param excludedIds - IDs of resources to be excluded from the query.
     * @returns A promise that resolves to an array of Resources.
     */
    async getResourcesToSpend(quantities, excludedIds) {
      const resources = await this.provider.getResourcesToSpend(
        this.address,
        quantities,
        excludedIds
      );
      return resources.map((resource) => ({
        ...resource,
        predicate: hexlify(this.bytes),
        predicateData: hexlify(this.getPredicateData())
      }));
    }
    /**
     * Generates an array of fake resources based on the provided coins.
     *
     * @param coins - An array of `FakeResources` objects representing the coins.
     * @returns An array of `Resource` objects with generated properties.
     */
    generateFakeResources(coins) {
      return super.generateFakeResources(coins).map((coin) => ({
        ...coin,
        predicate: hexlify(this.bytes),
        predicateData: hexlify(this.getPredicateData())
      }));
    }
    /**
     * Sets the configurable constants for the predicate.
     *
     * @param bytes - The bytes of the predicate.
     * @param configurableConstants - Configurable constants to be set.
     * @param abiInterface - The ABI interface of the predicate.
     * @returns The mutated bytes with the configurable constants set.
     */
    static setConfigurableConstants(bytes2, configurableConstants, abiInterface) {
      const mutatedBytes = bytes2;
      try {
        if (Object.keys(abiInterface.configurables).length === 0) {
          throw new FuelError(
            ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
            "Predicate has no configurable constants to be set"
          );
        }
        Object.entries(configurableConstants).forEach(([key, value]) => {
          if (!abiInterface?.configurables[key]) {
            throw new FuelError(
              ErrorCode.CONFIGURABLE_NOT_FOUND,
              `No configurable constant named '${key}' found in the Predicate`
            );
          }
          const { offset } = abiInterface.configurables[key];
          const encoded = abiInterface.encodeConfigurable(key, value);
          mutatedBytes.set(encoded, offset);
        });
      } catch (err2) {
        throw new FuelError(
          ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
          `Error setting configurable constants: ${err2.message}.`
        );
      }
      return mutatedBytes;
    }
    /**
     * Returns the index of the witness placeholder that was added to this predicate.
     * If no witness placeholder was added, it returns -1.
     * @param request - The transaction request.
     * @returns The index of the witness placeholder, or -1 if there is no witness placeholder.
     */
    getIndexFromPlaceholderWitness(request) {
      const predicateInputs = request.inputs.filter(isRequestInputResource).filter((input) => isRequestInputResourceFromOwner(input, this.address));
      let index = -1;
      const hasEmptyPredicateInputs = predicateInputs.find((input) => !input.predicate);
      if (hasEmptyPredicateInputs) {
        index = hasEmptyPredicateInputs.witnessIndex;
        const allInputsAreEmpty = predicateInputs.every((input) => !input.predicate);
        if (!allInputsAreEmpty) {
          const wasFilledInputAddedFirst = !!predicateInputs[0]?.predicate;
          if (wasFilledInputAddedFirst) {
            index = -1;
          }
        }
      }
      return index;
    }
    /**
     *
     * @param account - The account used to pay the deployment costs.
     * @returns The _blobId_ and a _waitForResult_ callback that returns the deployed predicate
     * once the blob deployment transaction finishes.
     *
     * The returned loader predicate will have the same configurable constants
     * as the original predicate which was used to generate the loader predicate.
     */
    async deploy(account) {
      return deployScriptOrPredicate({
        deployer: account,
        abi: this.interface.jsonAbi,
        bytecode: this.bytes,
        loaderInstanceCallback: (loaderBytecode, newAbi) => new Predicate({
          bytecode: loaderBytecode,
          abi: newAbi,
          provider: this.provider,
          data: this.predicateData
        })
      });
    }
  };
  var FuelConnectorMethods = /* @__PURE__ */ ((FuelConnectorMethods2) => {
    FuelConnectorMethods2["ping"] = "ping";
    FuelConnectorMethods2["version"] = "version";
    FuelConnectorMethods2["connect"] = "connect";
    FuelConnectorMethods2["disconnect"] = "disconnect";
    FuelConnectorMethods2["isConnected"] = "isConnected";
    FuelConnectorMethods2["accounts"] = "accounts";
    FuelConnectorMethods2["currentAccount"] = "currentAccount";
    FuelConnectorMethods2["signMessage"] = "signMessage";
    FuelConnectorMethods2["sendTransaction"] = "sendTransaction";
    FuelConnectorMethods2["assets"] = "assets";
    FuelConnectorMethods2["addAsset"] = "addAsset";
    FuelConnectorMethods2["addAssets"] = "addAssets";
    FuelConnectorMethods2["networks"] = "networks";
    FuelConnectorMethods2["currentNetwork"] = "currentNetwork";
    FuelConnectorMethods2["addNetwork"] = "addNetwork";
    FuelConnectorMethods2["selectNetwork"] = "selectNetwork";
    FuelConnectorMethods2["addABI"] = "addABI";
    FuelConnectorMethods2["getABI"] = "getABI";
    FuelConnectorMethods2["hasABI"] = "hasABI";
    return FuelConnectorMethods2;
  })(FuelConnectorMethods || {});
  var FuelConnectorEventTypes = /* @__PURE__ */ ((FuelConnectorEventTypes2) => {
    FuelConnectorEventTypes2["connectors"] = "connectors";
    FuelConnectorEventTypes2["currentConnector"] = "currentConnector";
    FuelConnectorEventTypes2["connection"] = "connection";
    FuelConnectorEventTypes2["accounts"] = "accounts";
    FuelConnectorEventTypes2["currentAccount"] = "currentAccount";
    FuelConnectorEventTypes2["networks"] = "networks";
    FuelConnectorEventTypes2["currentNetwork"] = "currentNetwork";
    FuelConnectorEventTypes2["assets"] = "assets";
    FuelConnectorEventTypes2["abis"] = "abis";
    return FuelConnectorEventTypes2;
  })(FuelConnectorEventTypes || {});
  var FuelConnectorEventType = "FuelConnector";
  var LocalStorage = class {
    storage;
    constructor(localStorage2) {
      this.storage = localStorage2;
    }
    async setItem(key, value) {
      this.storage.setItem(key, value);
    }
    async getItem(key) {
      return this.storage.getItem(key);
    }
    async removeItem(key) {
      this.storage.removeItem(key);
    }
    async clear() {
      this.storage.clear();
    }
  };
  var FuelConnector = class extends import_events2.EventEmitter {
    name = "";
    metadata = {};
    connected = false;
    installed = false;
    external = true;
    events = FuelConnectorEventTypes;
    /**
     * Should return true if the connector is loaded
     * in less then one second.
     *
     * @returns Always true.
     */
    async ping() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return the current version of the connector
     * and the network version that is compatible.
     *
     * @returns boolean - connection status.
     */
    async version() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return true if the connector is connected
     * to any of the accounts available.
     *
     * @returns The connection status.
     */
    async isConnected() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return all the accounts authorized for the
     * current connection.
     *
     * @returns The accounts addresses strings
     */
    async accounts() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should start the connection process and return
     * true if the account authorize the connection.
     *
     * and return false if the user reject the connection.
     *
     * @emits accounts
     * @returns boolean - connection status.
     */
    async connect() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should disconnect the current connection and
     * return false if the disconnection was successful.
     *
     * @emits assets connection
     * @returns The connection status.
     */
    async disconnect() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should start the sign message process and return
     * the signed message.
     *
     * @param address - The address to sign the message
     * @param message - The message to sign all text will be treated as text utf-8
     *
     * @returns Message signature
     */
    async signMessage(_address, _message) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should start the sign transaction process and return
     * the signed transaction.
     *
     * @param address - The address to sign the transaction
     * @param transaction - The transaction to sign
     *
     * @returns Transaction signature
     */
    async signTransaction(_address, _transaction) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should start the send transaction process and return
     * the transaction id submitted to the network.
     *
     * If the network is not available for the connection
     * it should throw an error to avoid the transaction
     * to be sent to the wrong network and lost.
     *
     * @param address - The address to sign the transaction
     * @param transaction - The transaction to send
     * @param params - Optional parameters to send the transaction
     * @returns The transaction id
     */
    async sendTransaction(_address, _transaction, _params) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return the current account selected inside the connector, if the account
     * is authorized for the connection.
     *
     * If the account is not authorized it should return null.
     *
     * @returns The current account selected otherwise null.
     */
    async currentAccount() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should add the assets metadata to the connector and return true if the asset
     * was added successfully.
     *
     * If the asset already exists it should throw an error.
     *
     * @emits assets
     * @param assets - The assets to add the metadata to the connection.
     * @throws Error if the asset already exists
     * @returns True if the asset was added successfully
     */
    async addAssets(_assets) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should add the asset metadata to the connector and return true if the asset
     * was added successfully.
     *
     * If the asset already exists it should throw an error.
     *
     * @emits assets
     * @param asset - The asset to add the metadata to the connection.
     * @throws Error if the asset already exists
     * @returns True if the asset was added successfully
     */
    async addAsset(_asset) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return all the assets added to the connector. If a connection is already established.
     *
     * @returns Array of assets metadata from the connector vinculated to the all accounts from a specific Wallet.
     */
    async assets() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should start the add network process and return true if the network was added successfully.
     *
     * @emits networks
     * @throws Error if the network already exists
     * @param networkUrl - The URL of the network to be added.
     * @returns Return true if the network was added successfully
     */
    async addNetwork(_networkUrl) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should start the select network process and return true if the network has change successfully.
     *
     * @emits networks
     * @throws Error if the network already exists
     * @param network - The network to be selected.
     * @returns Return true if the network was added successfully
     */
    async selectNetwork(_network) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return all the networks available from the connector. If the connection is already established.
     *
     * @returns Return all the networks added to the connector.
     */
    async networks() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return the current network selected inside the connector. Even if the connection is not established.
     *
     * @returns Return the current network selected inside the connector.
     */
    async currentNetwork() {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should add the ABI to the connector and return true if the ABI was added successfully.
     *
     * @param contractId - The contract id to add the ABI.
     * @param abi - The JSON ABI that represents a contract.
     * @returns Return true if the ABI was added successfully.
     */
    async addABI(_contractId, _abi) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.
     *
     * @param id - The contract id to get the ABI.
     * @returns The ABI if it exists, otherwise return null.
     */
    async getABI(_id) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.
     *
     * @param id - The contract id to get the abi
     * @returns Returns true if the abi exists or false if not.
     */
    async hasABI(_id) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
    }
    /**
     * Event listener for the connector.
     *
     * @param eventName - The event name to listen
     * @param listener - The listener function
     */
    on(eventName, listener) {
      super.on(eventName, listener);
      return this;
    }
  };
  function cacheFor(fn, { cache: cache22, cacheTime, key }) {
    return async (...args) => {
      if (cache22[key] && cache22[key]?.value) {
        return cache22[key]?.value;
      }
      clearTimeout(cache22[key]?.timeout);
      const result = await fn(...args);
      cache22[key] = {
        timeout: Number(
          setTimeout(() => {
            cache22[key] = null;
          }, cacheTime)
        ),
        value: result
      };
      return result;
    };
  }
  function deferPromise() {
    const defer2 = {};
    defer2.promise = new Promise((resolve10, reject) => {
      defer2.reject = reject;
      defer2.resolve = resolve10;
    });
    return defer2;
  }
  async function withTimeout(promise, timeout = 1050) {
    const timeoutPromise = new Promise((resolve10, reject) => {
      setTimeout(() => {
        reject(new FuelError(FuelError.CODES.TIMEOUT_EXCEEDED, "Promise timed out"));
      }, timeout);
    });
    return Promise.race([timeoutPromise, promise]);
  }
  var HAS_CONNECTOR_TIMEOUT = 2e3;
  var PING_CACHE_TIME = 5e3;
  var { warn: warn2 } = console;
  var _Fuel = class extends FuelConnector {
    _storage = null;
    _connectors = [];
    _targetObject = null;
    _unsubscribes = [];
    _targetUnsubscribe = () => {
    };
    _pingCache = {};
    _currentConnector;
    _initializationPromise = null;
    constructor(config = _Fuel.defaultConfig) {
      super();
      this.setMaxListeners(1e3);
      this._connectors = config.connectors ?? [];
      this._targetObject = this.getTargetObject(config.targetObject);
      this._storage = config.storage === void 0 ? this.getStorage() : config.storage;
      this.setupMethods();
      this._initializationPromise = this.initialize();
    }
    async initialize() {
      try {
        const connectResponse = this.setDefaultConnector();
        this._targetUnsubscribe = this.setupConnectorListener();
        await connectResponse;
      } catch (error3) {
        throw new FuelError(ErrorCode.INVALID_PROVIDER, "Error initializing Fuel Connector");
      }
    }
    async init() {
      await this._initializationPromise;
      return this;
    }
    /**
     * Return the target object to listen for global events.
     */
    getTargetObject(targetObject) {
      if (targetObject) {
        return targetObject;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof document !== "undefined") {
        return document;
      }
      return null;
    }
    /**
     * Return the storage used.
     */
    getStorage() {
      if (typeof window !== "undefined") {
        return new LocalStorage(window.localStorage);
      }
      return void 0;
    }
    /**
     * Setup the default connector from the storage.
     */
    async setDefaultConnector() {
      const connectorName = await this._storage?.getItem(_Fuel.STORAGE_KEY) || this._connectors[0]?.name;
      if (connectorName) {
        return this.selectConnector(connectorName, {
          emitEvents: false
        });
      }
      return void 0;
    }
    /**
     * Start listener for all the events of the current
     * connector and emit them to the Fuel instance
     */
    setupConnectorEvents(events) {
      if (!this._currentConnector) {
        return;
      }
      const currentConnector = this._currentConnector;
      this._unsubscribes.map((unSub) => unSub());
      this._unsubscribes = events.map((event) => {
        const handler = (...args) => this.emit(event, ...args);
        currentConnector.on(event, handler);
        return () => currentConnector.off(event, handler);
      });
    }
    /**
     * Call method from the current connector.
     */
    async callMethod(method, ...args) {
      const hasConnector = await this.hasConnector();
      await this.pingConnector();
      if (!this._currentConnector || !hasConnector) {
        throw new FuelError(
          ErrorCode.MISSING_CONNECTOR,
          `No connector selected for calling ${method}. Use hasConnector before executing other methods.`
        );
      }
      if (typeof this._currentConnector[method] === "function") {
        return this._currentConnector[method](...args);
      }
      return void 0;
    }
    /**
     * Create a method for each method proxy that is available on the Common interface
     * and call the method from the current connector.
     */
    setupMethods() {
      Object.values(FuelConnectorMethods).forEach((method) => {
        this[method] = async (...args) => this.callMethod(method, ...args);
      });
    }
    /**
     * Fetch the status of a connector and set the installed and connected
     * status.
     */
    async fetchConnectorStatus(connector) {
      const requestTimestamp = Date.now();
      const [isConnected, ping] = await Promise.allSettled([
        withTimeout(connector.isConnected()),
        withTimeout(this.pingConnector(connector))
      ]);
      const isStale = requestTimestamp < (connector._latestUpdate || 0);
      if (!isStale) {
        connector._latestUpdate = Date.now();
        connector.installed = ping.status === "fulfilled" && ping.value;
        connector.connected = isConnected.status === "fulfilled" && isConnected.value;
      }
      return {
        installed: connector.installed,
        connected: connector.connected
      };
    }
    /**
     * Fetch the status of all connectors and set the installed and connected
     * status.
     */
    async fetchConnectorsStatus() {
      return Promise.all(
        this._connectors.map(async (connector) => this.fetchConnectorStatus(connector))
      );
    }
    /**
     * Fetch the status of a connector and set the installed and connected
     * status. If no connector is provided it will ping the current connector.
     */
    async pingConnector(connector) {
      const curConnector = connector || this._currentConnector;
      if (!curConnector) {
        return false;
      }
      try {
        return await cacheFor(async () => withTimeout(curConnector.ping()), {
          key: curConnector.name,
          cache: this._pingCache,
          cacheTime: PING_CACHE_TIME
        })();
      } catch {
        throw new FuelError(ErrorCode.INVALID_PROVIDER, "Current connector is not available.");
      }
    }
    /**
     * Setup a listener for the FuelConnector event and add the connector
     * to the list of new connectors.
     */
    setupConnectorListener = () => {
      const { _targetObject: targetObject } = this;
      const eventName = FuelConnectorEventType;
      if (targetObject?.on) {
        targetObject.on(eventName, this.addConnector);
        return () => {
          targetObject.off?.(eventName, this.addConnector);
        };
      }
      if (targetObject?.addEventListener) {
        const handler = (e) => {
          this.addConnector(e.detail);
        };
        targetObject.addEventListener(eventName, handler);
        return () => {
          targetObject.removeEventListener?.(eventName, handler);
        };
      }
      return () => {
      };
    };
    /**
     * Add a new connector to the list of connectors.
     */
    addConnector = async (connector) => {
      if (!this.getConnector(connector)) {
        this._connectors.push(connector);
      }
      await this.fetchConnectorStatus(connector);
      this.emit(this.events.connectors, this._connectors);
      if (!this._currentConnector) {
        await this.selectConnector(connector.name, {
          emitEvents: false
        });
      }
    };
    triggerConnectorEvents = async () => {
      const [isConnected, networks, currentNetwork] = await Promise.all([
        this.isConnected(),
        this.networks(),
        this.currentNetwork()
      ]);
      this.emit(this.events.connection, isConnected);
      this.emit(this.events.networks, networks);
      this.emit(this.events.currentNetwork, currentNetwork);
      if (isConnected) {
        const [accounts, currentAccount] = await Promise.all([
          this.accounts(),
          this.currentAccount()
        ]);
        this.emit(this.events.accounts, accounts);
        this.emit(this.events.currentAccount, currentAccount);
      }
    };
    /**
     * Get a connector from the list of connectors.
     */
    getConnector = (connector) => this._connectors.find((c) => {
      const connectorName = typeof connector === "string" ? connector : connector.name;
      return c.name === connectorName || c === connector;
    }) || null;
    /**
     * Return the list of connectors with the status of installed and connected.
     */
    async connectors() {
      await this.fetchConnectorsStatus();
      return this._connectors;
    }
    /**
     * Set the current connector to be used.
     */
    async selectConnector(connectorName, options = {
      emitEvents: true
    }) {
      const connector = this.getConnector(connectorName);
      if (!connector) {
        return false;
      }
      if (this._currentConnector?.name === connectorName) {
        return true;
      }
      const { installed } = await this.fetchConnectorStatus(connector);
      if (installed) {
        this._currentConnector = connector;
        this.emit(this.events.currentConnector, connector);
        this.setupConnectorEvents(Object.values(FuelConnectorEventTypes));
        await this._storage?.setItem(_Fuel.STORAGE_KEY, connector.name);
        if (options.emitEvents) {
          this.triggerConnectorEvents();
        }
        return true;
      }
      return false;
    }
    /**
     * Return the current selected connector.
     */
    currentConnector() {
      return this._currentConnector;
    }
    /**
     * Return true if any connector is available.
     */
    async hasConnector() {
      if (this._currentConnector) {
        return true;
      }
      const defer2 = deferPromise();
      this.once(this.events.currentConnector, () => {
        defer2.resolve(true);
      });
      return withTimeout(defer2.promise, HAS_CONNECTOR_TIMEOUT).then(() => true).catch(() => false);
    }
    async hasWallet() {
      return this.hasConnector();
    }
    /**
     * Return a Fuel Provider instance with extends features to work with
     * connectors.
     *
     * @deprecated getProvider is deprecated and is going to be removed in the future, use getWallet instead.
     */
    async getProvider(providerOrNetwork) {
      warn2(
        "getProvider is deprecated and is going to be removed in the future, use getWallet instead."
      );
      return this._getProvider(providerOrNetwork);
    }
    /**
     * Return a Fuel Provider instance with extends features to work with
     * connectors.
     */
    async _getProvider(providerOrNetwork) {
      let provider;
      if (providerOrNetwork && "getTransactionResponse" in providerOrNetwork) {
        provider = providerOrNetwork;
      } else if (providerOrNetwork && "chainId" in providerOrNetwork && "url" in providerOrNetwork) {
        provider = new Provider(providerOrNetwork.url);
      } else if (!providerOrNetwork) {
        const currentNetwork = await this.currentNetwork();
        provider = new Provider(currentNetwork.url);
      } else {
        throw new FuelError(ErrorCode.INVALID_PROVIDER, "Provider is not valid.");
      }
      return provider;
    }
    /**
     * Return a Fuel Wallet Locked instance with extends features to work with
     * connectors.
     */
    async getWallet(address, providerOrNetwork) {
      const provider = await this._getProvider(providerOrNetwork);
      return new Account(address, provider, this);
    }
    /**
     * Remove all open listeners this is useful when you want to
     * remove the Fuel instance and avoid memory leaks.
     */
    unsubscribe() {
      this._unsubscribes.map((unSub) => unSub());
      this._targetUnsubscribe();
      this.removeAllListeners();
    }
    /**
     * Clean all the data from the storage.
     */
    async clean() {
      await this._storage?.removeItem(_Fuel.STORAGE_KEY);
    }
    /**
     * Removes all listeners and cleans the storage.
     */
    async destroy() {
      this.unsubscribe();
      await this.clean();
    }
  };
  var Fuel = _Fuel;
  __publicField8(Fuel, "STORAGE_KEY", "fuel-current-connector");
  __publicField8(Fuel, "defaultConfig", {});

  // ../program/dist/index.mjs
  var asm22 = __toESM(require_node(), 1);
  var asm3 = __toESM(require_node(), 1);
  var AbstractProgram = class {
  };
  function assert2(condition, message) {
    if (!condition) {
      throw new FuelError(ErrorCode.TRANSACTION_ERROR, message);
    }
  }
  function getAbisFromAllCalls(functionScopes) {
    return functionScopes.reduce((acc, funcScope, i) => {
      const { program: program2, externalAbis } = funcScope.getCallConfig();
      if (i === 0) {
        acc.main = program2.interface.jsonAbi;
        acc.otherContractsAbis = {};
      } else {
        acc.otherContractsAbis[program2.id.toB256()] = program2.interface.jsonAbi;
      }
      acc.otherContractsAbis = { ...acc.otherContractsAbis, ...externalAbis };
      return acc;
    }, {});
  }
  var getResultLogs = (receipts, mainCallConfig, functionScopes) => {
    if (!mainCallConfig) {
      return [];
    }
    const { main, otherContractsAbis } = getAbisFromAllCalls(functionScopes);
    return getDecodedLogs(receipts, main, otherContractsAbis);
  };
  var InstructionSet = class {
    #operations;
    constructor(...args) {
      this.#operations = args || [];
    }
    entries() {
      return this.#operations;
    }
    push(...args) {
      this.#operations.push(...args);
    }
    concat(ops) {
      return this.#operations.concat(ops);
    }
    extend(ops) {
      this.#operations.push(...ops);
    }
    toBytes() {
      return concat(
        this.#operations.reduce((instructions, line) => {
          instructions.push(line.to_bytes());
          return instructions;
        }, [])
      );
    }
    toHex() {
      return hexlify(this.toBytes());
    }
    toString() {
      return `Program:
${JSON.stringify(this.#operations, null, 2)}`;
    }
    byteLength() {
      return this.toBytes().byteLength;
    }
  };
  var calculateScriptDataBaseOffset = (maxInputs) => SCRIPT_FIXED_SIZE + calculateVmTxMemory({ maxInputs });
  var POINTER_DATA_OFFSET = WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;
  function callResultToScriptResult(callResult) {
    const receipts = [...callResult.receipts];
    let scriptResultReceipt;
    let returnReceipt;
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.ScriptResult) {
        scriptResultReceipt = receipt;
      } else if (receipt.type === ReceiptType.Return || receipt.type === ReceiptType.ReturnData || receipt.type === ReceiptType.Revert) {
        returnReceipt = receipt;
      }
    });
    if (!scriptResultReceipt || !returnReceipt) {
      throw new FuelError(ErrorCode.SCRIPT_REVERTED, `Transaction reverted.`);
    }
    const scriptResult = {
      code: scriptResultReceipt.result,
      gasUsed: scriptResultReceipt.gasUsed,
      receipts,
      scriptResultReceipt,
      returnReceipt,
      callResult
    };
    return scriptResult;
  }
  function decodeCallResult(callResult, decoder, logs = []) {
    try {
      const scriptResult = callResultToScriptResult(callResult);
      return decoder(scriptResult);
    } catch (error3) {
      if (error3.code === ErrorCode.SCRIPT_REVERTED) {
        const statusReason = callResult?.dryRunStatus?.reason;
        throw extractTxError({
          logs,
          receipts: callResult.receipts,
          statusReason
        });
      }
      throw error3;
    }
  }
  function callResultToInvocationResult(callResult, call2, logs) {
    return decodeCallResult(
      callResult,
      (scriptResult) => {
        if (scriptResult.returnReceipt.type === ReceiptType.Revert) {
          throw new FuelError(
            ErrorCode.SCRIPT_REVERTED,
            `Script Reverted. Logs: ${JSON.stringify(logs)}`
          );
        }
        if (scriptResult.returnReceipt.type !== ReceiptType.Return && scriptResult.returnReceipt.type !== ReceiptType.ReturnData) {
          const { type: type3 } = scriptResult.returnReceipt;
          throw new FuelError(
            ErrorCode.SCRIPT_REVERTED,
            `Script Return Type [${type3}] Invalid. Logs: ${JSON.stringify({
              logs,
              receipt: scriptResult.returnReceipt
            })}`
          );
        }
        let value;
        if (scriptResult.returnReceipt.type === ReceiptType.Return) {
          value = scriptResult.returnReceipt.val;
        }
        if (scriptResult.returnReceipt.type === ReceiptType.ReturnData) {
          const decoded = call2.func.decodeOutput(scriptResult.returnReceipt.data);
          value = decoded[0];
        }
        return value;
      },
      logs
    );
  }
  var ScriptRequest = class {
    /**
     * The bytes of the script.
     */
    bytes;
    /**
     * A function to encode the script data.
     */
    scriptDataEncoder;
    /**
     * A function to decode the script result.
     */
    scriptResultDecoder;
    /**
     * Creates an instance of the ScriptRequest class.
     *
     * @param bytes - The bytes of the script.
     * @param scriptDataEncoder - The script data encoder function.
     * @param scriptResultDecoder - The script result decoder function.
     */
    constructor(bytes2, scriptDataEncoder, scriptResultDecoder2) {
      this.bytes = arrayify(bytes2);
      this.scriptDataEncoder = scriptDataEncoder;
      this.scriptResultDecoder = scriptResultDecoder2;
    }
    /**
     * Gets the script data offset for the given bytes.
     *
     * @param byteLength - The byte length of the script.
     * @param maxInputs - The maxInputs value from the chain's consensus params.
     * @returns The script data offset.
     */
    static getScriptDataOffsetWithScriptBytes(byteLength, maxInputs) {
      const scriptDataBaseOffset = calculateVmTxMemory({ maxInputs }) + SCRIPT_FIXED_SIZE;
      return scriptDataBaseOffset + byteLength;
    }
    /**
     * Gets the script data offset.
     *
     * @param maxInputs - The maxInputs value from the chain's consensus params.
     * @returns The script data offset.
     */
    getScriptDataOffset(maxInputs) {
      return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);
    }
    /**
     * Encodes the data for a script call.
     *
     * @param data - The script data.
     * @returns The encoded data.
     */
    encodeScriptData(data) {
      const callScript = this.scriptDataEncoder(data);
      if (ArrayBuffer.isView(callScript)) {
        return callScript;
      }
      this.bytes = arrayify(callScript.script);
      return callScript.data;
    }
    /**
     * Decodes the result of a script call.
     *
     * @param callResult - The CallResult from the script call.
     * @param logs - Optional logs associated with the decoding.
     * @returns The decoded result.
     */
    decodeCallResult(callResult, logs = []) {
      return decodeCallResult(callResult, this.scriptResultDecoder, logs);
    }
  };
  var DEFAULT_OPCODE_PARAMS = {
    assetIdOffset: 0,
    amountOffset: 0,
    gasForwardedOffset: 0,
    callDataOffset: 0
  };
  var SCRIPT_WRAPPER_CONTRACT_ID = ZeroBytes32;
  var getSingleCallInstructions = ({
    callDataOffset,
    gasForwardedOffset,
    amountOffset,
    assetIdOffset
  }) => {
    const inst = new InstructionSet(
      asm3.movi(16, callDataOffset),
      asm3.movi(17, amountOffset),
      asm3.lw(17, 17, 0),
      asm3.movi(18, assetIdOffset)
    );
    if (gasForwardedOffset) {
      inst.push(
        asm3.movi(19, gasForwardedOffset),
        asm3.lw(19, 19, 0),
        asm3.call(16, 17, 18, 19)
      );
    } else {
      inst.push(asm3.call(16, 17, 18, asm3.RegId.cgas().to_u8()));
    }
    return inst;
  };
  function getInstructions(offsets) {
    if (!offsets.length) {
      return new Uint8Array();
    }
    const multiCallInstructions = new InstructionSet();
    for (let i = 0; i < offsets.length; i += 1) {
      multiCallInstructions.extend(getSingleCallInstructions(offsets[i]).entries());
    }
    multiCallInstructions.push(asm3.ret(1));
    return multiCallInstructions.toBytes();
  }
  var isReturnType = (type3) => type3 === ReceiptType.Return || type3 === ReceiptType.ReturnData;
  var getMainCallReceipt = (receipts, contractId) => receipts.find(
    ({ type: type3, id, to }) => type3 === ReceiptType.Call && id === SCRIPT_WRAPPER_CONTRACT_ID && to === contractId
  );
  var scriptResultDecoder = (contractId) => (result) => {
    if (toNumber(result.code) !== 0) {
      throw new FuelError(ErrorCode.SCRIPT_REVERTED, `Transaction reverted.`);
    }
    const mainCallResult = getMainCallReceipt(
      result.receipts,
      contractId.toB256()
    );
    const mainCallInstructionStart = bn(mainCallResult?.is);
    const receipts = result.receipts;
    return receipts.filter(({ type: type3 }) => isReturnType(type3)).flatMap((receipt) => {
      if (!mainCallInstructionStart.eq(bn(receipt.is))) {
        return [];
      }
      if (receipt.type === ReceiptType.Return) {
        return [new BigNumberCoder("u64").encode(receipt.val)];
      }
      if (receipt.type === ReceiptType.ReturnData) {
        const encodedScriptReturn = arrayify(receipt.data);
        return [encodedScriptReturn];
      }
      return [new Uint8Array()];
    });
  };
  var decodeContractCallScriptResult = (callResult, contractId, logs = []) => decodeCallResult(callResult, scriptResultDecoder(contractId), logs);
  var getCallInstructionsLength = (contractCalls) => contractCalls.reduce(
    (sum, call2) => {
      const offset = { ...DEFAULT_OPCODE_PARAMS };
      if (call2.gas) {
        offset.gasForwardedOffset = 1;
      }
      return sum + getSingleCallInstructions(offset).byteLength();
    },
    asm3.Instruction.size()
    // placeholder for single RET instruction which is added later
  );
  var getContractCallScript = (functionScopes, maxInputs) => new ScriptRequest(
    // Script to call the contract, start with stub size matching length of calls
    getInstructions(new Array(functionScopes.length).fill(DEFAULT_OPCODE_PARAMS)),
    (contractCalls) => {
      const TOTAL_CALLS = contractCalls.length;
      if (TOTAL_CALLS === 0) {
        return { data: new Uint8Array(), script: new Uint8Array() };
      }
      const callInstructionsLength = getCallInstructionsLength(contractCalls);
      const paddingLength = (8 - callInstructionsLength % 8) % 8;
      const paddedInstructionsLength = callInstructionsLength + paddingLength;
      const dataOffset = calculateScriptDataBaseOffset(maxInputs.toNumber()) + paddedInstructionsLength;
      const paramOffsets = [];
      let segmentOffset = dataOffset;
      const scriptData = [];
      for (let i = 0; i < TOTAL_CALLS; i += 1) {
        const call2 = contractCalls[i];
        const amountOffset = segmentOffset;
        const assetIdOffset = amountOffset + WORD_SIZE;
        const callDataOffset = assetIdOffset + ASSET_ID_LEN;
        const encodedSelectorOffset = callDataOffset + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;
        const encodedArgsOffset = encodedSelectorOffset + call2.fnSelectorBytes.byteLength;
        const encodedArgs = arrayify(call2.data);
        let gasForwardedOffset = 0;
        scriptData.push(new BigNumberCoder("u64").encode(call2.amount || 0));
        scriptData.push(new B256Coder().encode(call2.assetId?.toString() || ZeroBytes32));
        scriptData.push(call2.contractId.toBytes());
        scriptData.push(new BigNumberCoder("u64").encode(encodedSelectorOffset));
        scriptData.push(new BigNumberCoder("u64").encode(encodedArgsOffset));
        scriptData.push(call2.fnSelectorBytes);
        scriptData.push(encodedArgs);
        if (call2.gas) {
          scriptData.push(new BigNumberCoder("u64").encode(call2.gas));
          gasForwardedOffset = encodedArgsOffset + encodedArgs.byteLength;
        }
        const callParamOffsets = {
          amountOffset,
          assetIdOffset,
          gasForwardedOffset,
          callDataOffset
        };
        paramOffsets.push(callParamOffsets);
        segmentOffset = dataOffset + concat(scriptData).byteLength;
      }
      const script = getInstructions(paramOffsets);
      const finalScriptData = concat(scriptData);
      return { data: finalScriptData, script };
    },
    () => [new Uint8Array()]
  );
  var extractInvocationResult = (functionScopes, receipts, isMultiCall, logs) => {
    const mainCallConfig = functionScopes[0]?.getCallConfig();
    if (functionScopes.length === 1 && mainCallConfig && "bytes" in mainCallConfig.program) {
      return callResultToInvocationResult({ receipts }, mainCallConfig, logs);
    }
    const encodedResults = decodeContractCallScriptResult(
      { receipts },
      (mainCallConfig?.program).id,
      logs
    );
    const decodedResults = encodedResults.map((encodedResult, i) => {
      const { func } = functionScopes[i].getCallConfig();
      return func.decodeOutput(encodedResult)?.[0];
    });
    return isMultiCall ? decodedResults : decodedResults?.[0];
  };
  var buildFunctionResult = async (params) => {
    const { funcScope, isMultiCall, program: program2, transactionResponse } = params;
    const txResult = await transactionResponse.waitForResult();
    const { receipts } = txResult;
    const functionScopes = Array.isArray(funcScope) ? funcScope : [funcScope];
    const mainCallConfig = functionScopes[0]?.getCallConfig();
    const logs = getResultLogs(receipts, mainCallConfig, functionScopes);
    const value = extractInvocationResult(functionScopes, receipts, isMultiCall, logs);
    const gasUsed = getGasUsedFromReceipts(receipts);
    const submitResult = {
      isMultiCall,
      functionScopes,
      value,
      program: program2,
      transactionResult: txResult,
      transactionResponse,
      transactionId: transactionResponse.id,
      logs,
      gasUsed
    };
    return submitResult;
  };
  var buildDryRunResult = (params) => {
    const { funcScopes, callResult, isMultiCall } = params;
    const { receipts } = callResult;
    const functionScopes = Array.isArray(funcScopes) ? funcScopes : [funcScopes];
    const mainCallConfig = functionScopes[0]?.getCallConfig();
    const logs = getResultLogs(receipts, mainCallConfig, functionScopes);
    const value = extractInvocationResult(functionScopes, receipts, isMultiCall, logs);
    const gasUsed = getGasUsedFromReceipts(receipts);
    const submitResult = {
      functionScopes,
      callResult,
      isMultiCall,
      gasUsed,
      value
    };
    return submitResult;
  };
  function createContractCall(funcScope) {
    const { program: program2, args, forward, func, callParameters, externalAbis } = funcScope.getCallConfig();
    const data = func.encodeArguments(args);
    return {
      contractId: program2.id,
      fnSelectorBytes: func.selectorBytes,
      data,
      assetId: forward?.assetId,
      amount: forward?.amount,
      gas: callParameters?.gasLimit,
      externalContractsAbis: externalAbis
    };
  }
  var BaseInvocationScope = class {
    transactionRequest;
    program;
    functionInvocationScopes = [];
    txParameters;
    requiredCoins = [];
    isMultiCall = false;
    hasCallParamsGasLimit = false;
    // flag to check if any of the callParams has gasLimit set
    externalAbis = {};
    addSignersCallback;
    /**
     * Constructs an instance of BaseInvocationScope.
     *
     * @param program - The abstract program to be invoked.
     * @param isMultiCall - A flag indicating whether the invocation is a multi-call.
     */
    constructor(program2, isMultiCall) {
      this.program = program2;
      this.isMultiCall = isMultiCall;
      this.transactionRequest = new ScriptTransactionRequest();
    }
    /**
     * Getter for the contract calls.
     *
     * @returns An array of contract calls.
     */
    get calls() {
      return this.functionInvocationScopes.map((funcScope) => createContractCall(funcScope));
    }
    /**
     * Updates the script request with the current contract calls.
     */
    async updateScriptRequest() {
      const provider = this.getProvider();
      const {
        consensusParameters: {
          txParameters: { maxInputs }
        }
      } = await provider.getChain();
      const contractCallScript = getContractCallScript(this.functionInvocationScopes, maxInputs);
      this.transactionRequest.setScript(contractCallScript, this.calls);
    }
    /**
     * Updates the transaction request with the current input/output.
     */
    updateContractInputAndOutput() {
      const calls = this.calls;
      calls.forEach((c) => {
        if (c.contractId) {
          this.transactionRequest.addContractInputAndOutput(c.contractId);
        }
        if (c.externalContractsAbis) {
          Object.keys(c.externalContractsAbis).forEach(
            (contractId) => this.transactionRequest.addContractInputAndOutput(Address.fromB256(contractId))
          );
        }
      });
    }
    /**
     * Gets the required coins for the transaction.
     *
     * @returns An array of required coin quantities.
     */
    getRequiredCoins() {
      const forwardingAssets = this.calls.map((call2) => ({
        assetId: String(call2.assetId),
        amount: bn(call2.amount || 0)
      })).filter(({ assetId, amount }) => assetId && !bn(amount).isZero());
      return forwardingAssets;
    }
    /**
     * Updates the required coins for the transaction.
     */
    updateRequiredCoins() {
      const assets3 = this.getRequiredCoins();
      const reduceForwardCoins = (requiredCoins, { assetId, amount }) => {
        const currentAmount = requiredCoins.get(assetId)?.amount || bn(0);
        return requiredCoins.set(assetId, {
          assetId: String(assetId),
          amount: currentAmount.add(amount)
        });
      };
      this.requiredCoins = Array.from(
        assets3.reduce(reduceForwardCoins, /* @__PURE__ */ new Map()).values()
      );
    }
    /**
     * Adds a single call to the invocation scope.
     *
     * @param funcScope - The function scope to add.
     * @returns The current instance of the class.
     */
    addCall(funcScope) {
      this.addCalls([funcScope]);
      return this;
    }
    /**
     * Adds multiple calls to the invocation scope.
     *
     * @param funcScopes - An array of function scopes to add.
     * @returns The current instance of the class.
     */
    addCalls(funcScopes) {
      this.functionInvocationScopes.push(...funcScopes);
      this.updateContractInputAndOutput();
      this.updateRequiredCoins();
      return this;
    }
    /**
     * Prepares the transaction by updating the script request, required coins, and checking the gas limit.
     */
    async prepareTransaction() {
      await asm22.initWasm();
      await this.updateScriptRequest();
      this.updateRequiredCoins();
      this.checkGasLimitTotal();
      if (this.transactionRequest.type === TransactionType.Script) {
        this.transactionRequest.abis = getAbisFromAllCalls(this.functionInvocationScopes);
      }
    }
    /**
     * Checks if the total gas limit is within the acceptable range.
     */
    checkGasLimitTotal() {
      const gasLimitOnCalls = this.calls.reduce((total, call2) => total.add(call2.gas || 0), bn(0));
      if (this.transactionRequest.gasLimit.eq(0)) {
        this.transactionRequest.gasLimit = gasLimitOnCalls;
      } else if (gasLimitOnCalls.gt(this.transactionRequest.gasLimit)) {
        throw new FuelError(
          ErrorCode.TRANSACTION_ERROR,
          "Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls."
        );
      }
    }
    /**
     * Gets the transaction cost for dry running the transaction.
     *
     * @param options - Optional transaction cost options.
     * @returns The transaction cost details.
     */
    async getTransactionCost() {
      const request = clone_default(await this.getTransactionRequest());
      const account = this.program.account ?? Wallet.generate({ provider: this.getProvider() });
      return account.getTransactionCost(request, {
        quantities: this.getRequiredCoins(),
        signatureCallback: this.addSignersCallback
      });
    }
    /**
     * Costs and funds the underlying transaction request.
     *
     * @returns The invocation scope as a funded transaction request.
     */
    async fundWithRequiredCoins() {
      let transactionRequest = await this.getTransactionRequest();
      transactionRequest = clone_default(transactionRequest);
      const txCost = await this.getTransactionCost();
      const { gasUsed, missingContractIds, outputVariables, maxFee } = txCost;
      this.setDefaultTxParams(transactionRequest, gasUsed, maxFee);
      transactionRequest.inputs = transactionRequest.inputs.filter((i) => i.type !== InputType.Coin);
      missingContractIds.forEach((contractId) => {
        transactionRequest.addContractInputAndOutput(Address.fromString(contractId));
      });
      transactionRequest.addVariableOutputs(outputVariables);
      await this.program.account?.fund(transactionRequest, txCost);
      if (this.addSignersCallback) {
        await this.addSignersCallback(transactionRequest);
      }
      return transactionRequest;
    }
    /**
     * Sets the transaction parameters.
     *
     * @param txParams - The transaction parameters to set.
     * @returns The current instance of the class.
     */
    txParams(txParams) {
      this.txParameters = txParams;
      const request = this.transactionRequest;
      request.tip = bn(txParams.tip || request.tip);
      request.gasLimit = bn(txParams.gasLimit || request.gasLimit);
      request.maxFee = txParams.maxFee ? bn(txParams.maxFee) : request.maxFee;
      request.witnessLimit = txParams.witnessLimit ? bn(txParams.witnessLimit) : request.witnessLimit;
      request.maturity = txParams.maturity || request.maturity;
      request.addVariableOutputs(this.txParameters?.variableOutputs || 0);
      return this;
    }
    /**
     * Adds contracts to the invocation scope.
     *
     * @param contracts - An array of contracts to add.
     * @returns The current instance of the class.
     */
    addContracts(contracts) {
      contracts.forEach((contract) => {
        this.transactionRequest.addContractInputAndOutput(contract.id);
        this.externalAbis[contract.id.toB256()] = contract.interface.jsonAbi;
      });
      return this;
    }
    /**
     * Adds an asset transfer to an Account on the contract call transaction request.
     *
     * @param transferParams - The object representing the transfer to be made.
     * @returns The current instance of the class.
     */
    addTransfer(transferParams) {
      const { amount, destination, assetId } = transferParams;
      this.transactionRequest = this.transactionRequest.addCoinOutput(
        Address.fromAddressOrString(destination),
        amount,
        assetId
      );
      return this;
    }
    /**
     * Adds multiple transfers to the contract call transaction request.
     *
     * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
     * @returns The current instance of the class.
     */
    addBatchTransfer(transferParams) {
      transferParams.forEach(({ destination, amount, assetId }) => {
        this.transactionRequest = this.transactionRequest.addCoinOutput(
          Address.fromAddressOrString(destination),
          amount,
          assetId
        );
      });
      return this;
    }
    addSigners(signers) {
      this.addSignersCallback = (transactionRequest) => transactionRequest.addAccountWitnesses(signers);
      return this;
    }
    /**
     * Prepares and returns the transaction request object.
     *
     * @returns The prepared transaction request.
     */
    async getTransactionRequest() {
      await this.prepareTransaction();
      return this.transactionRequest;
    }
    /**
     * Submits the contract call transaction and returns a promise that resolves to an object
     * containing the transaction ID and a function to wait for the result. The promise will resolve
     * as soon as the transaction is submitted to the node.
     *
     * @returns A promise that resolves to an object containing:
     * - `transactionId`: The ID of the submitted transaction.
     * - `waitForResult`: A function that waits for the transaction result.
     * @template T - The type of the return value.
     */
    async call() {
      assert2(this.program.account, "Wallet is required!");
      const transactionRequest = await this.fundWithRequiredCoins();
      const response = await this.program.account.sendTransaction(transactionRequest, {
        estimateTxDependencies: false
      });
      const transactionId = response.id;
      return {
        transactionId,
        waitForResult: async () => buildFunctionResult({
          funcScope: this.functionInvocationScopes,
          isMultiCall: this.isMultiCall,
          program: this.program,
          transactionResponse: response
        })
      };
    }
    /**
     * Simulates a transaction.
     *
     * @returns The result of the invocation call.
     */
    async simulate() {
      assert2(this.program.account, "Wallet is required!");
      if (!("populateTransactionWitnessesSignature" in this.program.account)) {
        throw new FuelError(
          ErrorCode.ABI_MAIN_METHOD_MISSING,
          "An unlocked wallet is required to simulate a contract call."
        );
      }
      const transactionRequest = await this.fundWithRequiredCoins();
      const callResult = await this.program.account.simulateTransaction(transactionRequest, {
        estimateTxDependencies: false
      });
      return buildDryRunResult({
        funcScopes: this.functionInvocationScopes,
        callResult,
        isMultiCall: this.isMultiCall
      });
    }
    /**
     * Executes a transaction in dry run mode.
     *
     * @returns The result of the invocation call.
     */
    async dryRun() {
      const { receipts } = await this.getTransactionCost();
      const callResult = {
        receipts
      };
      return buildDryRunResult({
        funcScopes: this.functionInvocationScopes,
        callResult,
        isMultiCall: this.isMultiCall
      });
    }
    async get() {
      const { receipts } = await this.getTransactionCost();
      const callResult = {
        receipts
      };
      return buildDryRunResult({
        funcScopes: this.functionInvocationScopes,
        callResult,
        isMultiCall: this.isMultiCall
      });
    }
    getProvider() {
      const provider = this.program.provider;
      return provider;
    }
    /**
     * Obtains the ID of a transaction.
     *
     * @param chainId - the chainId to use to hash the transaction with
     * @returns the ID of the transaction.
     */
    async getTransactionId(chainId) {
      const chainIdToHash = chainId ?? await this.getProvider().getChainId();
      const transactionRequest = await this.getTransactionRequest();
      return transactionRequest.getTransactionId(chainIdToHash);
    }
    /**
     * In case the gasLimit is *not* set by the user, this method sets a default value.
     */
    setDefaultTxParams(transactionRequest, gasUsed, maxFee) {
      const gasLimitSpecified = isDefined(this.txParameters?.gasLimit) || this.hasCallParamsGasLimit;
      const maxFeeSpecified = isDefined(this.txParameters?.maxFee);
      const { gasLimit: setGasLimit, maxFee: setMaxFee } = transactionRequest;
      if (!gasLimitSpecified) {
        transactionRequest.gasLimit = gasUsed;
      } else if (setGasLimit.lt(gasUsed)) {
        throw new FuelError(
          ErrorCode.GAS_LIMIT_TOO_LOW,
          `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`
        );
      }
      if (!maxFeeSpecified) {
        transactionRequest.maxFee = maxFee;
      } else if (maxFee.gt(setMaxFee)) {
        throw new FuelError(
          ErrorCode.MAX_FEE_TOO_LOW,
          `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`
        );
      }
    }
  };
  var FunctionInvocationScope = class extends BaseInvocationScope {
    func;
    callParameters;
    forward;
    args;
    /**
     * Constructs an instance of FunctionInvocationScope.
     *
     * @param program - The program.
     * @param func - The function fragment.
     * @param args - The arguments.
     */
    constructor(program2, func, args) {
      super(program2, false);
      this.func = func;
      this.args = args || [];
      this.setArguments(...args);
      super.addCall(this);
    }
    /**
     * Gets the call configuration.
     *
     * @returns The call configuration.
     */
    getCallConfig() {
      return {
        func: this.func,
        program: this.program,
        callParameters: this.callParameters,
        txParameters: this.txParameters,
        forward: this.forward,
        args: this.args,
        externalAbis: this.externalAbis
      };
    }
    /**
     * Sets the arguments for the function invocation.
     *
     * @param args - The arguments.
     * @returns The instance of FunctionInvocationScope.
     */
    setArguments(...args) {
      this.args = args || [];
      return this;
    }
    /**
     * Sets the call parameters for the function invocation.
     *
     * @param callParams - The call parameters.
     * @returns The instance of FunctionInvocationScope.
     * @throws If the function is not payable and forward is set.
     */
    callParams(callParams) {
      if (!this.hasCallParamsGasLimit && callParams?.gasLimit !== void 0) {
        this.hasCallParamsGasLimit = true;
      }
      this.callParameters = callParams;
      if (callParams?.forward) {
        if (!this.func.attributes.find((attr) => attr.name === "payable")) {
          throw new FuelError(
            ErrorCode.TRANSACTION_ERROR,
            `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`
          );
        }
        this.forward = coinQuantityfy(callParams.forward);
      }
      this.setArguments(...this.args);
      this.updateRequiredCoins();
      return this;
    }
  };
  var MultiCallInvocationScope = class extends BaseInvocationScope {
    /**
     * Constructs an instance of MultiCallInvocationScope.
     *
     * @param contract - The contract.
     * @param funcScopes - An array of function invocation scopes.
     */
    constructor(contract, funcScopes) {
      super(contract, true);
      this.addCalls(funcScopes);
    }
    /**
     * Adds a single function invocation scope to the multi-call invocation scope.
     *
     * @param funcScope - The function invocation scope.
     * @returns The instance of MultiCallInvocationScope.
     */
    addCall(funcScope) {
      return super.addCalls([funcScope]);
    }
    /**
     * Adds multiple function invocation scopes to the multi-call invocation scope.
     *
     * @param funcScopes - An array of function invocation scopes.
     * @returns The instance of MultiCallInvocationScope.
     */
    addCalls(funcScopes) {
      return super.addCalls(funcScopes);
    }
  };
  var Contract = class {
    /**
     * The unique contract identifier.
     */
    id;
    /**
     * The provider for interacting with the contract.
     */
    provider;
    /**
     * The contract's ABI interface.
     */
    interface;
    /**
     * The account associated with the contract, if available.
     */
    account;
    /**
     * A collection of functions available on the contract.
     */
    functions = {};
    /**
     * Creates an instance of the Contract class.
     *
     * @param id - The contract's address.
     * @param abi - The contract's ABI (JSON ABI or Interface instance).
     * @param accountOrProvider - The account or provider for interaction.
     */
    constructor(id, abi2, accountOrProvider) {
      this.interface = abi2 instanceof Interface ? abi2 : new Interface(abi2);
      this.id = Address.fromAddressOrString(id);
      if (accountOrProvider && "provider" in accountOrProvider) {
        this.provider = accountOrProvider.provider;
        this.account = accountOrProvider;
      } else {
        this.provider = accountOrProvider;
        this.account = null;
      }
      Object.keys(this.interface.functions).forEach((name) => {
        const fragment = this.interface.getFunction(name);
        Object.defineProperty(this.functions, fragment.name, {
          value: this.buildFunction(fragment),
          writable: false
        });
      });
    }
    /**
     * Build a function invocation scope for the provided function fragment.
     *
     * @param func - The function fragment to build a scope for.
     * @returns A function that creates a FunctionInvocationScope.
     */
    buildFunction(func) {
      return (() => {
        const funcInvocationScopeCreator = (...args) => new FunctionInvocationScope(this, func, args);
        Object.defineProperty(funcInvocationScopeCreator, "isReadOnly", {
          value: () => func.isReadOnly(),
          writable: false
        });
        return funcInvocationScopeCreator;
      })();
    }
    /**
     * Create a multi-call invocation scope for the provided function invocation scopes.
     *
     * @param calls - An array of FunctionInvocationScopes to execute in a batch.
     * @returns A MultiCallInvocationScope instance.
     */
    multiCall(calls) {
      return new MultiCallInvocationScope(this, calls);
    }
    /**
     * Get the balance for a given asset ID for this contract.
     *
     * @param assetId - The specified asset ID.
     * @returns The balance of the contract for the specified asset.
     */
    getBalance(assetId) {
      return this.provider.getContractBalance(this.id, assetId);
    }
  };

  // ../contract/dist/index.mjs
  var asm4 = __toESM(require_node(), 1);
  var __defProp9 = Object.defineProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp9(target, name, { get: all[name], enumerable: true });
  };
  var getLoaderInstructions = (blobIds) => {
    const { RegId: RegId2, Instruction: Instruction2 } = asm4;
    const numberOfInstructions = 12;
    const numberOfBlobs = blobIds.length;
    const blobIdSize = BYTES_32;
    const blobIdBytes = concat(blobIds.map((b) => arrayify(b)));
    const instructionBytes = new InstructionSet(
      // 1. load the blob contents into memory
      // find the start of the hardcoded blob ids, which are located after the code ends
      asm4.move_(16, RegId2.pc().to_u8()),
      // 0x10 to hold the address of the current blob id
      asm4.addi(16, 16, numberOfInstructions * Instruction2.size()),
      // The contract is going to be loaded from the current value of SP onwards, save
      // the location into 0x16 so we can jump into it later on
      asm4.move_(22, RegId2.sp().to_u8()),
      // loop counter
      asm4.movi(19, numberOfBlobs),
      // LOOP starts here
      // 0x11 to hold the size of the current blob
      asm4.bsiz(17, 16),
      // push the blob contents onto the stack
      asm4.ldc(16, 0, 17, 1),
      // move on to the next blob
      asm4.addi(16, 16, blobIdSize),
      // decrement the loop counter
      asm4.subi(19, 19, 1),
      // Jump backwards (3+1) instructions if the counter has not reached 0
      asm4.jnzb(19, RegId2.zero().to_u8(), 3),
      // Jump into the memory where the contract is loaded
      // what follows is called _jmp_mem by the sway compiler
      // subtract the address contained in IS because jmp will add it back
      asm4.sub(22, 22, RegId2.is().to_u8()),
      // jmp will multiply by 4 so we need to divide to cancel that out
      asm4.divi(22, 22, 4),
      // jump to the start of the contract we loaded
      asm4.jmp(22)
    ).toBytes();
    return concat([instructionBytes, blobIdBytes]);
  };
  var getContractChunks = (bytecode2, chunkSize) => {
    const chunks = [];
    for (let offset = 0, index = 0; offset < bytecode2.length; offset += chunkSize, index++) {
      let chunk = bytecode2.slice(offset, offset + chunkSize);
      let length = chunk.length;
      if (length % WORD_SIZE !== 0) {
        chunk = concat([chunk, new Uint8Array(chunkSize - chunk.length)]);
        length = chunk.length;
      }
      chunks.push({ id: index, size: length, bytecode: chunk });
    }
    return chunks;
  };
  var util_exports = {};
  __export2(util_exports, {
    getContractId: () => getContractId,
    getContractRoot: () => getContractRoot,
    getContractStorageRoot: () => getContractStorageRoot,
    hexlifyWithPrefix: () => hexlifyWithPrefix
  });
  var getContractRoot = (bytecode2) => {
    const chunkSize = 16 * 1024;
    const bytes2 = arrayify(bytecode2);
    const chunks = chunkAndPadBytes(bytes2, chunkSize);
    return calcRoot(chunks.map((c) => hexlify(c)));
  };
  var getContractStorageRoot = (storageSlots2) => {
    const tree = new SparseMerkleTree();
    storageSlots2.forEach(({ key, value }) => tree.update(sha2562(key), value));
    return tree.root;
  };
  var getContractId = (bytecode2, salt, stateRoot) => {
    const root = getContractRoot(arrayify(bytecode2));
    const contractId = sha2562(concat(["0x4655454C", salt, root, stateRoot]));
    return contractId;
  };
  var hexlifyWithPrefix = (value) => hexlify(value.startsWith("0x") ? value : `0x${value}`);
  var CHUNK_SIZE_MULTIPLIER = 0.95;
  var ContractFactory = class {
    bytecode;
    interface;
    provider;
    account;
    storageSlots;
    /**
     * Create a ContractFactory instance.
     *
     * @param bytecode - The bytecode of the contract.
     * @param abi - The contract's ABI (Application Binary Interface).
     * @param accountOrProvider - An account or provider to be associated with the factory.
     */
    constructor(bytecode2, abi2, accountOrProvider = null, storageSlots2 = []) {
      this.bytecode = arrayify(bytecode2);
      if (abi2 instanceof Interface) {
        this.interface = abi2;
      } else {
        this.interface = new Interface(abi2);
      }
      if (accountOrProvider && "provider" in accountOrProvider) {
        this.provider = accountOrProvider.provider;
        this.account = accountOrProvider;
      } else {
        this.provider = accountOrProvider;
        this.account = null;
      }
      this.storageSlots = storageSlots2;
    }
    /**
     * Connect the factory to a provider.
     *
     * @param provider - The provider to be associated with the factory.
     * @returns A new ContractFactory instance.
     */
    connect(provider) {
      return new ContractFactory(this.bytecode, this.interface, provider);
    }
    /**
     * Create a transaction request to deploy a contract with the specified options.
     *
     * @param deployOptions - Options for deploying the contract.
     * @returns The CreateTransactionRequest object for deploying the contract.
     */
    createTransactionRequest(deployOptions) {
      const storageSlots2 = (deployOptions?.storageSlots ?? []).concat(this.storageSlots).map(({ key, value }) => ({
        key: hexlifyWithPrefix(key),
        value: hexlifyWithPrefix(value)
      })).filter((el, index, self2) => self2.findIndex((s) => s.key === el.key) === index).sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));
      const options = {
        salt: randomBytes22(32),
        ...deployOptions ?? {},
        storageSlots: storageSlots2
      };
      if (!this.provider) {
        throw new FuelError(
          ErrorCode.MISSING_PROVIDER,
          "Cannot create transaction request without provider"
        );
      }
      const bytecode2 = deployOptions?.bytecode || this.bytecode;
      const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);
      const contractId = getContractId(bytecode2, options.salt, stateRoot);
      const transactionRequest = new CreateTransactionRequest({
        bytecodeWitnessIndex: 0,
        witnesses: [bytecode2],
        ...options
      });
      transactionRequest.addContractCreatedOutput(contractId, stateRoot);
      return {
        contractId,
        transactionRequest
      };
    }
    /**
     * Takes a transaction request, estimates it and funds it.
     *
     * @param request - the request to fund.
     * @param options - options for funding the request.
     * @returns a funded transaction request.
     */
    async fundTransactionRequest(request, options = {}) {
      const account = this.getAccount();
      const { maxFee: setMaxFee } = options;
      const txCost = await account.getTransactionCost(request);
      if (isDefined(setMaxFee)) {
        if (txCost.maxFee.gt(setMaxFee)) {
          throw new FuelError(
            ErrorCode.MAX_FEE_TOO_LOW,
            `Max fee '${options.maxFee}' is lower than the required: '${txCost.maxFee}'.`
          );
        }
      } else {
        request.maxFee = txCost.maxFee;
      }
      await account.fund(request, txCost);
      return request;
    }
    /**
     * Deploy a contract of any length with the specified options.
     *
     * @param deployOptions - Options for deploying the contract.
     * @returns A promise that resolves to the deployed contract instance.
     */
    async deploy(deployOptions = {}) {
      const account = this.getAccount();
      const { consensusParameters } = await account.provider.getChain();
      const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();
      return this.bytecode.length > maxContractSize ? this.deployAsBlobTx(deployOptions) : this.deployAsCreateTx(deployOptions);
    }
    /**
     * Deploy a contract with the specified options.
     *
     * @param deployOptions - Options for deploying the contract.
     * @returns A promise that resolves to the deployed contract instance.
     */
    async deployAsCreateTx(deployOptions = {}) {
      const account = this.getAccount();
      const { consensusParameters } = await account.provider.getChain();
      const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();
      if (this.bytecode.length > maxContractSize) {
        throw new FuelError(
          ErrorCode.CONTRACT_SIZE_EXCEEDS_LIMIT,
          "Contract bytecode is too large. Please use `deployAsBlobTx` instead."
        );
      }
      const { contractId, transactionRequest } = await this.prepareDeploy(deployOptions);
      const transactionResponse = await account.sendTransaction(transactionRequest);
      const waitForResult = async () => {
        const transactionResult = await transactionResponse.waitForResult();
        const contract = new Contract(contractId, this.interface, account);
        return { contract, transactionResult };
      };
      return {
        contractId,
        waitForTransactionId: () => Promise.resolve(transactionResponse.id),
        waitForResult
      };
    }
    /**
     * Chunks and deploys a contract via a loader contract. Suitable for deploying contracts larger than the max contract size.
     *
     * @param deployOptions - Options for deploying the contract.
     * @returns A promise that resolves to the deployed contract instance.
     */
    async deployAsBlobTx(deployOptions = {
      chunkSizeMultiplier: CHUNK_SIZE_MULTIPLIER
    }) {
      const account = this.getAccount();
      const { configurableConstants, chunkSizeMultiplier } = deployOptions;
      if (configurableConstants) {
        this.setConfigurableConstants(configurableConstants);
      }
      const chunkSize = await this.getMaxChunkSize(deployOptions, chunkSizeMultiplier);
      const chunks = getContractChunks(arrayify(this.bytecode), chunkSize).map((c) => {
        const transactionRequest = this.blobTransactionRequest({
          ...deployOptions,
          bytecode: c.bytecode
        });
        return {
          ...c,
          transactionRequest,
          blobId: transactionRequest.blobId
        };
      });
      const blobIds = chunks.map(({ blobId }) => blobId);
      const loaderBytecode = getLoaderInstructions(blobIds);
      const { contractId, transactionRequest: createRequest } = this.createTransactionRequest({
        bytecode: loaderBytecode,
        ...deployOptions
      });
      const uniqueBlobIds = [...new Set(blobIds)];
      const uploadedBlobIds = await account.provider.getBlobs(uniqueBlobIds);
      const blobIdsToUpload = uniqueBlobIds.filter((id) => !uploadedBlobIds.includes(id));
      let totalCost = bn(0);
      const chainInfo = await account.provider.getChain();
      const gasPrice = await account.provider.estimateGasPrice(10);
      const priceFactor = chainInfo.consensusParameters.feeParameters.gasPriceFactor;
      for (const { transactionRequest, blobId } of chunks) {
        if (blobIdsToUpload.includes(blobId)) {
          const minGas = transactionRequest.calculateMinGas(chainInfo);
          const minFee = calculateGasFee({
            gasPrice,
            gas: minGas,
            priceFactor,
            tip: transactionRequest.tip
          }).add(1);
          totalCost = totalCost.add(minFee);
        }
        const createMinGas = createRequest.calculateMinGas(chainInfo);
        const createMinFee = calculateGasFee({
          gasPrice,
          gas: createMinGas,
          priceFactor,
          tip: createRequest.tip
        }).add(1);
        totalCost = totalCost.add(createMinFee);
      }
      if (totalCost.gt(await account.getBalance())) {
        throw new FuelError(ErrorCode.FUNDS_TOO_LOW, "Insufficient balance to deploy contract.");
      }
      let txIdResolver;
      const txIdPromise = new Promise((resolve10) => {
        txIdResolver = resolve10;
      });
      const waitForResult = async () => {
        const uploadedBlobs = [];
        for (const { blobId, transactionRequest } of chunks) {
          if (!uploadedBlobs.includes(blobId) && blobIdsToUpload.includes(blobId)) {
            const fundedBlobRequest = await this.fundTransactionRequest(
              transactionRequest,
              deployOptions
            );
            let result;
            try {
              const blobTx = await account.sendTransaction(fundedBlobRequest);
              result = await blobTx.waitForResult();
            } catch (err2) {
              if (err2.message.indexOf(`BlobId is already taken ${blobId}`) > -1) {
                uploadedBlobs.push(blobId);
                continue;
              }
              throw new FuelError(ErrorCode.TRANSACTION_FAILED, "Failed to deploy contract chunk");
            }
            if (!result.status || result.status !== TransactionStatus.success) {
              throw new FuelError(ErrorCode.TRANSACTION_FAILED, "Failed to deploy contract chunk");
            }
            uploadedBlobs.push(blobId);
          }
        }
        await this.fundTransactionRequest(createRequest, deployOptions);
        txIdResolver(createRequest.getTransactionId(await account.provider.getChainId()));
        const transactionResponse = await account.sendTransaction(createRequest);
        const transactionResult = await transactionResponse.waitForResult();
        const contract = new Contract(contractId, this.interface, account);
        return { contract, transactionResult };
      };
      const waitForTransactionId = () => txIdPromise;
      return { waitForResult, contractId, waitForTransactionId };
    }
    /**
     * Set configurable constants of the contract with the specified values.
     *
     * @param configurableConstants - An object containing configurable names and their values.
     */
    setConfigurableConstants(configurableConstants) {
      try {
        const hasConfigurable = Object.keys(this.interface.configurables).length;
        if (!hasConfigurable) {
          throw new FuelError(
            ErrorCode.CONFIGURABLE_NOT_FOUND,
            "Contract does not have configurables to be set"
          );
        }
        Object.entries(configurableConstants).forEach(([key, value]) => {
          if (!this.interface.configurables[key]) {
            throw new FuelError(
              ErrorCode.CONFIGURABLE_NOT_FOUND,
              `Contract does not have a configurable named: '${key}'`
            );
          }
          const { offset } = this.interface.configurables[key];
          const encoded = this.interface.encodeConfigurable(key, value);
          const bytes2 = arrayify(this.bytecode);
          bytes2.set(encoded, offset);
          this.bytecode = bytes2;
        });
      } catch (err2) {
        throw new FuelError(
          ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
          `Error setting configurable constants on contract: ${err2.message}.`
        );
      }
    }
    getAccount() {
      if (!this.account) {
        throw new FuelError(ErrorCode.ACCOUNT_REQUIRED, "Account not assigned to contract.");
      }
      return this.account;
    }
    async prepareDeploy(deployOptions) {
      const { configurableConstants } = deployOptions;
      if (configurableConstants) {
        this.setConfigurableConstants(configurableConstants);
      }
      const { contractId, transactionRequest } = this.createTransactionRequest(deployOptions);
      await this.fundTransactionRequest(transactionRequest, deployOptions);
      return {
        contractId,
        transactionRequest
      };
    }
    /**
     * Create a blob transaction request, used for deploying contract chunks.
     *
     * @param options - options for creating a blob transaction request.
     * @returns a populated BlobTransactionRequest.
     */
    blobTransactionRequest(options) {
      const { bytecode: bytecode2 } = options;
      return new BlobTransactionRequest({
        blobId: hash2(bytecode2),
        witnessIndex: 0,
        witnesses: [bytecode2],
        ...options
      });
    }
    /**
     * Get the maximum chunk size for deploying a contract by chunks.
     */
    async getMaxChunkSize(deployOptions, chunkSizeMultiplier = CHUNK_SIZE_MULTIPLIER) {
      if (chunkSizeMultiplier < 0 || chunkSizeMultiplier > 1) {
        throw new FuelError(
          ErrorCode.INVALID_CHUNK_SIZE_MULTIPLIER,
          "Chunk size multiplier must be between 0 and 1"
        );
      }
      const account = this.getAccount();
      const { consensusParameters } = await account.provider.getChain();
      const contractSizeLimit = consensusParameters.contractParameters.contractMaxSize.toNumber();
      const transactionSizeLimit = consensusParameters.txParameters.maxSize.toNumber();
      const maxLimit = 64e3;
      const chainLimit = transactionSizeLimit < contractSizeLimit ? transactionSizeLimit : contractSizeLimit;
      const sizeLimit = chainLimit < maxLimit ? chainLimit : maxLimit;
      const blobTx = this.blobTransactionRequest({
        ...deployOptions,
        bytecode: randomBytes22(32)
      }).addResources(
        account.generateFakeResources([
          { assetId: await account.provider.getBaseAssetId(), amount: bn(1) }
        ])
      );
      const maxChunkSize = (sizeLimit - blobTx.byteLength() - WORD_SIZE) * chunkSizeMultiplier;
      return Math.round(maxChunkSize / WORD_SIZE) * WORD_SIZE;
    }
  };

  // ../recipes/dist/index.mjs
  var __defProp10 = Object.defineProperty;
  var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp10(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
  }) : obj[key] = value;
  var __publicField9 = (obj, key, value) => {
    __defNormalProp9(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var abi = {
    programType: "contract",
    specVersion: "1",
    encodingVersion: "1",
    concreteTypes: [
      {
        type: "()",
        concreteTypeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
      },
      {
        type: "enum standards::src5::AccessError",
        concreteTypeId: "3f702ea3351c9c1ece2b84048006c8034a24cbc2bad2e740d0412b4172951d3d",
        metadataTypeId: 1
      },
      {
        type: "enum standards::src5::State",
        concreteTypeId: "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
        metadataTypeId: 2
      },
      {
        type: "enum std::option::Option<struct std::contract_id::ContractId>",
        concreteTypeId: "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
        metadataTypeId: 4,
        typeArguments: [
          "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54"
        ]
      },
      {
        type: "enum sway_libs::ownership::errors::InitializationError",
        concreteTypeId: "1dfe7feadc1d9667a4351761230f948744068a090fe91b1bc6763a90ed5d3893",
        metadataTypeId: 5
      },
      {
        type: "enum sway_libs::upgradability::errors::SetProxyOwnerError",
        concreteTypeId: "3c6e90ae504df6aad8b34a93ba77dc62623e00b777eecacfa034a8ac6e890c74",
        metadataTypeId: 6
      },
      {
        type: "str",
        concreteTypeId: "8c25cb3686462e9a86d2883c5688a22fe738b0bbc85f458d2d2b5f3f667c6d5a"
      },
      {
        type: "struct std::contract_id::ContractId",
        concreteTypeId: "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54",
        metadataTypeId: 9
      },
      {
        type: "struct sway_libs::upgradability::events::ProxyOwnerSet",
        concreteTypeId: "96dd838b44f99d8ccae2a7948137ab6256c48ca4abc6168abc880de07fba7247",
        metadataTypeId: 10
      },
      {
        type: "struct sway_libs::upgradability::events::ProxyTargetSet",
        concreteTypeId: "1ddc0adda1270a016c08ffd614f29f599b4725407c8954c8b960bdf651a9a6c8",
        metadataTypeId: 11
      }
    ],
    metadataTypes: [
      {
        type: "b256",
        metadataTypeId: 0
      },
      {
        type: "enum standards::src5::AccessError",
        metadataTypeId: 1,
        components: [
          {
            name: "NotOwner",
            typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
          }
        ]
      },
      {
        type: "enum standards::src5::State",
        metadataTypeId: 2,
        components: [
          {
            name: "Uninitialized",
            typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
          },
          {
            name: "Initialized",
            typeId: 3
          },
          {
            name: "Revoked",
            typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
          }
        ]
      },
      {
        type: "enum std::identity::Identity",
        metadataTypeId: 3,
        components: [
          {
            name: "Address",
            typeId: 8
          },
          {
            name: "ContractId",
            typeId: 9
          }
        ]
      },
      {
        type: "enum std::option::Option",
        metadataTypeId: 4,
        components: [
          {
            name: "None",
            typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
          },
          {
            name: "Some",
            typeId: 7
          }
        ],
        typeParameters: [7]
      },
      {
        type: "enum sway_libs::ownership::errors::InitializationError",
        metadataTypeId: 5,
        components: [
          {
            name: "CannotReinitialized",
            typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
          }
        ]
      },
      {
        type: "enum sway_libs::upgradability::errors::SetProxyOwnerError",
        metadataTypeId: 6,
        components: [
          {
            name: "CannotUninitialize",
            typeId: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"
          }
        ]
      },
      {
        type: "generic T",
        metadataTypeId: 7
      },
      {
        type: "struct std::address::Address",
        metadataTypeId: 8,
        components: [
          {
            name: "bits",
            typeId: 0
          }
        ]
      },
      {
        type: "struct std::contract_id::ContractId",
        metadataTypeId: 9,
        components: [
          {
            name: "bits",
            typeId: 0
          }
        ]
      },
      {
        type: "struct sway_libs::upgradability::events::ProxyOwnerSet",
        metadataTypeId: 10,
        components: [
          {
            name: "new_proxy_owner",
            typeId: 2
          }
        ]
      },
      {
        type: "struct sway_libs::upgradability::events::ProxyTargetSet",
        metadataTypeId: 11,
        components: [
          {
            name: "new_target",
            typeId: 9
          }
        ]
      }
    ],
    functions: [
      {
        inputs: [],
        name: "proxy_target",
        output: "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
        attributes: [
          {
            name: "doc-comment",
            arguments: [" Returns the target contract of the proxy contract."]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Returns"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [
              " * [Option<ContractId>] - The new proxy contract to which all fallback calls will be passed or `None`."
            ]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Number of Storage Accesses"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" * Reads: `1`"]
          },
          {
            name: "storage",
            arguments: ["read"]
          }
        ]
      },
      {
        inputs: [
          {
            name: "new_target",
            concreteTypeId: "29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54"
          }
        ],
        name: "set_proxy_target",
        output: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
        attributes: [
          {
            name: "doc-comment",
            arguments: [" Change the target contract of the proxy contract."]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Additional Information"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" This method can only be called by the `proxy_owner`."]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Arguments"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [
              " * `new_target`: [ContractId] - The new proxy contract to which all fallback calls will be passed."
            ]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Reverts"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" * When not called by `proxy_owner`."]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Number of Storage Accesses"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" * Reads: `1`"]
          },
          {
            name: "doc-comment",
            arguments: [" * Write: `1`"]
          },
          {
            name: "storage",
            arguments: ["read", "write"]
          }
        ]
      },
      {
        inputs: [],
        name: "proxy_owner",
        output: "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
        attributes: [
          {
            name: "doc-comment",
            arguments: [" Returns the owner of the proxy contract."]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Returns"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [
              " * [State] - Represents the state of ownership for this contract."
            ]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Number of Storage Accesses"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" * Reads: `1`"]
          },
          {
            name: "storage",
            arguments: ["read"]
          }
        ]
      },
      {
        inputs: [],
        name: "initialize_proxy",
        output: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
        attributes: [
          {
            name: "doc-comment",
            arguments: [" Initializes the proxy contract."]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Additional Information"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [
              " This method sets the storage values using the values of the configurable constants `INITIAL_TARGET` and `INITIAL_OWNER`."
            ]
          },
          {
            name: "doc-comment",
            arguments: [
              " This then allows methods that write to storage to be called."
            ]
          },
          {
            name: "doc-comment",
            arguments: [" This method can only be called once."]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Reverts"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [
              " * When `storage::SRC14.proxy_owner` is not [State::Uninitialized]."
            ]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Number of Storage Accesses"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" * Writes: `2`"]
          },
          {
            name: "storage",
            arguments: ["write"]
          }
        ]
      },
      {
        inputs: [
          {
            name: "new_proxy_owner",
            concreteTypeId: "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c"
          }
        ],
        name: "set_proxy_owner",
        output: "2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",
        attributes: [
          {
            name: "doc-comment",
            arguments: [" Changes proxy ownership to the passed State."]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Additional Information"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [
              " This method can be used to transfer ownership between Identities or to revoke ownership."
            ]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Arguments"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [
              " * `new_proxy_owner`: [State] - The new state of the proxy ownership."
            ]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Reverts"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" * When the sender is not the current proxy owner."]
          },
          {
            name: "doc-comment",
            arguments: [
              " * When the new state of the proxy ownership is [State::Uninitialized]."
            ]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" # Number of Storage Accesses"]
          },
          {
            name: "doc-comment",
            arguments: [""]
          },
          {
            name: "doc-comment",
            arguments: [" * Reads: `1`"]
          },
          {
            name: "doc-comment",
            arguments: [" * Writes: `1`"]
          },
          {
            name: "storage",
            arguments: ["write"]
          }
        ]
      }
    ],
    loggedTypes: [
      {
        logId: "4571204900286667806",
        concreteTypeId: "3f702ea3351c9c1ece2b84048006c8034a24cbc2bad2e740d0412b4172951d3d"
      },
      {
        logId: "2151606668983994881",
        concreteTypeId: "1ddc0adda1270a016c08ffd614f29f599b4725407c8954c8b960bdf651a9a6c8"
      },
      {
        logId: "2161305517876418151",
        concreteTypeId: "1dfe7feadc1d9667a4351761230f948744068a090fe91b1bc6763a90ed5d3893"
      },
      {
        logId: "4354576968059844266",
        concreteTypeId: "3c6e90ae504df6aad8b34a93ba77dc62623e00b777eecacfa034a8ac6e890c74"
      },
      {
        logId: "10870989709723147660",
        concreteTypeId: "96dd838b44f99d8ccae2a7948137ab6256c48ca4abc6168abc880de07fba7247"
      },
      {
        logId: "10098701174489624218",
        concreteTypeId: "8c25cb3686462e9a86d2883c5688a22fe738b0bbc85f458d2d2b5f3f667c6d5a"
      }
    ],
    messagesTypes: [],
    configurables: [
      {
        name: "INITIAL_TARGET",
        concreteTypeId: "0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",
        offset: 13368
      },
      {
        name: "INITIAL_OWNER",
        concreteTypeId: "192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",
        offset: 13320
      }
    ]
  };
  var storageSlots = [
    {
      key: "7bb458adc1d118713319a5baa00a2d049dd64d2916477d2688d76970c898cd55",
      value: "0000000000000000000000000000000000000000000000000000000000000000"
    },
    {
      key: "7bb458adc1d118713319a5baa00a2d049dd64d2916477d2688d76970c898cd56",
      value: "0000000000000000000000000000000000000000000000000000000000000000"
    },
    {
      key: "bb79927b15d9259ea316f2ecb2297d6cc8851888a98278c0a2e03e1a091ea754",
      value: "0000000000000000000000000000000000000000000000000000000000000000"
    },
    {
      key: "bb79927b15d9259ea316f2ecb2297d6cc8851888a98278c0a2e03e1a091ea755",
      value: "0000000000000000000000000000000000000000000000000000000000000000"
    }
  ];
  var Src14OwnedProxy = class extends Contract {
    constructor(id, accountOrProvider) {
      super(id, abi, accountOrProvider);
    }
  };
  __publicField9(Src14OwnedProxy, "abi", abi);
  __publicField9(Src14OwnedProxy, "storageSlots", storageSlots);
  var bytecode = decompressBytecode(
    "H4sIAAAAAAAAA9Vbe3Abx3lfgCAFvayz+TAFSjaUUjJkRwosUQ4ly9IhIATSEM2DSVpUGBhg64c0cSyIlVQ5tsccN001aSZlHcdlO06GrtOp6z4GAB+C7T7YR2bUiTtlZhxbTeMWmiatFAst60YZqm6j/r5v93DHw4GOJ84f0QznFne73+5+j9/32FVgISxOCOEV/K/Dn7o259GuXRO/JcSQ8c6CML4nwkZJF8HFnWLovZLXeK/kOyG89+JbGN9C+BZe+q2uEfRE4LIBGiv1VHThdi0i5gJdGTHa7TW0WNNY4JLmoFfXE4jPi3T5ep/q112j337Vr8WIF3PV373nAol5YfTls6OG8Id6m9E3+DG0tVB5F96/onG7b0akejWh9XaMpWNhYcSnL44exPv49JzLnNtoTtDMpMvaR0FvmxHPaaPd6B/rGDMSxRCP7WmaMxJ5I10Wt47qYg2etxnR/CJ/i7Tj29nuSr/42Tlux3yYLygC36+aMxiIzotTuuck+LeD+If9hoxEIQS6MdDX8DxgRAudNvrzNvql96Hvl/TFJdDfaaPfDbo9oL8az7tBf8hGf8GiXxTL0/cuKPpPg36Hjf4R0O1V678H9E9b9IuaRX+m9X3on1f0HwD9XTb6Z0A3Cfrr8LwX9Ccs+jOWnOIzkm+16c8p+juXvl/9f0Z0GnonHP19CeqfigmR6hGeVER4jb5Z7FH7a+jL32Atf2tEp84ELoUxV9XYQzQWOnVO6pRvzIi+AhugdTehPVtpV8/r/TyPTcxWdIv246CfIf3dHNGEES0GjXihRHSq9+z5slrHBOYLy3XkJ7nN6zg7brar17F6c0AXYjP+lr5fNWW+x/4nqsc1PK3mHLLmLGatOaddxtSxboHPsGHF6/7Zc6MDGJNs1o347CJ4/i/pcrgEvl/AvOcCl3Teb+CCk5b/tmq5zVyE3P4cNP4C4/8S40+7y63uklr7GUtuReKXktuMfxm5tSq5ST10lVvdu6bcoON3KB0PGokpjTAq8H1nf8/vME4lcoRlQann+TFux9rnHLTfgQ2QzuCbbw57PgJcDIZ660lOYab/PejIBez77aq1vyH3nfdjfDePjxaL3I5gzmh+Pn1Z22P0Cr+kuRnYOTuEdjfhMeQziXYoFKsXkq9OPVxxCnbrH+3C2Eg75Dnt5geO0V5TPeBNr+ZJxTTowNkh6EAwlKzXoaunIb//hA4sQJb/ZcSnFqUO0J6ctPyHXXRgHuNeBY3XoAN/Bj08X0MHjigd6LZ0oPCSKXfIbX0qnhtMJXL3dXh891q2MA0ZOmmt/JaiFcR48If1qZPb0haOuNjCtiW2kBTe1CDah9U+0oXiaAbjUy0C6/A1xjRxqktsT0VzhxojQge+ebHGwB28pkLRiAi/EX8lyHyMgY/xmUnwYBp8nEmX9VkjMW0ELpLukS059c/7lotMNJtMwqD1b6D17+DtRcgEOFRLJit+6JQJYgoN6wG+G/l0OVOAXKbAk87ARYll1bbtnXKRaxFzn8U68BSvYDywwU2u3neVLM7bbDtj2fb0Ym3b9mxStl3xN9W27X3PtO2vCHHzc34zXhKTgeikCMTHRSAxJgJ9JWH052CP5h6dcZgI8B4jAnGOWIv1HjGiuU6JD851iTbqC7sKh8o+yCOX5XZ02mr3+PTAD4V4htZxNSwmsK7fxvruXhS0zhXmOuUasb5ESaTB38AVzHc1aPZfofo/Ze3Lc5HHDGNfh0qw+6q1fZL40QjdOdUt7sZTx3M1/Li3MdJEfthzB2JKrHMB6/RChjch1jpjrhnjd5PfAu40utCOUkzY2BsUpw6KGxt7gkRb0kvkzmHMesR2uuRx2Dm2i2XZB5s08TESlLgWoXgyn8EaQ6HedoqhbwC9bPqyuA7vgzXohVkGhLtl4CbRonZ0Ghhs0TIiGvkO2D3Fl9inTvtsIswtcjvG89WDHzrmg83ivfKf/P1wE2SSgRzB96uGKZenlFwq+iblWJL40RMkDBEUN2u9u0Q6Aru4gtjoqubUA7u+ZphGAnKFrpKtMW/KhPM5ndtxxNrqvRZDPM5xCPhJ+A7d4yfpHeaC3mVc9M4+H3x/lX1ka9nHSSH+2GYfrZgXtrhUP9AnyrqXhO4ZogUYqQMjpX4A16EfKzEHYgCao4r+J1ievGfSDciN2tEZWtcEyzPZZMoqCFn5+H0XvWcbPMftSJfVtmxwwYUXdVWyw94CV/BnyanOaa/gm2b2Z9wq+8YC0VxlLObSbONN+91vG29YfAcNwjXob+CdXLV+98Fe+pEfDaAP4jHCeEefWwL9ZI+78AcdMwTZ5QbYWJhzM9gYYbJjzK2Krr4M3U0c//RDt7hPvVsfznu2JjuMwBWd9m3YcGv/B+CbZxm+fYh8rzsXOITx/ZBzdOHjMgbMXwQtituADYiTONajGCxvWHEb7LYqbhMPKfzvlvg/NcZtxv9Cd6Udz8MnuuUHvqwt1pHzRwuUE9A4Fz/oOy79YIH8oBmPIp6nfMvN54tBRf+IlQtMEQ6qXGAqo74Beym2yl2PmOYG+t3WA9w7KPxtPR1jW7pBuzsLbJ7K7O7xzcN3NJDfgO3BZxTO23zGdYQHsG/KNf1tsQ5diyHeTMA+D5IdYr0xxLDURvxsHwteE35hXe2ob+SGVSylfFQ+KOOoKRm7ESaTXQ8SxhmQOWR6VXfqnN3WupdiXJblz3FUuV6H7/Nh3SEzPgbGdIf6pqFPYdKnbhfa12x+2MLPYdCGL8Yawbcm4l9I62mnusTN6ll/s3z61qea5jAfeHRC534x/KZ+8ll/M56w35zpI7EmrLWDeEE1CenfIANT9g6575R6Aru1dFnlOFV9Q8ofS9/C+UqecAO8QJ6RyMs19LBvzr7Y63uB7IJ1BjqK71m8H8f7SV4b6xJ8bDRntRO5jLWOnMyfUD8A35vS5Wwzy/0wyZL9KzC64l+vKX6vs8lSt+Mm4T/+6vHXAH+0gv2gigWYZ3GSo0Zy1G24tK46nhLjLn7wNHSklbARa2wNleFT4oypreyDh3MNqUO5FbAZ8lF+LdksmpMxHT7PQ/4J77xtg4NiywCYvPEBPTCUFVryAT2dhO/W0R9xGPvDcmYlYvBVWP9qrL+V6UfY32e4jbwO/VspXlE+fdzmx8wYxM4jpe+kiz5h2W+uFXF6Hb3Dk/kGGWFfLKMw+NYaSkyT/mH+9jmFp9D/Cp6afLPbFvI1Sx6Yw+A1S50l2hSbEF61ks6m+nL1sGWN/A7yFr/Rq/vBY9QVKZ/B3rm21GXV8qTsjnz4PsVjs2H/PNktchCOSRx5xXa2jzTHyeFQClg1nA8D47YcBz4Bo6j+cx68HKY8H+8fOt5NeZFpu2RDs0XLhmaGpM06/XHdE7LOCrsxx/WofJ/G9SAOYgwlGzpLORRjOHKjuxzr/W/269H8ONa0g2p4JmZSXNAC3mLN7ci9QqgD6Oa3VDRfrzB3DfD3DNqUI9hy2akh7O3T+DuGuuWQGVdBz9eCb7rE5yL5FunH4lN+zD+i1i1tn8ZR/MZx91mKq8kPUCyHmtL0S2bu6tjPd5SPJblCR4qEm5r0sVMU33Ebaxamz6DaO35/Vu1hFdqP2b7V0TfKeRojPs7XtaSuI+6MEW2su5KfgietDppPKJoRtB930HzCheYnZT7suq+vK99MMlD58BTlHKrOkfM76J+20Yf/RV32skiCp1TXMWVxI+Regoz2jsQ+EYHeTaBWAd63YJ4Z5LCuddl/VjUuo9KXfDS1Y1vw3qIPmYVtMtuFvRVr7O0zam+qpk97m6Y4w9wb9rGEr19SfKV9ZbCvg1h7ybGvIvb1ceyrDt9O2/bVWmNfL6l9Bd33ZdG37ws6QLVaVR8iG5mi2HCJjQS6eK2eQBfXfr5CY1CDq9iZrG25+doKX6geq+I9qrHPEu+xlgbCINTV3Hy6937l08flfqjvzEVuR4gPs5W9uceagmurWPfDdMYBXsbB5wTbYWXdUxR78t4hkwUlo1a0R13wYFzZ/GnL5gtk89C7Qg7P+4xelddzjq/wS557vGTm31jXKkULOIrzoMvaR4EZ5C/8CjMqfRn3VIwI7CLd4pgW63tPrU/Fi9OaWhvFKXJvsYzM/3mfM7LOETlB9TiV5z/A8bYL3zg+MvdPeSTe3YQzBML8f8J4lcdW1VPvUzVdqj2a9k28NuuYbYgbsqhjHqc6Jn5vIL5K3PCg5kQ6ZWG3ev/oM+SrKvGRx4yPbPm8p1TxxxTj0t7gD+Fbw1bcD9/UJTI1cHOD+t2EdovJV9s3wXqP8yz6bsMkE6c2mO9UP9gJ8yxK80q54BnTwvjzq9hQ+rVIkORO+sfxKugYKh9Y41jHLer3BrQ/4lg/favYKNeQQEvOi2dMC8l5cQ5jxcYUb1AOpM6uqmLkAGHJMrRs8a06H6hNawXRknENZGXlFmY9omasW6lxmTEu5nghOh1UMY5bfGvPexdteW+nzHuR61p5r8opeQ+o/9TOe08q3bblvaRPZt57xJb3XqxhUwWXvDdXO+8VXHems1Rb3gvfUzPv3eeS99r0H3jzwfLecSvvzVPOgTOjwiL22WnLe7nu6ZL3EnaZeS/VGSnvrYwFvU5uSz1PO/LeTpX3Up1c1iIJt6y8d/GnyE3DP2FuGv4wc1PozuhPmpui75M/T7lpla2q/MXFLt1qjr73qzkGoiUxgjqqqunX2+uqhLXQQ8Za9b1Bfa/47JEuTx31AY16uS7hrJPZ68LIoaz9OGq07ZRjNCd9c5TrNsrntpGIF/VHrj0G8dTxbAIfyBdQzkE1I1lb70esSfkdxhEekm+C7TRQX+SEK+zfIXuq4aOG2UX7Ixqo+WrIXbV6/qbqm1Sz5n7JDrOfhj5ezFfH3xQ97hPrYvxFP8qBSX/pnopZJxizycsNkxEPLJFziDCZ6o9LbRc1AZsOgG7IRQ/sdHE/pRrrHTWM4PI1DJu9Uz5LfKT4IQnMg79ifGWsz827nXdDrgXyTWwbZR5Ddwh4jPO8GH1zCmMXuD/OlEF30rRj51nmSeF73XYW63IXIj+vvpmY7Acmr6yNyfn53T0dhDcW3vYhRxqi857YmDwPBy7E8/N3xnzjsv6/xH7NuokNL71WTT4NvBy24iclX4opvmCLmW6kNvqQjo8tjY8RE1BthfYWz1GM6a3lr8CbF1zOZo+RDgHD6O6BjI8SeaqPUB0I/g9nNHxuDJrV9Gaqz40R/w2QLtSTn2lQe6Fza2o7zq1zYfY7/QUaI8+a+/OoUwW3wj5vBTbehvkn5fzI/6rn/3b1/MDqyrk17jOUg3tA607Q2gtaiBNqnVuLAy68CdnWaJ2H96MuUw5uAd1bQBe5W+6MPMt2XeOPXdZI9T5zjROgtRO0OkBrF2jBZmqucaPLGtdRrGDTgSG5Fjf51/P5tn18OqWJdCroSaegN1ey0F3o5tWM0/fYdFfI8+Cl9ctWaz/QQaplRsxaJp+VGdymPGA4twq1TIrp11AdXIv59OZYM/sXrmXCj7QNDuiqlimolskx1KcI42JzqGsKbiebKXYIaoj/if+obV6P2uYNqG020jm6rbZJd1a4tsn+2HxPbVqTdX6J89ZKrdPct73+uMRPAQNCzrMu8PcA+atUMixSg2FPqjfstdmzXe9x11BHHdbAXb3wGtDSLJlV0fwSywz+DndE5F2IQzncxQuvBY3rsF/IP4fzMvjtqrimvk+dWfOZ3zL+x4zpbBjvteIMC+NxT4vxmvDTxHjcBXHDeO9tDoynOLgGxnu3qhxW9pcYz3dE3THe+zUXjKe43sT40gfE+JILxo8B48MK4zEHY3zJwnjwZ5nzefhI1IoRb8UXdmsxDZiawx0g5z5WrKZarPTtFK9TjV5bCb1sw3MV363j+jR/O8/9UDfHeuncGvEI67c6l8N5bDVebFe1Kds5HuxT3SujGo/7fTTRoPwY6tmV2M3tTF/FEuy/KI7gengYdxICB6lgnRTPoha8Q4d8dKFvge6nN8I29KwIRurEvYhF78Y7GW9U3VWwxxvFKswZ5lhdCx0GD/rhryyf8wvKz9yv2g7bk/dFlsqhoYPthM8ouIZR4jbH9nxWQDhBcTvdeeUzC2DYuhTOyimnQx95V1jyl843TJmNm++hf42UE9HdaIV5VNOzMC/ZpW8Br0IbB0RggDFP3kdEvUiLDQicZzTzfWfUAVDLaWL68EvAP5ozByxpAR7cqO5KkK2a/oDupgL/2EaoLiTfo61s0vyG8wK33KgB90QqOa6qL+H+oFVf2oy9bcKaPkL1JZVPtqraxQTnTYy9aC+5LwKZLn+2pGIkyBr662I737HbDseflNPLGgV8WNVZkh3bcFcLdBGrVmORb4fCLcRjzD+ZS+B+OOfV0v4kJsD+3M5YQOPv+F6KvLO3AxiwhzAglVi4U+sJ4mxqYa/WG55L9S/chXrbHPA8C6wJhgabxzDXDUbMCPHv2OYxo0sPc/45BOzsGRwzDuFeOsWe6CvnBoOXYuMlFQdiPO7IXxZtqs4J3nfNGd068A41mMqdzgLdtwe+bXa904la4OdULbIFtRO6B9MFvqk7V1V9v6l0hWogpq5U7kBDV7ZDV4LQlU32WiSwFHfWKjhj6oJNXnXynBFxskM33yS9xJrWgkeEj3TGD/mg3rSsfOpvN+WjZPQpyGifxGlVVyNb7kPewPUAxlnEjqBVuVvr3Lvfo7CW7sJDVoQFU6Sf8Hmw1XjhTKWdKJCv4bW6+07PBcddbr5H6ND/keq71Pg/BZW71HRfP9iLOOEeYEKftG/3u9Sof2ypvm+Zp9pEJ2jsxvg9GN/tdt8S6zDv0VIOp2Su7l5KmX8MMm+DzDfwPVqpS83QJdJNA7pUuQPm0GM+h7DO4/iOlTqDWwiD5nrQDCzVI+iJFbsu55P31/bJ/oWfpU+GbDln+qA+GePeruWTf1b/sqPHTj+WPjEy+vCD9N+CxC8/eCJtf/f49NCf/NW3Wo/vXP/7r06u2ub76pu9W1viT24589bR7LmJvx+UfY/9yqMPjjK9o48ePXF05JGjn31QkrHoyT4bv7vq7RduWeV5nf8J7/7s9hd3bXj+pmv8T4jXHnvm8eZ/3Py1F1vevVzY+uQj536t9cwfPn167vdK+wIrb/qDgQMjjzzyiyO/9OnY6Oix0T17BniR9xw70S+XL764+Zt3fP7A9t/N/+ZE57Nf/vrLvkvPvzZ7cNOb//qZYwfLl18+uv/V/5j8h4eu+8Ku/xk+uePbe3/06xf23ZVr+sG7/m8Uv9HxR0fvemvl2vu9D6f3bfzxUz/47sbnHn7u7V/9ja6rX/3i3kfH/9To/dHLkms7/1c+d7yuns+r50H5vF19335ePtvfkM8W9X3lEfn0qff1n1PPDvV8Vj7rJuXT88b/AzdExjYINgAA"
  );
  var _Src14OwnedProxyFactory = class extends ContractFactory {
    constructor(accountOrProvider) {
      super(
        bytecode,
        Src14OwnedProxy.abi,
        accountOrProvider,
        Src14OwnedProxy.storageSlots
      );
    }
    static deploy(wallet, options = {}) {
      const factory = new _Src14OwnedProxyFactory(wallet);
      return factory.deploy(options);
    }
  };
  var Src14OwnedProxyFactory = _Src14OwnedProxyFactory;
  __publicField9(Src14OwnedProxyFactory, "bytecode", bytecode);

  // src/cli/commands/deploy/deployContracts.ts
  var import_fs22 = __require2("fs");

  // src/cli/commands/deploy/createWallet.ts
  async function createWallet(providerUrl, privateKey) {
    let pvtKey;
    if (privateKey) {
      pvtKey = privateKey;
    } else if (process.env.PRIVATE_KEY) {
      pvtKey = process.env.PRIVATE_KEY;
    } else {
      throw new FuelError(
        FuelError.CODES.MISSING_REQUIRED_PARAMETER,
        "You must provide a privateKey via config.privateKey or env PRIVATE_KEY"
      );
    }
    try {
      const provider = new Provider(providerUrl);
      await provider.init();
      return Wallet.fromPrivateKey(pvtKey, provider);
    } catch (e) {
      const error3 = e;
      if (/EADDRNOTAVAIL|ECONNREFUSED/.test(error3.cause?.code ?? "")) {
        throw new FuelError(
          FuelError.CODES.CONNECTION_REFUSED,
          `Couldn't connect to the node at "${providerUrl}". Check that you've got a node running at the config's providerUrl or set autoStartFuelCore to true.`
        );
      } else {
        throw error3;
      }
    }
  }

  // src/cli/commands/deploy/getDeployConfig.ts
  async function getDeployConfig(deployConfig, options) {
    let config;
    if (typeof deployConfig === "function") {
      config = await deployConfig(options);
    } else {
      config = deployConfig;
    }
    return config;
  }

  // src/cli/commands/deploy/deployContracts.ts
  async function deployContract(wallet, binaryPath, abiPath, storageSlotsPath, deployConfig, contractPath, tomlContents) {
    debug(`Deploying contract for ABI: ${abiPath}`);
    if ((0, import_fs22.existsSync)(storageSlotsPath)) {
      const storageSlots3 = JSON.parse((0, import_fs22.readFileSync)(storageSlotsPath, "utf-8"));
      deployConfig.storageSlots = storageSlots3;
    }
    const targetBytecode = (0, import_fs22.readFileSync)(binaryPath);
    const targetAbi = JSON.parse((0, import_fs22.readFileSync)(abiPath, "utf-8"));
    const targetStorageSlots = deployConfig.storageSlots ?? [];
    const proxyBytecode = Src14OwnedProxyFactory.bytecode;
    const proxyAbi = Src14OwnedProxy.abi;
    const proxyStorageSlots = Src14OwnedProxy.storageSlots ?? [];
    const isProxyEnabled = tomlContents?.proxy?.enabled;
    const proxyAddress = tomlContents?.proxy?.address;
    if (!isProxyEnabled) {
      const contractFactory = new ContractFactory(targetBytecode, targetAbi, wallet);
      const { waitForResult } = await contractFactory.deploy(deployConfig);
      const { contract } = await waitForResult();
      return contract.id.toB256();
    }
    if (proxyAddress) {
      const targetContractFactory2 = new ContractFactory(targetBytecode, targetAbi, wallet);
      const { waitForResult: waitForTarget2 } = await targetContractFactory2.deploy(deployConfig);
      const { contract: targetContract2 } = await waitForTarget2();
      const proxyContract2 = new Contract(proxyAddress, proxyAbi, wallet);
      const { waitForResult: waitForProxyUpdate } = await proxyContract2.functions.set_proxy_target({ bits: targetContract2.id.toB256() }).call();
      await waitForProxyUpdate();
      return proxyAddress;
    }
    const targetContractFactory = new ContractFactory(targetBytecode, targetAbi, wallet);
    const { waitForResult: waitForTarget } = await targetContractFactory.deploy(deployConfig);
    const { contract: targetContract } = await waitForTarget();
    const { storageSlots: storageSlots2, stateRoot, ...commonDeployConfig } = deployConfig;
    const mergedStorageSlots = targetStorageSlots.concat(proxyStorageSlots);
    const proxyDeployConfig = {
      ...commonDeployConfig,
      storageSlots: mergedStorageSlots,
      configurableConstants: {
        INITIAL_TARGET: { bits: targetContract.id.toB256() },
        INITIAL_OWNER: { Initialized: { Address: { bits: wallet.address.toB256() } } }
      }
    };
    const proxyFactory = new ContractFactory(proxyBytecode, proxyAbi, wallet);
    const { waitForResult: waitForProxy } = await proxyFactory.deploy(proxyDeployConfig);
    const { contract: proxyContract } = await waitForProxy();
    const { waitForResult: waitForProxyInit } = await proxyContract.functions.initialize_proxy().call();
    await waitForProxyInit();
    const proxyContractId = proxyContract.id.toB256();
    setForcTomlProxyAddress(contractPath, proxyContractId);
    return proxyContractId;
  }
  async function deployContracts(config) {
    const contracts = [];
    const wallet = await createWallet(config.providerUrl, config.privateKey);
    log(`Deploying contracts to: ${wallet.provider.url}`);
    const contractsLen = config.contracts.length;
    for (let i = 0; i < contractsLen; i++) {
      const contractPath = config.contracts[i];
      const forcTomlPath = getClosestForcTomlDir(contractPath);
      const binaryPath = getBinaryPath(contractPath, config);
      const abiPath = getABIPath(contractPath, config);
      const storageSlotsPath = getStorageSlotsPath(contractPath, config);
      const projectName = getContractName(contractPath);
      const contractName = getContractCamelCase(contractPath);
      const tomlContents = readForcToml(forcTomlPath);
      const deployConfig = await getDeployConfig(config.deployConfig, {
        contracts: Array.from(contracts),
        contractName,
        contractPath
      });
      const contractId = await deployContract(
        wallet,
        binaryPath,
        abiPath,
        storageSlotsPath,
        deployConfig,
        contractPath,
        tomlContents
      );
      debug(`Contract deployed: ${projectName} - ${contractId}`);
      contracts.push({
        name: contractName,
        contractId
      });
    }
    return contracts;
  }

  // src/cli/commands/deploy/deployPredicates.ts
  var import_console = __require2("console");
  var import_fs23 = __require2("fs");
  async function deployPredicates(config) {
    const predicates = [];
    const wallet = await createWallet(config.providerUrl, config.privateKey);
    (0, import_console.log)(`Deploying predicates to: ${wallet.provider.url}`);
    const predicatesLen = config.predicates.length;
    for (let i = 0; i < predicatesLen; i++) {
      const predicatePath = config.predicates[i];
      const binaryPath = getBinaryPath(predicatePath, config);
      const abiPath = getABIPath(predicatePath, config);
      const projectName = getPredicateName(predicatePath);
      const bytecode2 = (0, import_fs23.readFileSync)(binaryPath);
      const abi2 = JSON.parse((0, import_fs23.readFileSync)(abiPath, "utf-8"));
      const predicate = new Predicate({ abi: abi2, bytecode: bytecode2, provider: wallet.provider });
      const {
        bytes: loaderBytecode,
        interface: { jsonAbi }
      } = await (await predicate.deploy(wallet)).waitForResult();
      const predicateRoot = getPredicateRoot(loaderBytecode);
      (0, import_console.debug)(`Predicate deployed: ${projectName} - ${predicateRoot}`);
      predicates.push({
        path: predicatePath,
        predicateRoot,
        loaderBytecode,
        abi: jsonAbi
      });
    }
    return predicates;
  }

  // ../script/dist/index.mjs
  var ScriptInvocationScope = class extends FunctionInvocationScope {
    scriptRequest;
    async updateScriptRequest() {
      if (!this.scriptRequest) {
        await this.buildScriptRequest();
      }
      this.transactionRequest.setScript(this.scriptRequest, this.args);
    }
    async buildScriptRequest() {
      const programBytes = this.program.bytes;
      const chainInfoCache = await this.program.provider.getChain();
      if (!chainInfoCache) {
        throw new FuelError(
          FuelError.CODES.CHAIN_INFO_CACHE_EMPTY,
          "Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `new Provider()`"
        );
      }
      this.scriptRequest = new ScriptRequest(
        programBytes,
        (args) => this.func.encodeArguments(args),
        () => []
      );
    }
  };
  var AbstractScript = class extends AbstractProgram {
  };
  var Script = class extends AbstractScript {
    /**
     * The compiled bytecode of the script.
     */
    bytes;
    /**
     * The ABI interface for the script.
     */
    interface;
    /**
     * The account associated with the script.
     */
    account;
    /**
     * The script request object.
     */
    script;
    /**
     * The provider used for interacting with the network.
     */
    provider;
    /**
     * Functions that can be invoked within the script.
     */
    functions;
    /**
     * Create a new instance of the Script class.
     *
     * @param bytecode - The compiled bytecode of the script.
     * @param abi - The ABI interface for the script.
     * @param account - The account associated with the script.
     */
    constructor(bytecode2, abi2, account) {
      super();
      this.bytes = arrayify(bytecode2);
      this.interface = new Interface(abi2);
      this.provider = account.provider;
      this.account = account;
      this.functions = {
        main: (...args) => new ScriptInvocationScope(this, this.interface.getFunction("main"), args)
      };
    }
    /**
     * Set the configurable constants of the script.
     *
     * @param configurables - An object containing the configurable constants and their values.
     * @throws Will throw an error if the script has no configurable constants to be set or if an invalid constant is provided.
     * @returns This instance of the `Script`.
     */
    setConfigurableConstants(configurables) {
      try {
        if (!Object.keys(this.interface.configurables).length) {
          throw new FuelError(
            FuelError.CODES.INVALID_CONFIGURABLE_CONSTANTS,
            `The script does not have configurable constants to be set`
          );
        }
        Object.entries(configurables).forEach(([key, value]) => {
          if (!this.interface.configurables[key]) {
            throw new FuelError(
              FuelError.CODES.CONFIGURABLE_NOT_FOUND,
              `The script does not have a configurable constant named: '${key}'`
            );
          }
          const { offset } = this.interface.configurables[key];
          const encoded = this.interface.encodeConfigurable(key, value);
          this.bytes.set(encoded, offset);
        });
      } catch (err2) {
        throw new FuelError(
          FuelError.CODES.INVALID_CONFIGURABLE_CONSTANTS,
          `Error setting configurable constants: ${err2.message}.`
        );
      }
      return this;
    }
    /**
     *
     * @param account - The account used to pay the deployment costs.
     * @returns The _blobId_ and a _waitForResult_ callback that returns the deployed predicate
     * once the blob deployment transaction finishes.
     *
     * The returned loader script will have the same configurable constants
     * as the original script which was used to generate the loader script.
     */
    deploy(account) {
      return deployScriptOrPredicate({
        deployer: account,
        abi: this.interface.jsonAbi,
        bytecode: this.bytes,
        loaderInstanceCallback: (loaderBytecode, newAbi) => new Script(loaderBytecode, newAbi, this.account)
      });
    }
  };
  var returnZeroScript2 = new ScriptRequest(
    /*
      Opcode::RET(REG_ZERO)
      Opcode::NOOP
    */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    "0x24000000",
    () => new Uint8Array(0),
    () => void 0
  );

  // src/cli/commands/deploy/deployScripts.ts
  var import_console2 = __require2("console");
  var import_fs24 = __require2("fs");
  async function deployScripts(config) {
    const scripts = [];
    const wallet = await createWallet(config.providerUrl, config.privateKey);
    (0, import_console2.log)(`Deploying scripts to: ${wallet.provider.url}`);
    const scriptsLen = config.scripts.length;
    for (let i = 0; i < scriptsLen; i++) {
      const scriptPath = config.scripts[i];
      const binaryPath = getBinaryPath(scriptPath, config);
      const abiPath = getABIPath(scriptPath, config);
      const projectName = getScriptName(scriptPath);
      const bytecode2 = (0, import_fs24.readFileSync)(binaryPath);
      const abi2 = JSON.parse((0, import_fs24.readFileSync)(abiPath, "utf-8"));
      const script = new Script(bytecode2, abi2, wallet);
      const {
        bytes: loaderBytecode,
        interface: { jsonAbi }
      } = await (await script.deploy(wallet)).waitForResult();
      (0, import_console2.debug)(`Script deployed: ${projectName}`);
      scripts.push({
        path: scriptPath,
        loaderBytecode,
        abi: jsonAbi
      });
    }
    return scripts;
  }

  // src/cli/commands/deploy/saveContractIds.ts
  var import_promises2 = __require2("fs/promises");
  var import_path20 = __require2("path");
  async function saveContractIds(contracts, output2) {
    const contractsMap = contracts.reduce(
      (cConfig, { name, contractId }) => ({
        ...cConfig,
        [name]: contractId
      }),
      {}
    );
    const filePath = (0, import_path20.resolve)(output2, "contract-ids.json");
    await (0, import_promises2.mkdir)(output2, { recursive: true });
    await (0, import_promises2.writeFile)(filePath, JSON.stringify(contractsMap, null, 2));
    log(`Contract IDs saved at: ${filePath}`);
  }

  // src/cli/commands/deploy/savePredicateFiles.ts
  var import_fs25 = __require2("fs");
  function savePredicateFiles(predicates, _config) {
    for (const { path: path6, predicateRoot, loaderBytecode, abi: abi2 } of predicates) {
      const predicateName = getPredicateName(path6);
      const predicateRootPath = `${path6}/out/${predicateName}-loader-bin-root`;
      (0, import_fs25.writeFileSync)(predicateRootPath, predicateRoot);
      const loaderBytecodePath = `${path6}/out/${predicateName}-loader.bin`;
      (0, import_fs25.writeFileSync)(loaderBytecodePath, loaderBytecode);
      const abiPath = `${path6}/out/${predicateName}-loader-abi.json`;
      (0, import_fs25.writeFileSync)(abiPath, JSON.stringify(abi2, null, 2));
    }
  }

  // src/cli/commands/deploy/saveScriptFiles.ts
  var import_fs26 = __require2("fs");
  function saveScriptFiles(scripts, _config) {
    for (const { path: path6, loaderBytecode, abi: abi2 } of scripts) {
      const scriptName = getScriptName(path6);
      const loaderBytecodePath = `${path6}/out/${scriptName}-loader.bin`;
      (0, import_fs26.writeFileSync)(loaderBytecodePath, loaderBytecode);
      const abiPath = `${path6}/out/${scriptName}-loader-abi.json`;
      (0, import_fs26.writeFileSync)(abiPath, JSON.stringify(abi2, null, 2));
    }
  }

  // src/cli/commands/deploy/index.ts
  async function deploy(config) {
    const contracts = await deployContracts(config);
    await saveContractIds(contracts, config.output);
    const scripts = await deployScripts(config);
    saveScriptFiles(scripts, config);
    const predicates = await deployPredicates(config);
    savePredicateFiles(predicates, config);
    config.onDeploy?.(config, {
      contracts,
      scripts,
      predicates
    });
    await generateTypes(config);
    return {
      contracts,
      scripts,
      predicates
    };
  }

  // src/cli/commands/dev/autoStartFuelCore.ts
  var import_portfinder = __toESM(require_portfinder());

  // ../account/dist/test-utils.mjs
  var import_fs27 = __require2("fs");
  var import_os2 = __toESM(__require2("os"), 1);
  var import_path21 = __toESM(__require2("path"), 1);
  var asm5 = __toESM(require_node(), 1);
  var __defProp11 = Object.defineProperty;
  var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField10 = (obj, key, value) => {
    __defNormalProp10(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck3 = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateAdd3 = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateMethod3 = (obj, member, method) => {
    __accessCheck3(obj, member, "access private method");
    return method;
  };
  var Signer2 = class {
    address;
    publicKey;
    compressedPublicKey;
    privateKey;
    /**
     * Create a Signer instance from a given private key
     *
     * @param privateKey - The private key to use for signing
     * @returns A new Signer instance
     */
    constructor(privateKey) {
      if (typeof privateKey === "string") {
        if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
          privateKey = `0x${privateKey}`;
        }
      }
      const privateKeyBytes = toBytes(privateKey, 32);
      this.privateKey = hexlify(privateKeyBytes);
      this.publicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
      this.compressedPublicKey = hexlify(secp256k1.getPublicKey(privateKeyBytes, true));
      this.address = Address.fromPublicKey(this.publicKey);
    }
    /**
     * Sign data using the Signer instance
     *
     * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
     * @ignore
     * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
     *
     * @param data - The data to be sign
     * @returns hashed signature
     */
    sign(data) {
      const signature = secp256k1.sign(arrayify(data), arrayify(this.privateKey));
      const r = toBytes(`0x${signature.r.toString(16)}`, 32);
      const s = toBytes(`0x${signature.s.toString(16)}`, 32);
      s[0] |= (signature.recovery || 0) << 7;
      return hexlify(concat([r, s]));
    }
    /**
     * Add point on the current elliptic curve
     *
     * @param point - Point to add on the curve
     * @returns compressed point on the curve
     */
    addPoint(point) {
      const p0 = secp256k1.ProjectivePoint.fromHex(arrayify(this.compressedPublicKey));
      const p1 = secp256k1.ProjectivePoint.fromHex(arrayify(point));
      const result = p0.add(p1);
      return `0x${result.toHex(true)}`;
    }
    /**
     * Recover the public key from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - hashed signature
     * @returns public key from signature from the
     */
    static recoverPublicKey(data, signature) {
      const signedMessageBytes = arrayify(signature);
      const r = signedMessageBytes.slice(0, 32);
      const s = signedMessageBytes.slice(32, 64);
      const recoveryParam = (s[0] & 128) >> 7;
      s[0] &= 127;
      const sig = new secp256k1.Signature(BigInt(hexlify(r)), BigInt(hexlify(s))).addRecoveryBit(
        recoveryParam
      );
      const publicKey = sig.recoverPublicKey(arrayify(data)).toRawBytes(false).slice(1);
      return hexlify(publicKey);
    }
    /**
     * Recover the address from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - Signature
     * @returns Address from signature
     */
    static recoverAddress(data, signature) {
      return Address.fromPublicKey(Signer2.recoverPublicKey(data, signature));
    }
    /**
     * Generate a random privateKey
     *
     * @param entropy - Adds extra entropy to generate the privateKey
     * @returns random 32-byte hashed
     */
    static generatePrivateKey(entropy) {
      return entropy ? hash2(concat([randomBytes22(32), arrayify(entropy)])) : randomBytes22(32);
    }
    /**
     * Extended publicKey from a compact publicKey
     *
     * @param publicKey - Compact publicKey
     * @returns extended publicKey
     */
    static extendPublicKey(publicKey) {
      const point = secp256k1.ProjectivePoint.fromHex(arrayify(publicKey));
      return hexlify(point.toRawBytes(false).slice(1));
    }
  };
  var getFlagValueFromArgs = (args, flag) => {
    const flagIndex = args.indexOf(flag);
    if (flagIndex === -1) {
      return void 0;
    }
    return args[flagIndex + 1];
  };
  var extractRemainingArgs = (args, flagsToRemove) => {
    const newArgs = [...args];
    flagsToRemove.forEach((flag) => {
      const flagIndex = newArgs.indexOf(flag);
      if (flagIndex !== -1) {
        newArgs.splice(flagIndex, 2);
      }
    });
    return newArgs;
  };
  function getFinalStateConfigJSON({
    stateConfig,
    chainConfig,
    includeInitialState = false
  }) {
    const defaultCoins = defaultSnapshotConfigs.stateConfig.coins.map((coin) => ({
      ...coin,
      amount: "18446744073709551615"
    }));
    const defaultMessages = defaultSnapshotConfigs.stateConfig.messages.map((message) => ({
      ...message,
      amount: "18446744073709551615"
    }));
    const coins = defaultCoins.concat(stateConfig.coins.map((coin) => ({ ...coin, amount: coin.amount.toString() }))).filter((coin, index, self2) => self2.findIndex((c) => c.tx_id === coin.tx_id) === index);
    const messages = defaultMessages.concat(stateConfig.messages.map((msg) => ({ ...msg, amount: msg.amount.toString() }))).filter((msg, index, self2) => self2.findIndex((m) => m.nonce === msg.nonce) === index);
    if (includeInitialState) {
      coins.push({
        tx_id: "0x0000000000000000000000000000000000000000000000000000000000000001",
        output_index: 0,
        tx_pointer_block_height: 0,
        tx_pointer_tx_idx: 0,
        owner: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d",
        amount: "18446744073709551615",
        asset_id: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      });
      coins.push({
        tx_id: "0x0000000000000000000000000000000000000000000000000000000000000002",
        output_index: 0,
        tx_pointer_block_height: 0,
        tx_pointer_tx_idx: 0,
        owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
        amount: "18446744073709551615",
        asset_id: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      });
    }
    if (!process.env.GENESIS_SECRET) {
      const pk = Signer2.generatePrivateKey();
      const signer = new Signer2(pk);
      process.env.GENESIS_SECRET = hexlify(pk);
      coins.push({
        tx_id: hexlify(randomBytes22(BYTES_32)),
        owner: signer.address.toHexString(),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        amount: "18446744073709551615",
        asset_id: chainConfig.consensus_parameters.V2.base_asset_id,
        output_index: 0,
        tx_pointer_block_height: 0,
        tx_pointer_tx_idx: 0
      });
    }
    const json = JSON.stringify({
      ...stateConfig,
      coins,
      messages
    });
    const regexMakeNumber = /("amount":)"(\d+)"/gm;
    return json.replace(regexMakeNumber, "$1$2");
  }
  var launchNode = async ({
    ip,
    port,
    args = [],
    fuelCorePath = process.env.FUEL_CORE_PATH || void 0,
    loggingEnabled = true,
    basePath,
    snapshotConfig = defaultSnapshotConfigs,
    includeInitialState = false,
    killProcessOnExit = false
  } = {}) => (
    // eslint-disable-next-line no-async-promise-executor
    new Promise(async (resolve10, reject) => {
      const remainingArgs = extractRemainingArgs(args, [
        "--snapshot",
        "--consensus-key",
        "--db-type",
        "--poa-instant",
        "--min-gas-price",
        "--native-executor-version"
      ]);
      const snapshotDir = getFlagValueFromArgs(args, "--snapshot");
      const consensusKey = getFlagValueFromArgs(args, "--consensus-key") || defaultConsensusKey;
      const dbTypeFlagValue = getFlagValueFromArgs(args, "--db-type");
      const useInMemoryDb = dbTypeFlagValue === "in-memory" || dbTypeFlagValue === void 0;
      const poaInstantFlagValue = getFlagValueFromArgs(args, "--poa-instant");
      const poaInstant = poaInstantFlagValue === "true" || poaInstantFlagValue === void 0;
      const nativeExecutorVersion = getFlagValueFromArgs(args, "--native-executor-version") || "0";
      const minGasPrice = getFlagValueFromArgs(args, "--min-gas-price") || "1";
      const graphQLStartSubstring = "Binding GraphQL provider to";
      const command = fuelCorePath || "fuel-core";
      const ipToUse = ip || "0.0.0.0";
      const portToUse = port || "0";
      let snapshotDirToUse;
      const prefix = basePath || import_os2.default.tmpdir();
      const suffix = basePath ? "" : randomUUID2();
      const tempDir = import_path21.default.join(prefix, ".fuels", suffix, "snapshotDir");
      if (snapshotDir) {
        snapshotDirToUse = snapshotDir;
      } else {
        if (!(0, import_fs27.existsSync)(tempDir)) {
          (0, import_fs27.mkdirSync)(tempDir, { recursive: true });
        }
        const { metadata } = snapshotConfig;
        const metadataPath = import_path21.default.join(tempDir, "metadata.json");
        const chainConfigPath = import_path21.default.join(tempDir, metadata.chain_config);
        const stateConfigPath = import_path21.default.join(tempDir, metadata.table_encoding.Json.filepath);
        const stateTransitionPath = import_path21.default.join(tempDir, "state_transition_bytecode.wasm");
        (0, import_fs27.writeFileSync)(chainConfigPath, JSON.stringify(snapshotConfig.chainConfig), "utf8");
        (0, import_fs27.writeFileSync)(
          stateConfigPath,
          getFinalStateConfigJSON({
            ...snapshotConfig,
            includeInitialState
          }),
          "utf8"
        );
        (0, import_fs27.writeFileSync)(metadataPath, JSON.stringify(metadata), "utf8");
        (0, import_fs27.writeFileSync)(stateTransitionPath, JSON.stringify(""));
        snapshotDirToUse = tempDir;
      }
      const { spawn: spawn2 } = await import("child_process");
      const child = spawn2(
        command,
        [
          "run",
          ["--ip", ipToUse],
          ["--port", portToUse],
          useInMemoryDb ? ["--db-type", "in-memory"] : ["--db-path", tempDir],
          ["--min-gas-price", minGasPrice],
          poaInstant ? ["--poa-instant", "true"] : [],
          ["--native-executor-version", nativeExecutorVersion],
          ["--consensus-key", consensusKey],
          ["--snapshot", snapshotDirToUse],
          "--vm-backtrace",
          "--utxo-validation",
          "--debug",
          ...remainingArgs
        ].flat(),
        { stdio: "pipe", detached: true }
      );
      if (loggingEnabled) {
        child.stderr.on("data", (chunk) => {
          console.log(chunk.toString());
        });
      }
      const removeChildListeners = () => {
        child.stderr.removeAllListeners();
      };
      const removeTempDir = () => {
        if ((0, import_fs27.existsSync)(tempDir)) {
          (0, import_fs27.rmSync)(tempDir, { recursive: true });
        }
      };
      const childState = {
        isDead: false
      };
      const cleanup = () => {
        if (childState.isDead) {
          return;
        }
        childState.isDead = true;
        removeChildListeners();
        if (child.pid !== void 0) {
          try {
            process.kill(-child.pid);
          } catch (e) {
            const error3 = e;
            if (error3.code === "ESRCH") {
              console.log(
                `fuel-core node under pid ${child.pid} does not exist. The node might have been killed before cleanup was called. Exiting cleanly.`
              );
            } else if (error3.message.includes("pid must be a positive integer")) {
              process.kill(+child.pid);
            } else {
              throw e;
            }
          }
        } else {
          console.error("No PID available for the child process, unable to kill launched node");
        }
        removeTempDir();
      };
      child.stderr.on("data", (chunk) => {
        const text = typeof chunk === "string" ? chunk : chunk.toString();
        if (text.indexOf(graphQLStartSubstring) !== -1) {
          const rows = text.split("\n");
          const rowWithUrl = rows.find((row) => row.indexOf(graphQLStartSubstring) !== -1);
          const [realIp, realPort] = rowWithUrl.split(" ").at(-1).trim().split(":");
          resolve10({
            cleanup,
            ip: realIp,
            port: realPort,
            url: `http://${realIp}:${realPort}/v1/graphql`,
            snapshotDir: snapshotDirToUse,
            pid: child.pid
          });
        }
        if (/error/i.test(text)) {
          console.log(text);
          reject(new FuelError(FuelError.CODES.NODE_LAUNCH_FAILED, text));
        }
      });
      process.setMaxListeners(100);
      process.on("exit", cleanup);
      process.on("SIGINT", cleanup);
      process.on("SIGUSR1", cleanup);
      process.on("SIGUSR2", cleanup);
      process.on("beforeExit", cleanup);
      process.on("uncaughtException", cleanup);
      child.on("exit", (code, _signal) => {
        removeChildListeners();
        removeTempDir();
        if (killProcessOnExit) {
          process.exit(code);
        }
      });
      child.on("error", (err2) => {
        removeChildListeners();
        removeTempDir();
        reject(err2);
      });
    })
  );
  var coinQuantityfy2 = (coinQuantityLike) => {
    let assetId;
    let amount;
    let max2;
    if (Array.isArray(coinQuantityLike)) {
      amount = coinQuantityLike[0];
      assetId = coinQuantityLike[1];
      max2 = coinQuantityLike[2] ?? void 0;
    } else {
      amount = coinQuantityLike.amount;
      assetId = coinQuantityLike.assetId;
      max2 = coinQuantityLike.max ?? void 0;
    }
    const bnAmount = bn(amount);
    return {
      assetId: hexlify(assetId),
      amount: bnAmount.lt(1) ? bn(1) : bnAmount,
      max: max2 ? bn(max2) : void 0
    };
  };
  var addAmountToCoinQuantities2 = (params) => {
    const { amount, assetId } = params;
    const coinQuantities = [...params.coinQuantities];
    const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
    if (assetIdx !== -1) {
      coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
    } else {
      coinQuantities.push({ assetId, amount });
    }
    return coinQuantities;
  };
  var SubmittedStatusFragmentDoc2 = lib_default2`
    fragment SubmittedStatusFragment on SubmittedStatus {
  type: __typename
  time
}
    `;
  var ReceiptFragmentDoc2 = lib_default2`
    fragment receiptFragment on Receipt {
  id
  pc
  is
  to
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
  var SuccessStatusFragmentDoc2 = lib_default2`
    fragment SuccessStatusFragment on SuccessStatus {
  type: __typename
  time
  programState {
    returnType
    data
  }
  receipts {
    ...receiptFragment
  }
  totalGas
  totalFee
}
    ${ReceiptFragmentDoc2}`;
  var SuccessStatusWithBlockIdFragmentDoc2 = lib_default2`
    fragment SuccessStatusWithBlockIdFragment on SuccessStatus {
  ...SuccessStatusFragment
  block {
    id
  }
}
    ${SuccessStatusFragmentDoc2}`;
  var MalleableTransactionFieldsFragmentDoc2 = lib_default2`
    fragment malleableTransactionFieldsFragment on Transaction {
  receiptsRoot
  inputs {
    type: __typename
    ... on InputCoin {
      txPointer
    }
    ... on InputContract {
      txPointer
    }
  }
  outputs {
    type: __typename
    ... on CoinOutput {
      to
      amount
      assetId
    }
    ... on ContractOutput {
      inputIndex
      balanceRoot
      stateRoot
    }
    ... on ChangeOutput {
      to
      amount
      assetId
    }
    ... on VariableOutput {
      to
      amount
      assetId
    }
    ... on ContractCreated {
      contract
      stateRoot
    }
  }
}
    `;
  var FailureStatusFragmentDoc2 = lib_default2`
    fragment FailureStatusFragment on FailureStatus {
  type: __typename
  totalGas
  totalFee
  time
  reason
  receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc2}`;
  var FailureStatusWithBlockIdFragmentDoc2 = lib_default2`
    fragment FailureStatusWithBlockIdFragment on FailureStatus {
  ...FailureStatusFragment
  block {
    id
  }
}
    ${FailureStatusFragmentDoc2}`;
  var SqueezedOutStatusFragmentDoc2 = lib_default2`
    fragment SqueezedOutStatusFragment on SqueezedOutStatus {
  type: __typename
  reason
}
    `;
  var TransactionStatusSubscriptionFragmentDoc2 = lib_default2`
    fragment transactionStatusSubscriptionFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on FailureStatus {
    ...FailureStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc2}
${SuccessStatusWithBlockIdFragmentDoc2}
${MalleableTransactionFieldsFragmentDoc2}
${FailureStatusWithBlockIdFragmentDoc2}
${SqueezedOutStatusFragmentDoc2}`;
  var TransactionStatusFragmentDoc2 = lib_default2`
    fragment transactionStatusFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusFragment
  }
  ... on FailureStatus {
    ...FailureStatusFragment
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc2}
${SuccessStatusFragmentDoc2}
${FailureStatusFragmentDoc2}
${SqueezedOutStatusFragmentDoc2}`;
  var TransactionFragmentDoc2 = lib_default2`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  status {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentDoc2}`;
  var TransactionRawPayloadFragmentDoc2 = lib_default2`
    fragment transactionRawPayloadFragment on Transaction {
  id
  rawPayload
}
    `;
  var InputEstimatePredicatesFragmentDoc2 = lib_default2`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
  var TransactionEstimatePredicatesFragmentDoc2 = lib_default2`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentDoc2}`;
  var DryRunFailureStatusFragmentDoc2 = lib_default2`
    fragment dryRunFailureStatusFragment on DryRunFailureStatus {
  type: __typename
  totalGas
  totalFee
  reason
  programState {
    returnType
    data
  }
}
    `;
  var DryRunSuccessStatusFragmentDoc2 = lib_default2`
    fragment dryRunSuccessStatusFragment on DryRunSuccessStatus {
  type: __typename
  totalGas
  totalFee
  programState {
    returnType
    data
  }
}
    `;
  var DryRunTransactionStatusFragmentDoc2 = lib_default2`
    fragment dryRunTransactionStatusFragment on DryRunTransactionStatus {
  ... on DryRunFailureStatus {
    ...dryRunFailureStatusFragment
  }
  ... on DryRunSuccessStatus {
    ...dryRunSuccessStatusFragment
  }
}
    ${DryRunFailureStatusFragmentDoc2}
${DryRunSuccessStatusFragmentDoc2}`;
  var DryRunTransactionExecutionStatusFragmentDoc2 = lib_default2`
    fragment dryRunTransactionExecutionStatusFragment on DryRunTransactionExecutionStatus {
  id
  status {
    ...dryRunTransactionStatusFragment
  }
  receipts {
    ...receiptFragment
  }
}
    ${DryRunTransactionStatusFragmentDoc2}
${ReceiptFragmentDoc2}`;
  var BlockFragmentDoc2 = lib_default2`
    fragment blockFragment on Block {
  id
  height
  header {
    time
    daHeight
    stateTransitionBytecodeVersion
    transactionsCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    prevRoot
    applicationHash
  }
  transactions {
    id
  }
}
    `;
  var CoinFragmentDoc2 = lib_default2`
    fragment coinFragment on Coin {
  type: __typename
  utxoId
  amount
  assetId
  blockCreated
  txCreatedIdx
}
    `;
  var MessageCoinFragmentDoc2 = lib_default2`
    fragment messageCoinFragment on MessageCoin {
  type: __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
  var MessageFragmentDoc2 = lib_default2`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  daHeight
}
    `;
  var GetMessageFragmentDoc2 = lib_default2`
    fragment getMessageFragment on Message {
  ...messageFragment
  nonce
}
    ${MessageFragmentDoc2}`;
  var MessageProofFragmentDoc2 = lib_default2`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  commitBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  sender
  recipient
  amount
  data
}
    `;
  var TxParametersFragmentDoc2 = lib_default2`
    fragment TxParametersFragment on TxParameters {
  version
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
  maxBytecodeSubsections
}
    `;
  var PredicateParametersFragmentDoc2 = lib_default2`
    fragment PredicateParametersFragment on PredicateParameters {
  version
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
  var ScriptParametersFragmentDoc2 = lib_default2`
    fragment ScriptParametersFragment on ScriptParameters {
  version
  maxScriptLength
  maxScriptDataLength
}
    `;
  var ContractParametersFragmentDoc2 = lib_default2`
    fragment ContractParametersFragment on ContractParameters {
  version
  contractMaxSize
  maxStorageSlots
}
    `;
  var FeeParametersFragmentDoc2 = lib_default2`
    fragment FeeParametersFragment on FeeParameters {
  version
  gasPriceFactor
  gasPerByte
}
    `;
  var DependentCostFragmentDoc2 = lib_default2`
    fragment DependentCostFragment on DependentCost {
  ... on LightOperation {
    type: __typename
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    type: __typename
    base
    gasPerUnit
  }
}
    `;
  var GasCostsFragmentDoc2 = lib_default2`
    fragment GasCostsFragment on GasCosts {
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  ecr1
  newStoragePerByte
}
    ${DependentCostFragmentDoc2}`;
  var ConsensusParametersFragmentDoc2 = lib_default2`
    fragment consensusParametersFragment on ConsensusParameters {
  version
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentDoc2}
${PredicateParametersFragmentDoc2}
${ScriptParametersFragmentDoc2}
${ContractParametersFragmentDoc2}
${FeeParametersFragmentDoc2}
${GasCostsFragmentDoc2}`;
  var ChainInfoFragmentDoc2 = lib_default2`
    fragment chainInfoFragment on ChainInfo {
  name
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${ConsensusParametersFragmentDoc2}`;
  var ContractBalanceFragmentDoc2 = lib_default2`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
  var PageInfoFragmentDoc2 = lib_default2`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
  var NodeInfoFragmentDoc2 = lib_default2`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  maxTx
  maxDepth
  nodeVersion
}
    `;
  var RelayedTransactionStatusFragmentDoc2 = lib_default2`
    fragment relayedTransactionStatusFragment on RelayedTransactionStatus {
  ... on RelayedTransactionFailed {
    blockHeight
    failure
  }
}
    `;
  var GetVersionDocument2 = lib_default2`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
  var GetNodeInfoDocument2 = lib_default2`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentDoc2}`;
  var GetChainDocument2 = lib_default2`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentDoc2}`;
  var GetChainAndNodeInfoDocument2 = lib_default2`
    query getChainAndNodeInfo {
  chain {
    ...chainInfoFragment
  }
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${ChainInfoFragmentDoc2}
${NodeInfoFragmentDoc2}`;
  var GetTransactionDocument2 = lib_default2`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentDoc2}`;
  var GetTransactionWithReceiptsDocument2 = lib_default2`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    id
    rawPayload
    status {
      ... on SubmittedStatus {
        ...SubmittedStatusFragment
      }
      ... on SuccessStatus {
        ...SuccessStatusWithBlockIdFragment
      }
      ... on FailureStatus {
        ...FailureStatusWithBlockIdFragment
      }
      ... on SqueezedOutStatus {
        ...SqueezedOutStatusFragment
      }
    }
  }
}
    ${SubmittedStatusFragmentDoc2}
${SuccessStatusWithBlockIdFragmentDoc2}
${FailureStatusWithBlockIdFragmentDoc2}
${SqueezedOutStatusFragmentDoc2}`;
  var GetTransactionsDocument2 = lib_default2`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        rawPayload
      }
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${PageInfoFragmentDoc2}`;
  var GetTransactionsByOwnerDocument2 = lib_default2`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc2}
${TransactionFragmentDoc2}`;
  var EstimatePredicatesDocument2 = lib_default2`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentDoc2}`;
  var GetLatestBlockDocument2 = lib_default2`
    query getLatestBlock {
  chain {
    latestBlock {
      ...blockFragment
    }
  }
}
    ${BlockFragmentDoc2}`;
  var GetLatestBlockHeightDocument2 = lib_default2`
    query getLatestBlockHeight {
  chain {
    latestBlock {
      height
    }
  }
}
    `;
  var GetBlockDocument2 = lib_default2`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentDoc2}`;
  var GetBlockWithTransactionsDocument2 = lib_default2`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionRawPayloadFragment
    }
  }
}
    ${BlockFragmentDoc2}
${TransactionRawPayloadFragmentDoc2}`;
  var GetBlocksDocument2 = lib_default2`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc2}
${BlockFragmentDoc2}`;
  var GetCoinDocument2 = lib_default2`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
    owner
  }
}
    ${CoinFragmentDoc2}`;
  var GetCoinsDocument2 = lib_default2`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc2}
${CoinFragmentDoc2}`;
  var GetCoinsToSpendDocument2 = lib_default2`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentDoc2}
${MessageCoinFragmentDoc2}`;
  var GetContractDocument2 = lib_default2`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
  var GetContractBalanceDocument2 = lib_default2`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentDoc2}`;
  var GetBalanceDocument2 = lib_default2`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amount
  }
}
    `;
  var GetLatestGasPriceDocument2 = lib_default2`
    query getLatestGasPrice {
  latestGasPrice {
    gasPrice
  }
}
    `;
  var EstimateGasPriceDocument2 = lib_default2`
    query estimateGasPrice($blockHorizon: U32!) {
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    `;
  var GetBalancesDocument2 = lib_default2`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        assetId
        amount
      }
    }
  }
}
    ${PageInfoFragmentDoc2}`;
  var GetMessagesDocument2 = lib_default2`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...getMessageFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc2}
${GetMessageFragmentDoc2}`;
  var GetMessageProofDocument2 = lib_default2`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentDoc2}`;
  var GetMessageStatusDocument2 = lib_default2`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
  var GetRelayedTransactionStatusDocument2 = lib_default2`
    query getRelayedTransactionStatus($relayedTransactionId: RelayedTransactionId!) {
  relayedTransactionStatus(id: $relayedTransactionId) {
    ...relayedTransactionStatusFragment
  }
}
    ${RelayedTransactionStatusFragmentDoc2}`;
  var DryRunDocument2 = lib_default2`
    mutation dryRun($encodedTransactions: [HexString!]!, $utxoValidation: Boolean, $gasPrice: U64) {
  dryRun(
    txs: $encodedTransactions
    utxoValidation: $utxoValidation
    gasPrice: $gasPrice
  ) {
    ...dryRunTransactionExecutionStatusFragment
  }
}
    ${DryRunTransactionExecutionStatusFragmentDoc2}`;
  var SubmitDocument2 = lib_default2`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
  var ProduceBlocksDocument2 = lib_default2`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
  var GetMessageByNonceDocument2 = lib_default2`
    query getMessageByNonce($nonce: Nonce!) {
  message(nonce: $nonce) {
    ...messageFragment
  }
}
    ${MessageFragmentDoc2}`;
  var IsUserAccountDocument2 = lib_default2`
    query isUserAccount($blobId: BlobId!, $contractId: ContractId!, $transactionId: TransactionId!) {
  blob(id: $blobId) {
    id
  }
  contract(id: $contractId) {
    id
  }
  transaction(id: $transactionId) {
    id
  }
}
    `;
  var GetConsensusParametersVersionDocument2 = lib_default2`
    query getConsensusParametersVersion {
  chain {
    latestBlock {
      header {
        consensusParametersVersion
      }
    }
  }
}
    `;
  var SubmitAndAwaitStatusDocument2 = lib_default2`
    subscription submitAndAwaitStatus($encodedTransaction: HexString!) {
  submitAndAwaitStatus(tx: $encodedTransaction) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc2}`;
  var StatusChangeDocument2 = lib_default2`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc2}`;
  function getSdk2(requester) {
    return {
      getVersion(variables, options) {
        return requester(GetVersionDocument2, variables, options);
      },
      getNodeInfo(variables, options) {
        return requester(GetNodeInfoDocument2, variables, options);
      },
      getChain(variables, options) {
        return requester(GetChainDocument2, variables, options);
      },
      getChainAndNodeInfo(variables, options) {
        return requester(GetChainAndNodeInfoDocument2, variables, options);
      },
      getTransaction(variables, options) {
        return requester(GetTransactionDocument2, variables, options);
      },
      getTransactionWithReceipts(variables, options) {
        return requester(GetTransactionWithReceiptsDocument2, variables, options);
      },
      getTransactions(variables, options) {
        return requester(GetTransactionsDocument2, variables, options);
      },
      getTransactionsByOwner(variables, options) {
        return requester(GetTransactionsByOwnerDocument2, variables, options);
      },
      estimatePredicates(variables, options) {
        return requester(EstimatePredicatesDocument2, variables, options);
      },
      getLatestBlock(variables, options) {
        return requester(GetLatestBlockDocument2, variables, options);
      },
      getLatestBlockHeight(variables, options) {
        return requester(GetLatestBlockHeightDocument2, variables, options);
      },
      getBlock(variables, options) {
        return requester(GetBlockDocument2, variables, options);
      },
      getBlockWithTransactions(variables, options) {
        return requester(GetBlockWithTransactionsDocument2, variables, options);
      },
      getBlocks(variables, options) {
        return requester(GetBlocksDocument2, variables, options);
      },
      getCoin(variables, options) {
        return requester(GetCoinDocument2, variables, options);
      },
      getCoins(variables, options) {
        return requester(GetCoinsDocument2, variables, options);
      },
      getCoinsToSpend(variables, options) {
        return requester(GetCoinsToSpendDocument2, variables, options);
      },
      getContract(variables, options) {
        return requester(GetContractDocument2, variables, options);
      },
      getContractBalance(variables, options) {
        return requester(GetContractBalanceDocument2, variables, options);
      },
      getBalance(variables, options) {
        return requester(GetBalanceDocument2, variables, options);
      },
      getLatestGasPrice(variables, options) {
        return requester(GetLatestGasPriceDocument2, variables, options);
      },
      estimateGasPrice(variables, options) {
        return requester(EstimateGasPriceDocument2, variables, options);
      },
      getBalances(variables, options) {
        return requester(GetBalancesDocument2, variables, options);
      },
      getMessages(variables, options) {
        return requester(GetMessagesDocument2, variables, options);
      },
      getMessageProof(variables, options) {
        return requester(GetMessageProofDocument2, variables, options);
      },
      getMessageStatus(variables, options) {
        return requester(GetMessageStatusDocument2, variables, options);
      },
      getRelayedTransactionStatus(variables, options) {
        return requester(GetRelayedTransactionStatusDocument2, variables, options);
      },
      dryRun(variables, options) {
        return requester(DryRunDocument2, variables, options);
      },
      submit(variables, options) {
        return requester(SubmitDocument2, variables, options);
      },
      produceBlocks(variables, options) {
        return requester(ProduceBlocksDocument2, variables, options);
      },
      getMessageByNonce(variables, options) {
        return requester(GetMessageByNonceDocument2, variables, options);
      },
      isUserAccount(variables, options) {
        return requester(IsUserAccountDocument2, variables, options);
      },
      getConsensusParametersVersion(variables, options) {
        return requester(GetConsensusParametersVersionDocument2, variables, options);
      },
      submitAndAwaitStatus(variables, options) {
        return requester(SubmitAndAwaitStatusDocument2, variables, options);
      },
      statusChange(variables, options) {
        return requester(StatusChangeDocument2, variables, options);
      }
    };
  }
  var _FuelGraphqlSubscriber2 = class {
    constructor(stream2) {
      this.stream = stream2;
    }
    static async create(options) {
      const { url, query, variables, fetchFn } = options;
      const response = await fetchFn(`${url}-sub`, {
        method: "POST",
        body: JSON.stringify({
          query: print(query),
          variables
        }),
        headers: {
          "Content-Type": "application/json",
          Accept: "text/event-stream"
        }
      });
      const [errorReader, resultReader] = response.body.tee().map((stream2) => stream2.getReader());
      await new _FuelGraphqlSubscriber2(errorReader).next();
      return new _FuelGraphqlSubscriber2(resultReader);
    }
    events = [];
    parsingLeftover = "";
    async next() {
      while (true) {
        if (this.events.length > 0) {
          const { data, errors: errors2 } = this.events.shift();
          if (Array.isArray(errors2)) {
            throw new FuelError(
              FuelError.CODES.INVALID_REQUEST,
              errors2.map((err2) => err2.message).join("\n\n")
            );
          }
          return { value: data, done: false };
        }
        const { value, done } = await this.stream.read();
        if (done) {
          return { value, done };
        }
        const decoded = _FuelGraphqlSubscriber2.textDecoder.decode(value).replace(":keep-alive-text\n\n", "");
        if (decoded === "") {
          continue;
        }
        const text = `${this.parsingLeftover}${decoded}`;
        const regex = /data:.*\n\n/g;
        const matches = [...text.matchAll(regex)].flatMap((match3) => match3);
        matches.forEach((match3) => {
          try {
            this.events.push(JSON.parse(match3.replace(/^data:/, "")));
          } catch (e) {
            throw new FuelError(
              ErrorCode.STREAM_PARSING_ERROR,
              `Error while parsing stream data response: ${text}`
            );
          }
        });
        this.parsingLeftover = text.replace(matches.join(), "");
      }
    }
    /**
     * Gets called when `break` is called in a `for-await-of` loop.
     */
    return() {
      return Promise.resolve({ done: true, value: void 0 });
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  var FuelGraphqlSubscriber2 = _FuelGraphqlSubscriber2;
  __publicField10(FuelGraphqlSubscriber2, "textDecoder", new TextDecoder());
  var cache2 = /* @__PURE__ */ new Map();
  var ResourceCache2 = class {
    ttl;
    constructor(ttl) {
      this.ttl = ttl;
      if (typeof ttl !== "number" || this.ttl <= 0) {
        throw new FuelError(
          ErrorCode.INVALID_TTL,
          `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
        );
      }
    }
    // Add resources to the cache
    set(transactionId, resources) {
      const currentTime = Date.now();
      const existingResources = cache2.get(transactionId) || {
        utxos: /* @__PURE__ */ new Set(),
        messages: /* @__PURE__ */ new Set(),
        timestamp: currentTime
      };
      resources.utxos.forEach((utxo) => existingResources.utxos.add(hexlify(utxo)));
      resources.messages.forEach((message) => existingResources.messages.add(hexlify(message)));
      cache2.set(transactionId, existingResources);
    }
    // Remove resources from the cache for a given transaction ID
    unset(transactionId) {
      cache2.delete(transactionId);
    }
    // Get all cached resources and remove expired ones
    getActiveData() {
      const allResources = { utxos: [], messages: [] };
      const currentTime = Date.now();
      cache2.forEach((resource, transactionId) => {
        if (currentTime - resource.timestamp < this.ttl) {
          allResources.utxos.push(...resource.utxos);
          allResources.messages.push(...resource.messages);
        } else {
          cache2.delete(transactionId);
        }
      });
      return allResources;
    }
    // Check if a UTXO ID or message nonce is already cached and not expired
    isCached(key) {
      const currentTime = Date.now();
      for (const [transactionId, resourceData] of cache2.entries()) {
        if (currentTime - resourceData.timestamp > this.ttl) {
          cache2.delete(transactionId);
        } else if (resourceData.utxos.has(key) || resourceData.messages.has(key)) {
          return true;
        }
      }
      return false;
    }
    clear() {
      cache2.clear();
    }
  };
  var inputify2 = (value) => {
    const { type: type3 } = value;
    switch (value.type) {
      case InputType.Coin: {
        const predicate = arrayify(value.predicate ?? "0x");
        const predicateData = arrayify(value.predicateData ?? "0x");
        return {
          type: InputType.Coin,
          txID: hexlify(arrayify(value.id).slice(0, BYTES_32)),
          outputIndex: toNumber(arrayify(value.id).slice(BYTES_32, UTXO_ID_LEN)),
          owner: hexlify(value.owner),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId),
          txPointer: {
            blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),
            txIndex: toNumber(arrayify(value.txPointer).slice(8, 16))
          },
          witnessIndex: value.witnessIndex,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: bn(predicate.length),
          predicateDataLength: bn(predicateData.length),
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData)
        };
      }
      case InputType.Contract: {
        return {
          type: InputType.Contract,
          txID: ZeroBytes32,
          outputIndex: 0,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32,
          txPointer: {
            blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),
            txIndex: toNumber(arrayify(value.txPointer).slice(8, 16))
          },
          contractID: hexlify(value.contractId)
        };
      }
      case InputType.Message: {
        const predicate = arrayify(value.predicate ?? "0x");
        const predicateData = arrayify(value.predicateData ?? "0x");
        const data = arrayify(value.data ?? "0x");
        return {
          type: InputType.Message,
          sender: hexlify(value.sender),
          recipient: hexlify(value.recipient),
          amount: bn(value.amount),
          nonce: hexlify(value.nonce),
          witnessIndex: value.witnessIndex,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: bn(predicate.length),
          predicateDataLength: bn(predicateData.length),
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData),
          data: hexlify(data),
          dataLength: data.length
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${type3}.`
        );
      }
    }
  };
  var outputify2 = (value) => {
    const { type: type3 } = value;
    switch (type3) {
      case OutputType.Coin: {
        return {
          type: OutputType.Coin,
          to: hexlify(value.to),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Contract: {
        return {
          type: OutputType.Contract,
          inputIndex: value.inputIndex,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32
        };
      }
      case OutputType.Change: {
        return {
          type: OutputType.Change,
          to: hexlify(value.to),
          amount: bn(0),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Variable: {
        return {
          type: OutputType.Variable,
          to: ZeroBytes32,
          amount: bn(0),
          assetId: ZeroBytes32
        };
      }
      case OutputType.ContractCreated: {
        return {
          type: OutputType.ContractCreated,
          contractId: hexlify(value.contractId),
          stateRoot: hexlify(value.stateRoot)
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction output type: ${type3}.`
        );
      }
    }
  };
  var isMessageCoin2 = (message) => !("data" in message);
  var isCoin2 = (resource) => "id" in resource;
  var doesReceiptHaveMissingOutputVariables2 = (receipt) => receipt.type === ReceiptType.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
  var doesReceiptHaveMissingContractId2 = (receipt) => receipt.type === ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
  var getReceiptsWithMissingData2 = (receipts) => receipts.reduce(
    (memo, receipt) => {
      if (doesReceiptHaveMissingOutputVariables2(receipt)) {
        memo.missingOutputVariables.push(receipt);
      }
      if (doesReceiptHaveMissingContractId2(receipt)) {
        memo.missingOutputContractIds.push(receipt);
      }
      return memo;
    },
    {
      missingOutputVariables: [],
      missingOutputContractIds: []
    }
  );
  var hexOrZero2 = (hex) => hex || ZeroBytes32;
  function assembleReceiptByType2(receipt) {
    const { receiptType } = receipt;
    switch (receiptType) {
      case "CALL": {
        const id = hexOrZero2(receipt.id || receipt.contractId);
        const callReceipt = {
          type: ReceiptType.Call,
          id,
          to: hexOrZero2(receipt?.to),
          amount: bn(receipt.amount),
          assetId: hexOrZero2(receipt.assetId),
          gas: bn(receipt.gas),
          param1: bn(receipt.param1),
          param2: bn(receipt.param2),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return callReceipt;
      }
      case "RETURN": {
        const returnReceipt = {
          type: ReceiptType.Return,
          id: hexOrZero2(receipt.id || receipt.contractId),
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return returnReceipt;
      }
      case "RETURN_DATA": {
        const returnDataReceipt = {
          type: ReceiptType.ReturnData,
          id: hexOrZero2(receipt.id || receipt.contractId),
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero2(receipt.digest),
          pc: bn(receipt.pc),
          data: hexOrZero2(receipt.data),
          is: bn(receipt.is)
        };
        return returnDataReceipt;
      }
      case "PANIC": {
        const panicReceipt = {
          type: ReceiptType.Panic,
          id: hexOrZero2(receipt.id),
          reason: bn(receipt.reason),
          pc: bn(receipt.pc),
          is: bn(receipt.is),
          contractId: hexOrZero2(receipt.contractId)
        };
        return panicReceipt;
      }
      case "REVERT": {
        const revertReceipt = {
          type: ReceiptType.Revert,
          id: hexOrZero2(receipt.id || receipt.contractId),
          val: bn(receipt.ra),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return revertReceipt;
      }
      case "LOG": {
        const ra = bn(receipt.ra);
        const rb = bn(receipt.rb);
        const rc = bn(receipt.rc);
        const rd = bn(receipt.rd);
        const logReceipt = {
          type: ReceiptType.Log,
          id: hexOrZero2(receipt.id || receipt.contractId),
          ra,
          rb,
          rc,
          rd,
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return logReceipt;
      }
      case "LOG_DATA": {
        const ra = bn(receipt.ra);
        const rb = bn(receipt.rb);
        const logDataReceipt = {
          type: ReceiptType.LogData,
          id: hexOrZero2(receipt.id || receipt.contractId),
          ra,
          rb,
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero2(receipt.digest),
          pc: bn(receipt.pc),
          data: hexOrZero2(receipt.data),
          is: bn(receipt.is)
        };
        return logDataReceipt;
      }
      case "TRANSFER": {
        const id = hexOrZero2(receipt.id || receipt.contractId);
        const transferReceipt = {
          type: ReceiptType.Transfer,
          id,
          to: hexOrZero2(receipt.toAddress || receipt?.to),
          amount: bn(receipt.amount),
          assetId: hexOrZero2(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferReceipt;
      }
      case "TRANSFER_OUT": {
        const id = hexOrZero2(receipt.id || receipt.contractId);
        const transferOutReceipt = {
          type: ReceiptType.TransferOut,
          id,
          to: hexOrZero2(receipt.toAddress || receipt.to),
          amount: bn(receipt.amount),
          assetId: hexOrZero2(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferOutReceipt;
      }
      case "SCRIPT_RESULT": {
        const scriptResultReceipt = {
          type: ReceiptType.ScriptResult,
          result: bn(receipt.result),
          gasUsed: bn(receipt.gasUsed)
        };
        return scriptResultReceipt;
      }
      case "MESSAGE_OUT": {
        const sender = hexOrZero2(receipt.sender);
        const recipient = hexOrZero2(receipt.recipient);
        const nonce = hexOrZero2(receipt.nonce);
        const amount = bn(receipt.amount);
        const data = receipt.data ? arrayify(receipt.data) : Uint8Array.from([]);
        const digest = hexOrZero2(receipt.digest);
        const len = bn(receipt.len).toNumber();
        const messageId = InputMessageCoder.getMessageId({
          sender,
          recipient,
          nonce,
          amount,
          data: hexlify(data)
        });
        const receiptMessageOut = {
          type: ReceiptType.MessageOut,
          sender,
          recipient,
          amount,
          nonce,
          len,
          data,
          digest,
          messageId
        };
        return receiptMessageOut;
      }
      case "MINT": {
        const contractId = hexOrZero2(receipt.id || receipt.contractId);
        const subId = hexOrZero2(receipt.subId);
        const assetId = getMintedAssetId(contractId, subId);
        const mintReceipt = {
          type: ReceiptType.Mint,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return mintReceipt;
      }
      case "BURN": {
        const contractId = hexOrZero2(receipt.id || receipt.contractId);
        const subId = hexOrZero2(receipt.subId);
        const assetId = getMintedAssetId(contractId, subId);
        const burnReceipt = {
          type: ReceiptType.Burn,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return burnReceipt;
      }
      default:
        throw new FuelError(ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
    }
  }
  var getGasUsedFromReceipts2 = (receipts) => {
    const scriptResult = receipts.filter(
      (receipt) => receipt.type === ReceiptType.ScriptResult
    );
    const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn(0));
    return gasUsed;
  };
  function resolveGasDependentCosts2(byteSize, gasDependentCost) {
    const base2 = bn(gasDependentCost.base);
    let dependentValue = bn(0);
    if ("unitsPerGas" in gasDependentCost) {
      dependentValue = bn(byteSize).div(bn(gasDependentCost.unitsPerGas));
    } else {
      dependentValue = bn(byteSize).mul(bn(gasDependentCost.gasPerUnit));
    }
    return base2.add(dependentValue);
  }
  function gasUsedByInputs2(inputs, txBytesSize, gasCosts) {
    const witnessCache = [];
    const chargeableInputs = inputs.filter((input) => {
      const isCoinOrMessage = "owner" in input || "sender" in input;
      if (isCoinOrMessage) {
        if ("predicate" in input && input.predicate && input.predicate !== "0x") {
          return true;
        }
        if (!witnessCache.includes(input.witnessIndex)) {
          witnessCache.push(input.witnessIndex);
          return true;
        }
      }
      return false;
    });
    const vmInitializationCost = resolveGasDependentCosts2(txBytesSize, gasCosts.vmInitialization);
    const totalGas = chargeableInputs.reduce((total, input) => {
      if ("predicate" in input && input.predicate && input.predicate !== "0x") {
        return total.add(
          vmInitializationCost.add(resolveGasDependentCosts2(arrayify(input.predicate).length, gasCosts.contractRoot)).add(bn(input.predicateGasUsed))
        );
      }
      return total.add(gasCosts.ecr1);
    }, bn(0));
    return totalGas;
  }
  function getMinGas2(params) {
    const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
    const vmInitGas = resolveGasDependentCosts2(txBytesSize, gasCosts.vmInitialization);
    const bytesGas = bn(txBytesSize).mul(gasPerByte);
    const inputsGas = gasUsedByInputs2(inputs, txBytesSize, gasCosts);
    const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
    return minGas;
  }
  function getMaxGas2(params) {
    const {
      gasPerByte,
      witnessesLength,
      witnessLimit,
      minGas,
      gasLimit = bn(0),
      maxGasPerTx
    } = params;
    let remainingAllowedWitnessGas = bn(0);
    if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
      remainingAllowedWitnessGas = bn(witnessLimit).sub(witnessesLength).mul(gasPerByte);
    }
    const maxGas = remainingAllowedWitnessGas.add(minGas).add(gasLimit);
    return maxGas.gte(maxGasPerTx) ? maxGasPerTx : maxGas;
  }
  function calculateMetadataGasForTxCreate2({
    gasCosts,
    stateRootSize,
    txBytesSize,
    contractBytesSize
  }) {
    const contractRootGas = resolveGasDependentCosts2(contractBytesSize, gasCosts.contractRoot);
    const stateRootGas = resolveGasDependentCosts2(stateRootSize, gasCosts.stateRoot);
    const txIdGas = resolveGasDependentCosts2(txBytesSize, gasCosts.s256);
    const contractIdInputSize = bn(4 + 32 + 32 + 32);
    const contractIdGas = resolveGasDependentCosts2(contractIdInputSize, gasCosts.s256);
    const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
    return metadataGas.maxU64();
  }
  function calculateMetadataGasForTxScript2({
    gasCosts,
    txBytesSize
  }) {
    return resolveGasDependentCosts2(txBytesSize, gasCosts.s256);
  }
  function calculateMetadataGasForTxBlob2({
    gasCosts,
    txBytesSize,
    witnessBytesSize
  }) {
    const txId = resolveGasDependentCosts2(txBytesSize, gasCosts.s256);
    const blobLen = resolveGasDependentCosts2(witnessBytesSize, gasCosts.s256);
    return txId.add(blobLen);
  }
  function calculateMetadataGasForTxUpgrade2({
    gasCosts,
    txBytesSize,
    consensusSize
  }) {
    const txId = resolveGasDependentCosts2(txBytesSize, gasCosts.s256);
    if (consensusSize) {
      const consensusLen = resolveGasDependentCosts2(consensusSize, gasCosts.s256);
      txId.add(consensusLen);
    }
    return txId;
  }
  function calculateMetadataGasForTxUpload2({
    gasCosts,
    txBytesSize,
    subsectionSize,
    subsectionsSize
  }) {
    const txId = resolveGasDependentCosts2(txBytesSize, gasCosts.s256);
    const subsectionLen = resolveGasDependentCosts2(subsectionSize, gasCosts.s256);
    txId.add(subsectionLen);
    const subsectionsLen = resolveGasDependentCosts2(subsectionsSize, gasCosts.stateRoot);
    txId.add(subsectionsLen);
    return txId;
  }
  function calculateMinGasForTxUpload2({
    gasCosts,
    baseMinGas,
    subsectionSize
  }) {
    const additionalStoragePerByte = bn(gasCosts.newStoragePerByte).mul(subsectionSize);
    return bn(baseMinGas).add(additionalStoragePerByte);
  }
  var calculateGasFee2 = (params) => {
    const { gas, gasPrice, priceFactor, tip } = params;
    return gas.mul(gasPrice).div(priceFactor).add(bn(tip));
  };
  function normalize4(object2) {
    Object.keys(object2).forEach((key) => {
      switch (object2[key]?.constructor.name) {
        case "Uint8Array":
          object2[key] = hexlify(object2[key]);
          break;
        case "Array":
          object2[key] = normalize4(object2[key]);
          break;
        case "BN":
          object2[key] = object2[key].toHex();
          break;
        case "Address":
          object2[key] = object2[key].toB256();
          break;
        case "Object":
          object2[key] = normalize4(object2[key]);
          break;
        default:
          break;
      }
    });
    return object2;
  }
  function normalizeJSON2(root) {
    return normalize4(clone_default(root));
  }
  var assemblePanicError2 = (statusReason, metadata) => {
    let errorMessage = `The transaction reverted with reason: "${statusReason}".`;
    if (PANIC_REASONS.includes(statusReason)) {
      errorMessage = `${errorMessage}

You can read more about this error at:

${PANIC_DOC_URL}#variant.${statusReason}`;
    }
    return new FuelError(ErrorCode.SCRIPT_REVERTED, errorMessage, {
      ...metadata,
      reason: statusReason
    });
  };
  var stringify2 = (obj) => JSON.stringify(obj, null, 2);
  var assembleRevertError2 = (receipts, logs, metadata) => {
    let errorMessage = "The transaction reverted with an unknown reason.";
    const revertReceipt = receipts.find(({ type: type3 }) => type3 === ReceiptType.Revert);
    let reason = "";
    if (revertReceipt) {
      const reasonHex = bn(revertReceipt.val).toHex();
      const lastLog = logs[logs.length - 1];
      const lastButOneLog = logs[logs.length - 2];
      switch (reasonHex) {
        case FAILED_REQUIRE_SIGNAL: {
          reason = "require";
          errorMessage = `The transaction reverted because a "require" statement has thrown ${logs.length ? stringify2(lastLog) : "an error."}.`;
          break;
        }
        case FAILED_ASSERT_EQ_SIGNAL: {
          const sufix = logs.length >= 2 ? ` comparing ${stringify2(lastLog)} and ${stringify2(lastButOneLog)}.` : ".";
          reason = "assert_eq";
          errorMessage = `The transaction reverted because of an "assert_eq" statement${sufix}`;
          break;
        }
        case FAILED_ASSERT_NE_SIGNAL: {
          const sufix = logs.length >= 2 ? ` comparing ${stringify2(lastButOneLog)} and ${stringify2(lastLog)}.` : ".";
          reason = "assert_ne";
          errorMessage = `The transaction reverted because of an "assert_ne" statement${sufix}`;
          break;
        }
        case FAILED_ASSERT_SIGNAL:
          reason = "assert";
          errorMessage = `The transaction reverted because an "assert" statement failed to evaluate to true.`;
          break;
        case FAILED_TRANSFER_TO_ADDRESS_SIGNAL:
          reason = "MissingOutputChange";
          errorMessage = `The transaction reverted because it's missing an "OutputChange".`;
          break;
        default:
          throw new FuelError(
            ErrorCode.UNKNOWN,
            `The transaction reverted with an unknown reason: ${revertReceipt.val}`,
            {
              ...metadata,
              reason: "unknown"
            }
          );
      }
    }
    return new FuelError(ErrorCode.SCRIPT_REVERTED, errorMessage, {
      ...metadata,
      reason
    });
  };
  var extractTxError2 = (params) => {
    const { receipts, statusReason, logs } = params;
    const isPanic = receipts.some(({ type: type3 }) => type3 === ReceiptType.Panic);
    const isRevert = receipts.some(({ type: type3 }) => type3 === ReceiptType.Revert);
    const metadata = {
      logs,
      receipts,
      panic: isPanic,
      revert: isRevert,
      reason: ""
    };
    if (isPanic) {
      return assemblePanicError2(statusReason, metadata);
    }
    return assembleRevertError2(receipts, logs, metadata);
  };
  var NoWitnessAtIndexError2 = class extends Error {
    constructor(index) {
      super();
      this.index = index;
      this.message = `Witness at index "${index}" was not found`;
    }
    name = "NoWitnessAtIndexError";
  };
  var isRequestInputCoin2 = (input) => input.type === InputType.Coin;
  var isRequestInputMessage2 = (input) => input.type === InputType.Message;
  var isRequestInputMessageWithoutData2 = (input) => input.type === InputType.Message && bn(input.data).isZero();
  var isRequestInputCoinOrMessage2 = (input) => isRequestInputCoin2(input) || isRequestInputMessage2(input);
  var isRequestInputResource2 = (input) => isRequestInputCoin2(input) || isRequestInputMessageWithoutData2(input);
  var getRequestInputResourceOwner2 = (input) => isRequestInputCoin2(input) ? input.owner : input.recipient;
  var isRequestInputResourceFromOwner2 = (input, owner) => getRequestInputResourceOwner2(input) === owner.toB256();
  var getAssetAmountInRequestInputs2 = (inputs, assetId, baseAsset) => inputs.filter(isRequestInputResource2).reduce((acc, input) => {
    if (isRequestInputCoin2(input) && input.assetId === assetId) {
      return acc.add(input.amount);
    }
    if (isRequestInputMessage2(input) && assetId === baseAsset) {
      return acc.add(input.amount);
    }
    return acc;
  }, bn(0));
  var cacheRequestInputsResourcesFromOwner2 = (inputs, owner) => inputs.reduce(
    (acc, input) => {
      if (isRequestInputCoin2(input) && input.owner === owner.toB256()) {
        acc.utxos.push(input.id);
      } else if (isRequestInputMessage2(input) && input.recipient === owner.toB256()) {
        acc.messages.push(input.nonce);
      }
      return acc;
    },
    {
      utxos: [],
      messages: []
    }
  );
  var getBurnableAssetCount2 = (baseAssetId, transactionRequest) => {
    const { inputs, outputs } = transactionRequest;
    const coinInputs = new Set(inputs.filter(isRequestInputCoin2).map((input) => input.assetId));
    if (inputs.some((i) => isRequestInputMessage2(i) && bn(i.amount).gt(0))) {
      coinInputs.add(baseAssetId);
    }
    const changeOutputs = new Set(
      outputs.filter((output2) => output2.type === OutputType.Change).map((output2) => output2.assetId)
    );
    const difference = new Set([...coinInputs].filter((x) => !changeOutputs.has(x)));
    return difference.size;
  };
  var validateTransactionForAssetBurn2 = (baseAssetId, transactionRequest, enableAssetBurn = false) => {
    if (enableAssetBurn === true) {
      return;
    }
    if (getBurnableAssetCount2(baseAssetId, transactionRequest) <= 0) {
      return;
    }
    const message = [
      "Asset burn detected.",
      "Add the relevant change outputs to the transaction to avoid burning assets.",
      "Or enable asset burn, upon sending the transaction."
    ].join("\n");
    throw new FuelError(ErrorCode.ASSET_BURN_DETECTED, message);
  };
  var witnessify2 = (value) => {
    const data = arrayify(value);
    return {
      data: hexlify(data),
      dataLength: data.length
    };
  };
  var BaseTransactionRequest2 = class {
    /** Gas price for transaction */
    tip;
    /** Block until which tx cannot be included */
    maturity;
    /** The maximum fee payable by this transaction using BASE_ASSET. */
    maxFee;
    /** The maximum amount of witness data allowed for the transaction */
    witnessLimit;
    /** List of inputs */
    inputs = [];
    /** List of outputs */
    outputs = [];
    /** List of witnesses */
    witnesses = [];
    /**
     * Constructor for initializing a base transaction request.
     *
     * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
     */
    constructor({
      tip,
      maturity,
      maxFee,
      witnessLimit,
      inputs,
      outputs,
      witnesses
    } = {}) {
      this.tip = tip ? bn(tip) : void 0;
      this.maturity = maturity && maturity > 0 ? maturity : void 0;
      this.witnessLimit = isDefined(witnessLimit) ? bn(witnessLimit) : void 0;
      this.maxFee = bn(maxFee);
      this.inputs = inputs ?? [];
      this.outputs = outputs ?? [];
      this.witnesses = witnesses ?? [];
    }
    static getPolicyMeta(req2) {
      let policyTypes = 0;
      const policies = [];
      const { tip, witnessLimit, maturity } = req2;
      if (bn(tip).gt(0)) {
        policyTypes += PolicyType.Tip;
        policies.push({ data: bn(tip), type: PolicyType.Tip });
      }
      if (isDefined(witnessLimit) && bn(witnessLimit).gte(0)) {
        policyTypes += PolicyType.WitnessLimit;
        policies.push({ data: bn(witnessLimit), type: PolicyType.WitnessLimit });
      }
      if (maturity && maturity > 0) {
        policyTypes += PolicyType.Maturity;
        policies.push({ data: maturity, type: PolicyType.Maturity });
      }
      policyTypes += PolicyType.MaxFee;
      policies.push({ data: req2.maxFee, type: PolicyType.MaxFee });
      return {
        policyTypes,
        policies
      };
    }
    /**
     * Method to obtain the base transaction details.
     *
     * @returns The base transaction details.
     */
    getBaseTransaction() {
      const inputs = this.inputs?.map(inputify2) ?? [];
      const outputs = this.outputs?.map(outputify2) ?? [];
      const witnesses = this.witnesses?.map(witnessify2) ?? [];
      const { policyTypes, policies } = BaseTransactionRequest2.getPolicyMeta(this);
      return {
        policyTypes,
        inputs,
        outputs,
        policies,
        witnesses,
        inputsCount: inputs.length,
        outputsCount: outputs.length,
        witnessesCount: witnesses.length
      };
    }
    /**
     * Converts the transaction request to a byte array.
     *
     * @returns The transaction bytes.
     */
    toTransactionBytes() {
      return new TransactionCoder().encode(this.toTransaction());
    }
    /**
     * @hidden
     *
     * Pushes an input to the list without any side effects and returns the index
     */
    pushInput(input) {
      this.inputs.push(input);
      return this.inputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes an output to the list without any side effects and returns the index
     */
    pushOutput(output2) {
      this.outputs.push(output2);
      return this.outputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes a witness to the list and returns the index
     *
     * @param signature - The signature to add to the witness.
     * @returns The index of the created witness.
     */
    addWitness(signature) {
      this.witnesses.push(signature);
      return this.witnesses.length - 1;
    }
    /**
     * @hidden
     *
     * Creates an empty witness without any side effects and returns the index
     *
     * @returns The index of the created witness.
     */
    addEmptyWitness() {
      this.addWitness(concat([ZeroBytes32, ZeroBytes32]));
      return this.witnesses.length - 1;
    }
    /**
     * Updates the witness for a given owner and signature.
     *
     * @param address - The address to get the coin input witness index for.
     * @param signature - The signature to update the witness with.
     */
    updateWitnessByOwner(address, signature) {
      const ownerAddress = Address.fromAddressOrString(address);
      const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
      if (typeof witnessIndex === "number") {
        this.updateWitness(witnessIndex, signature);
      }
    }
    /**
     * Updates an existing witness without any side effects.
     *
     * @param index - The index of the witness to update.
     * @param witness - The new witness.
     * @throws If the witness does not exist.
     */
    updateWitness(index, witness) {
      if (!this.witnesses[index]) {
        throw new NoWitnessAtIndexError2(index);
      }
      this.witnesses[index] = witness;
    }
    /**
     * Helper function to add an external signature to the transaction.
     *
     * @param account - The account/s to sign to the transaction.
     * @returns The transaction with the signature witness added.
     */
    async addAccountWitnesses(account) {
      const accounts = Array.isArray(account) ? account : [account];
      await Promise.all(
        accounts.map(async (acc) => {
          this.addWitness(await acc.signTransaction(this));
        })
      );
      return this;
    }
    /**
     * Gets the coin inputs for a transaction.
     *
     * @returns The coin inputs.
     */
    getCoinInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Coin
      );
    }
    /**
     * Gets the coin outputs for a transaction.
     *
     * @returns The coin outputs.
     */
    getCoinOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.Coin
      );
    }
    /**
     * Gets the change outputs for a transaction.
     *
     * @returns The change outputs.
     */
    getChangeOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.Change
      );
    }
    /**
     * @hidden
     *
     * Returns the witnessIndex of the found CoinInput.
     */
    getCoinInputWitnessIndexByOwner(owner) {
      const ownerAddress = addressify(owner);
      const found = this.inputs.find((input) => {
        switch (input.type) {
          case InputType.Coin:
            return hexlify(input.owner) === ownerAddress.toB256();
          case InputType.Message:
            return hexlify(input.recipient) === ownerAddress.toB256();
          default:
            return false;
        }
      });
      return found?.witnessIndex;
    }
    /**
     * Adds a single coin input to the transaction and a change output for the related
     * assetId, if one it was not added yet.
     *
     * @param coin - Coin resource.
     */
    addCoinInput(coin) {
      const { assetId, owner, amount, id, predicate, predicateData } = coin;
      let witnessIndex;
      if (coin.predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.addEmptyWitness();
        }
      }
      const input = {
        id,
        type: InputType.Coin,
        owner: owner.toB256(),
        amount,
        assetId,
        txPointer: "0x00000000000000000000000000000000",
        witnessIndex,
        predicate,
        predicateData
      };
      this.pushInput(input);
      this.addChangeOutput(owner, assetId);
    }
    /**
     * Adds a single message input to the transaction and a change output for the
     * asset against the message
     *
     * @param message - Message resource.
     */
    addMessageInput(message) {
      const { recipient, sender, amount, predicate, nonce, predicateData } = message;
      let witnessIndex;
      if (message.predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.addEmptyWitness();
        }
      }
      const input = {
        nonce,
        type: InputType.Message,
        sender: sender.toB256(),
        recipient: recipient.toB256(),
        data: isMessageCoin2(message) ? "0x" : message.data,
        amount,
        witnessIndex,
        predicate,
        predicateData
      };
      this.pushInput(input);
      if (isMessageCoin2(message)) {
        this.addChangeOutput(recipient, message.assetId);
      }
    }
    /**
     * Adds a single resource to the transaction by adding a coin/message input and a
     * change output for the related assetId, if one it was not added yet.
     *
     * @param resource - The resource to add.
     * @returns This transaction.
     */
    addResource(resource) {
      if (isCoin2(resource)) {
        this.addCoinInput(resource);
      } else {
        this.addMessageInput(resource);
      }
      return this;
    }
    /**
     * Adds multiple resources to the transaction by adding coin/message inputs and change
     * outputs from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addResources(resources) {
      resources.forEach((resource) => this.addResource(resource));
      return this;
    }
    /**
     * Adds a coin output to the transaction.
     *
     * @param to - Address of the owner.
     * @param amount - Amount of coin.
     * @param assetId - Asset ID of coin.
     */
    addCoinOutput(to, amount, assetId) {
      this.pushOutput({
        type: OutputType.Coin,
        to: addressify(to).toB256(),
        amount,
        assetId
      });
      return this;
    }
    /**
     * Adds multiple coin outputs to the transaction.
     *
     * @param to - Address of the destination.
     * @param quantities - Quantities of coins.
     */
    addCoinOutputs(to, quantities) {
      quantities.map(coinQuantityfy2).forEach((quantity) => {
        this.pushOutput({
          type: OutputType.Coin,
          to: addressify(to).toB256(),
          amount: quantity.amount,
          assetId: quantity.assetId
        });
      });
      return this;
    }
    /**
     * Adds a change output to the transaction.
     *
     * @param to - Address of the owner.
     * @param assetId - Asset ID of coin.
     */
    addChangeOutput(to, assetId) {
      const changeOutput = this.getChangeOutputs().find(
        (output2) => hexlify(output2.assetId) === assetId
      );
      if (!changeOutput) {
        this.pushOutput({
          type: OutputType.Change,
          to: addressify(to).toB256(),
          assetId
        });
      }
    }
    /**
     * @hidden
     */
    byteSize() {
      return this.toTransactionBytes().length;
    }
    /**
     * @hidden
     */
    metadataGas(_gasCosts) {
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Not implemented");
    }
    /**
     * @hidden
     */
    calculateMinGas(chainInfo) {
      const { consensusParameters } = chainInfo;
      const {
        gasCosts,
        feeParameters: { gasPerByte }
      } = consensusParameters;
      return getMinGas2({
        gasPerByte,
        gasCosts,
        inputs: this.inputs,
        txBytesSize: this.byteSize(),
        metadataGas: this.metadataGas(gasCosts)
      });
    }
    calculateMaxGas(chainInfo, minGas) {
      const { consensusParameters } = chainInfo;
      const {
        feeParameters: { gasPerByte },
        txParameters: { maxGasPerTx }
      } = consensusParameters;
      const witnessesLength = this.toTransaction().witnesses.reduce(
        (acc, wit) => acc + wit.dataLength,
        0
      );
      return getMaxGas2({
        gasPerByte,
        minGas,
        witnessesLength,
        witnessLimit: this.witnessLimit,
        maxGasPerTx
      });
    }
    /**
     * Funds the transaction with fake UTXOs for each assetId and amount in the
     * quantities array.
     *
     * @param quantities - CoinQuantity Array.
     * @param baseAssetId - The base asset to fund the transaction.
     * @deprecated - This method is deprecated and will be removed in future versions.
     * Please use `Account.generateFakeResources` along with `this.addResources` instead.
     */
    fundWithFakeUtxos(quantities, baseAssetId, resourcesOwner) {
      const findAssetInput = (assetId) => this.inputs.find((input) => {
        if ("assetId" in input) {
          return input.assetId === assetId;
        }
        return false;
      });
      const updateAssetInput = (assetId, quantity) => {
        const assetInput = findAssetInput(assetId);
        let usedQuantity = quantity;
        if (assetId === baseAssetId) {
          usedQuantity = bn("1000000000000000000");
        }
        if (assetInput && "assetId" in assetInput) {
          assetInput.id = hexlify(randomBytes22(UTXO_ID_LEN));
          assetInput.amount = usedQuantity;
        } else {
          this.addResources([
            {
              id: hexlify(randomBytes22(UTXO_ID_LEN)),
              amount: usedQuantity,
              assetId,
              owner: resourcesOwner || Address.fromRandom(),
              blockCreated: bn(1),
              txCreatedIdx: bn(1)
            }
          ]);
        }
      };
      updateAssetInput(baseAssetId, bn(1e11));
      quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
      return this;
    }
    /**
     * Retrieves an array of CoinQuantity for each coin output present in the transaction.
     * a transaction.
     *
     * @returns  CoinQuantity array.
     */
    getCoinOutputsQuantities() {
      const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
        amount: bn(amount),
        assetId: assetId.toString()
      }));
      return coinsQuantities;
    }
    /**
     * Return the minimum amount in native coins required to create
     * a transaction.
     *
     * @returns The transaction as a JSON object.
     */
    toJSON() {
      return normalizeJSON2(this);
    }
    removeWitness(index) {
      this.witnesses.splice(index, 1);
      this.adjustWitnessIndexes(index);
    }
    adjustWitnessIndexes(removedIndex) {
      this.inputs.filter(isRequestInputResource2).forEach((input) => {
        if (input.witnessIndex > removedIndex) {
          input.witnessIndex -= 1;
        }
      });
    }
    updatePredicateGasUsed(inputs) {
      const inputsToExtractGasUsed = inputs.filter(isRequestInputCoinOrMessage2);
      this.inputs.filter(isRequestInputResource2).forEach((i) => {
        const owner = getRequestInputResourceOwner2(i);
        const correspondingInput = inputsToExtractGasUsed.find(
          (x) => isRequestInputResourceFromOwner2(x, Address.fromString(String(owner)))
        );
        if (correspondingInput && "predicateGasUsed" in correspondingInput && bn(correspondingInput.predicateGasUsed).gt(0)) {
          i.predicateGasUsed = correspondingInput.predicateGasUsed;
        }
      });
    }
    byteLength() {
      return this.toTransactionBytes().byteLength;
    }
  };
  function hashTransaction2(transactionRequest, chainId) {
    const transaction = transactionRequest.toTransaction();
    if (transaction.type === TransactionType.Script) {
      transaction.receiptsRoot = ZeroBytes32;
    }
    transaction.inputs = transaction.inputs.map((input) => {
      const inputClone = clone_default(input);
      switch (inputClone.type) {
        case InputType.Coin: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Message: {
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Contract: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.txID = ZeroBytes32;
          inputClone.outputIndex = 0;
          inputClone.balanceRoot = ZeroBytes32;
          inputClone.stateRoot = ZeroBytes32;
          return inputClone;
        }
        default:
          return inputClone;
      }
    });
    transaction.outputs = transaction.outputs.map((output2) => {
      const outputClone = clone_default(output2);
      switch (outputClone.type) {
        case OutputType.Contract: {
          outputClone.balanceRoot = ZeroBytes32;
          outputClone.stateRoot = ZeroBytes32;
          return outputClone;
        }
        case OutputType.Change: {
          outputClone.amount = bn(0);
          return outputClone;
        }
        case OutputType.Variable: {
          outputClone.to = ZeroBytes32;
          outputClone.amount = bn(0);
          outputClone.assetId = ZeroBytes32;
          return outputClone;
        }
        default:
          return outputClone;
      }
    });
    transaction.witnessesCount = 0;
    transaction.witnesses = [];
    const chainIdBytes = uint64ToBytesBE(chainId);
    const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);
    return sha2562(concatenatedData);
  }
  var BlobTransactionRequest2 = class extends BaseTransactionRequest2 {
    static from(obj) {
      return new this(clone_default(obj));
    }
    /** Type of the transaction */
    type = TransactionType.Blob;
    /** Blob ID */
    blobId;
    /** Witness index of the bytecode to create */
    witnessIndex;
    /**
     * Creates an instance `BlobTransactionRequest`.
     *
     * @param blobTransactionRequestLike - The initial values for the instance
     */
    constructor({ witnessIndex, blobId, ...rest }) {
      super(rest);
      this.blobId = blobId;
      this.witnessIndex = witnessIndex ?? 0;
    }
    /**
     * Converts the transaction request to a `TransactionBlob`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const { witnessIndex, blobId } = this;
      return {
        type: TransactionType.Blob,
        ...baseTransaction,
        blobId,
        witnessIndex
      };
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction2(this, chainId);
    }
    /**
     * Calculates the metadata gas cost for a blob transaction.
     *
     * @param gasCosts - gas costs passed from the chain.
     * @returns metadata gas cost for the blob transaction.
     */
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxBlob2({
        gasCosts,
        txBytesSize: this.byteSize(),
        witnessBytesSize: this.witnesses[this.witnessIndex].length
      });
    }
  };
  var getStorageValue2 = (value) => {
    const v = new Uint8Array(32);
    v.set(arrayify(value));
    return v;
  };
  var storageSlotify2 = (storageSlot) => {
    let key;
    let value;
    if (Array.isArray(storageSlot)) {
      key = storageSlot[0];
      value = storageSlot[1];
    } else {
      key = storageSlot.key;
      value = storageSlot.value;
    }
    return {
      key: hexlify(key),
      value: hexlify(getStorageValue2(value))
    };
  };
  var CreateTransactionRequest2 = class extends BaseTransactionRequest2 {
    static from(obj) {
      return new this(clone_default(obj));
    }
    /** Type of the transaction */
    type = TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex;
    /** Salt */
    salt;
    /** List of storage slots to initialize */
    storageSlots;
    /**
     * Creates an instance `CreateTransactionRequest`.
     *
     * @param createTransactionRequestLike - The initial values for the instance
     */
    constructor({ bytecodeWitnessIndex, salt, storageSlots: storageSlots2, ...rest }) {
      super(rest);
      this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
      this.salt = hexlify(salt ?? ZeroBytes32);
      this.storageSlots = [...storageSlots2 ?? []];
    }
    /**
     * Converts the transaction request to a `TransactionCreate`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
      const storageSlots2 = this.storageSlots?.map(storageSlotify2) ?? [];
      return {
        type: TransactionType.Create,
        ...baseTransaction,
        bytecodeWitnessIndex,
        storageSlotsCount: bn(storageSlots2.length),
        salt: this.salt ? hexlify(this.salt) : ZeroBytes32,
        storageSlots: storageSlots2
      };
    }
    /**
     * Get contract created outputs for the transaction.
     *
     * @returns An array of contract created transaction request outputs.
     */
    getContractCreatedOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.ContractCreated
      );
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction2(this, chainId);
    }
    /**
     * Adds a contract created output to the transaction request.
     *
     * @param contractId - The contract ID.
     * @param stateRoot - The state root.
     */
    addContractCreatedOutput(contractId, stateRoot) {
      this.pushOutput({
        type: OutputType.ContractCreated,
        contractId,
        stateRoot
      });
    }
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxCreate2({
        contractBytesSize: bn(arrayify(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
        gasCosts,
        stateRootSize: this.storageSlots.length,
        txBytesSize: this.byteSize()
      });
    }
  };
  var returnZeroScript3 = {
    /*
        Opcode::RET(REG_ZERO)
        Opcode::NOOP
      */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: arrayify("0x24000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var withdrawScript2 = {
    /*
            The following code loads some basic values into registers and calls SMO to create an output message
            5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
            5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
            4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
            24000000	- RET                [return 0]
            00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
            00000000 00000000 [amount value]
        */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: arrayify("0x5040C0105D44C0064C40001124000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var ScriptTransactionRequest2 = class extends BaseTransactionRequest2 {
    static from(obj) {
      return new this(clone_default(obj));
    }
    /** Type of the transaction */
    type = TransactionType.Script;
    /** Gas limit for transaction */
    gasLimit;
    /** Script to execute */
    script;
    /** Script input data (parameters) */
    scriptData;
    abis;
    /**
     * Constructor for `ScriptTransactionRequest`.
     *
     * @param scriptTransactionRequestLike - The initial values for the instance.
     */
    constructor({ script, scriptData, gasLimit, ...rest } = {}) {
      super(rest);
      this.gasLimit = bn(gasLimit);
      this.script = arrayify(script ?? returnZeroScript3.bytes);
      this.scriptData = arrayify(scriptData ?? returnZeroScript3.encodeScriptData());
      this.abis = rest.abis;
    }
    /**
     * Helper function to estimate and fund the transaction request with a specified account.
     *
     * @param account - The account to fund the transaction.
     * @param params - The parameters for the transaction cost.
     * @returns The current instance of the `ScriptTransactionRequest` funded.
     */
    async estimateAndFund(account, { signatureCallback, quantities = [] } = {}) {
      const txCost = await account.getTransactionCost(this, { signatureCallback, quantities });
      this.maxFee = txCost.maxFee;
      this.gasLimit = txCost.gasUsed;
      await account.fund(this, txCost);
      return this;
    }
    /**
     * Converts the transaction request to a `TransactionScript`.
     *
     * @returns The transaction script object.
     */
    toTransaction() {
      const script = arrayify(this.script ?? "0x");
      const scriptData = arrayify(this.scriptData ?? "0x");
      return {
        type: TransactionType.Script,
        scriptGasLimit: this.gasLimit,
        ...super.getBaseTransaction(),
        scriptLength: bn(script.length),
        scriptDataLength: bn(scriptData.length),
        receiptsRoot: ZeroBytes32,
        script: hexlify(script),
        scriptData: hexlify(scriptData)
      };
    }
    /**
     * Get contract inputs for the transaction.
     *
     * @returns An array of contract transaction request inputs.
     */
    getContractInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Contract
      );
    }
    /**
     * Get contract outputs for the transaction.
     *
     * @returns An array of contract transaction request outputs.
     */
    getContractOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.Contract
      );
    }
    /**
     * Get variable outputs for the transaction.
     *
     * @returns An array of variable transaction request outputs.
     */
    getVariableOutputs() {
      return this.outputs.filter(
        (output2) => output2.type === OutputType.Variable
      );
    }
    /**
     * Set the script and its data.
     *
     * @param script - The abstract script request.
     * @param data - The script data.
     */
    setScript(script, data) {
      this.scriptData = script.encodeScriptData(data);
      this.script = script.bytes;
    }
    /**
     * Adds variable outputs to the transaction request.
     *
     * @param numberOfVariables - The number of variables to add.
     * @returns The new length of the outputs array.
     */
    addVariableOutputs(numberOfVariables = 1) {
      let outputsNumber = numberOfVariables;
      while (outputsNumber) {
        this.pushOutput({
          type: OutputType.Variable
        });
        outputsNumber -= 1;
      }
      return this.outputs.length - 1;
    }
    /**
     * Calculates the maximum gas for the transaction.
     *
     * @param chainInfo - The chain information.
     * @param minGas - The minimum gas.
     * @returns the maximum gas.
     */
    calculateMaxGas(chainInfo, minGas) {
      const { consensusParameters } = chainInfo;
      const {
        feeParameters: { gasPerByte },
        txParameters: { maxGasPerTx }
      } = consensusParameters;
      const witnessesLength = this.toTransaction().witnesses.reduce(
        (acc, wit) => acc + wit.dataLength,
        0
      );
      return getMaxGas2({
        gasPerByte,
        minGas,
        witnessesLength,
        witnessLimit: this.witnessLimit,
        gasLimit: this.gasLimit,
        maxGasPerTx
      });
    }
    /**
     * Adds a contract input and output to the transaction request.
     *
     * @param contract - The contract ID.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    addContractInputAndOutput(contract) {
      const contractAddress = addressify(contract);
      if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
        return this;
      }
      const inputIndex = super.pushInput({
        type: InputType.Contract,
        contractId: contractAddress.toB256(),
        txPointer: "0x00000000000000000000000000000000"
      });
      this.pushOutput({
        type: OutputType.Contract,
        inputIndex
      });
      return this;
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction2(this, chainId);
    }
    /**
     * Sets the data for the transaction request.
     *
     * @param abi - Script JSON ABI.
     * @param args - The input arguments.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    setData(abi2, args) {
      const abiInterface = new Interface(abi2);
      this.scriptData = abiInterface.functions.main.encodeArguments(args);
      return this;
    }
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxScript2({
        gasCosts,
        txBytesSize: this.byteSize()
      });
    }
  };
  var UpgradeTransactionRequest2 = class extends BaseTransactionRequest2 {
    static from(obj) {
      if (obj instanceof UpgradeTransactionRequest2) {
        return obj;
      }
      return new this(clone_default(obj));
    }
    /** The type of transaction */
    type = TransactionType.Upgrade;
    /** The upgrade purpose */
    upgradePurpose;
    /** Witness index of consensus */
    bytecodeWitnessIndex;
    /**
     * Creates an instance `UpgradeTransactionRequest`.
     *
     * @param upgradeTransactionRequestLike - The initial values for the instance
     */
    constructor({
      upgradePurpose,
      bytecodeWitnessIndex,
      ...rest
    } = {}) {
      super(rest);
      this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
      this.upgradePurpose = upgradePurpose ?? {
        type: UpgradePurposeTypeEnum.ConsensusParameters,
        checksum: "0x"
      };
    }
    /**
     * Adds a consensus parameters upgrade purpose.
     *
     * @param consensus - The consensus bytecode.
     *
     * @returns - The current instance of `UpgradeTransactionRequest`.
     */
    addConsensusParametersUpgradePurpose(consensus) {
      this.bytecodeWitnessIndex = this.addWitness(consensus);
      this.upgradePurpose = {
        type: UpgradePurposeTypeEnum.ConsensusParameters,
        checksum: hash2(consensus)
      };
      return this;
    }
    /**
     * Adds a state transition upgrade purpose.
     *
     * @param bytecodeRoot - The Merkle root of the state transition.
     *
     * @returns - The current instance of `UpgradeTransactionRequest`.
     */
    addStateTransitionUpgradePurpose(bytecodeRoot) {
      this.upgradePurpose = {
        type: UpgradePurposeTypeEnum.StateTransition,
        data: hexlify(bytecodeRoot)
      };
      return this;
    }
    /**
     * Adds an upgrade purpose.
     *
     * @param type - The upgrade purpose type.
     * @param data - The bytecode or merkle root of upgrade purpose
     *
     * @returns - The current instance of `UpgradeTransactionRequest`.
     */
    addUpgradePurpose(type3, data) {
      if (type3 === UpgradePurposeTypeEnum.ConsensusParameters) {
        this.addConsensusParametersUpgradePurpose(data);
      }
      if (type3 === UpgradePurposeTypeEnum.StateTransition) {
        this.addStateTransitionUpgradePurpose(data);
      }
      return this;
    }
    /**
     * Converts the transaction request to a `TransactionUpgrade`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      let upgradePurpose;
      if (this.upgradePurpose.type === UpgradePurposeTypeEnum.ConsensusParameters) {
        upgradePurpose = {
          type: UpgradePurposeTypeEnum.ConsensusParameters,
          data: {
            witnessIndex: this.bytecodeWitnessIndex,
            checksum: this.upgradePurpose.checksum
          }
        };
      } else if (this.upgradePurpose.type === UpgradePurposeTypeEnum.StateTransition) {
        upgradePurpose = {
          type: UpgradePurposeTypeEnum.StateTransition,
          data: {
            bytecodeRoot: hexlify(this.upgradePurpose.data)
          }
        };
      } else {
        throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
      }
      return {
        type: TransactionType.Upgrade,
        ...super.getBaseTransaction(),
        upgradePurpose
      };
    }
    /**
     * Gets the Transaction ID by hashing the transaction
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction2(this, chainId);
    }
    /**
     * Calculates the metadata gas cost for an upgrade transaction.
     *
     * @param gasCosts - gas costs passed from the chain.
     *
     * @returns metadata gas cost for the upgrade transaction.
     */
    metadataGas(gasCosts) {
      const txBytesSize = this.byteSize();
      if (this.upgradePurpose.type === UpgradePurposeTypeEnum.ConsensusParameters) {
        const witnessIndex = this.bytecodeWitnessIndex;
        const consensusSize = this.witnesses[witnessIndex].length;
        return calculateMetadataGasForTxUpgrade2({
          gasCosts,
          txBytesSize,
          consensusSize
        });
      }
      if (this.upgradePurpose.type === UpgradePurposeTypeEnum.StateTransition) {
        return calculateMetadataGasForTxUpgrade2({
          gasCosts,
          txBytesSize
        });
      }
      throw new FuelError(FuelError.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
    }
  };
  var UploadTransactionRequest2 = class extends BaseTransactionRequest2 {
    static from(obj) {
      if (obj instanceof UploadTransactionRequest2) {
        return obj;
      }
      return new this(clone_default(obj));
    }
    /** Type of the transaction */
    type = TransactionType.Upload;
    /** The witness index of the subsection of the bytecode. */
    witnessIndex;
    /** The subsection data. */
    subsection;
    /**
     * Creates an instance `UploadTransactionRequest`.
     *
     * @param uploadTransactionRequestLike - The initial values for the instance
     */
    constructor({ witnessIndex, subsection, ...rest } = {}) {
      super(rest);
      this.witnessIndex = witnessIndex ?? 0;
      this.subsection = subsection ?? {
        proofSet: [],
        root: ZeroBytes32,
        subsectionIndex: 0,
        subsectionsNumber: 0
      };
    }
    /**
     * Adds the subsection.
     *
     * @param subsection - The subsection data.
     */
    addSubsection(subsection) {
      const { subsection: subsectionBytecode, ...rest } = subsection;
      this.subsection = rest;
      this.witnessIndex = this.addWitness(subsectionBytecode);
    }
    /**
     * Gets the Transaction Request by hashing the transaction.
     *
     * @param chainId - The chain ID.
     *
     * @returns - A hash of the transaction, which is the transaction ID.
     */
    getTransactionId(chainId) {
      return hashTransaction2(this, chainId);
    }
    /**
     * Converts the transaction request to a `TransactionUpload`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const { subsectionIndex, subsectionsNumber, root, proofSet } = this.subsection;
      return {
        type: TransactionType.Upload,
        ...baseTransaction,
        subsectionIndex,
        subsectionsNumber,
        root: hexlify(root),
        proofSet: proofSet.map(hexlify),
        witnessIndex: this.witnessIndex,
        proofSetCount: proofSet.length
      };
    }
    /**
     * Calculates the metadata gas cost for an upload transaction.
     *
     * @param gasCosts - gas costs passed from the chain.
     *
     * @returns metadata gas cost for the upload transaction.
     */
    metadataGas(gasCosts) {
      return calculateMetadataGasForTxUpload2({
        gasCosts,
        txBytesSize: this.byteSize(),
        subsectionSize: arrayify(this.witnesses[this.witnessIndex]).length,
        subsectionsSize: this.subsection.subsectionsNumber
      });
    }
    /**
     * Calculates the minimum gas for an upload transaction.
     *
     * @param chainInfo - The chain information.
     *
     * @returns the minimum gas for the upload transaction
     */
    calculateMinGas(chainInfo) {
      const minGas = super.calculateMinGas(chainInfo);
      const { gasCosts } = chainInfo.consensusParameters;
      const bytecode2 = this.witnesses[this.witnessIndex] ?? ZeroBytes32;
      return calculateMinGasForTxUpload2({
        gasCosts,
        baseMinGas: minGas.toNumber(),
        subsectionSize: arrayify(bytecode2).length
      });
    }
  };
  var transactionRequestify2 = (obj) => {
    if (obj instanceof ScriptTransactionRequest2 || obj instanceof CreateTransactionRequest2 || obj instanceof BlobTransactionRequest2 || obj instanceof UpgradeTransactionRequest2 || obj instanceof UploadTransactionRequest2) {
      return obj;
    }
    const { type: type3 } = obj;
    switch (obj.type) {
      case TransactionType.Script: {
        return ScriptTransactionRequest2.from(obj);
      }
      case TransactionType.Create: {
        return CreateTransactionRequest2.from(obj);
      }
      case TransactionType.Blob: {
        return BlobTransactionRequest2.from(obj);
      }
      case TransactionType.Upgrade: {
        return UpgradeTransactionRequest2.from(obj);
      }
      case TransactionType.Upload: {
        return UploadTransactionRequest2.from(obj);
      }
      default: {
        throw new FuelError(
          ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${type3}.`
        );
      }
    }
  };
  var isTransactionTypeScript2 = (request) => request.type === TransactionType.Script;
  var isTransactionTypeCreate2 = (request) => request.type === TransactionType.Create;
  var calculateTXFeeForSummary2 = (params) => {
    const {
      gasPrice,
      rawPayload,
      tip,
      consensusParameters: { gasCosts, feeParams, maxGasPerTx }
    } = params;
    const gasPerByte = bn(feeParams.gasPerByte);
    const gasPriceFactor = bn(feeParams.gasPriceFactor);
    const transactionBytes = arrayify(rawPayload);
    const [transaction] = new TransactionCoder().decode(transactionBytes, 0);
    const { type: type3, witnesses, inputs, policies } = transaction;
    let metadataGas = bn(0);
    let gasLimit = bn(0);
    if (type3 !== TransactionType.Create && type3 !== TransactionType.Script) {
      return bn(0);
    }
    if (type3 === TransactionType.Create) {
      const { bytecodeWitnessIndex, storageSlots: storageSlots2 } = transaction;
      const contractBytesSize = bn(arrayify(witnesses[bytecodeWitnessIndex].data).length);
      metadataGas = calculateMetadataGasForTxCreate2({
        contractBytesSize,
        gasCosts,
        stateRootSize: storageSlots2.length || 0,
        txBytesSize: transactionBytes.length
      });
    } else {
      const { scriptGasLimit } = transaction;
      if (scriptGasLimit) {
        gasLimit = scriptGasLimit;
      }
      metadataGas = calculateMetadataGasForTxScript2({
        gasCosts,
        txBytesSize: transactionBytes.length
      });
    }
    const minGas = getMinGas2({
      gasCosts,
      gasPerByte: bn(gasPerByte),
      inputs,
      metadataGas,
      txBytesSize: transactionBytes.length
    });
    const witnessLimit = policies.find((policy) => policy.type === PolicyType.WitnessLimit)?.data;
    const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
    const maxGas = getMaxGas2({
      gasPerByte,
      minGas,
      witnessesLength,
      gasLimit,
      witnessLimit,
      maxGasPerTx
    });
    const maxFee = calculateGasFee2({
      gasPrice,
      gas: maxGas,
      priceFactor: gasPriceFactor,
      tip
    });
    return maxFee;
  };
  var getFunctionCall2 = ({ abi: abi2, receipt }) => {
    const abiInterface = new Interface(abi2);
    const callFunctionSelector = receipt.param1.toHex(8);
    const functionFragment = abiInterface.getFunction(callFunctionSelector);
    const inputs = functionFragment.jsonFn.inputs;
    const encodedArgs = receipt.param2.toHex();
    let argumentsProvided;
    const data = functionFragment.decodeArguments(encodedArgs);
    if (data) {
      argumentsProvided = inputs.reduce((prev, input, index) => {
        const value = data[index];
        const name = input.name;
        if (name) {
          return {
            ...prev,
            // reparse to remove bn
            [name]: JSON.parse(JSON.stringify(value))
          };
        }
        return prev;
      }, {});
    }
    const call2 = {
      functionSignature: functionFragment.signature,
      functionName: functionFragment.name,
      argumentsProvided,
      ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
    };
    return call2;
  };
  function getInputsByTypes2(inputs, types2) {
    return inputs.filter((i) => types2.includes(i.type));
  }
  function getInputsByType2(inputs, type3) {
    return inputs.filter((i) => i.type === type3);
  }
  function getInputsCoin2(inputs) {
    return getInputsByType2(inputs, InputType.Coin);
  }
  function getInputsMessage2(inputs) {
    return getInputsByType2(inputs, InputType.Message);
  }
  function getInputsCoinAndMessage2(inputs) {
    return getInputsByTypes2(inputs, [InputType.Coin, InputType.Message]);
  }
  function isInputCoin2(input) {
    return input.type === InputType.Coin;
  }
  function getInputsContract2(inputs) {
    return getInputsByType2(inputs, InputType.Contract);
  }
  function findCoinInput2(inputs, assetId) {
    const coinInputs = getInputsCoin2(inputs);
    return coinInputs.find((i) => i.assetId === assetId);
  }
  function aggregateInputsAmountsByAssetAndOwner2(inputs, baseAssetId) {
    const aggregated = /* @__PURE__ */ new Map();
    getInputsCoinAndMessage2(inputs).forEach((input) => {
      const assetId = isInputCoin2(input) ? input.assetId : baseAssetId;
      const owner = isInputCoin2(input) ? input.owner : input.recipient;
      let ownersMap = aggregated.get(assetId);
      if (!ownersMap) {
        ownersMap = /* @__PURE__ */ new Map();
        aggregated.set(assetId, ownersMap);
      }
      let ownerBalance = ownersMap.get(owner);
      if (!ownerBalance) {
        ownerBalance = new BN(0);
        ownersMap.set(owner, ownerBalance);
      }
      ownersMap.set(owner, ownerBalance.add(input.amount));
    });
    return aggregated;
  }
  function findMessageInput2(inputs) {
    return getInputsMessage2(inputs)?.[0];
  }
  function getInputFromAssetId2(inputs, assetId, isBaseAsset = false) {
    const coinInput = findCoinInput2(inputs, assetId);
    if (coinInput) {
      return coinInput;
    }
    if (isBaseAsset) {
      return findMessageInput2(inputs);
    }
    return void 0;
  }
  function getInputContractFromIndex2(inputs, inputIndex) {
    if (inputIndex == null) {
      return void 0;
    }
    const contractInput = inputs?.[inputIndex];
    if (!contractInput) {
      return void 0;
    }
    if (contractInput.type !== InputType.Contract) {
      throw new FuelError(
        ErrorCode.INVALID_TRANSACTION_INPUT,
        `Contract input should be of type 'contract'.`
      );
    }
    return contractInput;
  }
  function getInputAccountAddress2(input) {
    if (input.type === InputType.Coin) {
      return input.owner.toString();
    }
    if (input.type === InputType.Message) {
      return input.recipient.toString();
    }
    return "";
  }
  function getOutputsByType2(outputs, type3) {
    return outputs.filter((o) => o.type === type3);
  }
  function getOutputsContractCreated2(outputs) {
    return getOutputsByType2(outputs, OutputType.ContractCreated);
  }
  function getOutputsCoin2(outputs) {
    return getOutputsByType2(outputs, OutputType.Coin);
  }
  function getOutputsChange2(outputs) {
    return getOutputsByType2(outputs, OutputType.Change);
  }
  function getOutputsContract2(outputs) {
    return getOutputsByType2(outputs, OutputType.Contract);
  }
  function getReceiptsByType2(receipts, type3) {
    return (receipts ?? []).filter((r) => r.type === type3);
  }
  function getTransactionTypeName2(transactionType) {
    switch (transactionType) {
      case TransactionType.Mint:
        return "Mint";
      case TransactionType.Create:
        return "Create";
      case TransactionType.Script:
        return "Script";
      case TransactionType.Blob:
        return "Blob";
      case TransactionType.Upgrade:
        return "Upgrade";
      case TransactionType.Upload:
        return "Upload";
      default:
        throw new FuelError(
          ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
          `Unsupported transaction type: ${transactionType}.`
        );
    }
  }
  function isType2(transactionType, type3) {
    const txType = getTransactionTypeName2(transactionType);
    return txType === type3;
  }
  function isTypeMint2(transactionType) {
    return isType2(
      transactionType,
      "Mint"
      /* Mint */
    );
  }
  function isTypeCreate2(transactionType) {
    return isType2(
      transactionType,
      "Create"
      /* Create */
    );
  }
  function isTypeScript2(transactionType) {
    return isType2(
      transactionType,
      "Script"
      /* Script */
    );
  }
  function isTypeUpgrade2(transactionType) {
    return isType2(
      transactionType,
      "Upgrade"
      /* Upgrade */
    );
  }
  function isTypeUpload2(transactionType) {
    return isType2(
      transactionType,
      "Upload"
      /* Upload */
    );
  }
  function isTypeBlob2(transactionType) {
    return isType2(
      transactionType,
      "Blob"
      /* Blob */
    );
  }
  function getReceiptsCall2(receipts) {
    return getReceiptsByType2(receipts, ReceiptType.Call);
  }
  function getReceiptsMessageOut2(receipts) {
    return getReceiptsByType2(receipts, ReceiptType.MessageOut);
  }
  function mergeAssets2(op1, op2) {
    const assets1 = op1.assetsSent || [];
    const assets22 = op2.assetsSent || [];
    const assetMap = /* @__PURE__ */ new Map();
    assets1.forEach((asset) => {
      assetMap.set(asset.assetId, { ...asset });
    });
    assets22.forEach((asset) => {
      const existingAsset = assetMap.get(asset.assetId);
      if (existingAsset) {
        existingAsset.amount = bn(existingAsset.amount).add(asset.amount);
      } else {
        assetMap.set(asset.assetId, { ...asset });
      }
    });
    return Array.from(assetMap.values());
  }
  function isSameOperation2(a, b) {
    return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
  }
  function mergeAssetsSent2(existing, toAdd) {
    if (!toAdd.assetsSent?.length) {
      return existing.assetsSent;
    }
    return existing.assetsSent?.length ? mergeAssets2(existing, toAdd) : toAdd.assetsSent;
  }
  function mergeCalls2(existing, toAdd) {
    if (!toAdd.calls?.length) {
      return existing.calls;
    }
    return [...existing.calls || [], ...toAdd.calls];
  }
  function mergeOperations2(existing, toAdd) {
    return {
      ...existing,
      assetsSent: mergeAssetsSent2(existing, toAdd),
      calls: mergeCalls2(existing, toAdd)
    };
  }
  function addOperation2(operations, toAdd) {
    const existingIndex = operations.findIndex((op) => isSameOperation2(op, toAdd));
    if (existingIndex === -1) {
      return [...operations, toAdd];
    }
    return operations.map((op, index) => index === existingIndex ? mergeOperations2(op, toAdd) : op);
  }
  function getWithdrawFromFuelOperations2({
    inputs,
    receipts,
    baseAssetId
  }) {
    const messageOutReceipts = getReceiptsMessageOut2(receipts);
    const withdrawFromFuelOperations = messageOutReceipts.reduce(
      (prevWithdrawFromFuelOps, receipt) => {
        const input = getInputFromAssetId2(inputs, baseAssetId, true);
        if (input) {
          const inputAddress = getInputAccountAddress2(input);
          const newWithdrawFromFuelOps = addOperation2(prevWithdrawFromFuelOps, {
            name: "Withdraw from Fuel",
            from: {
              type: 1,
              address: inputAddress
            },
            to: {
              type: 1,
              address: receipt.recipient.toString(),
              chain: "ethereum"
              /* ethereum */
            },
            assetsSent: [
              {
                amount: receipt.amount,
                assetId: baseAssetId
              }
            ]
          });
          return newWithdrawFromFuelOps;
        }
        return prevWithdrawFromFuelOps;
      },
      []
    );
    return withdrawFromFuelOperations;
  }
  function getContractCalls2(contractInput, abiMap, receipt, rawPayload, maxInputs) {
    const abi2 = abiMap?.[contractInput.contractID];
    if (!abi2) {
      return [];
    }
    return [
      getFunctionCall2({
        abi: abi2,
        receipt,
        rawPayload,
        maxInputs
      })
    ];
  }
  function getAssetsSent2(receipt) {
    return receipt.amount?.isZero() ? void 0 : [
      {
        amount: receipt.amount,
        assetId: receipt.assetId
      }
    ];
  }
  function processCallReceipt2(receipt, contractInput, inputs, abiMap, rawPayload, maxInputs, baseAssetId) {
    const assetId = receipt.assetId === ZeroBytes32 ? baseAssetId : receipt.assetId;
    const input = getInputFromAssetId2(inputs, assetId, assetId === baseAssetId);
    if (!input) {
      return [];
    }
    const inputAddress = getInputAccountAddress2(input);
    const calls = getContractCalls2(contractInput, abiMap, receipt, rawPayload, maxInputs);
    return [
      {
        name: "Contract call",
        from: {
          type: 1,
          address: inputAddress
        },
        to: {
          type: 0,
          address: receipt.to
        },
        assetsSent: getAssetsSent2(receipt),
        calls
      }
    ];
  }
  function getContractCallOperations2({
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs,
    baseAssetId
  }) {
    const contractCallReceipts = getReceiptsCall2(receipts);
    const contractOutputs = getOutputsContract2(outputs);
    return contractOutputs.flatMap((output2) => {
      const contractInput = getInputContractFromIndex2(inputs, output2.inputIndex);
      if (!contractInput) {
        return [];
      }
      return contractCallReceipts.filter((receipt) => receipt.to === contractInput.contractID).flatMap(
        (receipt) => processCallReceipt2(
          receipt,
          contractInput,
          inputs,
          abiMap,
          rawPayload,
          maxInputs,
          baseAssetId
        )
      );
    });
  }
  function extractTransferOperationFromReceipt2(receipt, contractInputs, changeOutputs) {
    const { to: toAddress, assetId, amount } = receipt;
    let { id: fromAddress } = receipt;
    const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 : 1;
    if (ZeroBytes32 === fromAddress) {
      const change = changeOutputs.find((output2) => output2.assetId === assetId);
      fromAddress = change?.to || fromAddress;
    }
    const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 : 1;
    return {
      name: "Transfer asset",
      from: {
        type: fromType,
        address: fromAddress
      },
      to: {
        type: toType,
        address: toAddress
      },
      assetsSent: [
        {
          assetId: assetId.toString(),
          amount
        }
      ]
    };
  }
  function getTransferOperations2({
    inputs,
    outputs,
    receipts,
    baseAssetId
  }) {
    let operations = [];
    const coinOutputs = getOutputsCoin2(outputs);
    const contractInputs = getInputsContract2(inputs);
    const changeOutputs = getOutputsChange2(outputs);
    const aggregated = aggregateInputsAmountsByAssetAndOwner2(inputs, baseAssetId);
    coinOutputs.forEach(({ amount, assetId, to }) => {
      const txPayers = aggregated.get(assetId) || /* @__PURE__ */ new Map();
      let selectedPayer;
      let fallbackPayer;
      for (const [address, payedAmount] of txPayers) {
        if (!fallbackPayer) {
          fallbackPayer = address;
        }
        if (payedAmount.gte(amount)) {
          selectedPayer = address;
          break;
        }
      }
      selectedPayer = selectedPayer || fallbackPayer;
      if (selectedPayer) {
        operations = addOperation2(operations, {
          name: "Transfer asset",
          from: {
            type: 1,
            address: selectedPayer
          },
          to: {
            type: 1,
            address: to
          },
          assetsSent: [{ assetId, amount }]
        });
      }
    });
    const transferReceipts = getReceiptsByType2(
      receipts,
      ReceiptType.Transfer
    );
    const transferOutReceipts = getReceiptsByType2(
      receipts,
      ReceiptType.TransferOut
    );
    [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
      const operation = extractTransferOperationFromReceipt2(receipt, contractInputs, changeOutputs);
      operations = addOperation2(operations, operation);
    });
    return operations;
  }
  function getPayProducerOperations2(outputs) {
    const coinOutputs = getOutputsCoin2(outputs);
    const payProducerOperations = coinOutputs.reduce((prev, output2) => {
      const operations = addOperation2(prev, {
        name: "Pay network fee to block producer",
        from: {
          type: 1,
          address: "Network"
        },
        to: {
          type: 1,
          address: output2.to.toString()
        },
        assetsSent: [
          {
            assetId: output2.assetId.toString(),
            amount: output2.amount
          }
        ]
      });
      return operations;
    }, []);
    return payProducerOperations;
  }
  function getContractCreatedOperations2({ inputs, outputs }) {
    const contractCreatedOutputs = getOutputsContractCreated2(outputs);
    const input = getInputsCoinAndMessage2(inputs)[0];
    const fromAddress = getInputAccountAddress2(input);
    const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
      const operations = addOperation2(prev, {
        name: "Contract created",
        from: {
          type: 1,
          address: fromAddress
        },
        to: {
          type: 0,
          address: contractCreatedOutput?.contractId || ""
        }
      });
      return operations;
    }, []);
    return contractCreatedOperations;
  }
  function getOperations2({
    transactionType,
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs,
    baseAssetId
  }) {
    if (isTypeCreate2(transactionType)) {
      return [...getContractCreatedOperations2({ inputs, outputs })];
    }
    if (isTypeScript2(transactionType)) {
      return [
        ...getTransferOperations2({ inputs, outputs, receipts, baseAssetId }),
        ...getContractCallOperations2({
          inputs,
          outputs,
          receipts,
          abiMap,
          rawPayload,
          maxInputs,
          baseAssetId
        }),
        ...getWithdrawFromFuelOperations2({ inputs, receipts, baseAssetId })
      ];
    }
    return [...getPayProducerOperations2(outputs)];
  }
  var processGqlReceipt2 = (gqlReceipt) => assembleReceiptByType2(gqlReceipt);
  var extractMintedAssetsFromReceipts2 = (receipts) => {
    const mintedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Mint) {
        mintedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return mintedAssets;
  };
  var extractBurnedAssetsFromReceipts2 = (receipts) => {
    const burnedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Burn) {
        burnedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return burnedAssets;
  };
  var getTransactionStatusName2 = (gqlStatus) => {
    switch (gqlStatus) {
      case "FailureStatus":
        return "failure";
      case "SuccessStatus":
        return "success";
      case "SubmittedStatus":
        return "submitted";
      case "SqueezedOutStatus":
        return "squeezedout";
      default:
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_STATUS,
          `Invalid transaction status: ${gqlStatus}.`
        );
    }
  };
  var processGraphqlStatus2 = (gqlTransactionStatus) => {
    let time;
    let blockId;
    let status;
    let totalFee;
    let totalGas;
    let isStatusFailure = false;
    let isStatusSuccess = false;
    let isStatusPending = false;
    if (gqlTransactionStatus?.type) {
      status = getTransactionStatusName2(gqlTransactionStatus.type);
      switch (gqlTransactionStatus.type) {
        case "SuccessStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block?.id;
          isStatusSuccess = true;
          totalFee = bn(gqlTransactionStatus.totalFee);
          totalGas = bn(gqlTransactionStatus.totalGas);
          break;
        case "FailureStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block?.id;
          isStatusFailure = true;
          totalFee = bn(gqlTransactionStatus.totalFee);
          totalGas = bn(gqlTransactionStatus.totalGas);
          break;
        case "SubmittedStatus":
          time = gqlTransactionStatus.time;
          isStatusPending = true;
          break;
        default:
      }
    }
    const processedGraphqlStatus = {
      time,
      blockId,
      status,
      totalFee,
      totalGas,
      isStatusFailure,
      isStatusSuccess,
      isStatusPending
    };
    return processedGraphqlStatus;
  };
  var getTotalFeeFromStatus2 = (status) => status && "totalFee" in status ? bn(status.totalFee) : void 0;
  function assembleTransactionSummary2(params) {
    const {
      id,
      receipts,
      gasPerByte,
      gasPriceFactor,
      transaction,
      transactionBytes,
      gqlTransactionStatus,
      abiMap = {},
      maxInputs,
      gasCosts,
      maxGasPerTx,
      gasPrice,
      baseAssetId
    } = params;
    const gasUsed = getGasUsedFromReceipts2(receipts);
    const rawPayload = hexlify(transactionBytes);
    const operations = getOperations2({
      transactionType: transaction.type,
      inputs: transaction.inputs || [],
      outputs: transaction.outputs || [],
      receipts,
      rawPayload,
      abiMap,
      maxInputs,
      baseAssetId
    });
    const typeName = getTransactionTypeName2(transaction.type);
    const tip = bn(transaction.policies?.find((policy) => policy.type === PolicyType.Tip)?.data);
    const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time, totalFee } = processGraphqlStatus2(gqlTransactionStatus);
    const fee = totalFee ?? calculateTXFeeForSummary2({
      gasPrice,
      rawPayload,
      tip,
      consensusParameters: {
        gasCosts,
        maxGasPerTx,
        feeParams: {
          gasPerByte,
          gasPriceFactor
        }
      }
    });
    const mintedAssets = extractMintedAssetsFromReceipts2(receipts);
    const burnedAssets = extractBurnedAssetsFromReceipts2(receipts);
    let date2;
    if (time) {
      date2 = DateTime.fromTai64(time);
    }
    const transactionSummary = {
      id,
      tip,
      fee,
      gasUsed,
      operations,
      type: typeName,
      blockId,
      time,
      status,
      receipts,
      mintedAssets,
      burnedAssets,
      isTypeMint: isTypeMint2(transaction.type),
      isTypeCreate: isTypeCreate2(transaction.type),
      isTypeScript: isTypeScript2(transaction.type),
      isTypeUpgrade: isTypeUpgrade2(transaction.type),
      isTypeUpload: isTypeUpload2(transaction.type),
      isTypeBlob: isTypeBlob2(transaction.type),
      isStatusFailure,
      isStatusSuccess,
      isStatusPending,
      date: date2,
      transaction
    };
    return transactionSummary;
  }
  function getDecodedLogs2(receipts, mainAbi, externalAbis = {}) {
    return receipts.reduce((logs, receipt) => {
      if (receipt.type === ReceiptType.LogData || receipt.type === ReceiptType.Log) {
        const interfaceToUse = new Interface(externalAbis[receipt.id] || mainAbi);
        const data = receipt.type === ReceiptType.Log ? new BigNumberCoder("u64").encode(receipt.ra) : receipt.data;
        const [decodedLog] = interfaceToUse.decodeLog(data, receipt.rb.toString());
        logs.push(decodedLog);
      }
      return logs;
    }, []);
  }
  function mapGqlOutputsToTxOutputs2(outputs) {
    return outputs.map((o) => {
      const obj = "amount" in o ? { ...o, amount: bn(o.amount) } : o;
      switch (obj.type) {
        case "CoinOutput":
          return { ...obj, type: OutputType.Coin };
        case "ContractOutput":
          return {
            ...obj,
            type: OutputType.Contract,
            inputIndex: parseInt(obj.inputIndex, 10)
          };
        case "ChangeOutput":
          return {
            ...obj,
            type: OutputType.Change
          };
        case "VariableOutput":
          return { ...obj, type: OutputType.Variable };
        case "ContractCreated":
          return {
            ...obj,
            type: OutputType.ContractCreated,
            contractId: obj.contract
          };
        default:
          return assertUnreachable(obj);
      }
    });
  }
  var TransactionResponse2 = class {
    /**
     * Constructor for `TransactionResponse`.
     *
     * @param tx - The transaction ID or TransactionRequest.
     * @param provider - The provider.
     */
    constructor(tx, provider, chainId, abis, submitTxSubscription) {
      this.submitTxSubscription = submitTxSubscription;
      this.id = typeof tx === "string" ? tx : tx.getTransactionId(chainId);
      this.provider = provider;
      this.abis = abis;
      this.request = typeof tx === "string" ? void 0 : tx;
    }
    /** Transaction ID */
    id;
    /** Current provider */
    provider;
    /** Gas used on the transaction */
    gasUsed = bn(0);
    /** The graphql Transaction with receipts object. */
    gqlTransaction;
    request;
    status;
    abis;
    /**
     * Async constructor for `TransactionResponse`. This method can be used to create
     * an instance of `TransactionResponse` and wait for the transaction to be fetched
     * from the chain, ensuring that the `gqlTransaction` property is set.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    static async create(id, provider, abis) {
      const chainId = await provider.getChainId();
      const response = new TransactionResponse2(id, provider, chainId, abis);
      await response.fetch();
      return response;
    }
    applyMalleableSubscriptionFields(transaction) {
      const status = this.status;
      if (!status) {
        return;
      }
      const tx = transaction;
      if (status.type === "SuccessStatus" || status.type === "FailureStatus") {
        tx.inputs = tx.inputs.map((input, idx) => {
          if ("txPointer" in input) {
            const correspondingInput = status.transaction.inputs?.[idx];
            return {
              ...input,
              txPointer: TxPointerCoder.decodeFromGqlScalar(correspondingInput.txPointer)
            };
          }
          return input;
        });
        tx.outputs = mapGqlOutputsToTxOutputs2(status.transaction.outputs);
        if ("receiptsRoot" in status.transaction) {
          tx.receiptsRoot = status.transaction.receiptsRoot;
        }
      }
    }
    async getTransaction() {
      if (this.request) {
        const tx = this.request.toTransaction();
        this.applyMalleableSubscriptionFields(tx);
        return {
          tx,
          bytes: this.request.toTransactionBytes()
        };
      }
      const gqlTransaction = this.gqlTransaction ?? await this.fetch();
      return {
        tx: this.decodeTransaction(gqlTransaction),
        bytes: arrayify(gqlTransaction.rawPayload)
      };
    }
    getReceipts() {
      const status = this.status ?? this.gqlTransaction?.status;
      switch (status?.type) {
        case "SuccessStatus":
        case "FailureStatus":
          return status.receipts.map(processGqlReceipt2);
        default:
          return [];
      }
    }
    /**
     * Fetch the transaction with receipts from the provider.
     *
     * @returns Transaction with receipts query result.
     */
    async fetch() {
      const response = await this.provider.operations.getTransactionWithReceipts({
        transactionId: this.id
      });
      if (!response.transaction) {
        const subscription = await this.provider.operations.statusChange({
          transactionId: this.id
        });
        for await (const { statusChange } of subscription) {
          if (statusChange) {
            this.status = statusChange;
            break;
          }
        }
        return this.fetch();
      }
      this.gqlTransaction = response.transaction;
      return response.transaction;
    }
    /**
     * Decode the raw payload of the transaction.
     *
     * @param transactionWithReceipts - The transaction with receipts object.
     * @returns The decoded transaction.
     */
    decodeTransaction(transactionWithReceipts) {
      return new TransactionCoder().decode(
        arrayify(transactionWithReceipts.rawPayload),
        0
      )?.[0];
    }
    /**
     * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
     * fetch it from the provider
     *
     * @param contractsAbiMap - The contracts ABI map.
     * @returns
     */
    async getTransactionSummary(contractsAbiMap) {
      const { tx: transaction, bytes: transactionBytes } = await this.getTransaction();
      const { gasPerByte, gasPriceFactor, gasCosts, maxGasPerTx } = await this.provider.getGasConfig();
      const totalFee = getTotalFeeFromStatus2(this.status ?? this.gqlTransaction?.status);
      const gasPrice = totalFee ? bn(0) : await this.provider.getLatestGasPrice();
      const maxInputs = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs;
      const baseAssetId = await this.provider.getBaseAssetId();
      const transactionSummary = assembleTransactionSummary2({
        id: this.id,
        receipts: this.getReceipts(),
        transaction,
        transactionBytes,
        gqlTransactionStatus: this.status ?? this.gqlTransaction?.status,
        gasPerByte,
        gasPriceFactor,
        abiMap: contractsAbiMap,
        maxInputs,
        gasCosts,
        maxGasPerTx,
        gasPrice,
        baseAssetId
      });
      return transactionSummary;
    }
    async waitForStatusChange() {
      const status = this.gqlTransaction?.status?.type;
      if (status && status !== "SubmittedStatus") {
        return;
      }
      const subscription = this.submitTxSubscription ?? await this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const sub3 of subscription) {
        const statusChange = "statusChange" in sub3 ? sub3.statusChange : sub3.submitAndAwaitStatus;
        this.status = statusChange;
        if (statusChange.type === "SqueezedOutStatus") {
          this.unsetResourceCache();
          throw new FuelError(
            ErrorCode.TRANSACTION_SQUEEZED_OUT,
            `Transaction Squeezed Out with reason: ${statusChange.reason}`
          );
        }
        if (statusChange.type !== "SubmittedStatus") {
          break;
        }
      }
    }
    /**
     * Assembles the result of a transaction by retrieving the transaction summary,
     * decoding logs (if available), and handling transaction failure.
     *
     * This method can be used to obtain the result of a transaction that has just
     * been submitted or one that has already been processed.
     *
     * @template TTransactionType - The type of the transaction.
     * @param contractsAbiMap - The map of contract ABIs.
     * @returns - The assembled transaction result.
     * @throws If the transaction status is a failure.
     */
    async assembleResult(contractsAbiMap) {
      const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
      const transactionResult = {
        ...transactionSummary
      };
      let logs = [];
      if (this.abis) {
        logs = getDecodedLogs2(
          transactionSummary.receipts,
          this.abis.main,
          this.abis.otherContractsAbis
        );
        transactionResult.logs = logs;
      }
      const { receipts } = transactionResult;
      const status = this.status ?? this.gqlTransaction?.status;
      if (status?.type === "FailureStatus") {
        this.unsetResourceCache();
        const { reason } = status;
        throw extractTxError2({
          receipts,
          statusReason: reason,
          logs
        });
      }
      return transactionResult;
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @returns The completed transaction result
     */
    async waitForResult(contractsAbiMap) {
      await this.waitForStatusChange();
      return this.assembleResult(contractsAbiMap);
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @param contractsAbiMap - The contracts ABI map.
     */
    async wait(contractsAbiMap) {
      return this.waitForResult(contractsAbiMap);
    }
    unsetResourceCache() {
      this.provider.cache?.unset(this.id);
    }
  };
  function getWaitDelay2(options, retryAttemptNum) {
    const duration = options.baseDelay ?? 150;
    switch (options.backoff) {
      case "linear":
        return duration * retryAttemptNum;
      case "fixed":
        return duration;
      case "exponential":
      default:
        return 2 ** (retryAttemptNum - 1) * duration;
    }
  }
  function autoRetryFetch2(fetchFn, options, retryAttemptNum = 0) {
    if (options === void 0) {
      return fetchFn;
    }
    return async (...args) => {
      try {
        return await fetchFn(...args);
      } catch (_error) {
        const error3 = _error;
        if (error3.cause?.code !== "ECONNREFUSED") {
          throw error3;
        }
        const retryNum = retryAttemptNum + 1;
        if (retryNum > options.maxRetries) {
          throw error3;
        }
        const delay = getWaitDelay2(options, retryNum);
        await sleep(delay);
        return autoRetryFetch2(fetchFn, options, retryNum)(...args);
      }
    };
  }
  var handleGqlErrorMessage2 = (errorMessage, rawError) => {
    switch (errorMessage) {
      case "not enough coins to fit the target":
        throw new FuelError(
          ErrorCode.NOT_ENOUGH_FUNDS,
          `The account(s) sending the transaction don't have enough funds to cover the transaction.`,
          {},
          rawError
        );
      case "max number of coins is reached while trying to fit the target":
        throw new FuelError(
          ErrorCode.MAX_COINS_REACHED,
          "The account retrieving coins has exceeded the maximum number of coins per asset. Please consider combining your coins into a single UTXO.",
          {},
          rawError
        );
      default:
        throw new FuelError(ErrorCode.INVALID_REQUEST, errorMessage);
    }
  };
  var validatePaginationArgs2 = (params) => {
    const { paginationLimit, inputArgs = {} } = params;
    const { first, last, after, before } = inputArgs;
    if (after && before) {
      throw new FuelError(
        ErrorCode.INVALID_INPUT_PARAMETERS,
        'Pagination arguments "after" and "before" cannot be used together'
      );
    }
    if ((first || 0) > paginationLimit || (last || 0) > paginationLimit) {
      throw new FuelError(
        ErrorCode.INVALID_INPUT_PARAMETERS,
        `Pagination limit for this query cannot exceed ${paginationLimit} items`
      );
    }
    if (first && before) {
      throw new FuelError(
        ErrorCode.INVALID_INPUT_PARAMETERS,
        'The use of pagination argument "first" with "before" is not supported'
      );
    }
    if (last && after) {
      throw new FuelError(
        ErrorCode.INVALID_INPUT_PARAMETERS,
        'The use of pagination argument "last" with "after" is not supported'
      );
    }
    if (!first && !last) {
      inputArgs.first = paginationLimit;
    }
    return inputArgs;
  };
  var MAX_RETRIES2 = 10;
  var RESOURCES_PAGE_SIZE_LIMIT2 = 512;
  var TRANSACTIONS_PAGE_SIZE_LIMIT2 = 60;
  var BLOCKS_PAGE_SIZE_LIMIT2 = 5;
  var DEFAULT_RESOURCE_CACHE_TTL2 = 2e4;
  var GAS_USED_MODIFIER2 = 1.2;
  var processGqlChain2 = (chain) => {
    const { name, daHeight, consensusParameters } = chain;
    const {
      contractParams,
      feeParams,
      predicateParams,
      scriptParams,
      txParams,
      gasCosts,
      baseAssetId,
      chainId,
      version: version3
    } = consensusParameters;
    return {
      name,
      baseChainHeight: bn(daHeight),
      consensusParameters: {
        version: version3,
        chainId: bn(chainId),
        baseAssetId,
        feeParameters: {
          version: feeParams.version,
          gasPerByte: bn(feeParams.gasPerByte),
          gasPriceFactor: bn(feeParams.gasPriceFactor)
        },
        contractParameters: {
          version: contractParams.version,
          contractMaxSize: bn(contractParams.contractMaxSize),
          maxStorageSlots: bn(contractParams.maxStorageSlots)
        },
        txParameters: {
          version: txParams.version,
          maxInputs: bn(txParams.maxInputs),
          maxOutputs: bn(txParams.maxOutputs),
          maxWitnesses: bn(txParams.maxWitnesses),
          maxGasPerTx: bn(txParams.maxGasPerTx),
          maxSize: bn(txParams.maxSize),
          maxBytecodeSubsections: bn(txParams.maxBytecodeSubsections)
        },
        predicateParameters: {
          version: predicateParams.version,
          maxPredicateLength: bn(predicateParams.maxPredicateLength),
          maxPredicateDataLength: bn(predicateParams.maxPredicateDataLength),
          maxGasPerPredicate: bn(predicateParams.maxGasPerPredicate),
          maxMessageDataLength: bn(predicateParams.maxMessageDataLength)
        },
        scriptParameters: {
          version: scriptParams.version,
          maxScriptLength: bn(scriptParams.maxScriptLength),
          maxScriptDataLength: bn(scriptParams.maxScriptDataLength)
        },
        gasCosts
      }
    };
  };
  var _cacheInputs2;
  var cacheInputs_fn2;
  var _Provider2 = class {
    /**
     * Constructor to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     * @hidden
     */
    constructor(url, options = {}) {
      __privateAdd3(this, _cacheInputs2);
      __publicField10(this, "operations");
      __publicField10(this, "cache");
      __publicField10(this, "url");
      __publicField10(this, "urlWithoutAuth");
      __publicField10(this, "consensusParametersTimestamp");
      __publicField10(this, "options", {
        timeout: void 0,
        resourceCacheTTL: void 0,
        fetch: void 0,
        retryOptions: void 0,
        headers: void 0
      });
      const { url: rawUrl, urlWithoutAuth, headers: authHeaders } = _Provider2.extractBasicAuth(url);
      this.url = rawUrl;
      this.urlWithoutAuth = urlWithoutAuth;
      this.url = url;
      const { FUELS } = versions;
      const headers = { ...authHeaders, ...options.headers, Source: `ts-sdk-${FUELS}` };
      this.options = {
        ...this.options,
        ...options,
        headers
      };
      this.operations = this.createOperations();
      const { resourceCacheTTL } = this.options;
      if (isDefined(resourceCacheTTL)) {
        if (resourceCacheTTL !== -1) {
          this.cache = new ResourceCache2(resourceCacheTTL);
        } else {
          this.cache = void 0;
        }
      } else {
        this.cache = new ResourceCache2(DEFAULT_RESOURCE_CACHE_TTL2);
      }
    }
    /** @hidden */
    static clearChainAndNodeCaches() {
      _Provider2.nodeInfoCache = {};
      _Provider2.chainInfoCache = {};
    }
    /**
     * @hidden
     */
    static getFetchFn(options) {
      const { retryOptions, timeout, headers } = options;
      return autoRetryFetch2(async (...args) => {
        const url = args[0];
        const request = args[1];
        const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
        let fullRequest = {
          ...request,
          signal,
          headers: { ...request?.headers, ...headers }
        };
        if (options.requestMiddleware) {
          fullRequest = await options.requestMiddleware(fullRequest);
        }
        return options.fetch ? options.fetch(url, fullRequest, options) : fetch(url, fullRequest);
      }, retryOptions);
    }
    static extractBasicAuth(url) {
      let parsedUrl;
      try {
        parsedUrl = new URL(url);
      } catch (error3) {
        throw new FuelError(FuelError.CODES.INVALID_URL, "Invalid URL provided.", { url }, error3);
      }
      const username = parsedUrl.username;
      const password = parsedUrl.password;
      const urlWithoutAuth = `${parsedUrl.origin}${parsedUrl.pathname}`;
      if (!(username && password)) {
        return { url, urlWithoutAuth: url, headers: void 0 };
      }
      return {
        url,
        urlWithoutAuth,
        headers: { Authorization: `Basic ${btoa(`${username}:${password}`)}` }
      };
    }
    /**
     * Initialize Provider async stuff
     */
    async init() {
      await this.fetchChainAndNodeInfo();
      return this;
    }
    /**
     * Returns the `chainInfo` for the current network.
     *
     * @returns the chain information configuration.
     */
    async getChain() {
      await this.init();
      return _Provider2.chainInfoCache[this.urlWithoutAuth];
    }
    /**
     * Returns the `nodeInfo` for the current network.
     *
     * @returns the node information configuration.
     */
    async getNode() {
      await this.init();
      return _Provider2.nodeInfoCache[this.urlWithoutAuth];
    }
    /**
     * Returns some helpful parameters related to gas fees.
     */
    async getGasConfig() {
      const {
        txParameters: { maxGasPerTx },
        predicateParameters: { maxGasPerPredicate },
        feeParameters: { gasPriceFactor, gasPerByte },
        gasCosts
      } = (await this.getChain()).consensusParameters;
      return {
        maxGasPerTx,
        maxGasPerPredicate,
        gasPriceFactor,
        gasPerByte,
        gasCosts
      };
    }
    /**
     * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
     *
     * @param url - The URL to connect to.
     * @param options - Additional options for the provider.
     */
    async connect(url, options) {
      const { url: rawUrl, urlWithoutAuth, headers } = _Provider2.extractBasicAuth(url);
      this.url = rawUrl;
      this.urlWithoutAuth = urlWithoutAuth;
      this.options = options ?? this.options;
      this.options = { ...this.options, headers: { ...this.options.headers, ...headers } };
      this.operations = this.createOperations();
      await this.init();
    }
    /**
     * Return the chain and node information.
     * @param ignoreCache - If true, ignores the cache and re-fetch configs.
     * @returns A promise that resolves to the Chain and NodeInfo.
     */
    async fetchChainAndNodeInfo(ignoreCache = false) {
      let nodeInfo;
      let chain;
      try {
        nodeInfo = _Provider2.nodeInfoCache[this.urlWithoutAuth];
        chain = _Provider2.chainInfoCache[this.urlWithoutAuth];
        const noCache = !nodeInfo || !chain;
        if (ignoreCache || noCache) {
          throw new Error(`Jumps to the catch block and re-fetch`);
        }
      } catch (_err) {
        const data = await this.operations.getChainAndNodeInfo();
        nodeInfo = {
          maxDepth: bn(data.nodeInfo.maxDepth),
          maxTx: bn(data.nodeInfo.maxTx),
          nodeVersion: data.nodeInfo.nodeVersion,
          utxoValidation: data.nodeInfo.utxoValidation,
          vmBacktrace: data.nodeInfo.vmBacktrace
        };
        _Provider2.ensureClientVersionIsSupported(nodeInfo);
        chain = processGqlChain2(data.chain);
        _Provider2.chainInfoCache[this.urlWithoutAuth] = chain;
        _Provider2.nodeInfoCache[this.urlWithoutAuth] = nodeInfo;
        this.consensusParametersTimestamp = Date.now();
      }
      return {
        chain,
        nodeInfo
      };
    }
    /**
     * @hidden
     */
    static ensureClientVersionIsSupported(nodeInfo) {
      const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
      if (!isMajorSupported || !isMinorSupported) {
        console.warn(
          `The Fuel Node that you are trying to connect to is using fuel-core version ${nodeInfo.nodeVersion},
which is not supported by the version of the TS SDK that you are using.
Things may not work as expected.
Supported fuel-core version: ${supportedVersion}.`
        );
      }
    }
    /**
     * Create GraphQL client and set operations.
     *
     * @returns The operation SDK object
     * @hidden
     */
    createOperations() {
      const fetchFn = _Provider2.getFetchFn(this.options);
      const gqlClient = new GraphQLClient(this.urlWithoutAuth, {
        fetch: (input, requestInit) => fetchFn(input.toString(), requestInit || {}, this.options),
        responseMiddleware: (response) => {
          if ("response" in response) {
            const graphQlResponse = response.response;
            if (Array.isArray(graphQlResponse?.errors)) {
              for (const error3 of graphQlResponse.errors) {
                handleGqlErrorMessage2(error3.message, error3);
              }
            }
          }
        }
      });
      const executeQuery = (query, vars) => {
        const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
        const isSubscription = opDefinition?.operation === "subscription";
        if (isSubscription) {
          return FuelGraphqlSubscriber2.create({
            url: this.urlWithoutAuth,
            query,
            fetchFn: (url, requestInit) => fetchFn(url, requestInit, this.options),
            variables: vars
          });
        }
        return gqlClient.request(query, vars);
      };
      const customOperations = (requester) => ({
        getBlobs(variables) {
          const queryParams = variables.blobIds.map((_, i) => `$blobId${i}: BlobId!`).join(", ");
          const blobParams = variables.blobIds.map((_, i) => `blob${i}: blob(id: $blobId${i}) { id }`).join("\n");
          const updatedVariables = variables.blobIds.reduce(
            (acc, blobId, i) => {
              acc[`blobId${i}`] = blobId;
              return acc;
            },
            {}
          );
          const document2 = lib_default2`
          query getBlobs(${queryParams}) {
            ${blobParams}
          }
        `;
          return requester(document2, updatedVariables);
        }
      });
      return { ...getSdk2(executeQuery), ...customOperations(executeQuery) };
    }
    /**
     * Returns the version of the connected node.
     *
     * @returns A promise that resolves to the version string.
     */
    async getVersion() {
      const {
        nodeInfo: { nodeVersion }
      } = await this.operations.getVersion();
      return nodeVersion;
    }
    /**
     * Returns the latest block number.
     *
     * @returns A promise that resolves to the latest block number.
     */
    async getBlockNumber() {
      const {
        chain: {
          latestBlock: { height }
        }
      } = await this.operations.getLatestBlockHeight();
      return bn(height);
    }
    /**
     * Returns the node information for the current provider network.
     *
     * @returns a promise that resolves to the node information.
     */
    async fetchNode() {
      const { nodeInfo } = await this.operations.getNodeInfo();
      const processedNodeInfo = {
        maxDepth: bn(nodeInfo.maxDepth),
        maxTx: bn(nodeInfo.maxTx),
        nodeVersion: nodeInfo.nodeVersion,
        utxoValidation: nodeInfo.utxoValidation,
        vmBacktrace: nodeInfo.vmBacktrace
      };
      _Provider2.nodeInfoCache[this.urlWithoutAuth] = processedNodeInfo;
      return processedNodeInfo;
    }
    /**
     * Returns the chain information for the current provider network.
     *
     * @returns a promise that resolves to the chain information.
     */
    async fetchChain() {
      const { chain } = await this.operations.getChain();
      const processedChain = processGqlChain2(chain);
      _Provider2.chainInfoCache[this.urlWithoutAuth] = processedChain;
      return processedChain;
    }
    /**
     * Returns the chain ID for the current provider network.
     *
     * @returns A promise that resolves to the chain ID number.
     */
    async getChainId() {
      const {
        consensusParameters: { chainId }
      } = await this.getChain();
      return chainId.toNumber();
    }
    /**
     * Returns the base asset ID for the current provider network.
     *
     * @returns the base asset ID.
     */
    async getBaseAssetId() {
      const all = await this.getChain();
      const {
        consensusParameters: { baseAssetId }
      } = all;
      return baseAssetId;
    }
    /**
     * @hidden
     */
    async validateTransaction(tx) {
      const {
        consensusParameters: {
          txParameters: { maxInputs, maxOutputs }
        }
      } = await this.getChain();
      if (bn(tx.inputs.length).gt(maxInputs)) {
        throw new FuelError(
          ErrorCode.MAX_INPUTS_EXCEEDED,
          `The transaction exceeds the maximum allowed number of inputs. Tx inputs: ${tx.inputs.length}, max inputs: ${maxInputs}`
        );
      }
      if (bn(tx.outputs.length).gt(maxOutputs)) {
        throw new FuelError(
          ErrorCode.MAX_OUTPUTS_EXCEEDED,
          `The transaction exceeds the maximum allowed number of outputs. Tx outputs: ${tx.outputs.length}, max outputs: ${maxOutputs}`
        );
      }
    }
    /**
     * Submits a transaction to the chain to be executed.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider send transaction parameters (optional).
     * @returns A promise that resolves to the transaction response object.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, enableAssetBurn } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      validateTransactionForAssetBurn2(
        await this.getBaseAssetId(),
        transactionRequest,
        enableAssetBurn
      );
      if (estimateTxDependencies) {
        await this.estimateTxDependencies(transactionRequest);
      }
      await this.validateTransaction(transactionRequest);
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      let abis;
      if (isTransactionTypeScript2(transactionRequest)) {
        abis = transactionRequest.abis;
      }
      const subscription = await this.operations.submitAndAwaitStatus({ encodedTransaction });
      __privateMethod3(this, _cacheInputs2, cacheInputs_fn2).call(this, transactionRequest.inputs, transactionRequest.getTransactionId(await this.getChainId()));
      const chainId = await this.getChainId();
      return new TransactionResponse2(transactionRequest, this, chainId, abis, subscription);
    }
    /**
     * Executes a transaction without actually submitting it to the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider call parameters (optional).
     * @returns A promise that resolves to the call result object.
     */
    async dryRun(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        return this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { dryRun: dryRunStatuses } = await this.operations.dryRun({
        encodedTransactions: encodedTransaction,
        utxoValidation: utxoValidation || false
      });
      const [{ receipts: rawReceipts, status: dryRunStatus }] = dryRunStatuses;
      const receipts = rawReceipts.map(processGqlReceipt2);
      return { receipts, dryRunStatus };
    }
    /**
     * Verifies whether enough gas is available to complete transaction.
     *
     * @template T - The type of the transaction request object.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimated transaction request object.
     */
    async estimatePredicates(transactionRequest) {
      const shouldEstimatePredicates = Boolean(
        transactionRequest.inputs.find(
          (input) => "predicate" in input && input.predicate && !equalBytes(arrayify(input.predicate), arrayify("0x")) && new BN(input.predicateGasUsed).isZero()
        )
      );
      if (!shouldEstimatePredicates) {
        return transactionRequest;
      }
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const response = await this.operations.estimatePredicates({
        encodedTransaction
      });
      const {
        estimatePredicates: { inputs }
      } = response;
      if (inputs) {
        inputs.forEach((input, index) => {
          if ("predicateGasUsed" in input && bn(input.predicateGasUsed).gt(0)) {
            transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
          }
        });
      }
      return transactionRequest;
    }
    /**
     * Will dryRun a transaction and check for missing dependencies.
     *
     * If there are missing variable outputs,
     * `addVariableOutputs` is called on the transaction.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimate transaction dependencies.
     */
    async estimateTxDependencies(transactionRequest) {
      if (isTransactionTypeCreate2(transactionRequest)) {
        return {
          receipts: [],
          outputVariables: 0,
          missingContractIds: []
        };
      }
      let receipts = [];
      const missingContractIds = [];
      let outputVariables = 0;
      let dryRunStatus;
      await this.validateTransaction(transactionRequest);
      for (let attempt = 0; attempt < MAX_RETRIES2; attempt++) {
        const {
          dryRun: [{ receipts: rawReceipts, status }]
        } = await this.operations.dryRun({
          encodedTransactions: [hexlify(transactionRequest.toTransactionBytes())],
          utxoValidation: false,
          gasPrice: "0"
        });
        receipts = rawReceipts.map(processGqlReceipt2);
        dryRunStatus = status;
        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData2(receipts);
        const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
        if (hasMissingOutputs && isTransactionTypeScript2(transactionRequest)) {
          outputVariables += missingOutputVariables.length;
          transactionRequest.addVariableOutputs(missingOutputVariables.length);
          missingOutputContractIds.forEach(({ contractId }) => {
            transactionRequest.addContractInputAndOutput(Address.fromString(contractId));
            missingContractIds.push(contractId);
          });
          const { maxFee } = await this.estimateTxGasAndFee({
            transactionRequest,
            gasPrice: bn(0)
          });
          transactionRequest.maxFee = maxFee;
        } else {
          break;
        }
      }
      return {
        receipts,
        outputVariables,
        missingContractIds,
        dryRunStatus
      };
    }
    /**
     * Dry runs multiple transactions and checks for missing dependencies in batches.
     *
     * Transactions are dry run in batches. After each dry run, transactions requiring
     * further modifications are identified. The method iteratively updates these transactions
     * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @returns A promise that resolves to an array of results for each transaction.
     */
    async estimateMultipleTxDependencies(transactionRequests) {
      const results = transactionRequests.map(() => ({
        receipts: [],
        outputVariables: 0,
        missingContractIds: [],
        dryRunStatus: void 0
      }));
      const allRequests = clone_default(transactionRequests);
      const serializedTransactionsMap = /* @__PURE__ */ new Map();
      allRequests.forEach((req2, index) => {
        if (isTransactionTypeScript2(req2)) {
          serializedTransactionsMap.set(index, hexlify(req2.toTransactionBytes()));
        }
      });
      let transactionsToProcess = Array.from(serializedTransactionsMap.keys());
      let attempt = 0;
      while (transactionsToProcess.length > 0 && attempt < MAX_RETRIES2) {
        const encodedTransactions = transactionsToProcess.map(
          (index) => serializedTransactionsMap.get(index)
        );
        const dryRunResults = await this.operations.dryRun({
          encodedTransactions,
          utxoValidation: false
        });
        const nextRoundTransactions = [];
        for (let i = 0; i < dryRunResults.dryRun.length; i++) {
          const requestIdx = transactionsToProcess[i];
          const { receipts: rawReceipts, status } = dryRunResults.dryRun[i];
          const result = results[requestIdx];
          result.receipts = rawReceipts.map(processGqlReceipt2);
          result.dryRunStatus = status;
          const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData2(
            result.receipts
          );
          const hasMissingOutputs = missingOutputVariables.length > 0 || missingOutputContractIds.length > 0;
          const request = allRequests[requestIdx];
          if (hasMissingOutputs && isTransactionTypeScript2(request)) {
            result.outputVariables += missingOutputVariables.length;
            request.addVariableOutputs(missingOutputVariables.length);
            missingOutputContractIds.forEach(({ contractId }) => {
              request.addContractInputAndOutput(Address.fromString(contractId));
              result.missingContractIds.push(contractId);
            });
            const { maxFee } = await this.estimateTxGasAndFee({
              transactionRequest: request
            });
            request.maxFee = maxFee;
            serializedTransactionsMap.set(requestIdx, hexlify(request.toTransactionBytes()));
            nextRoundTransactions.push(requestIdx);
          }
        }
        transactionsToProcess = nextRoundTransactions;
        attempt += 1;
      }
      return results;
    }
    /**
     * Dry runs multiple transactions.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @param sendTransactionParams - The provider call parameters (optional).
     *
     * @returns A promise that resolves to an array of results for each transaction call.
     */
    async dryRunMultipleTransactions(transactionRequests, { utxoValidation, estimateTxDependencies = true } = {}) {
      if (estimateTxDependencies) {
        return this.estimateMultipleTxDependencies(transactionRequests);
      }
      const encodedTransactions = transactionRequests.map((tx) => hexlify(tx.toTransactionBytes()));
      const { dryRun: dryRunStatuses } = await this.operations.dryRun({
        encodedTransactions,
        utxoValidation: utxoValidation || false
      });
      const results = dryRunStatuses.map(({ receipts: rawReceipts, status }) => {
        const receipts = rawReceipts.map(processGqlReceipt2);
        return { receipts, dryRunStatus: status };
      });
      return results;
    }
    async autoRefetchConfigs() {
      const now = Date.now();
      const diff = now - (this.consensusParametersTimestamp ?? 0);
      if (diff < 6e4) {
        return;
      }
      if (!_Provider2.chainInfoCache?.[this.urlWithoutAuth]) {
        await this.fetchChainAndNodeInfo(true);
        return;
      }
      const chainInfo = _Provider2.chainInfoCache[this.urlWithoutAuth];
      const {
        consensusParameters: { version: previous }
      } = chainInfo;
      const {
        chain: {
          latestBlock: {
            header: { consensusParametersVersion: current }
          }
        }
      } = await this.operations.getConsensusParametersVersion();
      if (previous !== current) {
        await this.fetchChainAndNodeInfo(true);
      }
    }
    /**
     * Estimates the transaction gas and fee based on the provided transaction request.
     * @param transactionRequest - The transaction request object.
     * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
     */
    async estimateTxGasAndFee(params) {
      const { transactionRequest } = params;
      let { gasPrice } = params;
      await this.autoRefetchConfigs();
      const chainInfo = await this.getChain();
      const { gasPriceFactor, maxGasPerTx } = await this.getGasConfig();
      const minGas = transactionRequest.calculateMinGas(chainInfo);
      if (!isDefined(gasPrice)) {
        gasPrice = await this.estimateGasPrice(10);
      }
      const minFee = calculateGasFee2({
        gasPrice: bn(gasPrice),
        gas: minGas,
        priceFactor: gasPriceFactor,
        tip: transactionRequest.tip
      }).add(1);
      let gasLimit = bn(0);
      if (isTransactionTypeScript2(transactionRequest)) {
        gasLimit = transactionRequest.gasLimit;
        if (transactionRequest.gasLimit.eq(0)) {
          transactionRequest.gasLimit = minGas;
          transactionRequest.gasLimit = maxGasPerTx.sub(
            transactionRequest.calculateMaxGas(chainInfo, minGas)
          );
          gasLimit = transactionRequest.gasLimit;
        }
      }
      const maxGas = transactionRequest.calculateMaxGas(chainInfo, minGas);
      const maxFee = calculateGasFee2({
        gasPrice: bn(gasPrice),
        gas: maxGas,
        priceFactor: gasPriceFactor,
        tip: transactionRequest.tip
      }).add(1);
      return {
        minGas,
        minFee,
        maxGas,
        maxFee,
        gasPrice,
        gasLimit
      };
    }
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added
     *
     * @param transactionRequestLike - The transaction request object.
     * @param estimateTxParams - The estimate transaction params (optional).
     * @returns A promise that resolves to the call result object.
     */
    async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        return this.estimateTxDependencies(transactionRequest);
      }
      const encodedTransactions = [hexlify(transactionRequest.toTransactionBytes())];
      const { dryRun: dryRunStatuses } = await this.operations.dryRun({
        encodedTransactions,
        utxoValidation: true
      });
      const callResult = dryRunStatuses.map((dryRunStatus) => {
        const { id, receipts, status } = dryRunStatus;
        const processedReceipts = receipts.map(processGqlReceipt2);
        return { id, receipts: processedReceipts, status };
      });
      return { receipts: callResult[0].receipts };
    }
    /**
     * @hidden
     *
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the transaction.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param transactionCostParams - The transaction cost parameters (optional).
     *
     * @returns A promise that resolves to the transaction cost object.
     */
    async getTransactionCost(transactionRequestLike, { signatureCallback } = {}) {
      const txRequestClone = clone_default(transactionRequestify2(transactionRequestLike));
      const updateMaxFee = txRequestClone.maxFee.eq(0);
      const isScriptTransaction = isTransactionTypeScript2(txRequestClone);
      if (isScriptTransaction) {
        txRequestClone.gasLimit = bn(0);
      }
      const signedRequest = clone_default(txRequestClone);
      let addedSignatures = 0;
      if (signatureCallback && isTransactionTypeScript2(signedRequest)) {
        const lengthBefore = signedRequest.witnesses.length;
        await signatureCallback(signedRequest);
        addedSignatures = signedRequest.witnesses.length - lengthBefore;
      }
      await this.estimatePredicates(signedRequest);
      txRequestClone.updatePredicateGasUsed(signedRequest.inputs);
      let { maxFee, maxGas, minFee, minGas, gasPrice, gasLimit } = await this.estimateTxGasAndFee({
        transactionRequest: signedRequest
      });
      let receipts = [];
      let dryRunStatus;
      let missingContractIds = [];
      let outputVariables = 0;
      let gasUsed = bn(0);
      txRequestClone.maxFee = maxFee;
      if (isScriptTransaction) {
        txRequestClone.gasLimit = gasLimit;
        if (signatureCallback) {
          await signatureCallback(txRequestClone);
        }
        ({ receipts, missingContractIds, outputVariables, dryRunStatus } = await this.estimateTxDependencies(txRequestClone));
        if (dryRunStatus && "reason" in dryRunStatus) {
          throw this.extractDryRunError(txRequestClone, receipts, dryRunStatus);
        }
        const { maxGasPerTx } = await this.getGasConfig();
        const pristineGasUsed = getGasUsedFromReceipts2(receipts);
        gasUsed = bn(pristineGasUsed.muln(GAS_USED_MODIFIER2)).max(maxGasPerTx.sub(minGas));
        txRequestClone.gasLimit = gasUsed;
        ({ maxFee, maxGas, minFee, minGas, gasPrice } = await this.estimateTxGasAndFee({
          transactionRequest: txRequestClone,
          gasPrice
        }));
      }
      return {
        receipts,
        gasUsed,
        gasPrice,
        minGas,
        maxGas,
        minFee,
        maxFee,
        outputVariables,
        missingContractIds,
        addedSignatures,
        estimatedPredicates: txRequestClone.inputs,
        dryRunStatus,
        updateMaxFee
      };
    }
    /**
     * Returns coins for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get (optional).
     * @param paginationArgs - Pagination arguments (optional).
     *
     * @returns A promise that resolves to the coins.
     */
    async getCoins(owner, assetId, paginationArgs) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const {
        coins: { edges, pageInfo }
      } = await this.operations.getCoins({
        ...validatePaginationArgs2({
          paginationLimit: RESOURCES_PAGE_SIZE_LIMIT2,
          inputArgs: paginationArgs
        }),
        filter: { owner: ownerAddress.toB256(), assetId: assetId && hexlify(assetId) }
      });
      const coins = edges.map(({ node: node2 }) => ({
        id: node2.utxoId,
        assetId: node2.assetId,
        amount: bn(node2.amount),
        owner: ownerAddress,
        blockCreated: bn(node2.blockCreated),
        txCreatedIdx: bn(node2.txCreatedIdx)
      }));
      return {
        coins,
        pageInfo
      };
    }
    /**
     * Returns resources for the given owner satisfying the spend query.
     *
     * @param owner - The address to get resources for.
     * @param quantities - The coin quantities to get.
     * @param excludedIds - IDs of excluded resources from the selection (optional).
     * @returns A promise that resolves to the resources.
     */
    async getResourcesToSpend(owner, quantities, excludedIds) {
      const ownerAddress = Address.fromAddressOrString(owner);
      const excludeInput = {
        messages: excludedIds?.messages?.map((nonce) => hexlify(nonce)) || [],
        utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || []
      };
      if (this.cache) {
        const cached = this.cache.getActiveData();
        excludeInput.messages.push(...cached.messages);
        excludeInput.utxos.push(...cached.utxos);
      }
      const coinsQuery = {
        owner: ownerAddress.toB256(),
        queryPerAsset: quantities.map(coinQuantityfy2).map(({ assetId, amount, max: maxPerAsset }) => ({
          assetId: hexlify(assetId),
          amount: amount.toString(10),
          max: maxPerAsset ? maxPerAsset.toString(10) : void 0
        })),
        excludedIds: excludeInput
      };
      const result = await this.operations.getCoinsToSpend(coinsQuery);
      const coins = result.coinsToSpend.flat().map((coin) => {
        switch (coin.type) {
          case "MessageCoin":
            return {
              amount: bn(coin.amount),
              assetId: coin.assetId,
              daHeight: bn(coin.daHeight),
              sender: Address.fromAddressOrString(coin.sender),
              recipient: Address.fromAddressOrString(coin.recipient),
              nonce: coin.nonce
            };
          case "Coin":
            return {
              id: coin.utxoId,
              amount: bn(coin.amount),
              assetId: coin.assetId,
              owner: ownerAddress,
              blockCreated: bn(coin.blockCreated),
              txCreatedIdx: bn(coin.txCreatedIdx)
            };
          default:
            return null;
        }
      }).filter((v) => !!v);
      return coins;
    }
    /**
     * Returns an array of blobIds that exist on chain, for a given array of blobIds.
     *
     * @param blobIds - blobIds to check.
     * @returns - A promise that resolves to an array of blobIds that exist on chain.
     */
    async getBlobs(blobIds) {
      const res = await this.operations.getBlobs({ blobIds });
      const blobs = [];
      Object.keys(res).forEach((key) => {
        const val = res[key];
        blobs.push(val?.id ?? null);
      });
      return blobs.filter((v) => v);
    }
    /**
     * Returns block matching the given ID or height.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block or null.
     */
    async getBlock(idOrHeight) {
      let block2;
      if (idOrHeight === "latest") {
        const {
          chain: { latestBlock }
        } = await this.operations.getLatestBlock();
        block2 = latestBlock;
      } else {
        const isblockId = typeof idOrHeight === "string" && idOrHeight.length === 66;
        const variables = isblockId ? { blockId: idOrHeight } : { height: bn(idOrHeight).toString(10) };
        const response = await this.operations.getBlock(variables);
        block2 = response.block;
      }
      if (!block2) {
        return null;
      }
      const { header, height, id, transactions } = block2;
      return {
        id,
        height: bn(height),
        time: header.time,
        header: {
          applicationHash: header.applicationHash,
          daHeight: bn(header.daHeight),
          eventInboxRoot: header.eventInboxRoot,
          messageOutboxRoot: header.messageOutboxRoot,
          prevRoot: header.prevRoot,
          stateTransitionBytecodeVersion: header.stateTransitionBytecodeVersion,
          transactionsCount: header.transactionsCount,
          transactionsRoot: header.transactionsRoot
        },
        transactionIds: transactions.map((tx) => tx.id)
      };
    }
    /**
     * Returns all the blocks matching the given parameters.
     *
     * @param params - The parameters to query blocks.
     * @returns A promise that resolves to the blocks.
     */
    async getBlocks(params) {
      const {
        blocks: { edges, pageInfo }
      } = await this.operations.getBlocks({
        ...validatePaginationArgs2({
          paginationLimit: BLOCKS_PAGE_SIZE_LIMIT2,
          inputArgs: params
        })
      });
      const blocks = edges.map(({ node: block2 }) => ({
        id: block2.id,
        height: bn(block2.height),
        time: block2.header.time,
        header: {
          applicationHash: block2.header.applicationHash,
          daHeight: bn(block2.header.daHeight),
          eventInboxRoot: block2.header.eventInboxRoot,
          messageOutboxRoot: block2.header.messageOutboxRoot,
          prevRoot: block2.header.prevRoot,
          stateTransitionBytecodeVersion: block2.header.stateTransitionBytecodeVersion,
          transactionsCount: block2.header.transactionsCount,
          transactionsRoot: block2.header.transactionsRoot
        },
        transactionIds: block2.transactions.map((tx) => tx.id)
      }));
      return { blocks, pageInfo };
    }
    /**
     * Returns block matching the given ID or type, including transaction data.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    async getBlockWithTransactions(idOrHeight) {
      let variables;
      if (typeof idOrHeight === "number") {
        variables = { blockHeight: bn(idOrHeight).toString(10) };
      } else if (idOrHeight === "latest") {
        variables = { blockHeight: (await this.getBlockNumber()).toString() };
      } else {
        variables = { blockId: idOrHeight };
      }
      const { block: block2 } = await this.operations.getBlockWithTransactions(variables);
      if (!block2) {
        return null;
      }
      return {
        id: block2.id,
        height: bn(block2.height, 10),
        time: block2.header.time,
        header: {
          applicationHash: block2.header.applicationHash,
          daHeight: bn(block2.header.daHeight),
          eventInboxRoot: block2.header.eventInboxRoot,
          messageOutboxRoot: block2.header.messageOutboxRoot,
          prevRoot: block2.header.prevRoot,
          stateTransitionBytecodeVersion: block2.header.stateTransitionBytecodeVersion,
          transactionsCount: block2.header.transactionsCount,
          transactionsRoot: block2.header.transactionsRoot
        },
        transactionIds: block2.transactions.map((tx) => tx.id),
        transactions: block2.transactions.map(
          (tx) => new TransactionCoder().decode(arrayify(tx.rawPayload), 0)?.[0]
        )
      };
    }
    /**
     * Get transaction with the given ID.
     *
     * @param transactionId - ID of the transaction.
     * @returns A promise that resolves to the transaction.
     */
    async getTransaction(transactionId) {
      const { transaction } = await this.operations.getTransaction({ transactionId });
      if (!transaction) {
        return null;
      }
      try {
        return new TransactionCoder().decode(
          arrayify(transaction.rawPayload),
          0
        )?.[0];
      } catch (error3) {
        if (error3 instanceof FuelError && error3.code === ErrorCode.UNSUPPORTED_TRANSACTION_TYPE) {
          console.warn("Unsupported transaction type encountered");
          return null;
        }
        throw error3;
      }
    }
    /**
     * Retrieves transactions based on the provided pagination arguments.
     * @param paginationArgs - The pagination arguments for retrieving transactions.
     * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.
     */
    async getTransactions(paginationArgs) {
      const {
        transactions: { edges, pageInfo }
      } = await this.operations.getTransactions({
        ...validatePaginationArgs2({
          inputArgs: paginationArgs,
          paginationLimit: TRANSACTIONS_PAGE_SIZE_LIMIT2
        })
      });
      const coder = new TransactionCoder();
      const transactions = edges.map(({ node: { rawPayload } }) => {
        try {
          return coder.decode(arrayify(rawPayload), 0)[0];
        } catch (error3) {
          if (error3 instanceof FuelError && error3.code === ErrorCode.UNSUPPORTED_TRANSACTION_TYPE) {
            console.warn("Unsupported transaction type encountered");
            return null;
          }
          throw error3;
        }
      }).filter((tx) => tx !== null);
      return { transactions, pageInfo };
    }
    /**
     * Get deployed contract with the given ID.
     *
     * @param contractId - ID of the contract.
     * @returns A promise that resolves to the contract.
     */
    async getContract(contractId) {
      const { contract } = await this.operations.getContract({ contractId });
      if (!contract) {
        return null;
      }
      return contract;
    }
    /**
     * Returns the balance for the given contract for the given asset ID.
     *
     * @param contractId - The contract ID to get the balance for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getContractBalance(contractId, assetId) {
      const { contractBalance } = await this.operations.getContractBalance({
        contract: Address.fromAddressOrString(contractId).toB256(),
        asset: hexlify(assetId)
      });
      return bn(contractBalance.amount, 10);
    }
    /**
     * Returns the balance for the given owner for the given asset ID.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getBalance(owner, assetId) {
      const { balance } = await this.operations.getBalance({
        owner: Address.fromAddressOrString(owner).toB256(),
        assetId: hexlify(assetId)
      });
      return bn(balance.amount, 10);
    }
    /**
     * Returns balances for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the balances.
     */
    async getBalances(owner) {
      const {
        balances: { edges }
      } = await this.operations.getBalances({
        /**
         * The query parameters for this method were designed to support pagination,
         * but the current Fuel-Core implementation does not support pagination yet.
         */
        first: 1e4,
        filter: { owner: Address.fromAddressOrString(owner).toB256() }
      });
      const balances = edges.map(({ node: node2 }) => ({
        assetId: node2.assetId,
        amount: bn(node2.amount)
      }));
      return { balances };
    }
    /**
     * Returns message for the given address.
     *
     * @param address - The address to get message from.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the messages.
     */
    async getMessages(address, paginationArgs) {
      const {
        messages: { edges, pageInfo }
      } = await this.operations.getMessages({
        ...validatePaginationArgs2({
          inputArgs: paginationArgs,
          paginationLimit: RESOURCES_PAGE_SIZE_LIMIT2
        }),
        owner: Address.fromAddressOrString(address).toB256()
      });
      const messages = edges.map(({ node: node2 }) => ({
        messageId: InputMessageCoder.getMessageId({
          sender: node2.sender,
          recipient: node2.recipient,
          nonce: node2.nonce,
          amount: bn(node2.amount),
          data: node2.data
        }),
        sender: Address.fromAddressOrString(node2.sender),
        recipient: Address.fromAddressOrString(node2.recipient),
        nonce: node2.nonce,
        amount: bn(node2.amount),
        data: InputMessageCoder.decodeData(node2.data),
        daHeight: bn(node2.daHeight)
      }));
      return {
        messages,
        pageInfo
      };
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param transactionId - The transaction to get message from.
     * @param messageId - The message id from MessageOut receipt.
     * @param commitBlockId - The commit block id (optional).
     * @param commitBlockHeight - The commit block height (optional).
     * @returns A promise that resolves to the message proof.
     */
    async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
      let inputObject = {
        transactionId,
        nonce
      };
      if (commitBlockId && commitBlockHeight) {
        throw new FuelError(
          ErrorCode.INVALID_INPUT_PARAMETERS,
          "commitBlockId and commitBlockHeight cannot be used together"
        );
      }
      if (commitBlockId) {
        inputObject = {
          ...inputObject,
          commitBlockId
        };
      }
      if (commitBlockHeight) {
        inputObject = {
          ...inputObject,
          // Conver BN into a number string required on the query
          // This should problably be fixed on the fuel client side
          commitBlockHeight: commitBlockHeight.toNumber().toString()
        };
      }
      const result = await this.operations.getMessageProof(inputObject);
      if (!result.messageProof) {
        return null;
      }
      const {
        messageProof,
        messageBlockHeader,
        commitBlockHeader,
        blockProof,
        sender,
        recipient,
        amount,
        data
      } = result.messageProof;
      return {
        messageProof: {
          proofIndex: bn(messageProof.proofIndex),
          proofSet: messageProof.proofSet
        },
        blockProof: {
          proofIndex: bn(blockProof.proofIndex),
          proofSet: blockProof.proofSet
        },
        messageBlockHeader: {
          id: messageBlockHeader.id,
          daHeight: bn(messageBlockHeader.daHeight),
          transactionsCount: Number(messageBlockHeader.transactionsCount),
          transactionsRoot: messageBlockHeader.transactionsRoot,
          height: bn(messageBlockHeader.height),
          prevRoot: messageBlockHeader.prevRoot,
          time: messageBlockHeader.time,
          applicationHash: messageBlockHeader.applicationHash,
          messageReceiptCount: Number(messageBlockHeader.messageReceiptCount),
          messageOutboxRoot: messageBlockHeader.messageOutboxRoot,
          consensusParametersVersion: Number(messageBlockHeader.consensusParametersVersion),
          eventInboxRoot: messageBlockHeader.eventInboxRoot,
          stateTransitionBytecodeVersion: Number(messageBlockHeader.stateTransitionBytecodeVersion)
        },
        commitBlockHeader: {
          id: commitBlockHeader.id,
          daHeight: bn(commitBlockHeader.daHeight),
          transactionsCount: Number(commitBlockHeader.transactionsCount),
          transactionsRoot: commitBlockHeader.transactionsRoot,
          height: bn(commitBlockHeader.height),
          prevRoot: commitBlockHeader.prevRoot,
          time: commitBlockHeader.time,
          applicationHash: commitBlockHeader.applicationHash,
          messageReceiptCount: Number(commitBlockHeader.messageReceiptCount),
          messageOutboxRoot: commitBlockHeader.messageOutboxRoot,
          consensusParametersVersion: Number(commitBlockHeader.consensusParametersVersion),
          eventInboxRoot: commitBlockHeader.eventInboxRoot,
          stateTransitionBytecodeVersion: Number(commitBlockHeader.stateTransitionBytecodeVersion)
        },
        sender: Address.fromAddressOrString(sender),
        recipient: Address.fromAddressOrString(recipient),
        nonce,
        amount: bn(amount),
        data
      };
    }
    /**
     * Get the latest gas price from the node.
     *
     * @returns A promise that resolves to the latest gas price.
     */
    async getLatestGasPrice() {
      const { latestGasPrice } = await this.operations.getLatestGasPrice();
      return bn(latestGasPrice.gasPrice);
    }
    /**
     * Returns the estimate gas price for the given block horizon.
     *
     * @param blockHorizon - The block horizon to estimate gas price for.
     * @returns A promise that resolves to the estimated gas price.
     */
    async estimateGasPrice(blockHorizon) {
      const { estimateGasPrice } = await this.operations.estimateGasPrice({
        blockHorizon: String(blockHorizon)
      });
      return bn(estimateGasPrice.gasPrice);
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param nonce - The nonce of the message to get status from.
     * @returns A promise that resolves to the message status
     */
    async getMessageStatus(nonce) {
      const result = await this.operations.getMessageStatus({ nonce });
      return result.messageStatus;
    }
    /**
     * Lets you produce blocks with custom timestamps and the block number of the last block produced.
     *
     * @param amount - The amount of blocks to produce.
     * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
     * @returns A promise that resolves to the block number of the last produced block.
     */
    async produceBlocks(amount, startTime) {
      const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
        blocksToProduce: bn(amount).toString(10),
        startTimestamp: startTime ? DateTime.fromUnixMilliseconds(startTime).toTai64() : void 0
      });
      return bn(latestBlockHeight);
    }
    /**
     * Check if the given ID is an account.
     *
     * @param id - The ID to check.
     * @returns A promise that resolves to the result of the check.
     */
    async isUserAccount(id) {
      const { contract, blob, transaction } = await this.operations.isUserAccount({
        blobId: id,
        contractId: id,
        transactionId: id
      });
      if (contract || blob || transaction) {
        return false;
      }
      return true;
    }
    async getAddressType(id) {
      const { contract, blob, transaction } = await this.operations.isUserAccount({
        blobId: id,
        contractId: id,
        transactionId: id
      });
      if (contract) {
        return "Contract";
      }
      if (blob) {
        return "Blob";
      }
      if (transaction) {
        return "Transaction";
      }
      return "Account";
    }
    /**
     * Get the transaction response for the given transaction ID.
     *
     * @param transactionId - The transaction ID to get the response for.
     * @returns A promise that resolves to the transaction response.
     */
    async getTransactionResponse(transactionId) {
      const chainId = await this.getChainId();
      return new TransactionResponse2(transactionId, this, chainId);
    }
    /**
     * Returns Message for given nonce.
     *
     * @param nonce - The nonce of the message to retrieve.
     * @returns A promise that resolves to the Message object or null.
     */
    async getMessageByNonce(nonce) {
      const { message: rawMessage } = await this.operations.getMessageByNonce({ nonce });
      if (!rawMessage) {
        return null;
      }
      const message = {
        messageId: InputMessageCoder.getMessageId({
          sender: rawMessage.sender,
          recipient: rawMessage.recipient,
          nonce,
          amount: bn(rawMessage.amount),
          data: rawMessage.data
        }),
        sender: Address.fromAddressOrString(rawMessage.sender),
        recipient: Address.fromAddressOrString(rawMessage.recipient),
        nonce,
        amount: bn(rawMessage.amount),
        data: InputMessageCoder.decodeData(rawMessage.data),
        daHeight: bn(rawMessage.daHeight)
      };
      return message;
    }
    /**
     * Get the relayed transaction for the given transaction ID.
     *
     * @param relayedTransactionId - The relayed transaction ID to get the response for.
     * @returns A promise that resolves to the relayed transaction.
     */
    async getRelayedTransactionStatus(relayedTransactionId) {
      const { relayedTransactionStatus } = await this.operations.getRelayedTransactionStatus({
        relayedTransactionId
      });
      if (!relayedTransactionStatus) {
        return null;
      }
      return relayedTransactionStatus;
    }
    /**
     * @hidden
     */
    extractDryRunError(transactionRequest, receipts, dryRunStatus) {
      const status = dryRunStatus;
      let logs = [];
      if (transactionRequest.abis) {
        logs = getDecodedLogs2(
          receipts,
          transactionRequest.abis.main,
          transactionRequest.abis.otherContractsAbis
        );
      }
      return extractTxError2({
        logs,
        receipts,
        statusReason: status.reason
      });
    }
  };
  var Provider2 = _Provider2;
  _cacheInputs2 = /* @__PURE__ */ new WeakSet();
  cacheInputs_fn2 = function(inputs, transactionId) {
    if (!this.cache) {
      return;
    }
    const inputsToCache = inputs.reduce(
      (acc, input) => {
        if (input.type === InputType.Coin) {
          acc.utxos.push(input.id);
        } else if (input.type === InputType.Message) {
          acc.messages.push(input.nonce);
        }
        return acc;
      },
      { utxos: [], messages: [] }
    );
    this.cache.set(transactionId, inputsToCache);
  };
  __publicField10(Provider2, "chainInfoCache", {});
  __publicField10(Provider2, "nodeInfoCache", {});
  var CHAIN_IDS2 = {
    eth: {
      mainnet: 1,
      sepolia: 11155111,
      foundry: 31337
    },
    fuel: {
      devnet: 0,
      testnet: 0,
      mainnet: 9889
    }
  };
  var DELIMITER_PATH2 = "/";
  var trimRegex2 = /^\/|\/$/g;
  var trimPath2 = (path23 = "") => path23.replace(trimRegex2, "");
  function urlJoin2(baseUrl, ...paths) {
    const hasBaseUrl = baseUrl !== null && baseUrl !== void 0;
    const rootPath = baseUrl?.[0] === "/" && baseUrl.length > 1;
    const allPaths = [baseUrl, ...paths].filter(Boolean).map(trimPath2);
    if (rootPath && hasBaseUrl) {
      allPaths.unshift("");
    }
    return allPaths.join(DELIMITER_PATH2);
  }
  function resolveIconPaths2(assets22, basePath = "./") {
    return assets22.map((asset) => ({
      ...asset,
      icon: urlJoin2(basePath, asset.icon)
    }));
  }
  var fuelAssetsBaseUrl2 = "https://cdn.fuel.network/assets/";
  var rawAssets2 = [
    {
      name: "Ethereum",
      symbol: "ETH",
      icon: "eth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.sepolia,
          decimals: 18
        },
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.foundry,
          decimals: 18
        },
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.devnet,
          decimals: 9,
          assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.testnet,
          decimals: 9,
          assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          decimals: 9,
          assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
        }
      ]
    },
    {
      name: "WETH",
      symbol: "WETH",
      icon: "weth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xa38a5a8beeb08d95744bc7f58528073f4052b254def59eba20c99c202b5acaa3",
          decimals: 9
        }
      ]
    },
    {
      name: "weETH",
      symbol: "weETH",
      icon: "weETH.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x239ed6e12b7ce4089ee245244e3bf906999a6429c2a9a445a1e1faf56914a4ab",
          decimals: 9
        }
      ]
    },
    {
      name: "rsETH",
      symbol: "rsETH",
      icon: "rsETH.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xbae80f7fb8aa6b90d9b01ef726ec847cc4f59419c4d5f2ea88fec785d1b0e849",
          decimals: 9
        }
      ]
    },
    {
      name: "rETH",
      symbol: "rETH",
      icon: "reth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xae78736cd615f374d3085123a210448e74fc6393",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xf3f9a0ed0ce8eac5f89d6b83e41b3848212d5b5f56108c54a205bb228ca30c16",
          decimals: 9
        }
      ]
    },
    {
      name: "wbETH",
      symbol: "wbETH",
      icon: "wbeth.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xa2E3356610840701BDf5611a53974510Ae27E2e1",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x7843c74bef935e837f2bcf67b5d64ecb46dd53ff86375530b0caf3699e8ffafe",
          decimals: 9
        }
      ]
    },
    {
      name: "rstETH",
      symbol: "rstETH",
      icon: "rstETH.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x7a4EffD87C2f3C55CA251080b1343b605f327E3a",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x962792286fbc9b1d5860b4551362a12249362c21594c77abf4b3fe2bbe8d977a",
          decimals: 9
        }
      ]
    },
    {
      name: "amphrETH",
      symbol: "amphrETH",
      icon: "amphrETH.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x5fD13359Ba15A84B76f7F87568309040176167cd",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x05fc623e57bd7bc1258efa8e4f62b05af5471d73df6f2c2dc11ecc81134c4f36",
          decimals: 9
        }
      ]
    },
    {
      name: "Manta mBTC",
      symbol: "Manta mBTC",
      icon: "manta-mbtc.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x4041381e947CFD3D483d67a25C6aa9Dc924250c5",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xaf3111a248ff7a3238cdeea845bb2d43cf3835f1f6b8c9d28360728b55b9ce5b",
          decimals: 9
        }
      ]
    },
    {
      name: "Manta mETH",
      symbol: "Manta mETH",
      icon: "manta-meth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x8CdF550C04Bc9B9F10938368349C9c8051A772b6",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xafd219f513317b1750783c6581f55530d6cf189a5863fd18bd1b3ffcec1714b4",
          decimals: 9
        }
      ]
    },
    {
      name: "Manta mUSD",
      symbol: "Manta mUSD",
      icon: "manta-musd.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x3f24E1d7a973867fC2A03fE199E5502514E0e11E",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x89cb9401e55d49c3269654dd1cdfb0e80e57823a4a7db98ba8fc5953b120fef4",
          decimals: 9
        }
      ]
    },
    {
      name: "pumpBTC",
      symbol: "pumpBTC",
      icon: "pumpbtc.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xf469fbd2abcd6b9de8e169d128226c0fc90a012e",
          decimals: 8
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x0aa5eb2bb97ca915288b653a2529355d4dc66de2b37533213f0e4aeee3d3421f",
          decimals: 8
        }
      ]
    },
    {
      name: "FBTC",
      symbol: "FBTC",
      icon: "fbtc.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xc96de26018a54d51c097160568752c4e3bd6c364",
          decimals: 8
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xb5ecb0a1e08e2abbabf624ffea089df933376855f468ade35c6375b00c33996a",
          decimals: 8
        }
      ]
    },
    {
      name: "SolvBTC",
      symbol: "SolvBTC",
      icon: "solvBTC.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x7a56e1c57c7475ccf742a1832b028f0456652f97",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x1186afea9affb88809c210e13e2330b5258c2cef04bb8fff5eff372b7bd3f40f",
          decimals: 9
        }
      ]
    },
    {
      name: "SolvBTC.BBN",
      symbol: "SolvBTC.BBN",
      icon: "SolvBTC.BBN.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xd9d920aa40f578ab794426f5c90f6c731d159def",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x7a4f087c957d30218223c2baaaa365355c9ca81b6ea49004cfb1590a5399216f",
          decimals: 9
        }
      ]
    },
    {
      name: "Mantle mETH",
      symbol: "Mantle mETH",
      icon: "mantle-meth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xd5F7838F5C461fefF7FE49ea5ebaF7728bB0ADfa",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x642a5db59ec323c2f846d4d4cf3e58d78aff64accf4f8f6455ba0aa3ef000a3b",
          decimals: 9
        }
      ]
    },
    {
      name: "sDAI",
      symbol: "sDAI",
      icon: "sdai.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x83f20f44975d03b1b09e64809b757c47f942beea",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x9e46f919fbf978f3cad7cd34cca982d5613af63ff8aab6c379e4faa179552958",
          decimals: 9
        }
      ]
    },
    {
      name: "USDT",
      symbol: "USDT",
      icon: "usdt.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
          decimals: 6
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xa0265fb5c32f6e8db3197af3c7eb05c48ae373605b8165b6f4a51c5b0ba4812e",
          decimals: 6
        }
      ]
    },
    {
      name: "USDC",
      symbol: "USDC",
      icon: "usdc.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
          decimals: 6
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x286c479da40dc953bddc3bb4c453b608bba2e0ac483b077bd475174115395e6b",
          decimals: 6
        }
      ]
    },
    {
      name: "USDe",
      symbol: "USDe",
      icon: "USDe.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x4c9edd5852cd905f086c759e8383e09bff1e68b3",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xb6133b2ef9f6153eb869125d23dcf20d1e735331b5e41b15a6a7a6cec70e8651",
          decimals: 9
        }
      ]
    },
    {
      name: "sUSDe",
      symbol: "sUSDe",
      icon: "sUSDe.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x9d39a5de30e57443bff2a8307a4256c8797a3497",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xd05563025104fc36496c15c7021ad6b31034b0e89a356f4f818045d1f48808bc",
          decimals: 9
        }
      ]
    },
    {
      name: "rsUSDe",
      symbol: "rsUSDe",
      icon: "rsUSDe.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x82f5104b23FF2FA54C2345F821dAc9369e9E0B26",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x78d4522ec607f6e8efb66ea49439d1ee48623cf763f9688a8eada025def033d9",
          decimals: 9
        }
      ]
    },
    {
      name: "wstETH",
      symbol: "wstETH",
      icon: "wsteth.svg",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x1a7815cc9f75db5c24a5b0814bfb706bb9fe485333e98254015de8f48f84c67b",
          decimals: 9
        }
      ]
    },
    {
      name: "ezETH",
      symbol: "ezETH",
      icon: "ezeth.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xbf5495Efe5DB9ce00f80364C8B423567e58d2110",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x91b3559edb2619cde8ffb2aa7b3c3be97efd794ea46700db7092abeee62281b0",
          decimals: 9
        }
      ]
    },
    {
      name: "pzETH",
      symbol: "pzETH",
      icon: "pzETH.webp",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x8c9532a60e0e7c6bbd2b2c1303f63ace1c3e9811",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x1493d4ec82124de8f9b625682de69dcccda79e882b89a55a8c737b12de67bd68",
          decimals: 9
        }
      ]
    },
    {
      name: "Re7LRT",
      symbol: "Re7LRT",
      icon: "Re7LRT.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0x84631c0d0081FDe56DeB72F6DE77abBbF6A9f93a",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0xf2fc648c23a5db24610a1cf696acc4f0f6d9a7d6028dd9944964ab23f6e35995",
          decimals: 9
        }
      ]
    },
    {
      name: "steakLRT",
      symbol: "steakLRT",
      icon: "steakLRT.png",
      networks: [
        {
          type: "ethereum",
          chainId: CHAIN_IDS2.eth.mainnet,
          address: "0xBEEF69Ac7870777598A04B2bd4771c71212E6aBc",
          decimals: 18
        },
        {
          type: "fuel",
          chainId: CHAIN_IDS2.fuel.mainnet,
          contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
          assetId: "0x4fc8ac9f101df07e2c2dec4a53c8c42c439bdbe5e36ea2d863a61ff60afafc30",
          decimals: 9
        }
      ]
    }
  ];
  var assets2 = resolveIconPaths2(rawAssets2, fuelAssetsBaseUrl2);
  var _TestAssetId = class {
    constructor(value) {
      this.value = value;
    }
    static random(count = 1) {
      const assetIds = [];
      for (let i = 0; i < count; i++) {
        assetIds.push(new _TestAssetId(hexlify(randomBytes22(32))));
      }
      return assetIds;
    }
  };
  var TestAssetId = _TestAssetId;
  __publicField10(TestAssetId, "A", new _TestAssetId(
    "0x0101010101010101010101010101010101010101010101010101010101010101"
  ));
  __publicField10(TestAssetId, "B", new _TestAssetId(
    "0x0202020202020202020202020202020202020202020202020202020202020202"
  ));
  var mergeQuantities2 = (...coinQuantities) => {
    const resultMap = {};
    function addToMap({ amount, assetId }) {
      if (resultMap[assetId]) {
        resultMap[assetId] = resultMap[assetId].add(amount);
      } else {
        resultMap[assetId] = amount;
      }
    }
    coinQuantities.forEach((arr) => arr.forEach(addToMap));
    return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
  };
  var AbstractAccount2 = class {
  };
  var formatTransferToContractScriptData2 = (transferParams) => {
    const numberCoder = new BigNumberCoder("u64");
    return transferParams.reduce((acc, transferParam) => {
      const { assetId, amount, contractId } = transferParam;
      const encoded = numberCoder.encode(amount);
      const scriptData = concat([
        Address.fromAddressOrString(contractId).toBytes(),
        encoded,
        arrayify(assetId)
      ]);
      return concat([acc, scriptData]);
    }, new Uint8Array());
  };
  var assembleTransferToContractScript2 = async (transferParams) => {
    const scriptData = formatTransferToContractScriptData2(transferParams);
    await asm5.initWasm();
    let script = new Uint8Array();
    transferParams.forEach((_, i) => {
      const offset = (CONTRACT_ID_LEN + WORD_SIZE + ASSET_ID_LEN) * i;
      script = concat([
        script,
        // Load ScriptData into register 0x10.
        asm5.gtf(16, 0, asm5.GTFArgs.ScriptData).to_bytes(),
        // Add the offset to 0x10 so it will point to the current contract ID, store in 0x11.
        asm5.addi(17, 16, offset).to_bytes(),
        // Add CONTRACT_ID_LEN to 0x11 to point to the amount in the ScriptData, store in 0x12.
        asm5.addi(18, 17, CONTRACT_ID_LEN).to_bytes(),
        // Load word to the amount at 0x12 into register 0x13.
        asm5.lw(19, 18, 0).to_bytes(),
        // Add WORD_SIZE to 0x12 to point to the asset ID in the ScriptData, store in 0x14.
        asm5.addi(20, 18, WORD_SIZE).to_bytes(),
        // Perform the transfer using contract ID in 0x11, amount in 0x13, and asset ID in 0x14.
        asm5.tr(17, 19, 20).to_bytes()
      ]);
    });
    script = concat([script, asm5.ret(1).to_bytes()]);
    return { script, scriptData };
  };
  var MAX_FUNDING_ATTEMPTS2 = 5;
  var Account2 = class extends AbstractAccount2 {
    /**
     * The address associated with the account.
     */
    address;
    /**
     * The provider used to interact with the network.
     */
    _provider;
    /**
     * The connector for use with external wallets
     */
    _connector;
    /**
     * Creates a new Account instance.
     *
     * @param address - The address of the account.
     * @param provider - A Provider instance  (optional).
     * @param connector - A FuelConnector instance (optional).
     */
    constructor(address, provider, connector) {
      super();
      this._provider = provider;
      this._connector = connector;
      this.address = Address.fromDynamicInput(address);
    }
    /**
     * The provider used to interact with the network.
     *
     * @returns A Provider instance.
     *
     * @throws `FuelError` if the provider is not set.
     */
    get provider() {
      if (!this._provider) {
        throw new FuelError(ErrorCode.MISSING_PROVIDER, "Provider not set");
      }
      return this._provider;
    }
    /**
     * Sets the provider for the account.
     *
     * @param provider - A Provider instance.
     */
    set provider(provider) {
      this._provider = provider;
    }
    /**
     * Changes the provider connection for the account.
     *
     * @param provider - A Provider instance.
     * @returns The updated Provider instance.
     */
    connect(provider) {
      this._provider = provider;
      return this.provider;
    }
    /**
     * Retrieves resources satisfying the spend query for the account.
     *
     * @param quantities - Quantities of resources to be obtained.
     * @param excludedIds - IDs of resources to be excluded from the query (optional).
     * @returns A promise that resolves to an array of Resources.
     */
    async getResourcesToSpend(quantities, excludedIds) {
      return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
    }
    /**
     * Retrieves coins owned by the account.
     *
     * @param assetId - The asset ID of the coins to retrieve (optional).
     * @returns A promise that resolves to an array of Coins.
     */
    async getCoins(assetId, paginationArgs) {
      return this.provider.getCoins(this.address, assetId, paginationArgs);
    }
    /**
     * Retrieves messages owned by the account.
     *
     * @returns A promise that resolves to an array of Messages.
     */
    async getMessages(paginationArgs) {
      return this.provider.getMessages(this.address, paginationArgs);
    }
    /**
     * Retrieves the balance of the account for the given asset.
     *
     * @param assetId - The asset ID to check the balance for (optional).
     * @returns A promise that resolves to the balance amount.
     */
    async getBalance(assetId) {
      const assetIdToFetch = assetId ?? await this.provider.getBaseAssetId();
      const amount = await this.provider.getBalance(this.address, assetIdToFetch);
      return amount;
    }
    /**
     * Retrieves all the balances for the account.
     *
     * @returns A promise that resolves to an array of Coins and their quantities.
     */
    async getBalances() {
      return this.provider.getBalances(this.address);
    }
    /**
     * Funds a transaction request by adding the necessary resources.
     *
     * @typeParam T - The type of the TransactionRequest.
     * @param request - The transaction request to fund.
     * @param params - The estimated transaction parameters.
     * @returns A promise that resolves to the funded transaction request.
     */
    async fund(request, params) {
      const { addedSignatures, estimatedPredicates, requiredQuantities, updateMaxFee, gasPrice } = params;
      const fee = request.maxFee;
      const baseAssetId = await this.provider.getBaseAssetId();
      const requiredInBaseAsset = requiredQuantities.find((quantity) => quantity.assetId === baseAssetId)?.amount || bn(0);
      const requiredQuantitiesWithFee = addAmountToCoinQuantities2({
        amount: bn(fee),
        assetId: baseAssetId,
        coinQuantities: requiredQuantities
      });
      const quantitiesDict = {};
      requiredQuantitiesWithFee.forEach(({ amount, assetId }) => {
        quantitiesDict[assetId] = {
          required: amount,
          owned: bn(0)
        };
      });
      request.inputs.filter(isRequestInputResource2).forEach((input) => {
        const isCoin22 = isRequestInputCoin2(input);
        const assetId = isCoin22 ? String(input.assetId) : baseAssetId;
        if (quantitiesDict[assetId]) {
          quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(input.amount);
        }
      });
      let missingQuantities = [];
      Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
        if (owned.lt(required)) {
          missingQuantities.push({
            assetId,
            amount: required.sub(owned)
          });
        }
      });
      let needsToBeFunded = missingQuantities.length > 0;
      let fundingAttempts = 0;
      while (needsToBeFunded && fundingAttempts < MAX_FUNDING_ATTEMPTS2) {
        const resources = await this.getResourcesToSpend(
          missingQuantities,
          cacheRequestInputsResourcesFromOwner2(request.inputs, this.address)
        );
        request.addResources(resources);
        request.updatePredicateGasUsed(estimatedPredicates);
        const requestToReestimate2 = clone_default(request);
        if (addedSignatures) {
          Array.from({ length: addedSignatures }).forEach(
            () => requestToReestimate2.addEmptyWitness()
          );
        }
        if (!updateMaxFee) {
          needsToBeFunded = false;
          break;
        }
        const { maxFee: newFee } = await this.provider.estimateTxGasAndFee({
          transactionRequest: requestToReestimate2,
          gasPrice
        });
        const totalBaseAssetOnInputs = getAssetAmountInRequestInputs2(
          request.inputs.filter(isRequestInputResource2),
          baseAssetId,
          baseAssetId
        );
        const totalBaseAssetRequiredWithFee = requiredInBaseAsset.add(newFee);
        if (totalBaseAssetOnInputs.gt(totalBaseAssetRequiredWithFee)) {
          needsToBeFunded = false;
        } else {
          missingQuantities = [
            {
              amount: totalBaseAssetRequiredWithFee.sub(totalBaseAssetOnInputs),
              assetId: baseAssetId
            }
          ];
        }
        fundingAttempts += 1;
      }
      if (needsToBeFunded) {
        throw new FuelError(
          ErrorCode.NOT_ENOUGH_FUNDS,
          `The account ${this.address} does not have enough base asset funds to cover the transaction execution.`
        );
      }
      await this.provider.validateTransaction(request);
      request.updatePredicateGasUsed(estimatedPredicates);
      const requestToReestimate = clone_default(request);
      if (addedSignatures) {
        Array.from({ length: addedSignatures }).forEach(() => requestToReestimate.addEmptyWitness());
      }
      if (!updateMaxFee) {
        return request;
      }
      const { maxFee } = await this.provider.estimateTxGasAndFee({
        transactionRequest: requestToReestimate,
        gasPrice
      });
      request.maxFee = maxFee;
      return request;
    }
    /**
     * A helper that creates a transfer transaction request and returns it.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer (optional).
     * @param txParams - The transaction parameters (optional).
     * @returns A promise that resolves to the prepared transaction request.
     */
    async createTransfer(destination, amount, assetId, txParams = {}) {
      let request = new ScriptTransactionRequest2(txParams);
      request = this.addTransfer(request, {
        destination,
        amount,
        assetId: assetId || await this.provider.getBaseAssetId()
      });
      request = await this.estimateAndFundTransaction(request, txParams);
      return request;
    }
    /**
     * Transfers coins to a destination address.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer (optional).
     * @param txParams - The transaction parameters (optional).
     * @returns A promise that resolves to the transaction response.
     */
    async transfer(destination, amount, assetId, txParams = {}) {
      const request = await this.createTransfer(destination, amount, assetId, txParams);
      return this.sendTransaction(request, { estimateTxDependencies: false });
    }
    /**
     * Transfers multiple amounts of a token to multiple recipients.
     *
     * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
     * @param txParams - Optional transaction parameters.
     * @returns A promise that resolves to a `TransactionResponse` object representing the transaction result.
     */
    async batchTransfer(transferParams, txParams = {}) {
      let request = new ScriptTransactionRequest2(txParams);
      request = this.addBatchTransfer(request, transferParams);
      request = await this.estimateAndFundTransaction(request, txParams);
      return this.sendTransaction(request, { estimateTxDependencies: false });
    }
    /**
     * Adds a transfer to the given transaction request.
     *
     * @param request - The script transaction request to add transfers to.
     * @param transferParams - The object representing the transfer to be made.
     * @returns The updated transaction request with the added transfer.
     */
    addTransfer(request, transferParams) {
      const { destination, amount, assetId } = transferParams;
      this.validateTransferAmount(amount);
      request.addCoinOutput(Address.fromAddressOrString(destination), amount, assetId);
      return request;
    }
    /**
     * Adds multiple transfers to a script transaction request.
     *
     * @param request - The script transaction request to add transfers to.
     * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
     * @returns The updated script transaction request.
     */
    addBatchTransfer(request, transferParams) {
      transferParams.forEach(({ destination, amount, assetId }) => {
        this.addTransfer(request, {
          destination,
          amount,
          assetId
        });
      });
      return request;
    }
    /**
     * Transfers coins to a contract address.
     *
     * @param contractId - The address of the contract.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer (optional).
     * @param txParams - The transaction parameters (optional).
     * @returns A promise that resolves to the transaction response.
     */
    async transferToContract(contractId, amount, assetId, txParams = {}) {
      return this.batchTransferToContracts([{ amount, assetId, contractId }], txParams);
    }
    async batchTransferToContracts(contractTransferParams, txParams = {}) {
      let request = new ScriptTransactionRequest2({
        ...txParams
      });
      const quantities = [];
      const defaultAssetId = await this.provider.getBaseAssetId();
      const transferParams = contractTransferParams.map((transferParam) => {
        const amount = bn(transferParam.amount);
        const contractAddress = Address.fromAddressOrString(transferParam.contractId);
        const assetId = transferParam.assetId ? hexlify(transferParam.assetId) : defaultAssetId;
        if (amount.lte(0)) {
          throw new FuelError(
            ErrorCode.INVALID_TRANSFER_AMOUNT,
            "Transfer amount must be a positive number."
          );
        }
        request.addContractInputAndOutput(contractAddress);
        quantities.push({ amount, assetId });
        return {
          amount,
          contractId: contractAddress.toB256(),
          assetId
        };
      });
      const { script, scriptData } = await assembleTransferToContractScript2(transferParams);
      request.script = script;
      request.scriptData = scriptData;
      request = await this.estimateAndFundTransaction(request, txParams, { quantities });
      return this.sendTransaction(request);
    }
    /**
     * Withdraws an amount of the base asset to the base chain.
     *
     * @param recipient - Address of the recipient on the base chain.
     * @param amount - Amount of base asset.
     * @param txParams - The transaction parameters (optional).
     * @returns A promise that resolves to the transaction response.
     */
    async withdrawToBaseLayer(recipient, amount, txParams = {}) {
      const recipientAddress = Address.fromAddressOrString(recipient);
      const recipientDataArray = arrayify(
        "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
      );
      const amountDataArray = arrayify(
        "0x".concat(bn(amount).toHex().substring(2).padStart(16, "0"))
      );
      const script = new Uint8Array([
        ...arrayify(withdrawScript2.bytes),
        ...recipientDataArray,
        ...amountDataArray
      ]);
      const params = { script, ...txParams };
      const baseAssetId = await this.provider.getBaseAssetId();
      let request = new ScriptTransactionRequest2(params);
      const quantities = [{ amount: bn(amount), assetId: baseAssetId }];
      const txCost = await this.getTransactionCost(request, { quantities });
      request = this.validateGasLimitAndMaxFee({
        transactionRequest: request,
        gasUsed: txCost.gasUsed,
        maxFee: txCost.maxFee,
        txParams
      });
      await this.fund(request, txCost);
      return this.sendTransaction(request);
    }
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the transaction.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param transactionCostParams - The transaction cost parameters (optional).
     *
     * @returns A promise that resolves to the transaction cost object.
     */
    async getTransactionCost(transactionRequestLike, { signatureCallback, quantities = [] } = {}) {
      const txRequestClone = clone_default(transactionRequestify2(transactionRequestLike));
      const baseAssetId = await this.provider.getBaseAssetId();
      const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
      const requiredQuantities = mergeQuantities2(coinOutputsQuantities, quantities);
      const transactionFeeForDryRun = [{ assetId: baseAssetId, amount: bn("100000000000000000") }];
      const findAssetInput = (assetId) => txRequestClone.inputs.find((input) => {
        if (input.type === InputType.Coin) {
          return input.assetId === assetId;
        }
        if (isRequestInputMessageWithoutData2(input)) {
          return baseAssetId === assetId;
        }
        return false;
      });
      const updateAssetInput = (assetId, quantity) => {
        const assetInput = findAssetInput(assetId);
        const usedQuantity = quantity;
        if (assetInput && "amount" in assetInput) {
          assetInput.amount = usedQuantity;
        } else {
          txRequestClone.addResources(
            this.generateFakeResources([
              {
                amount: quantity,
                assetId
              }
            ])
          );
        }
      };
      mergeQuantities2(requiredQuantities, transactionFeeForDryRun).forEach(
        ({ amount, assetId }) => updateAssetInput(assetId, amount)
      );
      const txCost = await this.provider.getTransactionCost(txRequestClone, {
        signatureCallback
      });
      return {
        ...txCost,
        requiredQuantities
      };
    }
    /**
     * Sign a message from the account via the connector.
     *
     * @param message - the message to sign.
     * @returns a promise that resolves to the signature.
     *
     * @hidden
     */
    async signMessage(message) {
      if (!this._connector) {
        throw new FuelError(ErrorCode.MISSING_CONNECTOR, "A connector is required to sign messages.");
      }
      return this._connector.signMessage(this.address.toString(), message);
    }
    /**
     * Signs a transaction from the account via the connector..
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature of the transaction.
     */
    async signTransaction(transactionRequestLike) {
      if (!this._connector) {
        throw new FuelError(
          ErrorCode.MISSING_CONNECTOR,
          "A connector is required to sign transactions."
        );
      }
      return this._connector.signTransaction(this.address.toString(), transactionRequestLike);
    }
    /**
     * Sends a transaction to the network.
     *
     * @param transactionRequestLike - The transaction request to be sent.
     * @param sendTransactionParams - The provider send transaction parameters (optional).
     * @returns A promise that resolves to the transaction response.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, onBeforeSend, skipCustomFee = false } = {}) {
      if (this._connector) {
        return this.provider.getTransactionResponse(
          await this._connector.sendTransaction(this.address.toString(), transactionRequestLike, {
            onBeforeSend,
            skipCustomFee
          })
        );
      }
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.sendTransaction(transactionRequest, {
        estimateTxDependencies: false
      });
    }
    /**
     * Simulates a transaction.
     *
     * @param transactionRequestLike - The transaction request to be simulated.
     * @param estimateTxParams - The estimate transaction params (optional).
     * @returns A promise that resolves to the call result.
     */
    async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
    }
    /**
     * Generates an array of fake resources based on the provided coins.
     *
     * @param coins - An array of `FakeResources` objects representing the coins.
     * @returns An array of `Resource` objects with generated properties.
     */
    generateFakeResources(coins) {
      return coins.map((coin) => ({
        id: hexlify(randomBytes22(UTXO_ID_LEN)),
        owner: this.address,
        blockCreated: bn(1),
        txCreatedIdx: bn(1),
        ...coin
      }));
    }
    /** @hidden * */
    validateTransferAmount(amount) {
      if (bn(amount).lte(0)) {
        throw new FuelError(
          ErrorCode.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      }
    }
    /** @hidden * */
    async estimateAndFundTransaction(transactionRequest, txParams, costParams) {
      let request = transactionRequest;
      const txCost = await this.getTransactionCost(request, costParams);
      request = this.validateGasLimitAndMaxFee({
        transactionRequest: request,
        gasUsed: txCost.gasUsed,
        maxFee: txCost.maxFee,
        txParams
      });
      request = await this.fund(request, txCost);
      return request;
    }
    /** @hidden * */
    validateGasLimitAndMaxFee({
      gasUsed,
      maxFee,
      transactionRequest,
      txParams: { gasLimit: setGasLimit, maxFee: setMaxFee }
    }) {
      const request = transactionRequestify2(transactionRequest);
      if (!isDefined(setGasLimit)) {
        request.gasLimit = gasUsed;
      } else if (gasUsed.gt(setGasLimit)) {
        throw new FuelError(
          ErrorCode.GAS_LIMIT_TOO_LOW,
          `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`
        );
      }
      if (!isDefined(setMaxFee)) {
        request.maxFee = maxFee;
      } else if (maxFee.gt(setMaxFee)) {
        throw new FuelError(
          ErrorCode.MAX_FEE_TOO_LOW,
          `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`
        );
      }
      return request;
    }
  };
  var DEFAULT_KDF_PARAMS_LOG_N2 = 13;
  var DEFAULT_KDF_PARAMS_R2 = 8;
  var DEFAULT_KDF_PARAMS_P2 = 1;
  var DEFAULT_KEY_SIZE2 = 32;
  var DEFAULT_IV_SIZE2 = 16;
  var removeHexPrefix2 = (hexString) => {
    if (/^0x/.test(hexString)) {
      return hexString.slice(2);
    }
    return hexString;
  };
  async function encryptKeystoreWallet2(privateKey, address, password) {
    const privateKeyBuffer = bufferFromString2(removeHexPrefix2(privateKey), "hex");
    const ownerAddress = Address.fromAddressOrString(address);
    const salt = randomBytes22(DEFAULT_KEY_SIZE2);
    const key = scrypt22({
      password: bufferFromString2(password),
      salt,
      dklen: DEFAULT_KEY_SIZE2,
      n: 2 ** DEFAULT_KDF_PARAMS_LOG_N2,
      r: DEFAULT_KDF_PARAMS_R2,
      p: DEFAULT_KDF_PARAMS_P2
    });
    const iv = randomBytes22(DEFAULT_IV_SIZE2);
    const ciphertext = await encryptJsonWalletData2(privateKeyBuffer, key, iv);
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
    const macHashUint8Array = keccak2562(data);
    const mac = stringFromBuffer2(macHashUint8Array, "hex");
    const keystore = {
      id: randomUUID2(),
      version: 3,
      address: removeHexPrefix2(ownerAddress.toHexString()),
      crypto: {
        cipher: "aes-128-ctr",
        mac,
        cipherparams: { iv: stringFromBuffer2(iv, "hex") },
        ciphertext: stringFromBuffer2(ciphertext, "hex"),
        kdf: "scrypt",
        kdfparams: {
          dklen: DEFAULT_KEY_SIZE2,
          n: 2 ** DEFAULT_KDF_PARAMS_LOG_N2,
          p: DEFAULT_KDF_PARAMS_P2,
          r: DEFAULT_KDF_PARAMS_R2,
          salt: stringFromBuffer2(salt, "hex")
        }
      }
    };
    return JSON.stringify(keystore);
  }
  async function decryptKeystoreWallet2(jsonWallet, password) {
    const keystoreWallet = JSON.parse(jsonWallet);
    const {
      crypto: {
        mac,
        ciphertext,
        cipherparams: { iv },
        kdfparams: { dklen, n, r, p, salt }
      }
    } = keystoreWallet;
    const ciphertextBuffer = bufferFromString2(ciphertext, "hex");
    const ivBuffer = bufferFromString2(iv, "hex");
    const saltBuffer = bufferFromString2(salt, "hex");
    const passwordBuffer = bufferFromString2(password);
    const key = scrypt22({
      password: passwordBuffer,
      salt: saltBuffer,
      n,
      p,
      r,
      dklen
    });
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
    const macHashUint8Array = keccak2562(data);
    const macHash = stringFromBuffer2(macHashUint8Array, "hex");
    if (mac !== macHash) {
      throw new FuelError(
        ErrorCode.INVALID_PASSWORD,
        "Failed to decrypt the keystore wallet, the provided password is incorrect."
      );
    }
    const buffer = await decryptJsonWalletData2(ciphertextBuffer, key, ivBuffer);
    const privateKey = hexlify(buffer);
    return privateKey;
  }
  var BaseWalletUnlocked2 = class extends Account2 {
    /**
     * A function that returns the wallet's signer.
     */
    signer;
    /**
     * Creates a new BaseWalletUnlocked instance.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance (optional).
     */
    constructor(privateKey, provider) {
      const signer = new Signer2(privateKey);
      super(signer.address, provider);
      this.signer = () => signer;
    }
    /**
     * Gets the private key of the wallet.
     *
     * @returns The private key of the wallet.
     */
    get privateKey() {
      return this.signer().privateKey;
    }
    /**
     * Gets the public key of the wallet.
     *
     * @returns
     */
    get publicKey() {
      return this.signer().publicKey;
    }
    /**
     * Signs a message with the wallet's private key.
     *
     * @param message - The message to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signMessage(message) {
      const signedMessage = await this.signer().sign(hashMessage(message));
      return hexlify(signedMessage);
    }
    /**
     * Signs a transaction with the wallet's private key.
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      const chainId = await this.provider.getChainId();
      const hashedTransaction = transactionRequest.getTransactionId(chainId);
      const signature = await this.signer().sign(hashedTransaction);
      return hexlify(signature);
    }
    /**
     * Populates a transaction with the witnesses signature.
     *
     * @param transactionRequestLike - The transaction request to populate.
     * @returns The populated transaction request.
     */
    async populateTransactionWitnessesSignature(transactionRequestLike) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      const signedTransaction = await this.signTransaction(transactionRequest);
      transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
      return transactionRequest;
    }
    /**
     * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequestLike - The transaction request to send.
     * @param estimateTxDependencies - Whether to estimate the transaction dependencies.
     * @returns A promise that resolves to the TransactionResponse object.
     */
    async sendTransaction(transactionRequestLike, { estimateTxDependencies = false, enableAssetBurn } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      validateTransactionForAssetBurn2(
        await this.provider.getBaseAssetId(),
        transactionRequest,
        enableAssetBurn
      );
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.sendTransaction(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        { estimateTxDependencies: false, enableAssetBurn }
      );
    }
    /**
     * Populates the witness signature for a transaction and sends a call to the network using `provider.dryRun`.
     *
     * @param transactionRequestLike - The transaction request to simulate.
     * @returns A promise that resolves to the CallResult object.
     */
    async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
      const transactionRequest = transactionRequestify2(transactionRequestLike);
      if (estimateTxDependencies) {
        await this.provider.estimateTxDependencies(transactionRequest);
      }
      return this.provider.dryRun(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        {
          utxoValidation: true,
          estimateTxDependencies: false
        }
      );
    }
    /**
     * Encrypts an unlocked wallet with a password.
     *
     * @param password - the password to encrypt the wallet with.
     * @returns - the encrypted wallet.
     */
    async encrypt(password) {
      return encryptKeystoreWallet2(this.privateKey, this.address, password);
    }
  };
  __publicField10(BaseWalletUnlocked2, "defaultPath", "m/44'/1179993420'/0'/0/0");
  var english2 = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  function getLowerMask2(bits2) {
    return (1 << bits2) - 1;
  }
  function getUpperMask2(bits2) {
    return (1 << bits2) - 1 << 8 - bits2;
  }
  function getWords2(mnemonic) {
    if (!Array.isArray(mnemonic)) {
      return mnemonic.split(/\s+/);
    }
    return mnemonic;
  }
  function getPhrase2(mnemonic) {
    if (Array.isArray(mnemonic)) {
      return mnemonic.join(" ");
    }
    return mnemonic;
  }
  function entropyToMnemonicIndices2(entropy) {
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i += 1) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        indices.push(entropy[i] & getLowerMask2(8 - remainingBits));
        remainingBits += 3;
      }
    }
    const checksumBits = entropy.length / 4;
    const checksum = arrayify(sha2562(entropy))[0] & getUpperMask2(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return indices;
  }
  function mnemonicWordsToEntropy2(words, wordlist) {
    const size = Math.ceil(11 * words.length / 8);
    const entropy = arrayify(new Uint8Array(size));
    let offset = 0;
    for (let i = 0; i < words.length; i += 1) {
      const index = wordlist.indexOf(words[i].normalize("NFKD"));
      if (index === -1) {
        throw new FuelError(
          ErrorCode.INVALID_MNEMONIC,
          `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
        );
      }
      for (let bit = 0; bit < 11; bit += 1) {
        if (index & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset += 1;
      }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask2(checksumBits);
    const checksum = arrayify(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
      throw new FuelError(
        ErrorCode.INVALID_CHECKSUM,
        "Checksum validation failed for the provided mnemonic."
      );
    }
    return entropy.slice(0, entropyBits / 8);
  }
  var MasterSecret2 = toUtf8Bytes("Bitcoin seed");
  var MainnetPRV3 = "0x0488ade4";
  var TestnetPRV3 = "0x04358394";
  var MNEMONIC_SIZES2 = [12, 15, 18, 21, 24];
  function assertWordList2(wordlist) {
    if (wordlist.length !== 2048) {
      throw new FuelError(
        ErrorCode.INVALID_WORD_LIST,
        `Expected word list length of 2048, but got ${wordlist.length}.`
      );
    }
  }
  function assertEntropy2(entropy) {
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
      throw new FuelError(
        ErrorCode.INVALID_ENTROPY,
        `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
      );
    }
  }
  function assertMnemonic2(words) {
    if (!MNEMONIC_SIZES2.includes(words.length)) {
      const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES2.join(
        ", "
      )}] words, but got ${words.length}.`;
      throw new FuelError(ErrorCode.INVALID_MNEMONIC, errorMsg);
    }
  }
  var Mnemonic2 = class {
    wordlist;
    /**
     *
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic instance
     */
    constructor(wordlist = english2) {
      this.wordlist = wordlist;
      assertWordList2(this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns Entropy hash
     */
    mnemonicToEntropy(phrase) {
      return Mnemonic2.mnemonicToEntropy(phrase, this.wordlist);
    }
    /**
     *
     * @param entropy - Entropy source to the mnemonic phrase.
     * @returns Mnemonic phrase
     */
    entropyToMnemonic(entropy) {
      return Mnemonic2.entropyToMnemonic(entropy, this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic phrase
     */
    static mnemonicToEntropy(phrase, wordlist = english2) {
      const words = getWords2(phrase);
      assertMnemonic2(words);
      return hexlify(mnemonicWordsToEntropy2(words, wordlist));
    }
    /**
     * @param entropy - Entropy source to the mnemonic phrase.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static entropyToMnemonic(entropy, wordlist = english2) {
      const entropyBytes = arrayify(entropy);
      assertWordList2(wordlist);
      assertEntropy2(entropyBytes);
      return entropyToMnemonicIndices2(entropyBytes).map((i) => wordlist[i]).join(" ");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToSeed(phrase, passphrase = "") {
      assertMnemonic2(getWords2(phrase));
      const phraseBytes = toUtf8Bytes(getPhrase2(phrase));
      const salt = toUtf8Bytes(`mnemonic${passphrase}`);
      return pbkdf222(phraseBytes, salt, 2048, 64, "sha512");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToMasterKeys(phrase, passphrase = "") {
      const seed = Mnemonic2.mnemonicToSeed(phrase, passphrase);
      return Mnemonic2.masterKeysFromSeed(seed);
    }
    /**
     * Validates if given mnemonic is  valid
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns true if phrase is a valid mnemonic
     */
    static isMnemonicValid(phrase) {
      const words = getWords2(phrase);
      let i = 0;
      try {
        assertMnemonic2(words);
      } catch {
        return false;
      }
      while (i < words.length) {
        if (Mnemonic2.binarySearch(words[i]) === false) {
          return false;
        }
        i += 1;
      }
      return true;
    }
    static binarySearch(target) {
      const words = english2;
      let left = 0;
      let right = words.length - 1;
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (words[mid] === target) {
          return true;
        }
        if (target < words[mid]) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
      return false;
    }
    /**
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static masterKeysFromSeed(seed) {
      const seedArray = arrayify(seed);
      if (seedArray.length < 16 || seedArray.length > 64) {
        throw new FuelError(
          ErrorCode.INVALID_SEED,
          `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
        );
      }
      return arrayify(computeHmac2("sha512", MasterSecret2, seedArray));
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    static seedToExtendedKey(seed, testnet = false) {
      const masterKey = Mnemonic2.masterKeysFromSeed(seed);
      const prefix = arrayify(testnet ? TestnetPRV3 : MainnetPRV3);
      const depth = "0x00";
      const fingerprint = "0x00000000";
      const index = "0x00000000";
      const chainCode = masterKey.slice(32);
      const privateKey = masterKey.slice(0, 32);
      const extendedKey = concat([
        prefix,
        depth,
        fingerprint,
        index,
        chainCode,
        concat(["0x00", privateKey])
      ]);
      const checksum = dataSlice(sha2562(sha2562(extendedKey)), 0, 4);
      return encodeBase58(concat([extendedKey, checksum]));
    }
    /**
     *  Create a new mnemonic using a randomly generated number as entropy.
     *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
     *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
     *  If not provided, the default entropy length will be set to 256 bits.
     *  The return is a list of words that encodes the generated entropy.
     *
     *
     * @param size - Number of bytes used as an entropy
     * @param extraEntropy - Optional extra entropy to increase randomness
     * @returns A randomly generated mnemonic
     */
    static generate(size = 32, extraEntropy = "") {
      const entropy = extraEntropy ? sha2562(concat([randomBytes22(size), arrayify(extraEntropy)])) : randomBytes22(size);
      return Mnemonic2.entropyToMnemonic(entropy);
    }
  };
  var mnemonic_default2 = Mnemonic2;
  var HARDENED_INDEX2 = 2147483648;
  var MainnetPRV22 = hexlify("0x0488ade4");
  var MainnetPUB2 = hexlify("0x0488b21e");
  var TestnetPRV22 = hexlify("0x04358394");
  var TestnetPUB2 = hexlify("0x043587cf");
  function base58check2(data) {
    return encodeBase58(concat([data, dataSlice(sha2562(sha2562(data)), 0, 4)]));
  }
  function getExtendedKeyPrefix2(isPublic = false, testnet = false) {
    if (isPublic) {
      return testnet ? TestnetPUB2 : MainnetPUB2;
    }
    return testnet ? TestnetPRV22 : MainnetPRV22;
  }
  function isPublicExtendedKey2(extendedKey) {
    return [MainnetPUB2, TestnetPUB2].includes(hexlify(extendedKey.slice(0, 4)));
  }
  function isValidExtendedKey2(extendedKey) {
    return [MainnetPRV22, TestnetPRV22, MainnetPUB2, TestnetPUB2].includes(
      hexlify(extendedKey.slice(0, 4))
    );
  }
  function parsePath2(path23, depth = 0) {
    const components = path23.split("/");
    if (components.length === 0 || components[0] === "m" && depth !== 0) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, `invalid path - ${path23}`);
    }
    if (components[0] === "m") {
      components.shift();
    }
    return components.map(
      (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX2 : parseInt(p, 10)
    );
  }
  var HDWallet2 = class {
    depth = 0;
    index = 0;
    fingerprint = hexlify("0x00000000");
    parentFingerprint = hexlify("0x00000000");
    privateKey;
    publicKey;
    chainCode;
    /**
     * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
     *
     * @param config - Wallet configurations
     */
    constructor(config) {
      if (config.privateKey) {
        const signer = new Signer2(config.privateKey);
        this.publicKey = hexlify(signer.compressedPublicKey);
        this.privateKey = hexlify(config.privateKey);
      } else {
        if (!config.publicKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Both public and private Key cannot be missing. At least one should be provided."
          );
        }
        this.publicKey = hexlify(config.publicKey);
      }
      this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
      this.fingerprint = dataSlice(ripemd16022(sha2562(this.publicKey)), 0, 4);
      this.depth = config.depth || this.depth;
      this.index = config.index || this.index;
      this.chainCode = config.chainCode;
    }
    get extendedKey() {
      return this.toExtendedKey();
    }
    /**
     * Derive the current HDWallet instance navigating only on the index.
     * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param index - Index of the child HDWallet.
     * @returns A new instance of HDWallet on the derived index
     */
    deriveIndex(index) {
      const privateKey = this.privateKey && arrayify(this.privateKey);
      const publicKey = arrayify(this.publicKey);
      const chainCode = arrayify(this.chainCode);
      const data = new Uint8Array(37);
      if (index & HARDENED_INDEX2) {
        if (!privateKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Cannot derive a hardened index without a private Key."
          );
        }
        data.set(privateKey, 1);
      } else {
        data.set(arrayify(this.publicKey));
      }
      data.set(toBytes(index, 4), 33);
      const bytes2 = arrayify(computeHmac2("sha512", chainCode, data));
      const IL = bytes2.slice(0, 32);
      const IR = bytes2.slice(32);
      if (privateKey) {
        const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
        const ki = bn(IL).add(privateKey).mod(N).toBytes(32);
        return new HDWallet2({
          privateKey: ki,
          chainCode: IR,
          index,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint
        });
      }
      const signer = new Signer2(hexlify(IL));
      const Ki = signer.addPoint(publicKey);
      return new HDWallet2({
        publicKey: Ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    /**
     * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
     * @returns A new instance of HDWallet on the derived path
     */
    derivePath(path23) {
      const paths = parsePath2(path23, this.depth);
      return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    toExtendedKey(isPublic = false, testnet = false) {
      if (this.depth >= 256) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          `Exceeded max depth of 255. Current depth: ${this.depth}.`
        );
      }
      const prefix = getExtendedKeyPrefix2(this.privateKey == null || isPublic, testnet);
      const depth = hexlify(Uint8Array.from([this.depth]));
      const parentFingerprint = this.parentFingerprint;
      const index = toHex(this.index, 4);
      const chainCode = this.chainCode;
      const key = this.privateKey != null && !isPublic ? concat(["0x00", this.privateKey]) : this.publicKey;
      const extendedKey = arrayify(concat([prefix, depth, parentFingerprint, index, chainCode, key]));
      return base58check2(extendedKey);
    }
    /**
     * Create HDWallet instance from seed
     *
     * @param seed - Seed
     * @returns A new instance of HDWallet
     */
    static fromSeed(seed) {
      const masterKey = mnemonic_default2.masterKeysFromSeed(seed);
      return new HDWallet2({
        chainCode: arrayify(masterKey.slice(32)),
        privateKey: arrayify(masterKey.slice(0, 32))
      });
    }
    static fromExtendedKey(extendedKey) {
      const decoded = hexlify(toBytes(decodeBase58(extendedKey)));
      const bytes2 = arrayify(decoded);
      const validChecksum = base58check2(bytes2.slice(0, 78)) === extendedKey;
      if (bytes2.length !== 82 || !isValidExtendedKey2(bytes2)) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
      }
      if (!validChecksum) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
      }
      const depth = bytes2[4];
      const parentFingerprint = hexlify(bytes2.slice(5, 9));
      const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
      const chainCode = hexlify(bytes2.slice(13, 45));
      const key = bytes2.slice(45, 78);
      if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
        );
      }
      if (isPublicExtendedKey2(bytes2)) {
        if (key[0] !== 3) {
          throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
        }
        return new HDWallet2({
          publicKey: key,
          chainCode,
          index,
          depth,
          parentFingerprint
        });
      }
      if (key[0] !== 0) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
      }
      return new HDWallet2({
        privateKey: key.slice(1),
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
  };
  var hdwallet_default2 = HDWallet2;
  var WalletLocked2 = class extends Account2 {
    /**
     * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
     *
     * @param privateKey - The private key used to unlock the wallet.
     * @returns An instance of WalletUnlocked.
     */
    unlock(privateKey) {
      return new WalletUnlocked2(privateKey, this._provider);
    }
  };
  var WalletUnlocked2 = class extends BaseWalletUnlocked2 {
    /**
     * Locks the wallet and returns an instance of WalletLocked.
     *
     * @returns An instance of WalletLocked.
     */
    lock() {
      this.signer = () => new Signer2("0x00");
      return new WalletLocked2(this.address, this._provider);
    }
    /**
     * Generate a new Wallet Unlocked with a random key pair.
     *
     * @param generateOptions - Options to customize the generation process (optional).
     * @returns An instance of WalletUnlocked.
     */
    static generate(generateOptions) {
      const privateKey = Signer2.generatePrivateKey(generateOptions?.entropy);
      return new WalletUnlocked2(privateKey, generateOptions?.provider);
    }
    /**
     * Create a Wallet Unlocked from a seed.
     *
     * @param seed - The seed phrase.
     * @param provider - A Provider instance (optional).
     * @param path - The derivation path (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromSeed(seed, path23, provider) {
      const hdWallet = hdwallet_default2.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path23 || WalletUnlocked2.defaultPath);
      return new WalletUnlocked2(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from a mnemonic phrase.
     *
     * @param mnemonic - The mnemonic phrase.
     * @param provider - A Provider instance (optional).
     * @param path - The derivation path (optional).
     * @param passphrase - The passphrase for the mnemonic (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromMnemonic(mnemonic, path23, passphrase, provider) {
      const seed = mnemonic_default2.mnemonicToSeed(mnemonic, passphrase);
      const hdWallet = hdwallet_default2.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path23 || WalletUnlocked2.defaultPath);
      return new WalletUnlocked2(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an extended key.
     *
     * @param extendedKey - The extended key.
     * @param provider - A Provider instance (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromExtendedKey(extendedKey, provider) {
      const hdWallet = hdwallet_default2.fromExtendedKey(extendedKey);
      return new WalletUnlocked2(hdWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an encrypted JSON.
     *
     * @param jsonWallet - The encrypted JSON keystore.
     * @param password - The password to decrypt the JSON.
     * @param provider - A Provider instance (optional).
     * @returns An unlocked wallet instance.
     */
    static async fromEncryptedJson(jsonWallet, password, provider) {
      const privateKey = await decryptKeystoreWallet2(jsonWallet, password);
      return new WalletUnlocked2(privateKey, provider);
    }
  };
  var Wallet2 = class {
    /**
     * Creates a locked wallet instance from an address and a provider.
     *
     * @param address - The address of the wallet.
     * @param provider - A Provider instance (optional).
     * @returns A locked wallet instance.
     */
    static fromAddress(address, provider) {
      return new WalletLocked2(address, provider);
    }
    /**
     * Creates an unlocked wallet instance from a private key and a provider.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance (optional).
     * @returns An unlocked wallet instance.
     */
    static fromPrivateKey(privateKey, provider) {
      return new WalletUnlocked2(privateKey, provider);
    }
  };
  __publicField10(Wallet2, "generate", WalletUnlocked2.generate);
  __publicField10(Wallet2, "fromSeed", WalletUnlocked2.fromSeed);
  __publicField10(Wallet2, "fromMnemonic", WalletUnlocked2.fromMnemonic);
  __publicField10(Wallet2, "fromExtendedKey", WalletUnlocked2.fromExtendedKey);
  __publicField10(Wallet2, "fromEncryptedJson", WalletUnlocked2.fromEncryptedJson);
  var defaultWalletConfigOptions = {
    count: 2,
    assets: [TestAssetId.A, TestAssetId.B],
    coinsPerAsset: 1,
    amountPerCoin: 1e10,
    messages: []
  };

  // ../errors/dist/test-utils.mjs
  var ErrorCode2 = /* @__PURE__ */ ((ErrorCode22) => {
    ErrorCode22["NO_ABIS_FOUND"] = "no-abis-found";
    ErrorCode22["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
    ErrorCode22["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
    ErrorCode22["INVALID_COMPONENT"] = "invalid-component";
    ErrorCode22["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
    ErrorCode22["TYPE_NOT_FOUND"] = "type-not-found";
    ErrorCode22["LOG_TYPE_NOT_FOUND"] = "log-type-not-found";
    ErrorCode22["TYPE_NOT_SUPPORTED"] = "type-not-supported";
    ErrorCode22["INVALID_DECODE_VALUE"] = "invalid-decode-value";
    ErrorCode22["JSON_ABI_ERROR"] = "json-abi-error";
    ErrorCode22["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
    ErrorCode22["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
    ErrorCode22["CODER_NOT_FOUND"] = "coder-not-found";
    ErrorCode22["INVALID_DATA"] = "invalid-data";
    ErrorCode22["FUNCTION_NOT_FOUND"] = "function-not-found";
    ErrorCode22["UNSUPPORTED_ENCODING_VERSION"] = "unsupported-encoding-version";
    ErrorCode22["TIMEOUT_EXCEEDED"] = "timeout-exceeded";
    ErrorCode22["CONFIG_FILE_NOT_FOUND"] = "config-file-not-found";
    ErrorCode22["CONFIG_FILE_ALREADY_EXISTS"] = "config-file-already-exists";
    ErrorCode22["WORKSPACE_NOT_DETECTED"] = "workspace-not-detected";
    ErrorCode22["INVALID_ADDRESS"] = "invalid-address";
    ErrorCode22["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
    ErrorCode22["INVALID_B256_ADDRESS"] = "invalid-b256-address";
    ErrorCode22["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
    ErrorCode22["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
    ErrorCode22["MISSING_PROVIDER"] = "missing-provider";
    ErrorCode22["INVALID_PROVIDER"] = "invalid-provider";
    ErrorCode22["CONNECTION_REFUSED"] = "connection-refused";
    ErrorCode22["INVALID_URL"] = "invalid-url";
    ErrorCode22["INVALID_PUBLIC_KEY"] = "invalid-public-key";
    ErrorCode22["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
    ErrorCode22["HD_WALLET_ERROR"] = "hd-wallet-error";
    ErrorCode22["MISSING_CONNECTOR"] = "missing-connector";
    ErrorCode22["PARSE_FAILED"] = "parse-failed";
    ErrorCode22["ENCODE_ERROR"] = "encode-error";
    ErrorCode22["DECODE_ERROR"] = "decode-error";
    ErrorCode22["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
    ErrorCode22["INVALID_TTL"] = "invalid-ttl";
    ErrorCode22["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
    ErrorCode22["NOT_IMPLEMENTED"] = "not-implemented";
    ErrorCode22["NOT_SUPPORTED"] = "not-supported";
    ErrorCode22["CONVERTING_FAILED"] = "converting-error";
    ErrorCode22["ELEMENT_NOT_FOUND"] = "element-not-found";
    ErrorCode22["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
    ErrorCode22["INVALID_REQUEST"] = "invalid-request";
    ErrorCode22["INVALID_TRANSFER_AMOUNT"] = "invalid-transfer-amount";
    ErrorCode22["NOT_ENOUGH_FUNDS"] = "not-enough-funds";
    ErrorCode22["INVALID_CREDENTIALS"] = "invalid-credentials";
    ErrorCode22["HASHER_LOCKED"] = "hasher-locked";
    ErrorCode22["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
    ErrorCode22["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
    ErrorCode22["MAX_FEE_TOO_LOW"] = "max-fee-too-low";
    ErrorCode22["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
    ErrorCode22["TRANSACTION_FAILED"] = "transaction-failed";
    ErrorCode22["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
    ErrorCode22["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
    ErrorCode22["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
    ErrorCode22["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
    ErrorCode22["UNSUPPORTED_TRANSACTION_TYPE"] = "unsupported-transaction-type";
    ErrorCode22["TRANSACTION_ERROR"] = "transaction-error";
    ErrorCode22["INVALID_POLICY_TYPE"] = "invalid-policy-type";
    ErrorCode22["DUPLICATED_POLICY"] = "duplicated-policy";
    ErrorCode22["TRANSACTION_SQUEEZED_OUT"] = "transaction-squeezed-out";
    ErrorCode22["CONTRACT_SIZE_EXCEEDS_LIMIT"] = "contract-size-exceeds-limit";
    ErrorCode22["INVALID_CHUNK_SIZE_MULTIPLIER"] = "invalid-chunk-size-multiplier";
    ErrorCode22["MAX_INPUTS_EXCEEDED"] = "max-inputs-exceeded";
    ErrorCode22["FUNDS_TOO_LOW"] = "funds-too-low";
    ErrorCode22["MAX_OUTPUTS_EXCEEDED"] = "max-outputs-exceeded";
    ErrorCode22["MAX_COINS_REACHED"] = "max-coins-reached";
    ErrorCode22["ASSET_BURN_DETECTED"] = "asset-burn-detected";
    ErrorCode22["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
    ErrorCode22["INVALID_WORD_LIST"] = "invalid-word-list";
    ErrorCode22["INVALID_MNEMONIC"] = "invalid-mnemonic";
    ErrorCode22["INVALID_ENTROPY"] = "invalid-entropy";
    ErrorCode22["INVALID_SEED"] = "invalid-seed";
    ErrorCode22["INVALID_CHECKSUM"] = "invalid-checksum";
    ErrorCode22["INVALID_PASSWORD"] = "invalid-password";
    ErrorCode22["ACCOUNT_REQUIRED"] = "account-required";
    ErrorCode22["UNLOCKED_WALLET_REQUIRED"] = "unlocked-wallet-required";
    ErrorCode22["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
    ErrorCode22["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
    ErrorCode22["SCRIPT_REVERTED"] = "script-reverted";
    ErrorCode22["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
    ErrorCode22["STREAM_PARSING_ERROR"] = "stream-parsing-error";
    ErrorCode22["NODE_LAUNCH_FAILED"] = "node-launch-failed";
    ErrorCode22["UNKNOWN"] = "unknown";
    return ErrorCode22;
  })(ErrorCode2 || {});
  var codes2 = Object.values(ErrorCode2);

  // ../utils/dist/test-utils.mjs
  var TAI64_LEAP_SECONDS2 = 37;
  var TAI64_UNIX_OFFSET2 = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS2);
  var BN_02 = bn(0);
  var BN_582 = bn(58);

  // src/cli/commands/dev/autoStartFuelCore.ts
  var autoStartFuelCore = async (config) => {
    let fuelCore;
    if (config.autoStartFuelCore) {
      log(`Starting node using: '${config.fuelCorePath}'`);
      const bindIp = "0.0.0.0";
      const accessIp = "127.0.0.1";
      const port = config.fuelCorePort ?? await (0, import_portfinder.getPortPromise)({ port: 4e3 });
      const { cleanup, url, snapshotDir } = await launchNode({
        args: [
          ["--snapshot", config.snapshotDir],
          ["--db-type", "in-memory"]
        ].flat(),
        ip: bindIp,
        port: port.toString(),
        loggingEnabled: loggingConfig.isLoggingEnabled,
        basePath: config.basePath,
        fuelCorePath: config.fuelCorePath,
        includeInitialState: true,
        killProcessOnExit: true
      });
      fuelCore = {
        bindIp,
        accessIp,
        port,
        providerUrl: url,
        snapshotDir,
        killChildProcess: cleanup
      };
      config.providerUrl = fuelCore.providerUrl;
      config.privateKey = defaultConsensusKey;
    }
    return fuelCore;
  };

  // src/cli/commands/build/buildSwayProgram.ts
  var import_child_process2 = __require2("child_process");

  // src/cli/commands/build/forcHandlers.ts
  var onForcExit = (onResultFn, onErrorFn) => (code) => {
    if (code) {
      onErrorFn(code);
    } else {
      onResultFn();
    }
  };
  var onForcError = (onError2) => (err2) => {
    error(err2);
    onError2(err2);
  };

  // src/cli/commands/build/buildSwayProgram.ts
  var buildSwayProgram = async (config, path6) => {
    debug("Building Sway program", path6);
    return new Promise((resolve10, reject) => {
      const args = ["build", "-p", path6].concat(config.forcBuildFlags);
      const forc = (0, import_child_process2.spawn)(config.forcPath, args, { stdio: "pipe" });
      if (loggingConfig.isLoggingEnabled) {
        forc.stderr?.on("data", (chunk) => console.log(chunk.toString()));
      }
      if (loggingConfig.isDebugEnabled) {
        forc.stdout?.on("data", (chunk) => {
          console.log(chunk.toString());
        });
      }
      const onExit = onForcExit(resolve10, reject);
      const onError2 = onForcError(reject);
      forc.on("exit", onExit);
      forc.on("error", onError2);
    });
  };

  // src/cli/commands/build/buildSwayPrograms.ts
  async function buildSwayPrograms(config) {
    log(`Building Sway programs using: '${config.forcPath}'`);
    const paths = config.workspace ? [config.workspace] : [config.contracts, config.predicates, config.scripts].flat();
    await Promise.all(paths.map((path6) => buildSwayProgram(config, path6)));
  }

  // src/cli/commands/build/index.ts
  async function build(config, program2) {
    log("Building..");
    await buildSwayPrograms(config);
    await generateTypes(config);
    config.onBuild?.(config);
    const options = program2?.opts();
    if (options?.deploy) {
      const fuelCore = await autoStartFuelCore(config);
      await deploy(config);
      fuelCore?.killChildProcess();
    }
  }

  // src/cli/commands/dev/index.ts
  var import_chokidar = __toESM(require_chokidar());

  // ../../node_modules/.pnpm/bundle-require@5.0.0_esbuild@0.24.0/node_modules/bundle-require/dist/index.js
  var import_fs29 = __toESM(__require2("fs"), 1);
  var import_path23 = __toESM(__require2("path"), 1);
  var import_url2 = __require2("url");
  var import_esbuild = __toESM(require_main(), 1);

  // ../../node_modules/.pnpm/load-tsconfig@0.2.5/node_modules/load-tsconfig/dist/index.js
  var import_path22 = __toESM(__require2("path"), 1);
  var import_fs28 = __toESM(__require2("fs"), 1);
  var import_module2 = __require2("module");
  var import_meta = {};
  var singleComment = Symbol("singleComment");
  var multiComment = Symbol("multiComment");
  var stripWithoutWhitespace = () => "";
  var stripWithWhitespace = (string2, start, end) => string2.slice(start, end).replace(/\S/g, " ");
  var isEscaped = (jsonString, quotePosition) => {
    let index = quotePosition - 1;
    let backslashCount = 0;
    while (jsonString[index] === "\\") {
      index -= 1;
      backslashCount += 1;
    }
    return Boolean(backslashCount % 2);
  };
  function stripJsonComments(jsonString, { whitespace = true, trailingCommas = false } = {}) {
    if (typeof jsonString !== "string") {
      throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
    }
    const strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;
    let isInsideString = false;
    let isInsideComment = false;
    let offset = 0;
    let buffer = "";
    let result = "";
    let commaIndex = -1;
    for (let index = 0; index < jsonString.length; index++) {
      const currentCharacter = jsonString[index];
      const nextCharacter = jsonString[index + 1];
      if (!isInsideComment && currentCharacter === '"') {
        const escaped = isEscaped(jsonString, index);
        if (!escaped) {
          isInsideString = !isInsideString;
        }
      }
      if (isInsideString) {
        continue;
      }
      if (!isInsideComment && currentCharacter + nextCharacter === "//") {
        buffer += jsonString.slice(offset, index);
        offset = index;
        isInsideComment = singleComment;
        index++;
      } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
        index++;
        isInsideComment = false;
        buffer += strip(jsonString, offset, index);
        offset = index;
        continue;
      } else if (isInsideComment === singleComment && currentCharacter === "\n") {
        isInsideComment = false;
        buffer += strip(jsonString, offset, index);
        offset = index;
      } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
        buffer += jsonString.slice(offset, index);
        offset = index;
        isInsideComment = multiComment;
        index++;
        continue;
      } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
        index++;
        isInsideComment = false;
        buffer += strip(jsonString, offset, index + 1);
        offset = index + 1;
        continue;
      } else if (trailingCommas && !isInsideComment) {
        if (commaIndex !== -1) {
          if (currentCharacter === "}" || currentCharacter === "]") {
            buffer += jsonString.slice(offset, index);
            result += strip(buffer, 0, 1) + buffer.slice(1);
            buffer = "";
            offset = index;
            commaIndex = -1;
          } else if (currentCharacter !== " " && currentCharacter !== "	" && currentCharacter !== "\r" && currentCharacter !== "\n") {
            buffer += jsonString.slice(offset, index);
            offset = index;
            commaIndex = -1;
          }
        } else if (currentCharacter === ",") {
          result += buffer + jsonString.slice(offset, index);
          buffer = "";
          offset = index;
          commaIndex = index;
        }
      }
    }
    return result + buffer + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
  }
  function jsoncParse(data) {
    try {
      return new Function("return " + stripJsonComments(data).trim())();
    } catch (_) {
      return {};
    }
  }
  var req = true ? (0, import_module2.createRequire)(import_meta.url) : __require;
  var findUp = (name, startDir, stopDir = import_path22.default.parse(startDir).root) => {
    let dir = startDir;
    while (dir !== stopDir) {
      const file = import_path22.default.join(dir, name);
      if (import_fs28.default.existsSync(file))
        return file;
      if (!file.endsWith(".json")) {
        const fileWithExt = file + ".json";
        if (import_fs28.default.existsSync(fileWithExt))
          return fileWithExt;
      }
      dir = import_path22.default.dirname(dir);
    }
    return null;
  };
  var resolveTsConfigFromFile = (cwd, filename) => {
    if (import_path22.default.isAbsolute(filename))
      return import_fs28.default.existsSync(filename) ? filename : null;
    return findUp(filename, cwd);
  };
  var resolveTsConfigFromExtends = (cwd, name) => {
    if (import_path22.default.isAbsolute(name))
      return import_fs28.default.existsSync(name) ? name : null;
    if (name.startsWith("."))
      return findUp(name, cwd);
    const id = req.resolve(name, { paths: [cwd] });
    return id;
  };
  var loadTsConfigInternal = (dir = process.cwd(), name = "tsconfig.json", isExtends = false) => {
    var _a2, _b2;
    dir = import_path22.default.resolve(dir);
    const id = isExtends ? resolveTsConfigFromExtends(dir, name) : resolveTsConfigFromFile(dir, name);
    if (!id)
      return null;
    const data = jsoncParse(import_fs28.default.readFileSync(id, "utf-8"));
    const configDir = import_path22.default.dirname(id);
    if ((_a2 = data.compilerOptions) == null ? void 0 : _a2.baseUrl) {
      data.compilerOptions.baseUrl = import_path22.default.join(
        configDir,
        data.compilerOptions.baseUrl
      );
    }
    let extendsFiles = [];
    if (data.extends) {
      const extendsList = Array.isArray(data.extends) ? data.extends : [data.extends];
      const extendsData = {};
      for (const name2 of extendsList) {
        const parentConfig = loadTsConfigInternal(configDir, name2, true);
        if (parentConfig) {
          Object.assign(extendsData, {
            ...parentConfig == null ? void 0 : parentConfig.data,
            compilerOptions: {
              ...extendsData.compilerOptions,
              ...(_b2 = parentConfig == null ? void 0 : parentConfig.data) == null ? void 0 : _b2.compilerOptions
            }
          });
          extendsFiles.push(...parentConfig.files);
        }
      }
      Object.assign(data, {
        ...extendsData,
        ...data,
        compilerOptions: {
          ...extendsData.compilerOptions,
          ...data.compilerOptions
        }
      });
    }
    delete data.extends;
    return { path: id, data, files: [...extendsFiles, id] };
  };
  var loadTsConfig = (dir, name) => loadTsConfigInternal(dir, name);

  // ../../node_modules/.pnpm/bundle-require@5.0.0_esbuild@0.24.0/node_modules/bundle-require/dist/index.js
  var import_fs30 = __toESM(__require2("fs"), 1);
  var import_path24 = __toESM(__require2("path"), 1);
  var import_module3 = __require2("module");
  var import_meta2 = {};
  var getPkgType = () => {
    try {
      const pkg = JSON.parse(
        import_fs30.default.readFileSync(import_path24.default.resolve("package.json"), "utf-8")
      );
      return pkg.type;
    } catch (error3) {
    }
  };
  function guessFormat(inputFile) {
    if (!usingDynamicImport)
      return "cjs";
    const ext2 = import_path24.default.extname(inputFile);
    const type3 = getPkgType();
    if (ext2 === ".js") {
      return type3 === "module" ? "esm" : "cjs";
    } else if (ext2 === ".ts" || ext2 === ".mts") {
      return "esm";
    } else if (ext2 === ".mjs") {
      return "esm";
    }
    return "cjs";
  }
  var usingDynamicImport = typeof jest === "undefined";
  var dynamicImport = async (id, { format }) => {
    const fn = format === "esm" ? (file) => import(file) : true ? (0, import_module3.createRequire)(import_meta2.url) : __require;
    return fn(id);
  };
  var getRandomId = () => {
    return Math.random().toString(36).substring(2, 15);
  };
  var DIRNAME_VAR_NAME = "__injected_dirname__";
  var FILENAME_VAR_NAME = "__injected_filename__";
  var IMPORT_META_URL_VAR_NAME = "__injected_import_meta_url__";
  var JS_EXT_RE = /\.([mc]?[tj]s|[tj]sx)$/;
  var PATH_NODE_MODULES_RE = /[\/\\]node_modules[\/\\]/;
  function inferLoader(ext2) {
    if (ext2 === ".mjs" || ext2 === ".cjs")
      return "js";
    if (ext2 === ".mts" || ext2 === ".cts")
      return "ts";
    return ext2.slice(1);
  }
  var defaultGetOutputFile = (filepath, format) => filepath.replace(
    JS_EXT_RE,
    `.bundled_${getRandomId()}.${format === "esm" ? "mjs" : "cjs"}`
  );
  var tsconfigPathsToRegExp = (paths) => {
    return Object.keys(paths || {}).map((key) => {
      return new RegExp(`^${key.replace(/\*/, ".*")}$`);
    });
  };
  var match2 = (id, patterns) => {
    if (!patterns)
      return false;
    return patterns.some((p) => {
      if (p instanceof RegExp) {
        return p.test(id);
      }
      return id === p || id.startsWith(p + "/");
    });
  };
  var externalPlugin = ({
    external,
    notExternal,
    externalNodeModules = true
  } = {}) => {
    return {
      name: "bundle-require:external",
      setup(ctx) {
        ctx.onResolve({ filter: /.*/ }, async (args) => {
          if (match2(args.path, external)) {
            return {
              external: true
            };
          }
          if (match2(args.path, notExternal)) {
            return;
          }
          if (externalNodeModules && args.path.match(PATH_NODE_MODULES_RE)) {
            const resolved = args.path[0] === "." ? import_path23.default.resolve(args.resolveDir, args.path) : args.path;
            return {
              path: (0, import_url2.pathToFileURL)(resolved).toString(),
              external: true
            };
          }
          if (args.path[0] === "." || import_path23.default.isAbsolute(args.path)) {
            return;
          }
          return {
            external: true
          };
        });
      }
    };
  };
  var injectFileScopePlugin = () => {
    return {
      name: "bundle-require:inject-file-scope",
      setup(ctx) {
        ctx.initialOptions.define = {
          ...ctx.initialOptions.define,
          __dirname: DIRNAME_VAR_NAME,
          __filename: FILENAME_VAR_NAME,
          "import.meta.url": IMPORT_META_URL_VAR_NAME
        };
        ctx.onLoad({ filter: JS_EXT_RE }, async (args) => {
          const contents = await import_fs29.default.promises.readFile(args.path, "utf-8");
          const injectLines = [
            `const ${FILENAME_VAR_NAME} = ${JSON.stringify(args.path)};`,
            `const ${DIRNAME_VAR_NAME} = ${JSON.stringify(
              import_path23.default.dirname(args.path)
            )};`,
            `const ${IMPORT_META_URL_VAR_NAME} = ${JSON.stringify(
              (0, import_url2.pathToFileURL)(args.path).href
            )};`
          ];
          return {
            contents: injectLines.join("") + contents,
            loader: inferLoader(import_path23.default.extname(args.path))
          };
        });
      }
    };
  };
  function bundleRequire(options) {
    return new Promise((resolve10, reject) => {
      var _a2, _b2, _c, _d, _e;
      if (!JS_EXT_RE.test(options.filepath)) {
        throw new Error(`${options.filepath} is not a valid JS file`);
      }
      const preserveTemporaryFile = (_a2 = options.preserveTemporaryFile) != null ? _a2 : !!process.env.BUNDLE_REQUIRE_PRESERVE;
      const cwd = options.cwd || process.cwd();
      const format = (_b2 = options.format) != null ? _b2 : guessFormat(options.filepath);
      const tsconfig = options.tsconfig === false ? void 0 : typeof options.tsconfig === "string" || !options.tsconfig ? loadTsConfig(cwd, options.tsconfig) : { data: options.tsconfig, path: void 0 };
      const resolvePaths = tsconfigPathsToRegExp(
        ((_c = tsconfig == null ? void 0 : tsconfig.data.compilerOptions) == null ? void 0 : _c.paths) || {}
      );
      const extractResult = async (result) => {
        if (!result.outputFiles) {
          throw new Error(`[bundle-require] no output files`);
        }
        const { text } = result.outputFiles[0];
        const getOutputFile = options.getOutputFile || defaultGetOutputFile;
        const outfile = getOutputFile(options.filepath, format);
        await import_fs29.default.promises.writeFile(outfile, text, "utf8");
        let mod2;
        const req2 = options.require || dynamicImport;
        try {
          mod2 = await req2(
            format === "esm" ? (0, import_url2.pathToFileURL)(outfile).href : outfile,
            { format }
          );
        } finally {
          if (!preserveTemporaryFile) {
            await import_fs29.default.promises.unlink(outfile);
          }
        }
        return {
          mod: mod2,
          dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
        };
      };
      const { watch: watchMode, ...restEsbuildOptions } = options.esbuildOptions || {};
      const esbuildOptions = {
        ...restEsbuildOptions,
        entryPoints: [options.filepath],
        absWorkingDir: cwd,
        outfile: "out.js",
        format,
        platform: "node",
        sourcemap: "inline",
        bundle: true,
        metafile: true,
        write: false,
        ...(tsconfig == null ? void 0 : tsconfig.path) ? { tsconfig: tsconfig.path } : { tsconfigRaw: (tsconfig == null ? void 0 : tsconfig.data) || {} },
        plugins: [
          ...((_d = options.esbuildOptions) == null ? void 0 : _d.plugins) || [],
          externalPlugin({
            external: options.external,
            notExternal: [
              ...options.notExternal || [],
              ...resolvePaths
            ],
            externalNodeModules: (_e = options.externalNodeModules) != null ? _e : !options.filepath.match(PATH_NODE_MODULES_RE)
          }),
          injectFileScopePlugin()
        ]
      };
      const run2 = async () => {
        if (!(watchMode || options.onRebuild)) {
          const result = await (0, import_esbuild.build)(esbuildOptions);
          resolve10(await extractResult(result));
        } else {
          const rebuildCallback = typeof watchMode === "object" && typeof watchMode.onRebuild === "function" ? watchMode.onRebuild : async (error3, result) => {
            var _a22, _b22;
            if (error3) {
              (_a22 = options.onRebuild) == null ? void 0 : _a22.call(options, { err: error3 });
            }
            if (result) {
              (_b22 = options.onRebuild) == null ? void 0 : _b22.call(options, await extractResult(result));
            }
          };
          const onRebuildPlugin = () => {
            return {
              name: "bundle-require:on-rebuild",
              setup(ctx2) {
                let count = 0;
                ctx2.onEnd(async (result) => {
                  if (count++ === 0) {
                    if (result.errors.length === 0)
                      resolve10(await extractResult(result));
                  } else {
                    if (result.errors.length > 0) {
                      return rebuildCallback(
                        { errors: result.errors, warnings: result.warnings },
                        null
                      );
                    }
                    if (result) {
                      rebuildCallback(null, result);
                    }
                  }
                });
              }
            };
          };
          esbuildOptions.plugins.push(onRebuildPlugin());
          const ctx = await (0, import_esbuild.context)(esbuildOptions);
          await ctx.watch();
        }
      };
      run2().catch(reject);
    });
  }

  // src/cli/config/loadConfig.ts
  var import_joycon = __toESM(require_lib4());
  var import_path25 = __require2("path");

  // ../utils/dist/cli-utils.mjs
  var tryFindBinaries = (paths = {}) => {
    const { error: forcError, systemForcPath, systemForcVersion } = getSystemForc(paths.forcPath);
    const {
      error: fuelCoreError,
      systemFuelCorePath,
      systemFuelCoreVersion
    } = getSystemFuelCore(paths.fuelCorePath);
    if (forcError || fuelCoreError) {
      const errors2 = [
        "Unable to find the following binaries on the filesystem:",
        forcError ? ` -> 'forc' at path '${systemForcPath}'` : void 0,
        fuelCoreError ? ` -> 'fuel-core' at path '${systemFuelCorePath}'` : void 0,
        `
Visit https://docs.fuel.network/guides/installation/ for an installation guide.`
      ];
      throw new FuelError(
        FuelError.CODES.BIN_FILE_NOT_FOUND,
        `${errors2.filter(Boolean).join("\n")}`,
        { ...paths }
      );
    }
    const { systemForcIsLt, systemFuelCoreIsLt } = compareSystemVersions({
      systemForcVersion: eitherOr(systemForcVersion, "0"),
      systemFuelCoreVersion: eitherOr(systemFuelCoreVersion, "0")
    });
    if (systemForcIsLt || systemFuelCoreIsLt) {
      const { FORC: compatibleForcVersion, FUEL_CORE: compatibleFuelCoreVersion } = getBuiltinVersions2();
      const errors2 = [
        "The following binaries on the filesystem are outdated:",
        systemForcIsLt ? ` -> '${systemForcPath}' is currently 'v${systemForcVersion}', but the current 'fuels' version requires 'v${compatibleForcVersion}'.` : void 0,
        systemFuelCoreIsLt ? ` -> '${systemFuelCorePath}' is currently 'v${systemFuelCoreVersion}', but the current 'fuels' version requires 'v${compatibleFuelCoreVersion}'.` : void 0
      ];
      console.warn(`${errors2.filter(Boolean).join("\n")}`);
    }
    return {
      forcPath: systemForcPath,
      fuelCorePath: systemFuelCorePath
    };
  };

  // ../../node_modules/.pnpm/yup@1.4.0/node_modules/yup/index.esm.js
  var import_property_expr = __toESM(require_property_expr());
  var import_tiny_case = __toESM(require_tiny_case());
  var import_toposort = __toESM(require_toposort());
  var toString2 = Object.prototype.toString;
  var errorToString = Error.prototype.toString;
  var regExpToString = RegExp.prototype.toString;
  var symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  function printNumber(val) {
    if (val != +val)
      return "NaN";
    const isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? "-0" : "" + val;
  }
  function printSimpleValue(val, quoteStrings = false) {
    if (val == null || val === true || val === false)
      return "" + val;
    const typeOf = typeof val;
    if (typeOf === "number")
      return printNumber(val);
    if (typeOf === "string")
      return quoteStrings ? `"${val}"` : val;
    if (typeOf === "function")
      return "[Function " + (val.name || "anonymous") + "]";
    if (typeOf === "symbol")
      return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    const tag = toString2.call(val).slice(8, -1);
    if (tag === "Date")
      return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
    if (tag === "Error" || val instanceof Error)
      return "[" + errorToString.call(val) + "]";
    if (tag === "RegExp")
      return regExpToString.call(val);
    return null;
  }
  function printValue(value, quoteStrings) {
    let result = printSimpleValue(value, quoteStrings);
    if (result !== null)
      return result;
    return JSON.stringify(value, function(key, value2) {
      let result2 = printSimpleValue(this[key], quoteStrings);
      if (result2 !== null)
        return result2;
      return value2;
    }, 2);
  }
  function toArray(value) {
    return value == null ? [] : [].concat(value);
  }
  var _Symbol$toStringTag;
  var _Symbol$hasInstance;
  var _Symbol$toStringTag2;
  var strReg = /\$\{\s*(\w+)\s*\}/g;
  _Symbol$toStringTag = Symbol.toStringTag;
  var ValidationErrorNoStack = class {
    constructor(errorOrErrors, value, field, type3) {
      this.name = void 0;
      this.message = void 0;
      this.value = void 0;
      this.path = void 0;
      this.type = void 0;
      this.params = void 0;
      this.errors = void 0;
      this.inner = void 0;
      this[_Symbol$toStringTag] = "Error";
      this.name = "ValidationError";
      this.value = value;
      this.path = field;
      this.type = type3;
      this.errors = [];
      this.inner = [];
      toArray(errorOrErrors).forEach((err2) => {
        if (ValidationError.isError(err2)) {
          this.errors.push(...err2.errors);
          const innerErrors = err2.inner.length ? err2.inner : [err2];
          this.inner.push(...innerErrors);
        } else {
          this.errors.push(err2);
        }
      });
      this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
    }
  };
  _Symbol$hasInstance = Symbol.hasInstance;
  _Symbol$toStringTag2 = Symbol.toStringTag;
  var ValidationError = class extends Error {
    static formatError(message, params) {
      const path6 = params.label || params.path || "this";
      if (path6 !== params.path)
        params = Object.assign({}, params, {
          path: path6
        });
      if (typeof message === "string")
        return message.replace(strReg, (_, key) => printValue(params[key]));
      if (typeof message === "function")
        return message(params);
      return message;
    }
    static isError(err2) {
      return err2 && err2.name === "ValidationError";
    }
    constructor(errorOrErrors, value, field, type3, disableStack) {
      const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type3);
      if (disableStack) {
        return errorNoStack;
      }
      super();
      this.value = void 0;
      this.path = void 0;
      this.type = void 0;
      this.params = void 0;
      this.errors = [];
      this.inner = [];
      this[_Symbol$toStringTag2] = "Error";
      this.name = errorNoStack.name;
      this.message = errorNoStack.message;
      this.type = errorNoStack.type;
      this.value = errorNoStack.value;
      this.path = errorNoStack.path;
      this.errors = errorNoStack.errors;
      this.inner = errorNoStack.inner;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ValidationError);
      }
    }
    static [_Symbol$hasInstance](inst) {
      return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
    }
  };
  var mixed = {
    default: "${path} is invalid",
    required: "${path} is a required field",
    defined: "${path} must be defined",
    notNull: "${path} cannot be null",
    oneOf: "${path} must be one of the following values: ${values}",
    notOneOf: "${path} must not be one of the following values: ${values}",
    notType: ({
      path: path6,
      type: type3,
      value,
      originalValue
    }) => {
      const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
      return type3 !== "mixed" ? `${path6} must be a \`${type3}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path6} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
    }
  };
  var string = {
    length: "${path} must be exactly ${length} characters",
    min: "${path} must be at least ${min} characters",
    max: "${path} must be at most ${max} characters",
    matches: '${path} must match the following: "${regex}"',
    email: "${path} must be a valid email",
    url: "${path} must be a valid URL",
    uuid: "${path} must be a valid UUID",
    datetime: "${path} must be a valid ISO date-time",
    datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
    datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
    trim: "${path} must be a trimmed string",
    lowercase: "${path} must be a lowercase string",
    uppercase: "${path} must be a upper case string"
  };
  var number2 = {
    min: "${path} must be greater than or equal to ${min}",
    max: "${path} must be less than or equal to ${max}",
    lessThan: "${path} must be less than ${less}",
    moreThan: "${path} must be greater than ${more}",
    positive: "${path} must be a positive number",
    negative: "${path} must be a negative number",
    integer: "${path} must be an integer"
  };
  var date = {
    min: "${path} field must be later than ${min}",
    max: "${path} field must be at earlier than ${max}"
  };
  var boolean = {
    isValue: "${path} field must be ${value}"
  };
  var object = {
    noUnknown: "${path} field has unspecified keys: ${unknown}"
  };
  var array = {
    min: "${path} field must have at least ${min} items",
    max: "${path} field must have less than or equal to ${max} items",
    length: "${path} must have ${length} items"
  };
  var tuple = {
    notType: (params) => {
      const {
        path: path6,
        value,
        spec
      } = params;
      const typeLen = spec.types.length;
      if (Array.isArray(value)) {
        if (value.length < typeLen)
          return `${path6} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
        if (value.length > typeLen)
          return `${path6} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
      }
      return ValidationError.formatError(mixed.notType, params);
    }
  };
  var locale = Object.assign(/* @__PURE__ */ Object.create(null), {
    mixed,
    string,
    number: number2,
    date,
    object,
    array,
    boolean,
    tuple
  });
  var isSchema = (obj) => obj && obj.__isYupSchema__;
  var Condition = class {
    static fromOptions(refs, config) {
      if (!config.then && !config.otherwise)
        throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
      let {
        is,
        then,
        otherwise
      } = config;
      let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
      return new Condition(refs, (values, schema2) => {
        var _branch;
        let branch = check(...values) ? then : otherwise;
        return (_branch = branch == null ? void 0 : branch(schema2)) != null ? _branch : schema2;
      });
    }
    constructor(refs, builder) {
      this.fn = void 0;
      this.refs = refs;
      this.refs = refs;
      this.fn = builder;
    }
    resolve(base2, options) {
      let values = this.refs.map((ref) => (
        // TODO: ? operator here?
        ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)
      ));
      let schema2 = this.fn(values, base2, options);
      if (schema2 === void 0 || // @ts-ignore this can be base
      schema2 === base2) {
        return base2;
      }
      if (!isSchema(schema2))
        throw new TypeError("conditions must return a schema object");
      return schema2.resolve(options);
    }
  };
  var prefixes = {
    context: "$",
    value: "."
  };
  var Reference = class {
    constructor(key, options = {}) {
      this.key = void 0;
      this.isContext = void 0;
      this.isValue = void 0;
      this.isSibling = void 0;
      this.path = void 0;
      this.getter = void 0;
      this.map = void 0;
      if (typeof key !== "string")
        throw new TypeError("ref must be a string, got: " + key);
      this.key = key.trim();
      if (key === "")
        throw new TypeError("ref must be a non-empty string");
      this.isContext = this.key[0] === prefixes.context;
      this.isValue = this.key[0] === prefixes.value;
      this.isSibling = !this.isContext && !this.isValue;
      let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
      this.path = this.key.slice(prefix.length);
      this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
      this.map = options.map;
    }
    getValue(value, parent, context2) {
      let result = this.isContext ? context2 : this.isValue ? value : parent;
      if (this.getter)
        result = this.getter(result || {});
      if (this.map)
        result = this.map(result);
      return result;
    }
    /**
     *
     * @param {*} value
     * @param {Object} options
     * @param {Object=} options.context
     * @param {Object=} options.parent
     */
    cast(value, options) {
      return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
    }
    resolve() {
      return this;
    }
    describe() {
      return {
        type: "ref",
        key: this.key
      };
    }
    toString() {
      return `Ref(${this.key})`;
    }
    static isRef(value) {
      return value && value.__isYupRef;
    }
  };
  Reference.prototype.__isYupRef = true;
  var isAbsent = (value) => value == null;
  function createValidation(config) {
    function validate({
      value,
      path: path6 = "",
      options,
      originalValue,
      schema: schema2
    }, panic, next) {
      const {
        name,
        test,
        params,
        message,
        skipAbsent
      } = config;
      let {
        parent,
        context: context2,
        abortEarly = schema2.spec.abortEarly,
        disableStackTrace = schema2.spec.disableStackTrace
      } = options;
      function resolve10(item) {
        return Reference.isRef(item) ? item.getValue(value, parent, context2) : item;
      }
      function createError(overrides = {}) {
        const nextParams = Object.assign({
          value,
          originalValue,
          label: schema2.spec.label,
          path: overrides.path || path6,
          spec: schema2.spec,
          disableStackTrace: overrides.disableStackTrace || disableStackTrace
        }, params, overrides.params);
        for (const key of Object.keys(nextParams))
          nextParams[key] = resolve10(nextParams[key]);
        const error3 = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
        error3.params = nextParams;
        return error3;
      }
      const invalid = abortEarly ? panic : next;
      let ctx = {
        path: path6,
        parent,
        type: name,
        from: options.from,
        createError,
        resolve: resolve10,
        options,
        originalValue,
        schema: schema2
      };
      const handleResult = (validOrError) => {
        if (ValidationError.isError(validOrError))
          invalid(validOrError);
        else if (!validOrError)
          invalid(createError());
        else
          next(null);
      };
      const handleError = (err2) => {
        if (ValidationError.isError(err2))
          invalid(err2);
        else
          panic(err2);
      };
      const shouldSkip = skipAbsent && isAbsent(value);
      if (shouldSkip) {
        return handleResult(true);
      }
      let result;
      try {
        var _result;
        result = test.call(ctx, value, ctx);
        if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
          if (options.sync) {
            throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
          }
          return Promise.resolve(result).then(handleResult, handleError);
        }
      } catch (err2) {
        handleError(err2);
        return;
      }
      handleResult(result);
    }
    validate.OPTIONS = config;
    return validate;
  }
  function getIn(schema2, path6, value, context2 = value) {
    let parent, lastPart, lastPartDebug;
    if (!path6)
      return {
        parent,
        parentPath: path6,
        schema: schema2
      };
    (0, import_property_expr.forEach)(path6, (_part, isBracket, isArray) => {
      let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
      schema2 = schema2.resolve({
        context: context2,
        parent,
        value
      });
      let isTuple = schema2.type === "tuple";
      let idx = isArray ? parseInt(part, 10) : 0;
      if (schema2.innerType || isTuple) {
        if (isTuple && !isArray)
          throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
        if (value && idx >= value.length) {
          throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path6}. because there is no value at that index. `);
        }
        parent = value;
        value = value && value[idx];
        schema2 = isTuple ? schema2.spec.types[idx] : schema2.innerType;
      }
      if (!isArray) {
        if (!schema2.fields || !schema2.fields[part])
          throw new Error(`The schema does not contain the path: ${path6}. (failed at: ${lastPartDebug} which is a type: "${schema2.type}")`);
        parent = value;
        value = value && value[part];
        schema2 = schema2.fields[part];
      }
      lastPart = part;
      lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
    });
    return {
      schema: schema2,
      parent,
      parentPath: lastPart
    };
  }
  var ReferenceSet = class extends Set {
    describe() {
      const description = [];
      for (const item of this.values()) {
        description.push(Reference.isRef(item) ? item.describe() : item);
      }
      return description;
    }
    resolveAll(resolve10) {
      let result = [];
      for (const item of this.values()) {
        result.push(resolve10(item));
      }
      return result;
    }
    clone() {
      return new ReferenceSet(this.values());
    }
    merge(newItems, removeItems) {
      const next = this.clone();
      newItems.forEach((value) => next.add(value));
      removeItems.forEach((value) => next.delete(value));
      return next;
    }
  };
  function clone4(src, seen = /* @__PURE__ */ new Map()) {
    if (isSchema(src) || !src || typeof src !== "object")
      return src;
    if (seen.has(src))
      return seen.get(src);
    let copy;
    if (src instanceof Date) {
      copy = new Date(src.getTime());
      seen.set(src, copy);
    } else if (src instanceof RegExp) {
      copy = new RegExp(src);
      seen.set(src, copy);
    } else if (Array.isArray(src)) {
      copy = new Array(src.length);
      seen.set(src, copy);
      for (let i = 0; i < src.length; i++)
        copy[i] = clone4(src[i], seen);
    } else if (src instanceof Map) {
      copy = /* @__PURE__ */ new Map();
      seen.set(src, copy);
      for (const [k, v] of src.entries())
        copy.set(k, clone4(v, seen));
    } else if (src instanceof Set) {
      copy = /* @__PURE__ */ new Set();
      seen.set(src, copy);
      for (const v of src)
        copy.add(clone4(v, seen));
    } else if (src instanceof Object) {
      copy = {};
      seen.set(src, copy);
      for (const [k, v] of Object.entries(src))
        copy[k] = clone4(v, seen);
    } else {
      throw Error(`Unable to clone ${src}`);
    }
    return copy;
  }
  var Schema = class {
    constructor(options) {
      this.type = void 0;
      this.deps = [];
      this.tests = void 0;
      this.transforms = void 0;
      this.conditions = [];
      this._mutate = void 0;
      this.internalTests = {};
      this._whitelist = new ReferenceSet();
      this._blacklist = new ReferenceSet();
      this.exclusiveTests = /* @__PURE__ */ Object.create(null);
      this._typeCheck = void 0;
      this.spec = void 0;
      this.tests = [];
      this.transforms = [];
      this.withMutation(() => {
        this.typeError(mixed.notType);
      });
      this.type = options.type;
      this._typeCheck = options.check;
      this.spec = Object.assign({
        strip: false,
        strict: false,
        abortEarly: true,
        recursive: true,
        disableStackTrace: false,
        nullable: false,
        optional: true,
        coerce: true
      }, options == null ? void 0 : options.spec);
      this.withMutation((s) => {
        s.nonNullable();
      });
    }
    // TODO: remove
    get _type() {
      return this.type;
    }
    clone(spec) {
      if (this._mutate) {
        if (spec)
          Object.assign(this.spec, spec);
        return this;
      }
      const next = Object.create(Object.getPrototypeOf(this));
      next.type = this.type;
      next._typeCheck = this._typeCheck;
      next._whitelist = this._whitelist.clone();
      next._blacklist = this._blacklist.clone();
      next.internalTests = Object.assign({}, this.internalTests);
      next.exclusiveTests = Object.assign({}, this.exclusiveTests);
      next.deps = [...this.deps];
      next.conditions = [...this.conditions];
      next.tests = [...this.tests];
      next.transforms = [...this.transforms];
      next.spec = clone4(Object.assign({}, this.spec, spec));
      return next;
    }
    label(label) {
      let next = this.clone();
      next.spec.label = label;
      return next;
    }
    meta(...args) {
      if (args.length === 0)
        return this.spec.meta;
      let next = this.clone();
      next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
      return next;
    }
    withMutation(fn) {
      let before = this._mutate;
      this._mutate = true;
      let result = fn(this);
      this._mutate = before;
      return result;
    }
    concat(schema2) {
      if (!schema2 || schema2 === this)
        return this;
      if (schema2.type !== this.type && this.type !== "mixed")
        throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema2.type}`);
      let base2 = this;
      let combined = schema2.clone();
      const mergedSpec = Object.assign({}, base2.spec, combined.spec);
      combined.spec = mergedSpec;
      combined.internalTests = Object.assign({}, base2.internalTests, combined.internalTests);
      combined._whitelist = base2._whitelist.merge(schema2._whitelist, schema2._blacklist);
      combined._blacklist = base2._blacklist.merge(schema2._blacklist, schema2._whitelist);
      combined.tests = base2.tests;
      combined.exclusiveTests = base2.exclusiveTests;
      combined.withMutation((next) => {
        schema2.tests.forEach((fn) => {
          next.test(fn.OPTIONS);
        });
      });
      combined.transforms = [...base2.transforms, ...combined.transforms];
      return combined;
    }
    isType(v) {
      if (v == null) {
        if (this.spec.nullable && v === null)
          return true;
        if (this.spec.optional && v === void 0)
          return true;
        return false;
      }
      return this._typeCheck(v);
    }
    resolve(options) {
      let schema2 = this;
      if (schema2.conditions.length) {
        let conditions = schema2.conditions;
        schema2 = schema2.clone();
        schema2.conditions = [];
        schema2 = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema2);
        schema2 = schema2.resolve(options);
      }
      return schema2;
    }
    resolveOptions(options) {
      var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
      return Object.assign({}, options, {
        from: options.from || [],
        strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
        abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
        recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
        disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
      });
    }
    /**
     * Run the configured transform pipeline over an input value.
     */
    cast(value, options = {}) {
      let resolvedSchema = this.resolve(Object.assign({
        value
      }, options));
      let allowOptionality = options.assert === "ignore-optionality";
      let result = resolvedSchema._cast(value, options);
      if (options.assert !== false && !resolvedSchema.isType(result)) {
        if (allowOptionality && isAbsent(result)) {
          return result;
        }
        let formattedValue = printValue(value);
        let formattedResult = printValue(result);
        throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
      }
      return result;
    }
    _cast(rawValue, options) {
      let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
      if (value === void 0) {
        value = this.getDefault(options);
      }
      return value;
    }
    _validate(_value, options = {}, panic, next) {
      let {
        path: path6,
        originalValue = _value,
        strict = this.spec.strict
      } = options;
      let value = _value;
      if (!strict) {
        value = this._cast(value, Object.assign({
          assert: false
        }, options));
      }
      let initialTests = [];
      for (let test of Object.values(this.internalTests)) {
        if (test)
          initialTests.push(test);
      }
      this.runTests({
        path: path6,
        value,
        originalValue,
        options,
        tests: initialTests
      }, panic, (initialErrors) => {
        if (initialErrors.length) {
          return next(initialErrors, value);
        }
        this.runTests({
          path: path6,
          value,
          originalValue,
          options,
          tests: this.tests
        }, panic, next);
      });
    }
    /**
     * Executes a set of validations, either schema, produced Tests or a nested
     * schema validate result.
     */
    runTests(runOptions, panic, next) {
      let fired = false;
      let {
        tests,
        value,
        originalValue,
        path: path6,
        options
      } = runOptions;
      let panicOnce = (arg) => {
        if (fired)
          return;
        fired = true;
        panic(arg, value);
      };
      let nextOnce = (arg) => {
        if (fired)
          return;
        fired = true;
        next(arg, value);
      };
      let count = tests.length;
      let nestedErrors = [];
      if (!count)
        return nextOnce([]);
      let args = {
        value,
        originalValue,
        path: path6,
        options,
        schema: this
      };
      for (let i = 0; i < tests.length; i++) {
        const test = tests[i];
        test(args, panicOnce, function finishTestRun(err2) {
          if (err2) {
            Array.isArray(err2) ? nestedErrors.push(...err2) : nestedErrors.push(err2);
          }
          if (--count <= 0) {
            nextOnce(nestedErrors);
          }
        });
      }
    }
    asNestedTest({
      key,
      index,
      parent,
      parentPath,
      originalParent,
      options
    }) {
      const k = key != null ? key : index;
      if (k == null) {
        throw TypeError("Must include `key` or `index` for nested validations");
      }
      const isIndex = typeof k === "number";
      let value = parent[k];
      const testOptions = Object.assign({}, options, {
        // Nested validations fields are always strict:
        //    1. parent isn't strict so the casting will also have cast inner values
        //    2. parent is strict in which case the nested values weren't cast either
        strict: true,
        parent,
        value,
        originalValue: originalParent[k],
        // FIXME: tests depend on `index` being passed around deeply,
        //   we should not let the options.key/index bleed through
        key: void 0,
        // index: undefined,
        [isIndex ? "index" : "key"]: k,
        path: isIndex || k.includes(".") ? `${parentPath || ""}[${isIndex ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : "") + key
      });
      return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
    }
    validate(value, options) {
      var _options$disableStack2;
      let schema2 = this.resolve(Object.assign({}, options, {
        value
      }));
      let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema2.spec.disableStackTrace;
      return new Promise((resolve10, reject) => schema2._validate(value, options, (error3, parsed) => {
        if (ValidationError.isError(error3))
          error3.value = parsed;
        reject(error3);
      }, (errors2, validated) => {
        if (errors2.length)
          reject(new ValidationError(errors2, validated, void 0, void 0, disableStackTrace));
        else
          resolve10(validated);
      }));
    }
    validateSync(value, options) {
      var _options$disableStack3;
      let schema2 = this.resolve(Object.assign({}, options, {
        value
      }));
      let result;
      let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema2.spec.disableStackTrace;
      schema2._validate(value, Object.assign({}, options, {
        sync: true
      }), (error3, parsed) => {
        if (ValidationError.isError(error3))
          error3.value = parsed;
        throw error3;
      }, (errors2, validated) => {
        if (errors2.length)
          throw new ValidationError(errors2, value, void 0, void 0, disableStackTrace);
        result = validated;
      });
      return result;
    }
    isValid(value, options) {
      return this.validate(value, options).then(() => true, (err2) => {
        if (ValidationError.isError(err2))
          return false;
        throw err2;
      });
    }
    isValidSync(value, options) {
      try {
        this.validateSync(value, options);
        return true;
      } catch (err2) {
        if (ValidationError.isError(err2))
          return false;
        throw err2;
      }
    }
    _getDefault(options) {
      let defaultValue = this.spec.default;
      if (defaultValue == null) {
        return defaultValue;
      }
      return typeof defaultValue === "function" ? defaultValue.call(this, options) : clone4(defaultValue);
    }
    getDefault(options) {
      let schema2 = this.resolve(options || {});
      return schema2._getDefault(options);
    }
    default(def) {
      if (arguments.length === 0) {
        return this._getDefault();
      }
      let next = this.clone({
        default: def
      });
      return next;
    }
    strict(isStrict = true) {
      return this.clone({
        strict: isStrict
      });
    }
    nullability(nullable, message) {
      const next = this.clone({
        nullable
      });
      next.internalTests.nullable = createValidation({
        message,
        name: "nullable",
        test(value) {
          return value === null ? this.schema.spec.nullable : true;
        }
      });
      return next;
    }
    optionality(optional, message) {
      const next = this.clone({
        optional
      });
      next.internalTests.optionality = createValidation({
        message,
        name: "optionality",
        test(value) {
          return value === void 0 ? this.schema.spec.optional : true;
        }
      });
      return next;
    }
    optional() {
      return this.optionality(true);
    }
    defined(message = mixed.defined) {
      return this.optionality(false, message);
    }
    nullable() {
      return this.nullability(true);
    }
    nonNullable(message = mixed.notNull) {
      return this.nullability(false, message);
    }
    required(message = mixed.required) {
      return this.clone().withMutation((next) => next.nonNullable(message).defined(message));
    }
    notRequired() {
      return this.clone().withMutation((next) => next.nullable().optional());
    }
    transform(fn) {
      let next = this.clone();
      next.transforms.push(fn);
      return next;
    }
    /**
     * Adds a test function to the schema's queue of tests.
     * tests can be exclusive or non-exclusive.
     *
     * - exclusive tests, will replace any existing tests of the same name.
     * - non-exclusive: can be stacked
     *
     * If a non-exclusive test is added to a schema with an exclusive test of the same name
     * the exclusive test is removed and further tests of the same name will be stacked.
     *
     * If an exclusive test is added to a schema with non-exclusive tests of the same name
     * the previous tests are removed and further tests of the same name will replace each other.
     */
    test(...args) {
      let opts;
      if (args.length === 1) {
        if (typeof args[0] === "function") {
          opts = {
            test: args[0]
          };
        } else {
          opts = args[0];
        }
      } else if (args.length === 2) {
        opts = {
          name: args[0],
          test: args[1]
        };
      } else {
        opts = {
          name: args[0],
          message: args[1],
          test: args[2]
        };
      }
      if (opts.message === void 0)
        opts.message = mixed.default;
      if (typeof opts.test !== "function")
        throw new TypeError("`test` is a required parameters");
      let next = this.clone();
      let validate = createValidation(opts);
      let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
      if (opts.exclusive) {
        if (!opts.name)
          throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
      }
      if (opts.name)
        next.exclusiveTests[opts.name] = !!opts.exclusive;
      next.tests = next.tests.filter((fn) => {
        if (fn.OPTIONS.name === opts.name) {
          if (isExclusive)
            return false;
          if (fn.OPTIONS.test === validate.OPTIONS.test)
            return false;
        }
        return true;
      });
      next.tests.push(validate);
      return next;
    }
    when(keys4, options) {
      if (!Array.isArray(keys4) && typeof keys4 !== "string") {
        options = keys4;
        keys4 = ".";
      }
      let next = this.clone();
      let deps = toArray(keys4).map((key) => new Reference(key));
      deps.forEach((dep) => {
        if (dep.isSibling)
          next.deps.push(dep.key);
      });
      next.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
      return next;
    }
    typeError(message) {
      let next = this.clone();
      next.internalTests.typeError = createValidation({
        message,
        name: "typeError",
        skipAbsent: true,
        test(value) {
          if (!this.schema._typeCheck(value))
            return this.createError({
              params: {
                type: this.schema.type
              }
            });
          return true;
        }
      });
      return next;
    }
    oneOf(enums, message = mixed.oneOf) {
      let next = this.clone();
      enums.forEach((val) => {
        next._whitelist.add(val);
        next._blacklist.delete(val);
      });
      next.internalTests.whiteList = createValidation({
        message,
        name: "oneOf",
        skipAbsent: true,
        test(value) {
          let valids = this.schema._whitelist;
          let resolved = valids.resolveAll(this.resolve);
          return resolved.includes(value) ? true : this.createError({
            params: {
              values: Array.from(valids).join(", "),
              resolved
            }
          });
        }
      });
      return next;
    }
    notOneOf(enums, message = mixed.notOneOf) {
      let next = this.clone();
      enums.forEach((val) => {
        next._blacklist.add(val);
        next._whitelist.delete(val);
      });
      next.internalTests.blacklist = createValidation({
        message,
        name: "notOneOf",
        test(value) {
          let invalids = this.schema._blacklist;
          let resolved = invalids.resolveAll(this.resolve);
          if (resolved.includes(value))
            return this.createError({
              params: {
                values: Array.from(invalids).join(", "),
                resolved
              }
            });
          return true;
        }
      });
      return next;
    }
    strip(strip = true) {
      let next = this.clone();
      next.spec.strip = strip;
      return next;
    }
    /**
     * Return a serialized description of the schema including validations, flags, types etc.
     *
     * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
     */
    describe(options) {
      const next = (options ? this.resolve(options) : this).clone();
      const {
        label,
        meta,
        optional,
        nullable
      } = next.spec;
      const description = {
        meta,
        label,
        optional,
        nullable,
        default: next.getDefault(options),
        type: next.type,
        oneOf: next._whitelist.describe(),
        notOneOf: next._blacklist.describe(),
        tests: next.tests.map((fn) => ({
          name: fn.OPTIONS.name,
          params: fn.OPTIONS.params
        })).filter((n, idx, list) => list.findIndex((c) => c.name === n.name) === idx)
      };
      return description;
    }
  };
  Schema.prototype.__isYupSchema__ = true;
  for (const method of ["validate", "validateSync"])
    Schema.prototype[`${method}At`] = function(path6, value, options = {}) {
      const {
        parent,
        parentPath,
        schema: schema2
      } = getIn(this, path6, value, options.context);
      return schema2[method](parent && parent[parentPath], Object.assign({}, options, {
        parent,
        path: path6
      }));
    };
  for (const alias of ["equals", "is"])
    Schema.prototype[alias] = Schema.prototype.oneOf;
  for (const alias of ["not", "nope"])
    Schema.prototype[alias] = Schema.prototype.notOneOf;
  var returnsTrue = () => true;
  function create$8(spec) {
    return new MixedSchema(spec);
  }
  var MixedSchema = class extends Schema {
    constructor(spec) {
      super(typeof spec === "function" ? {
        type: "mixed",
        check: spec
      } : Object.assign({
        type: "mixed",
        check: returnsTrue
      }, spec));
    }
  };
  create$8.prototype = MixedSchema.prototype;
  function create$7() {
    return new BooleanSchema();
  }
  var BooleanSchema = class extends Schema {
    constructor() {
      super({
        type: "boolean",
        check(v) {
          if (v instanceof Boolean)
            v = v.valueOf();
          return typeof v === "boolean";
        }
      });
      this.withMutation(() => {
        this.transform((value, _raw, ctx) => {
          if (ctx.spec.coerce && !ctx.isType(value)) {
            if (/^(true|1)$/i.test(String(value)))
              return true;
            if (/^(false|0)$/i.test(String(value)))
              return false;
          }
          return value;
        });
      });
    }
    isTrue(message = boolean.isValue) {
      return this.test({
        message,
        name: "is-value",
        exclusive: true,
        params: {
          value: "true"
        },
        test(value) {
          return isAbsent(value) || value === true;
        }
      });
    }
    isFalse(message = boolean.isValue) {
      return this.test({
        message,
        name: "is-value",
        exclusive: true,
        params: {
          value: "false"
        },
        test(value) {
          return isAbsent(value) || value === false;
        }
      });
    }
    default(def) {
      return super.default(def);
    }
    defined(msg) {
      return super.defined(msg);
    }
    optional() {
      return super.optional();
    }
    required(msg) {
      return super.required(msg);
    }
    notRequired() {
      return super.notRequired();
    }
    nullable() {
      return super.nullable();
    }
    nonNullable(msg) {
      return super.nonNullable(msg);
    }
    strip(v) {
      return super.strip(v);
    }
  };
  create$7.prototype = BooleanSchema.prototype;
  var isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
  function parseIsoDate(date2) {
    const struct = parseDateStruct(date2);
    if (!struct)
      return Date.parse ? Date.parse(date2) : Number.NaN;
    if (struct.z === void 0 && struct.plusMinus === void 0) {
      return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
    }
    let totalMinutesOffset = 0;
    if (struct.z !== "Z" && struct.plusMinus !== void 0) {
      totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
      if (struct.plusMinus === "+")
        totalMinutesOffset = 0 - totalMinutesOffset;
    }
    return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
  }
  function parseDateStruct(date2) {
    var _regexResult$7$length, _regexResult$;
    const regexResult = isoReg.exec(date2);
    if (!regexResult)
      return null;
    return {
      year: toNumber2(regexResult[1]),
      month: toNumber2(regexResult[2], 1) - 1,
      day: toNumber2(regexResult[3], 1),
      hour: toNumber2(regexResult[4]),
      minute: toNumber2(regexResult[5]),
      second: toNumber2(regexResult[6]),
      millisecond: regexResult[7] ? (
        // allow arbitrary sub-second precision beyond milliseconds
        toNumber2(regexResult[7].substring(0, 3))
      ) : 0,
      precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
      z: regexResult[8] || void 0,
      plusMinus: regexResult[9] || void 0,
      hourOffset: toNumber2(regexResult[10]),
      minuteOffset: toNumber2(regexResult[11])
    };
  }
  function toNumber2(str, defaultValue = 0) {
    return Number(str) || defaultValue;
  }
  var rEmail = (
    // eslint-disable-next-line
    /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
  );
  var rUrl = (
    // eslint-disable-next-line
    /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
  );
  var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  var yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
  var hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
  var zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
  var rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
  var isTrimmed = (value) => isAbsent(value) || value === value.trim();
  var objStringTag = {}.toString();
  function create$6() {
    return new StringSchema();
  }
  var StringSchema = class extends Schema {
    constructor() {
      super({
        type: "string",
        check(value) {
          if (value instanceof String)
            value = value.valueOf();
          return typeof value === "string";
        }
      });
      this.withMutation(() => {
        this.transform((value, _raw, ctx) => {
          if (!ctx.spec.coerce || ctx.isType(value))
            return value;
          if (Array.isArray(value))
            return value;
          const strValue = value != null && value.toString ? value.toString() : value;
          if (strValue === objStringTag)
            return value;
          return strValue;
        });
      });
    }
    required(message) {
      return super.required(message).withMutation((schema2) => schema2.test({
        message: message || mixed.required,
        name: "required",
        skipAbsent: true,
        test: (value) => !!value.length
      }));
    }
    notRequired() {
      return super.notRequired().withMutation((schema2) => {
        schema2.tests = schema2.tests.filter((t) => t.OPTIONS.name !== "required");
        return schema2;
      });
    }
    length(length, message = string.length) {
      return this.test({
        message,
        name: "length",
        exclusive: true,
        params: {
          length
        },
        skipAbsent: true,
        test(value) {
          return value.length === this.resolve(length);
        }
      });
    }
    min(min, message = string.min) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        skipAbsent: true,
        test(value) {
          return value.length >= this.resolve(min);
        }
      });
    }
    max(max2, message = string.max) {
      return this.test({
        name: "max",
        exclusive: true,
        message,
        params: {
          max: max2
        },
        skipAbsent: true,
        test(value) {
          return value.length <= this.resolve(max2);
        }
      });
    }
    matches(regex, options) {
      let excludeEmptyString = false;
      let message;
      let name;
      if (options) {
        if (typeof options === "object") {
          ({
            excludeEmptyString = false,
            message,
            name
          } = options);
        } else {
          message = options;
        }
      }
      return this.test({
        name: name || "matches",
        message: message || string.matches,
        params: {
          regex
        },
        skipAbsent: true,
        test: (value) => value === "" && excludeEmptyString || value.search(regex) !== -1
      });
    }
    email(message = string.email) {
      return this.matches(rEmail, {
        name: "email",
        message,
        excludeEmptyString: true
      });
    }
    url(message = string.url) {
      return this.matches(rUrl, {
        name: "url",
        message,
        excludeEmptyString: true
      });
    }
    uuid(message = string.uuid) {
      return this.matches(rUUID, {
        name: "uuid",
        message,
        excludeEmptyString: false
      });
    }
    datetime(options) {
      let message = "";
      let allowOffset;
      let precision;
      if (options) {
        if (typeof options === "object") {
          ({
            message = "",
            allowOffset = false,
            precision = void 0
          } = options);
        } else {
          message = options;
        }
      }
      return this.matches(rIsoDateTime, {
        name: "datetime",
        message: message || string.datetime,
        excludeEmptyString: true
      }).test({
        name: "datetime_offset",
        message: message || string.datetime_offset,
        params: {
          allowOffset
        },
        skipAbsent: true,
        test: (value) => {
          if (!value || allowOffset)
            return true;
          const struct = parseDateStruct(value);
          if (!struct)
            return false;
          return !!struct.z;
        }
      }).test({
        name: "datetime_precision",
        message: message || string.datetime_precision,
        params: {
          precision
        },
        skipAbsent: true,
        test: (value) => {
          if (!value || precision == void 0)
            return true;
          const struct = parseDateStruct(value);
          if (!struct)
            return false;
          return struct.precision === precision;
        }
      });
    }
    //-- transforms --
    ensure() {
      return this.default("").transform((val) => val === null ? "" : val);
    }
    trim(message = string.trim) {
      return this.transform((val) => val != null ? val.trim() : val).test({
        message,
        name: "trim",
        test: isTrimmed
      });
    }
    lowercase(message = string.lowercase) {
      return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
        message,
        name: "string_case",
        exclusive: true,
        skipAbsent: true,
        test: (value) => isAbsent(value) || value === value.toLowerCase()
      });
    }
    uppercase(message = string.uppercase) {
      return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
        message,
        name: "string_case",
        exclusive: true,
        skipAbsent: true,
        test: (value) => isAbsent(value) || value === value.toUpperCase()
      });
    }
  };
  create$6.prototype = StringSchema.prototype;
  var isNaN$1 = (value) => value != +value;
  function create$5() {
    return new NumberSchema();
  }
  var NumberSchema = class extends Schema {
    constructor() {
      super({
        type: "number",
        check(value) {
          if (value instanceof Number)
            value = value.valueOf();
          return typeof value === "number" && !isNaN$1(value);
        }
      });
      this.withMutation(() => {
        this.transform((value, _raw, ctx) => {
          if (!ctx.spec.coerce)
            return value;
          let parsed = value;
          if (typeof parsed === "string") {
            parsed = parsed.replace(/\s/g, "");
            if (parsed === "")
              return NaN;
            parsed = +parsed;
          }
          if (ctx.isType(parsed) || parsed === null)
            return parsed;
          return parseFloat(parsed);
        });
      });
    }
    min(min, message = number2.min) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        skipAbsent: true,
        test(value) {
          return value >= this.resolve(min);
        }
      });
    }
    max(max2, message = number2.max) {
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        skipAbsent: true,
        test(value) {
          return value <= this.resolve(max2);
        }
      });
    }
    lessThan(less, message = number2.lessThan) {
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          less
        },
        skipAbsent: true,
        test(value) {
          return value < this.resolve(less);
        }
      });
    }
    moreThan(more, message = number2.moreThan) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          more
        },
        skipAbsent: true,
        test(value) {
          return value > this.resolve(more);
        }
      });
    }
    positive(msg = number2.positive) {
      return this.moreThan(0, msg);
    }
    negative(msg = number2.negative) {
      return this.lessThan(0, msg);
    }
    integer(message = number2.integer) {
      return this.test({
        name: "integer",
        message,
        skipAbsent: true,
        test: (val) => Number.isInteger(val)
      });
    }
    truncate() {
      return this.transform((value) => !isAbsent(value) ? value | 0 : value);
    }
    round(method) {
      var _method;
      let avail = ["ceil", "floor", "round", "trunc"];
      method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
      if (method === "trunc")
        return this.truncate();
      if (avail.indexOf(method.toLowerCase()) === -1)
        throw new TypeError("Only valid options for round() are: " + avail.join(", "));
      return this.transform((value) => !isAbsent(value) ? Math[method](value) : value);
    }
  };
  create$5.prototype = NumberSchema.prototype;
  var invalidDate = /* @__PURE__ */ new Date("");
  var isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
  function create$4() {
    return new DateSchema();
  }
  var DateSchema = class extends Schema {
    constructor() {
      super({
        type: "date",
        check(v) {
          return isDate(v) && !isNaN(v.getTime());
        }
      });
      this.withMutation(() => {
        this.transform((value, _raw, ctx) => {
          if (!ctx.spec.coerce || ctx.isType(value) || value === null)
            return value;
          value = parseIsoDate(value);
          return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
        });
      });
    }
    prepareParam(ref, name) {
      let param;
      if (!Reference.isRef(ref)) {
        let cast = this.cast(ref);
        if (!this._typeCheck(cast))
          throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
        param = cast;
      } else {
        param = ref;
      }
      return param;
    }
    min(min, message = date.min) {
      let limit = this.prepareParam(min, "min");
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        skipAbsent: true,
        test(value) {
          return value >= this.resolve(limit);
        }
      });
    }
    max(max2, message = date.max) {
      let limit = this.prepareParam(max2, "max");
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        skipAbsent: true,
        test(value) {
          return value <= this.resolve(limit);
        }
      });
    }
  };
  DateSchema.INVALID_DATE = invalidDate;
  create$4.prototype = DateSchema.prototype;
  create$4.INVALID_DATE = invalidDate;
  function sortFields(fields, excludedEdges = []) {
    let edges = [];
    let nodes = /* @__PURE__ */ new Set();
    let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
    function addNode(depPath, key) {
      let node2 = (0, import_property_expr.split)(depPath)[0];
      nodes.add(node2);
      if (!excludes.has(`${key}-${node2}`))
        edges.push([key, node2]);
    }
    for (const key of Object.keys(fields)) {
      let value = fields[key];
      nodes.add(key);
      if (Reference.isRef(value) && value.isSibling)
        addNode(value.path, key);
      else if (isSchema(value) && "deps" in value)
        value.deps.forEach((path6) => addNode(path6, key));
    }
    return import_toposort.default.array(Array.from(nodes), edges).reverse();
  }
  function findIndex(arr, err2) {
    let idx = Infinity;
    arr.some((key, ii) => {
      var _err$path;
      if ((_err$path = err2.path) != null && _err$path.includes(key)) {
        idx = ii;
        return true;
      }
    });
    return idx;
  }
  function sortByKeyOrder(keys4) {
    return (a, b) => {
      return findIndex(keys4, a) - findIndex(keys4, b);
    };
  }
  var parseJson = (value, _, ctx) => {
    if (typeof value !== "string") {
      return value;
    }
    let parsed = value;
    try {
      parsed = JSON.parse(value);
    } catch (err2) {
    }
    return ctx.isType(parsed) ? parsed : value;
  };
  function deepPartial(schema2) {
    if ("fields" in schema2) {
      const partial = {};
      for (const [key, fieldSchema] of Object.entries(schema2.fields)) {
        partial[key] = deepPartial(fieldSchema);
      }
      return schema2.setFields(partial);
    }
    if (schema2.type === "array") {
      const nextArray = schema2.optional();
      if (nextArray.innerType)
        nextArray.innerType = deepPartial(nextArray.innerType);
      return nextArray;
    }
    if (schema2.type === "tuple") {
      return schema2.optional().clone({
        types: schema2.spec.types.map(deepPartial)
      });
    }
    if ("optional" in schema2) {
      return schema2.optional();
    }
    return schema2;
  }
  var deepHas = (obj, p) => {
    const path6 = [...(0, import_property_expr.normalizePath)(p)];
    if (path6.length === 1)
      return path6[0] in obj;
    let last = path6.pop();
    let parent = (0, import_property_expr.getter)((0, import_property_expr.join)(path6), true)(obj);
    return !!(parent && last in parent);
  };
  var isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
  function unknown(ctx, value) {
    let known = Object.keys(ctx.fields);
    return Object.keys(value).filter((key) => known.indexOf(key) === -1);
  }
  var defaultSort = sortByKeyOrder([]);
  function create$3(spec) {
    return new ObjectSchema(spec);
  }
  var ObjectSchema = class extends Schema {
    constructor(spec) {
      super({
        type: "object",
        check(value) {
          return isObject(value) || typeof value === "function";
        }
      });
      this.fields = /* @__PURE__ */ Object.create(null);
      this._sortErrors = defaultSort;
      this._nodes = [];
      this._excludedEdges = [];
      this.withMutation(() => {
        if (spec) {
          this.shape(spec);
        }
      });
    }
    _cast(_value, options = {}) {
      var _options$stripUnknown;
      let value = super._cast(_value, options);
      if (value === void 0)
        return this.getDefault(options);
      if (!this._typeCheck(value))
        return value;
      let fields = this.fields;
      let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
      let props = [].concat(this._nodes, Object.keys(value).filter((v) => !this._nodes.includes(v)));
      let intermediateValue = {};
      let innerOptions = Object.assign({}, options, {
        parent: intermediateValue,
        __validating: options.__validating || false
      });
      let isChanged = false;
      for (const prop of props) {
        let field = fields[prop];
        let exists2 = prop in value;
        if (field) {
          let fieldValue;
          let inputValue = value[prop];
          innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
          field = field.resolve({
            value: inputValue,
            context: options.context,
            parent: intermediateValue
          });
          let fieldSpec = field instanceof Schema ? field.spec : void 0;
          let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
          if (fieldSpec != null && fieldSpec.strip) {
            isChanged = isChanged || prop in value;
            continue;
          }
          fieldValue = !options.__validating || !strict ? (
            // TODO: use _cast, this is double resolving
            field.cast(value[prop], innerOptions)
          ) : value[prop];
          if (fieldValue !== void 0) {
            intermediateValue[prop] = fieldValue;
          }
        } else if (exists2 && !strip) {
          intermediateValue[prop] = value[prop];
        }
        if (exists2 !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
          isChanged = true;
        }
      }
      return isChanged ? intermediateValue : value;
    }
    _validate(_value, options = {}, panic, next) {
      let {
        from = [],
        originalValue = _value,
        recursive = this.spec.recursive
      } = options;
      options.from = [{
        schema: this,
        value: originalValue
      }, ...from];
      options.__validating = true;
      options.originalValue = originalValue;
      super._validate(_value, options, panic, (objectErrors, value) => {
        if (!recursive || !isObject(value)) {
          next(objectErrors, value);
          return;
        }
        originalValue = originalValue || value;
        let tests = [];
        for (let key of this._nodes) {
          let field = this.fields[key];
          if (!field || Reference.isRef(field)) {
            continue;
          }
          tests.push(field.asNestedTest({
            options,
            key,
            parent: value,
            parentPath: options.path,
            originalParent: originalValue
          }));
        }
        this.runTests({
          tests,
          value,
          originalValue,
          options
        }, panic, (fieldErrors) => {
          next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
        });
      });
    }
    clone(spec) {
      const next = super.clone(spec);
      next.fields = Object.assign({}, this.fields);
      next._nodes = this._nodes;
      next._excludedEdges = this._excludedEdges;
      next._sortErrors = this._sortErrors;
      return next;
    }
    concat(schema2) {
      let next = super.concat(schema2);
      let nextFields = next.fields;
      for (let [field, schemaOrRef] of Object.entries(this.fields)) {
        const target = nextFields[field];
        nextFields[field] = target === void 0 ? schemaOrRef : target;
      }
      return next.withMutation((s) => (
        // XXX: excludes here is wrong
        s.setFields(nextFields, [...this._excludedEdges, ...schema2._excludedEdges])
      ));
    }
    _getDefault(options) {
      if ("default" in this.spec) {
        return super._getDefault(options);
      }
      if (!this._nodes.length) {
        return void 0;
      }
      let dft = {};
      this._nodes.forEach((key) => {
        var _innerOptions;
        const field = this.fields[key];
        let innerOptions = options;
        if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
          innerOptions = Object.assign({}, innerOptions, {
            parent: innerOptions.value,
            value: innerOptions.value[key]
          });
        }
        dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
      });
      return dft;
    }
    setFields(shape, excludedEdges) {
      let next = this.clone();
      next.fields = shape;
      next._nodes = sortFields(shape, excludedEdges);
      next._sortErrors = sortByKeyOrder(Object.keys(shape));
      if (excludedEdges)
        next._excludedEdges = excludedEdges;
      return next;
    }
    shape(additions, excludes = []) {
      return this.clone().withMutation((next) => {
        let edges = next._excludedEdges;
        if (excludes.length) {
          if (!Array.isArray(excludes[0]))
            excludes = [excludes];
          edges = [...next._excludedEdges, ...excludes];
        }
        return next.setFields(Object.assign(next.fields, additions), edges);
      });
    }
    partial() {
      const partial = {};
      for (const [key, schema2] of Object.entries(this.fields)) {
        partial[key] = "optional" in schema2 && schema2.optional instanceof Function ? schema2.optional() : schema2;
      }
      return this.setFields(partial);
    }
    deepPartial() {
      const next = deepPartial(this);
      return next;
    }
    pick(keys4) {
      const picked = {};
      for (const key of keys4) {
        if (this.fields[key])
          picked[key] = this.fields[key];
      }
      return this.setFields(picked, this._excludedEdges.filter(([a, b]) => keys4.includes(a) && keys4.includes(b)));
    }
    omit(keys4) {
      const remaining = [];
      for (const key of Object.keys(this.fields)) {
        if (keys4.includes(key))
          continue;
        remaining.push(key);
      }
      return this.pick(remaining);
    }
    from(from, to, alias) {
      let fromGetter = (0, import_property_expr.getter)(from, true);
      return this.transform((obj) => {
        if (!obj)
          return obj;
        let newObj = obj;
        if (deepHas(obj, from)) {
          newObj = Object.assign({}, obj);
          if (!alias)
            delete newObj[from];
          newObj[to] = fromGetter(obj);
        }
        return newObj;
      });
    }
    /** Parse an input JSON string to an object */
    json() {
      return this.transform(parseJson);
    }
    noUnknown(noAllow = true, message = object.noUnknown) {
      if (typeof noAllow !== "boolean") {
        message = noAllow;
        noAllow = true;
      }
      let next = this.test({
        name: "noUnknown",
        exclusive: true,
        message,
        test(value) {
          if (value == null)
            return true;
          const unknownKeys = unknown(this.schema, value);
          return !noAllow || unknownKeys.length === 0 || this.createError({
            params: {
              unknown: unknownKeys.join(", ")
            }
          });
        }
      });
      next.spec.noUnknown = noAllow;
      return next;
    }
    unknown(allow = true, message = object.noUnknown) {
      return this.noUnknown(!allow, message);
    }
    transformKeys(fn) {
      return this.transform((obj) => {
        if (!obj)
          return obj;
        const result = {};
        for (const key of Object.keys(obj))
          result[fn(key)] = obj[key];
        return result;
      });
    }
    camelCase() {
      return this.transformKeys(import_tiny_case.camelCase);
    }
    snakeCase() {
      return this.transformKeys(import_tiny_case.snakeCase);
    }
    constantCase() {
      return this.transformKeys((key) => (0, import_tiny_case.snakeCase)(key).toUpperCase());
    }
    describe(options) {
      const next = (options ? this.resolve(options) : this).clone();
      const base2 = super.describe(options);
      base2.fields = {};
      for (const [key, value] of Object.entries(next.fields)) {
        var _innerOptions2;
        let innerOptions = options;
        if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
          innerOptions = Object.assign({}, innerOptions, {
            parent: innerOptions.value,
            value: innerOptions.value[key]
          });
        }
        base2.fields[key] = value.describe(innerOptions);
      }
      return base2;
    }
  };
  create$3.prototype = ObjectSchema.prototype;
  function create$2(type3) {
    return new ArraySchema(type3);
  }
  var ArraySchema = class extends Schema {
    constructor(type3) {
      super({
        type: "array",
        spec: {
          types: type3
        },
        check(v) {
          return Array.isArray(v);
        }
      });
      this.innerType = void 0;
      this.innerType = type3;
    }
    _cast(_value, _opts) {
      const value = super._cast(_value, _opts);
      if (!this._typeCheck(value) || !this.innerType) {
        return value;
      }
      let isChanged = false;
      const castArray = value.map((v, idx) => {
        const castElement = this.innerType.cast(v, Object.assign({}, _opts, {
          path: `${_opts.path || ""}[${idx}]`
        }));
        if (castElement !== v) {
          isChanged = true;
        }
        return castElement;
      });
      return isChanged ? castArray : value;
    }
    _validate(_value, options = {}, panic, next) {
      var _options$recursive;
      let innerType = this.innerType;
      let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
      options.originalValue != null ? options.originalValue : _value;
      super._validate(_value, options, panic, (arrayErrors, value) => {
        var _options$originalValu2;
        if (!recursive || !innerType || !this._typeCheck(value)) {
          next(arrayErrors, value);
          return;
        }
        let tests = new Array(value.length);
        for (let index = 0; index < value.length; index++) {
          var _options$originalValu;
          tests[index] = innerType.asNestedTest({
            options,
            index,
            parent: value,
            parentPath: options.path,
            originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
          });
        }
        this.runTests({
          value,
          tests,
          originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
          options
        }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(arrayErrors), value));
      });
    }
    clone(spec) {
      const next = super.clone(spec);
      next.innerType = this.innerType;
      return next;
    }
    /** Parse an input JSON string to an object */
    json() {
      return this.transform(parseJson);
    }
    concat(schema2) {
      let next = super.concat(schema2);
      next.innerType = this.innerType;
      if (schema2.innerType)
        next.innerType = next.innerType ? (
          // @ts-expect-error Lazy doesn't have concat and will break
          next.innerType.concat(schema2.innerType)
        ) : schema2.innerType;
      return next;
    }
    of(schema2) {
      let next = this.clone();
      if (!isSchema(schema2))
        throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema2));
      next.innerType = schema2;
      next.spec = Object.assign({}, next.spec, {
        types: schema2
      });
      return next;
    }
    length(length, message = array.length) {
      return this.test({
        message,
        name: "length",
        exclusive: true,
        params: {
          length
        },
        skipAbsent: true,
        test(value) {
          return value.length === this.resolve(length);
        }
      });
    }
    min(min, message) {
      message = message || array.min;
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        skipAbsent: true,
        // FIXME(ts): Array<typeof T>
        test(value) {
          return value.length >= this.resolve(min);
        }
      });
    }
    max(max2, message) {
      message = message || array.max;
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        skipAbsent: true,
        test(value) {
          return value.length <= this.resolve(max2);
        }
      });
    }
    ensure() {
      return this.default(() => []).transform((val, original) => {
        if (this._typeCheck(val))
          return val;
        return original == null ? [] : [].concat(original);
      });
    }
    compact(rejector) {
      let reject = !rejector ? (v) => !!v : (v, i, a) => !rejector(v, i, a);
      return this.transform((values) => values != null ? values.filter(reject) : values);
    }
    describe(options) {
      const next = (options ? this.resolve(options) : this).clone();
      const base2 = super.describe(options);
      if (next.innerType) {
        var _innerOptions;
        let innerOptions = options;
        if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
          innerOptions = Object.assign({}, innerOptions, {
            parent: innerOptions.value,
            value: innerOptions.value[0]
          });
        }
        base2.innerType = next.innerType.describe(innerOptions);
      }
      return base2;
    }
  };
  create$2.prototype = ArraySchema.prototype;
  function create$1(schemas) {
    return new TupleSchema(schemas);
  }
  var TupleSchema = class extends Schema {
    constructor(schemas) {
      super({
        type: "tuple",
        spec: {
          types: schemas
        },
        check(v) {
          const types2 = this.spec.types;
          return Array.isArray(v) && v.length === types2.length;
        }
      });
      this.withMutation(() => {
        this.typeError(tuple.notType);
      });
    }
    _cast(inputValue, options) {
      const {
        types: types2
      } = this.spec;
      const value = super._cast(inputValue, options);
      if (!this._typeCheck(value)) {
        return value;
      }
      let isChanged = false;
      const castArray = types2.map((type3, idx) => {
        const castElement = type3.cast(value[idx], Object.assign({}, options, {
          path: `${options.path || ""}[${idx}]`
        }));
        if (castElement !== value[idx])
          isChanged = true;
        return castElement;
      });
      return isChanged ? castArray : value;
    }
    _validate(_value, options = {}, panic, next) {
      let itemTypes = this.spec.types;
      super._validate(_value, options, panic, (tupleErrors, value) => {
        var _options$originalValu2;
        if (!this._typeCheck(value)) {
          next(tupleErrors, value);
          return;
        }
        let tests = [];
        for (let [index, itemSchema] of itemTypes.entries()) {
          var _options$originalValu;
          tests[index] = itemSchema.asNestedTest({
            options,
            index,
            parent: value,
            parentPath: options.path,
            originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
          });
        }
        this.runTests({
          value,
          tests,
          originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
          options
        }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(tupleErrors), value));
      });
    }
    describe(options) {
      const next = (options ? this.resolve(options) : this).clone();
      const base2 = super.describe(options);
      base2.innerType = next.spec.types.map((schema2, index) => {
        var _innerOptions;
        let innerOptions = options;
        if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
          innerOptions = Object.assign({}, innerOptions, {
            parent: innerOptions.value,
            value: innerOptions.value[index]
          });
        }
        return schema2.describe(innerOptions);
      });
      return base2;
    }
  };
  create$1.prototype = TupleSchema.prototype;

  // src/cli/config/validateConfig.ts
  var schema = create$3({
    workspace: create$6(),
    contracts: create$2(create$6()),
    scripts: create$2(create$6()),
    predicates: create$2(create$6()),
    output: create$6().required("config.output should be a valid string")
  }).required();
  async function validateConfig(config) {
    return schema.validate(config);
  }

  // src/cli/config/loadConfig.ts
  async function loadUserConfig(cwd) {
    const configJoycon = new import_joycon.default();
    const configPath = await configJoycon.resolve({
      files: ["ts", "js", "cjs", "mjs"].map((e) => `fuels.config.${e}`),
      cwd,
      stopDir: (0, import_path25.parse)(cwd).root
    });
    if (!configPath) {
      throw new FuelError(FuelError.CODES.CONFIG_FILE_NOT_FOUND, "Config file not found!");
    }
    const esbuildOptions = {
      target: "ES2021",
      platform: "node",
      format: "esm"
    };
    const result = await bundleRequire({
      filepath: configPath,
      esbuildOptions,
      cwd
    });
    const userConfig = result.mod.default;
    return { configPath, userConfig };
  }
  async function loadConfig(cwd) {
    const { configPath, userConfig } = await loadUserConfig(cwd);
    await validateConfig(userConfig);
    const { forcBuildFlags = [] } = userConfig;
    const releaseFlag = forcBuildFlags.find((f2) => f2 === "--release");
    const buildMode = releaseFlag ? "release" : "debug";
    const { forcPath, fuelCorePath } = tryFindBinaries({
      forcPath: userConfig.forcPath,
      fuelCorePath: userConfig.fuelCorePath
    });
    const config = {
      contracts: [],
      scripts: [],
      predicates: [],
      deployConfig: {},
      autoStartFuelCore: true,
      fuelCorePort: 4e3,
      providerUrl: process.env.FUEL_NETWORK_URL ?? "http://127.0.0.1:4000/v1/graphql",
      privateKey: defaultConsensusKey,
      ...userConfig,
      basePath: cwd,
      forcPath,
      fuelCorePath,
      configPath,
      forcBuildFlags,
      buildMode
    };
    config.output = (0, import_path25.resolve)(cwd, config.output);
    config.autoStartFuelCore = userConfig.autoStartFuelCore ?? true;
    if (!userConfig.workspace) {
      const { contracts, predicates, scripts } = userConfig;
      config.contracts = (contracts || []).map((c) => (0, import_path25.resolve)(cwd, c));
      config.scripts = (scripts || []).map((s) => (0, import_path25.resolve)(cwd, s));
      config.predicates = (predicates || []).map((p) => (0, import_path25.resolve)(cwd, p));
    } else {
      const workspace = (0, import_path25.resolve)(cwd, userConfig.workspace);
      const forcToml = readForcToml(workspace);
      if (!forcToml.workspace) {
        const workspaceMsg = `Forc workspace not detected in:
  ${workspace}/Forc.toml`;
        const swayProgramType = readSwayType(workspace);
        const exampleMsg = `Try using '${swayProgramType}s' instead of 'workspace' in:
  ${configPath}`;
        throw new FuelError(
          FuelError.CODES.WORKSPACE_NOT_DETECTED,
          [workspaceMsg, exampleMsg].join("\n\n")
        );
      }
      const swayMembers = forcToml.workspace.members.map((member) => (0, import_path25.resolve)(workspace, member));
      swayMembers.map((path6) => ({ path: path6, type: readSwayType(path6) })).filter(({ type: type3 }) => type3 !== "library" /* library */).forEach(({ path: path6, type: type3 }) => config[`${type3}s`].push(path6));
      config.workspace = workspace;
    }
    return config;
  }

  // src/cli/commands/withConfig.ts
  var withConfigErrorHandler = async (err2, config) => {
    error(err2.message);
    if (config) {
      await config.onFailure?.(config, err2);
    }
  };
  function withConfig(program2, command, fn) {
    return async () => {
      const options = program2.opts();
      let config;
      try {
        config = await loadConfig(options.path);
      } catch (err2) {
        await withConfigErrorHandler(err2);
        return;
      }
      try {
        await fn(config, program2);
        log(`\u{1F389}  ${capitalizeString(command)} completed successfully!`);
      } catch (err2) {
        await withConfigErrorHandler(err2, config);
      }
    };
  }

  // src/cli/commands/dev/index.ts
  var closeAllFileHandlers = (handlers) => {
    handlers.forEach((h) => h.close());
  };
  var buildAndDeploy = async (config) => {
    await build(config);
    const deployedContracts = await deploy(config);
    config.onDev?.(config);
    return deployedContracts;
  };
  var getConfigFilepathsToWatch = (config) => {
    const configFilePathsToWatch = [config.configPath];
    if (config.snapshotDir) {
      configFilePathsToWatch.push(config.snapshotDir);
    }
    return configFilePathsToWatch;
  };
  var workspaceFileChanged = (state) => async (_event, path6) => {
    log(`
File changed: ${path6}`);
    await buildAndDeploy(state.config);
  };
  var configFileChanged = (state) => async (_event, path6) => {
    log(`
File changed: ${path6}`);
    closeAllFileHandlers(state.watchHandlers);
    state.fuelCore?.killChildProcess();
    try {
      await dev(await loadConfig(state.config.basePath));
    } catch (err2) {
      await withConfigErrorHandler(err2, state.config);
    }
  };
  var dev = async (config) => {
    const fuelCore = await autoStartFuelCore(config);
    const configFilePaths = getConfigFilepathsToWatch(config);
    const { contracts, scripts, predicates, basePath: cwd } = config;
    const workspaceFilePaths = [contracts, predicates, scripts].flat().flatMap((dir) => [
      dir,
      globSync(`${dir}/**/*.toml`, { cwd }),
      globSync(`${dir}/**/*.sw`, { cwd })
    ]).flat();
    try {
      await buildAndDeploy(config);
      const watchHandlers = [];
      const options = { persistent: true, ignoreInitial: true, ignored: "**/out/**" };
      const state = { config, watchHandlers, fuelCore };
      watchHandlers.push((0, import_chokidar.watch)(configFilePaths, options).on("all", configFileChanged(state)));
      watchHandlers.push((0, import_chokidar.watch)(workspaceFilePaths, options).on("all", workspaceFileChanged(state)));
    } catch (err2) {
      error(err2);
      throw err2;
    }
  };

  // src/cli/commands/init/index.ts
  var import_fs31 = __require2("fs");
  var import_path26 = __require2("path");

  // src/cli/templates/fuels.config.ts
  var import_handlebars5 = __toESM(require_lib());

  // src/cli/templates/fuels.config.hbs
  var fuels_config_default = "import { createConfig } from 'fuels';\n\nexport default createConfig({\n  {{#if (isDefined workspace)}}\n  workspace: '{{workspace}}',\n  {{else}}\n    {{#if (isDefined contracts)}}\n  contracts: [\n      {{#each contracts}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n    {{#if (isDefined predicates)}}\n  predicates: [\n      {{#each predicates}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n    {{#if (isDefined scripts)}}\n  scripts: [\n      {{#each scripts}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n  {{/if}}\n  output: '{{output}}',\n  {{#if (isDefined forcPath)}}\n  forcPath: '{{forcPath}}',\n  {{/if}}\n  {{#if (isDefined fuelCorePath)}}\n  fuelCorePath: '{{fuelCorePath}}',\n  {{/if}}\n  {{#if (isDefined autoStartFuelCore)}}\n  autoStartFuelCore: {{autoStartFuelCore}},\n  {{/if}}\n  {{#if (isDefined fuelCorePort)}}\n  fuelCorePort: {{fuelCorePort}},\n  {{/if}}\n});\n\n/**\n * Check the docs:\n * https://docs.fuel.network/docs/fuels-ts/fuels-cli/config-file/\n */\n";

  // src/cli/templates/fuels.config.ts
  import_handlebars5.default.registerHelper("isDefined", (v) => v !== void 0);
  function renderFuelsConfigTemplate(props) {
    const renderTemplate = import_handlebars5.default.compile(fuels_config_default, {
      strict: true,
      noEscape: true
    });
    return renderTemplate(props);
  }

  // src/cli/commands/init/index.ts
  function init(program2) {
    const options = program2.opts();
    const { path: path6, autoStartFuelCore: autoStartFuelCore2, forcPath, fuelCorePath, fuelCorePort } = options;
    let workspace;
    let absoluteWorkspace;
    if (options.workspace) {
      absoluteWorkspace = (0, import_path26.resolve)(path6, options.workspace);
      workspace = `./${(0, import_path26.relative)(path6, absoluteWorkspace)}`;
    }
    const absoluteOutput = (0, import_path26.resolve)(path6, options.output);
    const output2 = `./${(0, import_path26.relative)(path6, absoluteOutput)}`;
    const [contracts, scripts, predicates] = ["contracts", "scripts", "predicates"].map(
      (optionName) => {
        const pathOrGlob = options[optionName];
        if (!pathOrGlob) {
          return void 0;
        }
        const expanded = globSync(pathOrGlob, { cwd: path6 });
        const relatives = expanded.map((e) => (0, import_path26.relative)(path6, e));
        return relatives;
      }
    );
    const noneIsInformed = ![workspace, contracts, scripts, predicates].find((v) => v !== void 0);
    if (noneIsInformed) {
      console.log(`error: required option '-w, --workspace <path>' not specified\r`);
      process.exit(1);
    } else {
      const fuelsConfigPath = (0, import_path26.join)(path6, "fuels.config.ts");
      if ((0, import_fs31.existsSync)(fuelsConfigPath)) {
        throw new FuelError(
          FuelError.CODES.CONFIG_FILE_ALREADY_EXISTS,
          `Config file exists, aborting.
  ${fuelsConfigPath}`
        );
      }
      const renderedConfig = renderFuelsConfigTemplate({
        workspace,
        contracts,
        scripts,
        predicates,
        output: output2,
        forcPath,
        fuelCorePath,
        autoStartFuelCore: autoStartFuelCore2,
        fuelCorePort
      });
      (0, import_fs31.writeFileSync)(fuelsConfigPath, renderedConfig);
      log(`Config file created at:

 ${fuelsConfigPath}
`);
    }
  }

  // src/cli/commands/node/index.ts
  var import_chokidar2 = __toESM(require_chokidar());
  var getConfigFilepathsToWatch2 = (config) => {
    const configFilePathsToWatch = [config.configPath];
    if (config.snapshotDir) {
      configFilePathsToWatch.push(config.snapshotDir);
    }
    return configFilePathsToWatch;
  };
  var closeAllFileHandlers2 = (handlers) => {
    handlers.forEach((h) => h.close());
  };
  var configFileChanged2 = (state) => async (_event, path6) => {
    log(`
File changed: ${path6}`);
    closeAllFileHandlers2(state.watchHandlers);
    state.fuelCore?.killChildProcess();
    try {
      await node(await loadConfig(state.config.basePath));
      state.config.onNode?.(state.config);
    } catch (err2) {
      await withConfigErrorHandler(err2, state.config);
    }
  };
  var node = async (config) => {
    const fuelCore = await autoStartFuelCore(config);
    const configFilePaths = getConfigFilepathsToWatch2(config);
    try {
      const watchHandlers = [];
      const options = { persistent: true, ignoreInitial: true, ignored: "**/out/**" };
      const state = { config, watchHandlers, fuelCore };
      watchHandlers.push((0, import_chokidar2.watch)(configFilePaths, options).on("all", configFileChanged2(state)));
    } catch (err2) {
      error(err2);
      throw err2;
    }
  };

  // src/cli/commands/withBinaryPaths.ts
  function withBinaryPaths(program2, _command, fn) {
    return async () => {
      const options = program2.opts();
      const paths = {};
      try {
        const { userConfig } = await loadUserConfig(options.path);
        paths.forcPath = userConfig.forcPath;
        paths.fuelCorePath = userConfig.fuelCorePath;
      } catch (err2) {
        debug(err2.message);
      }
      try {
        await fn(paths);
      } catch (err2) {
        error(err2);
      }
    };
  }

  // src/cli/commands/withProgram.ts
  function withProgram(program2, _command, fn) {
    return async () => {
      try {
        await fn(program2);
      } catch (err2) {
        error(err2);
      }
    };
  }

  // src/cli.ts
  var onPreAction = (command) => {
    const opts = command.opts();
    configureLogging({
      isDebugEnabled: opts.debug,
      isLoggingEnabled: !opts.silent
    });
  };
  var configureCli = () => {
    const program2 = new Command();
    program2.name("fuels");
    program2.option("-D, --debug", "Enables verbose logging", false);
    program2.option("-S, --silent", "Omit output messages", false);
    program2.version(versions.FUELS, "-v, --version", "Output the version number");
    program2.helpOption("-h, --help", "Display help");
    program2.helpCommand("help [command]", "Display help for command");
    program2.enablePositionalOptions(true);
    program2.hook("preAction", onPreAction);
    const pathOption = new Option("--path <path>", "Path to project root").default(process.cwd());
    let command;
    (command = program2.command("init" /* init */)).description("Create a sample `fuel.config.ts` file").addOption(pathOption).option("-w, --workspace <path>", "Relative dir path to Forc workspace").addOption(
      new Option(`-c, --contracts [paths...]`, `Relative paths to Contracts`).conflicts("workspace")
    ).addOption(
      new Option(`-s, --scripts [paths...]`, `Relative paths to Scripts`).conflicts("workspace")
    ).addOption(
      new Option(`-p, --predicates [paths...]`, `Relative paths to Predicates`).conflicts(
        "workspace"
      )
    ).requiredOption("-o, --output <path>", "Relative dir path for Typescript generation output").option("--forc-path <path>", "Path to the `forc` binary").option("--fuel-core-path <path>", "Path to the `fuel-core` binary").option("--auto-start-fuel-core", "Auto-starts a `fuel-core` node during `dev` command").option(
      "--fuel-core-port <port>",
      "Port to use when starting a local `fuel-core` node for dev mode"
    ).action(withProgram(command, "init" /* init */, init));
    (command = program2.command("dev" /* dev */)).description("Start a Fuel node with hot-reload capabilities").addOption(pathOption).action(withConfig(command, "dev" /* dev */, dev));
    (command = program2.command("node" /* node */)).description("Start a Fuel node using project configs").addOption(pathOption).action(withConfig(command, "node" /* node */, node));
    (command = program2.command("build" /* build */)).description("Build Sway programs and generate Typescript for them").addOption(pathOption).option(
      "-d, --deploy",
      "Deploy contracts after build (auto-starts a `fuel-core` node if needed)"
    ).action(withConfig(command, "build" /* build */, build));
    (command = program2.command("deploy" /* deploy */)).description("Deploy contracts to the Fuel network").addOption(pathOption).action(withConfig(command, "deploy" /* deploy */, deploy));
    configureCliOptions(
      program2.command("typegen").description(`Generate Typescript from Sway ABI JSON files`)
    );
    (command = program2.command("versions")).description("Check for version incompatibilities").addOption(pathOption).action(withBinaryPaths(command, "versions" /* versions */, runVersions));
    return program2;
  };

  // src/cli/utils/fuelsVersionCache.ts
  var import_fs32 = __toESM(__require2("fs"));
  var import_path27 = __toESM(__require2("path"));
  var FUELS_VERSION_CACHE_FILE = import_path27.default.join(__dirname, "FUELS_VERSION");
  var saveToCache = (cache3) => {
    import_fs32.default.writeFileSync(FUELS_VERSION_CACHE_FILE, cache3, "utf-8");
  };
  var FUELS_VERSION_CACHE_TTL = 6 * 60 * 60 * 1e3;
  var checkAndLoadCache = () => {
    const doesVersionCacheExist = import_fs32.default.existsSync(FUELS_VERSION_CACHE_FILE);
    if (doesVersionCacheExist) {
      const cachedVersion = import_fs32.default.readFileSync(FUELS_VERSION_CACHE_FILE, "utf-8").trim();
      if (!cachedVersion) {
        return null;
      }
      const { mtimeMs: cacheTimestamp } = import_fs32.default.statSync(FUELS_VERSION_CACHE_FILE);
      const hasCacheExpired = Date.now() - cacheTimestamp > FUELS_VERSION_CACHE_TTL;
      return hasCacheExpired ? null : cachedVersion;
    }
    return null;
  };

  // src/cli/utils/getLatestFuelsVersion.ts
  var getLatestFuelsVersion = async () => {
    const cachedVersion = checkAndLoadCache();
    if (cachedVersion) {
      return cachedVersion;
    }
    const data = await Promise.race([
      new Promise((_, reject) => {
        setTimeout(() => reject(null), 3e3);
      }),
      fetch("https://registry.npmjs.org/fuels/latest").then((response) => response.json())
    ]);
    if (!data) {
      throw new Error("Failed to fetch latest fuels version.");
    }
    const version3 = data.version;
    saveToCache(version3);
    return version3;
  };

  // src/cli/utils/checkForAndDisplayUpdates.ts
  var checkForAndDisplayUpdates = async () => {
    try {
      const { FUELS: userFuelsVersion } = versions;
      const latestFuelsVersion = await getLatestFuelsVersion();
      if (!latestFuelsVersion) {
        log(`
 Unable to fetch latest fuels version. Skipping...
`);
        return;
      }
      const isFuelsVersionOutdated = gt(latestFuelsVersion, userFuelsVersion);
      const isFuelsVersionUpToDate = eq(latestFuelsVersion, userFuelsVersion);
      if (isFuelsVersionOutdated) {
        warn(
          `
\u26A0\uFE0F There is a newer version of fuels available: ${latestFuelsVersion}. Your version is: ${userFuelsVersion}
`
        );
        return;
      }
      if (isFuelsVersionUpToDate) {
        log(`
\u2705 Your fuels version is up to date: ${userFuelsVersion}
`);
      }
    } catch {
      log(`
 Unable to fetch latest fuels version. Skipping...
`);
    }
  };

  // src/run.ts
  var run = async (argv) => {
    await checkForAndDisplayUpdates().catch(error);
    const program2 = configureCli();
    return program2.parseAsync(argv);
  };

  // src/bin.ts
  try {
    run(process.argv).catch((x) => {
      console.log(x);
    });
  } catch (err2) {
    error(err2?.message || err2);
    process.exit(1);
  }
})();
/*! Bundled license information:

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=bin.global.js.map