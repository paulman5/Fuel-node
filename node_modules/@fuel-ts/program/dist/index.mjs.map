{"version":3,"sources":["../src/types.ts","../src/utils.ts","../src/functions/invocation-scope.ts","../src/functions/base-invocation-scope.ts","../src/contract-call-script.ts","../src/instruction-set.ts","../src/script-request.ts","../src/response.ts","../src/functions/multicall-scope.ts","../src/contract.ts"],"sourcesContent":["/* eslint-disable max-classes-per-file */\nimport type { FunctionFragment, JsonAbi, Interface } from '@fuel-ts/abi-coder';\nimport type {\n  CallResult,\n  CoinQuantity,\n  CoinQuantityLike,\n  TransactionResponse,\n  TransactionResult,\n  TransactionType,\n  AbstractAccount,\n  Provider,\n} from '@fuel-ts/account';\nimport type { Address, WithContractId } from '@fuel-ts/address';\nimport type { BN, BigNumberish } from '@fuel-ts/math';\nimport type { BytesLike } from '@fuel-ts/utils';\n\nimport type { FunctionInvocationScope } from './functions/invocation-scope';\n\n/**\n * @hidden\n */\nexport abstract class AbstractProgram {\n  abstract account: AbstractAccount | null;\n  abstract interface: Pick<Interface, 'jsonAbi'>;\n  abstract provider: Pick<Provider, 'sendTransaction' | 'getTransactionCost'> | null;\n}\n\nexport abstract class AbstractContract extends AbstractProgram implements WithContractId {\n  abstract id: Address;\n}\n\n/**\n * Represents a contract call.\n */\nexport type ContractCall = {\n  contractId: Address;\n  data: BytesLike;\n  fnSelectorBytes: Uint8Array;\n  amount?: BigNumberish;\n  assetId?: BytesLike;\n  gas?: BigNumberish;\n  externalContractsAbis?: Record<string, JsonAbi>;\n};\n\n/**\n * Represents call parameters for a contract call.\n */\nexport type CallParams = Partial<{\n  forward: CoinQuantityLike;\n  gasLimit: BigNumberish;\n}>;\n\n/**\n * Represents transaction parameters for a contract call.\n */\nexport type TxParams = Partial<{\n  tip: BigNumberish;\n  gasLimit: BigNumberish;\n  maturity?: number;\n  maxFee?: BigNumberish;\n  witnessLimit?: BigNumberish;\n  variableOutputs: number;\n}>;\n\n/**\n * Represents configuration for calling a contract function.\n *\n * @template T - Type of the function's arguments.\n */\nexport type CallConfig<T = unknown> = {\n  func: FunctionFragment;\n  program: AbstractProgram;\n  callParameters?: CallParams;\n  txParameters?: TxParams;\n  forward?: CoinQuantity;\n  externalAbis: Record<string, JsonAbi>;\n  args: T;\n};\n\n/**\n * Represents a function that can be invoked.\n *\n * @template TArgs - Type of the function's arguments.\n * @template TReturn - Type of the function's return value.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface InvokeFunction<TArgs extends Array<any> = Array<any>, TReturn = any> {\n  (...args: TArgs): FunctionInvocationScope<TArgs, TReturn>;\n  /**\n   * Checks if the function is read-only i.e. it only reads from storage, does not write to it.\n   *\n   * @returns True if the function is read-only or pure, false otherwise.\n   */\n  isReadOnly: () => boolean;\n}\n\n/**\n * Represents a collection of functions that can be invoked.\n */\nexport interface InvokeFunctions {\n  [key: string]: InvokeFunction;\n}\n\n/**\n * Represents a like object of InvocationScope with a method to get its call configuration.\n * @template T - Type of the function's arguments.\n */\nexport type InvocationScopeLike<T = unknown> = {\n  /**\n   * Get the call configuration for this invocation scope.\n   * @returns \\{CallConfig<T>\\} The call configuration.\n   */\n  getCallConfig(): CallConfig<T>;\n};\n\n/**\n * Represents options for calculating the transaction cost.\n */\nexport type TransactionCostOptions = Partial<{\n  fundTransaction: boolean;\n}>;\n\nexport type FunctionResult<TReturn> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly logs: Array<any>;\n  readonly value: TReturn;\n  readonly gasUsed: BN;\n  readonly program: AbstractProgram;\n  readonly isMultiCall: boolean;\n  readonly transactionId: string;\n  readonly functionScopes: Array<InvocationScopeLike>;\n  readonly transactionResponse: TransactionResponse;\n  readonly transactionResult: TransactionResult<TransactionType.Script>;\n};\n\nexport type DryRunResult<TReturn> = {\n  readonly gasUsed: BN;\n  readonly value: TReturn;\n  readonly isMultiCall: boolean;\n  readonly callResult: CallResult;\n  readonly functionScopes: Array<InvocationScopeLike>;\n};\n","import { getDecodedLogs } from '@fuel-ts/account';\nimport type { TransactionResultReceipt, JsonAbisFromAllCalls } from '@fuel-ts/account';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { AbstractContract, CallConfig, InvocationScopeLike } from './types';\n\n/**\n * @hidden\n *\n * Generic assert function to avoid undesirable errors\n */\nexport function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new FuelError(ErrorCode.TRANSACTION_ERROR, message);\n  }\n}\n\n/**\n * @hidden\n *\n * Gets the ABI from an array of InvocationScopeLike.\n */\nexport function getAbisFromAllCalls(\n  functionScopes: Array<InvocationScopeLike>\n): JsonAbisFromAllCalls {\n  return functionScopes.reduce((acc, funcScope, i) => {\n    const { program, externalAbis } = funcScope.getCallConfig();\n\n    if (i === 0) {\n      acc.main = program.interface.jsonAbi;\n      acc.otherContractsAbis = {};\n    } else {\n      acc.otherContractsAbis[(<AbstractContract>program).id.toB256()] = program.interface.jsonAbi;\n    }\n\n    acc.otherContractsAbis = { ...acc.otherContractsAbis, ...externalAbis };\n\n    return acc;\n  }, {} as JsonAbisFromAllCalls);\n}\n\n/**\n * @hidden\n *\n */\nexport const getResultLogs = (\n  receipts: TransactionResultReceipt[],\n  mainCallConfig: CallConfig | undefined,\n  functionScopes: Array<InvocationScopeLike>\n) => {\n  if (!mainCallConfig) {\n    return [];\n  }\n  const { main, otherContractsAbis } = getAbisFromAllCalls(functionScopes);\n  return getDecodedLogs(receipts, main, otherContractsAbis);\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { FunctionFragment } from '@fuel-ts/abi-coder';\nimport type { CoinQuantity } from '@fuel-ts/account';\nimport { coinQuantityfy } from '@fuel-ts/account';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { AbstractProgram, CallConfig, CallParams } from '../types';\n\nimport { BaseInvocationScope } from './base-invocation-scope';\n\n/**\n * Represents a scope for invoking a function.\n *\n * @template TArgs - The type of the function arguments.\n * @template TReturn - The type of the return value.\n */\nexport class FunctionInvocationScope<\n  TArgs extends Array<any> = Array<any>,\n  TReturn = any,\n> extends BaseInvocationScope<TReturn> {\n  protected func: FunctionFragment;\n  private callParameters?: CallParams;\n  private forward?: CoinQuantity;\n  protected args: TArgs;\n\n  /**\n   * Constructs an instance of FunctionInvocationScope.\n   *\n   * @param program - The program.\n   * @param func - The function fragment.\n   * @param args - The arguments.\n   */\n  constructor(program: AbstractProgram, func: FunctionFragment, args: TArgs) {\n    super(program, false);\n    this.func = func;\n    this.args = args || [];\n    this.setArguments(...args);\n    super.addCall(this);\n  }\n\n  /**\n   * Gets the call configuration.\n   *\n   * @returns The call configuration.\n   */\n  getCallConfig(): CallConfig<TArgs> {\n    return {\n      func: this.func,\n      program: this.program,\n      callParameters: this.callParameters,\n      txParameters: this.txParameters,\n      forward: this.forward,\n      args: this.args,\n      externalAbis: this.externalAbis,\n    };\n  }\n\n  /**\n   * Sets the arguments for the function invocation.\n   *\n   * @param args - The arguments.\n   * @returns The instance of FunctionInvocationScope.\n   */\n  setArguments(...args: TArgs) {\n    this.args = args || [];\n    return this;\n  }\n\n  /**\n   * Sets the call parameters for the function invocation.\n   *\n   * @param callParams - The call parameters.\n   * @returns The instance of FunctionInvocationScope.\n   * @throws If the function is not payable and forward is set.\n   */\n  callParams(callParams: CallParams) {\n    if (!this.hasCallParamsGasLimit && callParams?.gasLimit !== undefined) {\n      this.hasCallParamsGasLimit = true;\n    }\n    this.callParameters = callParams;\n\n    if (callParams?.forward) {\n      if (!this.func.attributes.find((attr) => attr.name === 'payable')) {\n        throw new FuelError(\n          ErrorCode.TRANSACTION_ERROR,\n          `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`\n        );\n      }\n\n      this.forward = coinQuantityfy(callParams.forward);\n    }\n\n    // Update transaction script with new forward params\n    this.setArguments(...this.args);\n\n    // Update required coins\n    this.updateRequiredCoins();\n\n    return this;\n  }\n}\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { InputValue, JsonAbi } from '@fuel-ts/abi-coder';\nimport type {\n  Provider,\n  CoinQuantity,\n  CallResult,\n  Account,\n  TransferParams,\n  TransactionResponse,\n  TransactionCost,\n  AbstractAccount,\n} from '@fuel-ts/account';\nimport { ScriptTransactionRequest, Wallet } from '@fuel-ts/account';\nimport { Address } from '@fuel-ts/address';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport { InputType, TransactionType } from '@fuel-ts/transactions';\nimport { isDefined } from '@fuel-ts/utils';\nimport * as asm from '@fuels/vm-asm';\nimport { clone } from 'ramda';\n\nimport { getContractCallScript } from '../contract-call-script';\nimport { buildDryRunResult, buildFunctionResult } from '../response';\nimport type {\n  ContractCall,\n  InvocationScopeLike,\n  TxParams,\n  FunctionResult,\n  DryRunResult,\n  AbstractContract,\n  AbstractProgram,\n} from '../types';\nimport { assert, getAbisFromAllCalls } from '../utils';\n\n/**\n * Creates a contract call object based on the provided invocation scope.\n *\n * @param funcScope - The invocation scope containing the necessary information for the contract call.\n * @returns The contract call object.\n */\nfunction createContractCall(funcScope: InvocationScopeLike): ContractCall {\n  const { program, args, forward, func, callParameters, externalAbis } = funcScope.getCallConfig();\n  const data = func.encodeArguments(args as Array<InputValue>);\n\n  return {\n    contractId: (program as AbstractContract).id,\n    fnSelectorBytes: func.selectorBytes,\n    data,\n    assetId: forward?.assetId,\n    amount: forward?.amount,\n    gas: callParameters?.gasLimit,\n    externalContractsAbis: externalAbis,\n  };\n}\n\n/**\n * Base class for managing invocation scopes and preparing transactions.\n */\nexport class BaseInvocationScope<TReturn = any> {\n  protected transactionRequest: ScriptTransactionRequest;\n  protected program: AbstractProgram;\n  protected functionInvocationScopes: Array<InvocationScopeLike> = [];\n  protected txParameters?: TxParams;\n  protected requiredCoins: CoinQuantity[] = [];\n  protected isMultiCall: boolean = false;\n  protected hasCallParamsGasLimit: boolean = false; // flag to check if any of the callParams has gasLimit set\n  protected externalAbis: Record<string, JsonAbi> = {};\n  private addSignersCallback?: (\n    txRequest: ScriptTransactionRequest\n  ) => Promise<ScriptTransactionRequest>;\n\n  /**\n   * Constructs an instance of BaseInvocationScope.\n   *\n   * @param program - The abstract program to be invoked.\n   * @param isMultiCall - A flag indicating whether the invocation is a multi-call.\n   */\n  constructor(program: AbstractProgram, isMultiCall: boolean) {\n    this.program = program;\n    this.isMultiCall = isMultiCall;\n    this.transactionRequest = new ScriptTransactionRequest();\n  }\n\n  /**\n   * Getter for the contract calls.\n   *\n   * @returns An array of contract calls.\n   */\n  protected get calls() {\n    return this.functionInvocationScopes.map((funcScope) => createContractCall(funcScope));\n  }\n\n  /**\n   * Updates the script request with the current contract calls.\n   */\n  protected async updateScriptRequest() {\n    const provider = this.getProvider();\n    const {\n      consensusParameters: {\n        txParameters: { maxInputs },\n      },\n    } = await provider.getChain();\n    const contractCallScript = getContractCallScript(this.functionInvocationScopes, maxInputs);\n    this.transactionRequest.setScript(contractCallScript, this.calls);\n  }\n\n  /**\n   * Updates the transaction request with the current input/output.\n   */\n  protected updateContractInputAndOutput() {\n    const calls = this.calls;\n    calls.forEach((c) => {\n      if (c.contractId) {\n        this.transactionRequest.addContractInputAndOutput(c.contractId);\n      }\n      if (c.externalContractsAbis) {\n        Object.keys(c.externalContractsAbis).forEach((contractId) =>\n          this.transactionRequest.addContractInputAndOutput(Address.fromB256(contractId))\n        );\n      }\n    });\n  }\n\n  /**\n   * Gets the required coins for the transaction.\n   *\n   * @returns An array of required coin quantities.\n   */\n  protected getRequiredCoins(): Array<CoinQuantity> {\n    const forwardingAssets = this.calls\n      .map((call) => ({\n        assetId: String(call.assetId),\n        amount: bn(call.amount || 0),\n      }))\n      .filter(({ assetId, amount }) => assetId && !bn(amount).isZero());\n    return forwardingAssets;\n  }\n\n  /**\n   * Updates the required coins for the transaction.\n   */\n  protected updateRequiredCoins() {\n    const assets = this.getRequiredCoins();\n    const reduceForwardCoins = (\n      requiredCoins: Map<any, CoinQuantity>,\n      { assetId, amount }: CoinQuantity\n    ) => {\n      const currentAmount = requiredCoins.get(assetId)?.amount || bn(0);\n\n      return requiredCoins.set(assetId, {\n        assetId: String(assetId),\n        amount: currentAmount.add(amount),\n      });\n    };\n    this.requiredCoins = Array.from(\n      assets.reduce(reduceForwardCoins, new Map<any, CoinQuantity>()).values()\n    );\n  }\n\n  /**\n   * Adds a single call to the invocation scope.\n   *\n   * @param funcScope - The function scope to add.\n   * @returns The current instance of the class.\n   */\n  protected addCall(funcScope: InvocationScopeLike) {\n    this.addCalls([funcScope]);\n    return this;\n  }\n\n  /**\n   * Adds multiple calls to the invocation scope.\n   *\n   * @param funcScopes - An array of function scopes to add.\n   * @returns The current instance of the class.\n   */\n  protected addCalls(funcScopes: Array<InvocationScopeLike>) {\n    this.functionInvocationScopes.push(...funcScopes);\n    this.updateContractInputAndOutput();\n    this.updateRequiredCoins();\n    return this;\n  }\n\n  /**\n   * Prepares the transaction by updating the script request, required coins, and checking the gas limit.\n   */\n  protected async prepareTransaction() {\n    // @ts-expect-error Property 'initWasm' does exist on type and is defined\n    await asm.initWasm();\n\n    // Update request scripts before call\n    await this.updateScriptRequest();\n\n    // Update required coins before call\n    this.updateRequiredCoins();\n\n    // Check if gasLimit is less than the\n    // sum of all call gasLimits\n    this.checkGasLimitTotal();\n\n    if (this.transactionRequest.type === TransactionType.Script) {\n      this.transactionRequest.abis = getAbisFromAllCalls(this.functionInvocationScopes);\n    }\n  }\n\n  /**\n   * Checks if the total gas limit is within the acceptable range.\n   */\n  protected checkGasLimitTotal() {\n    const gasLimitOnCalls = this.calls.reduce((total, call) => total.add(call.gas || 0), bn(0));\n\n    if (this.transactionRequest.gasLimit.eq(0)) {\n      this.transactionRequest.gasLimit = gasLimitOnCalls;\n    } else if (gasLimitOnCalls.gt(this.transactionRequest.gasLimit)) {\n      throw new FuelError(\n        ErrorCode.TRANSACTION_ERROR,\n        \"Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls.\"\n      );\n    }\n  }\n\n  /**\n   * Gets the transaction cost for dry running the transaction.\n   *\n   * @param options - Optional transaction cost options.\n   * @returns The transaction cost details.\n   */\n  async getTransactionCost(): Promise<TransactionCost> {\n    const request = clone(await this.getTransactionRequest());\n    const account: AbstractAccount =\n      this.program.account ?? Wallet.generate({ provider: this.getProvider() });\n    return account.getTransactionCost(request, {\n      quantities: this.getRequiredCoins(),\n      signatureCallback: this.addSignersCallback,\n    });\n  }\n\n  /**\n   * Costs and funds the underlying transaction request.\n   *\n   * @returns The invocation scope as a funded transaction request.\n   */\n  async fundWithRequiredCoins(): Promise<ScriptTransactionRequest> {\n    let transactionRequest = await this.getTransactionRequest();\n    transactionRequest = clone(transactionRequest);\n\n    const txCost = await this.getTransactionCost();\n    const { gasUsed, missingContractIds, outputVariables, maxFee } = txCost;\n    this.setDefaultTxParams(transactionRequest, gasUsed, maxFee);\n    // Clean coin inputs before add new coins to the request\n    transactionRequest.inputs = transactionRequest.inputs.filter((i) => i.type !== InputType.Coin);\n\n    // Adding missing contract ids\n    missingContractIds.forEach((contractId) => {\n      transactionRequest.addContractInputAndOutput(Address.fromString(contractId));\n    });\n\n    // Adding required number of OutputVariables\n    transactionRequest.addVariableOutputs(outputVariables);\n\n    await this.program.account?.fund(transactionRequest, txCost);\n\n    if (this.addSignersCallback) {\n      await this.addSignersCallback(transactionRequest);\n    }\n    return transactionRequest;\n  }\n\n  /**\n   * Sets the transaction parameters.\n   *\n   * @param txParams - The transaction parameters to set.\n   * @returns The current instance of the class.\n   */\n  txParams(txParams: TxParams) {\n    this.txParameters = txParams;\n    const request = this.transactionRequest;\n\n    request.tip = bn(txParams.tip || request.tip);\n    request.gasLimit = bn(txParams.gasLimit || request.gasLimit);\n    request.maxFee = txParams.maxFee ? bn(txParams.maxFee) : request.maxFee;\n    request.witnessLimit = txParams.witnessLimit ? bn(txParams.witnessLimit) : request.witnessLimit;\n    request.maturity = txParams.maturity || request.maturity;\n\n    request.addVariableOutputs(this.txParameters?.variableOutputs || 0);\n\n    return this;\n  }\n\n  /**\n   * Adds contracts to the invocation scope.\n   *\n   * @param contracts - An array of contracts to add.\n   * @returns The current instance of the class.\n   */\n  addContracts(contracts: Array<AbstractContract>) {\n    contracts.forEach((contract) => {\n      this.transactionRequest.addContractInputAndOutput(contract.id);\n      this.externalAbis[contract.id.toB256()] = contract.interface.jsonAbi;\n    });\n    return this;\n  }\n\n  /**\n   * Adds an asset transfer to an Account on the contract call transaction request.\n   *\n   * @param transferParams - The object representing the transfer to be made.\n   * @returns The current instance of the class.\n   */\n  addTransfer(transferParams: TransferParams) {\n    const { amount, destination, assetId } = transferParams;\n    this.transactionRequest = this.transactionRequest.addCoinOutput(\n      Address.fromAddressOrString(destination),\n      amount,\n      assetId\n    );\n\n    return this;\n  }\n\n  /**\n   * Adds multiple transfers to the contract call transaction request.\n   *\n   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.\n   * @returns The current instance of the class.\n   */\n  addBatchTransfer(transferParams: TransferParams[]) {\n    transferParams.forEach(({ destination, amount, assetId }) => {\n      this.transactionRequest = this.transactionRequest.addCoinOutput(\n        Address.fromAddressOrString(destination),\n        amount,\n        assetId\n      );\n    });\n\n    return this;\n  }\n\n  addSigners(signers: Account | Account[]) {\n    this.addSignersCallback = (transactionRequest) =>\n      transactionRequest.addAccountWitnesses(signers);\n\n    return this;\n  }\n\n  /**\n   * Prepares and returns the transaction request object.\n   *\n   * @returns The prepared transaction request.\n   */\n  async getTransactionRequest(): Promise<ScriptTransactionRequest> {\n    await this.prepareTransaction();\n    return this.transactionRequest;\n  }\n\n  /**\n   * Submits the contract call transaction and returns a promise that resolves to an object\n   * containing the transaction ID and a function to wait for the result. The promise will resolve\n   * as soon as the transaction is submitted to the node.\n   *\n   * @returns A promise that resolves to an object containing:\n   * - `transactionId`: The ID of the submitted transaction.\n   * - `waitForResult`: A function that waits for the transaction result.\n   * @template T - The type of the return value.\n   */\n  async call<T = TReturn>(): Promise<{\n    transactionId: string;\n    waitForResult: () => Promise<FunctionResult<T>>;\n  }> {\n    assert(this.program.account, 'Wallet is required!');\n\n    const transactionRequest = await this.fundWithRequiredCoins();\n\n    const response = (await this.program.account.sendTransaction(transactionRequest, {\n      estimateTxDependencies: false,\n    })) as TransactionResponse;\n\n    const transactionId = response.id;\n\n    return {\n      transactionId,\n      waitForResult: async () =>\n        buildFunctionResult<T>({\n          funcScope: this.functionInvocationScopes,\n          isMultiCall: this.isMultiCall,\n          program: this.program,\n          transactionResponse: response,\n        }),\n    };\n  }\n\n  /**\n   * Simulates a transaction.\n   *\n   * @returns The result of the invocation call.\n   */\n  async simulate<T = TReturn>(): Promise<DryRunResult<T>> {\n    assert(this.program.account, 'Wallet is required!');\n\n    if (!('populateTransactionWitnessesSignature' in this.program.account)) {\n      throw new FuelError(\n        ErrorCode.ABI_MAIN_METHOD_MISSING,\n        'An unlocked wallet is required to simulate a contract call.'\n      );\n    }\n    const transactionRequest = await this.fundWithRequiredCoins();\n\n    const callResult = await this.program.account.simulateTransaction(transactionRequest, {\n      estimateTxDependencies: false,\n    });\n\n    return buildDryRunResult<T>({\n      funcScopes: this.functionInvocationScopes,\n      callResult,\n      isMultiCall: this.isMultiCall,\n    });\n  }\n\n  /**\n   * Executes a transaction in dry run mode.\n   *\n   * @returns The result of the invocation call.\n   */\n  async dryRun<T = TReturn>(): Promise<DryRunResult<T>> {\n    const { receipts } = await this.getTransactionCost();\n\n    const callResult: CallResult = {\n      receipts,\n    };\n\n    return buildDryRunResult<T>({\n      funcScopes: this.functionInvocationScopes,\n      callResult,\n      isMultiCall: this.isMultiCall,\n    });\n  }\n\n  async get<T = TReturn>(): Promise<DryRunResult<T>> {\n    const { receipts } = await this.getTransactionCost();\n\n    const callResult: CallResult = {\n      receipts,\n    };\n\n    return buildDryRunResult<T>({\n      funcScopes: this.functionInvocationScopes,\n      callResult,\n      isMultiCall: this.isMultiCall,\n    });\n  }\n\n  getProvider(): Provider {\n    const provider = <Provider>this.program.provider;\n\n    return provider;\n  }\n\n  /**\n   * Obtains the ID of a transaction.\n   *\n   * @param chainId - the chainId to use to hash the transaction with\n   * @returns the ID of the transaction.\n   */\n  async getTransactionId(chainId?: number): Promise<string> {\n    const chainIdToHash = chainId ?? (await this.getProvider().getChainId());\n\n    const transactionRequest = await this.getTransactionRequest();\n    return transactionRequest.getTransactionId(chainIdToHash);\n  }\n\n  /**\n   * In case the gasLimit is *not* set by the user, this method sets a default value.\n   */\n  private setDefaultTxParams(\n    transactionRequest: ScriptTransactionRequest,\n    gasUsed: BN,\n    maxFee: BN\n  ) {\n    const gasLimitSpecified = isDefined(this.txParameters?.gasLimit) || this.hasCallParamsGasLimit;\n    const maxFeeSpecified = isDefined(this.txParameters?.maxFee);\n\n    const { gasLimit: setGasLimit, maxFee: setMaxFee } = transactionRequest;\n\n    if (!gasLimitSpecified) {\n      transactionRequest.gasLimit = gasUsed;\n    } else if (setGasLimit.lt(gasUsed)) {\n      throw new FuelError(\n        ErrorCode.GAS_LIMIT_TOO_LOW,\n        `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`\n      );\n    }\n\n    if (!maxFeeSpecified) {\n      transactionRequest.maxFee = maxFee;\n    } else if (maxFee.gt(setMaxFee)) {\n      throw new FuelError(\n        ErrorCode.MAX_FEE_TOO_LOW,\n        `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`\n      );\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  WORD_SIZE,\n  B256Coder,\n  ASSET_ID_LEN,\n  BigNumberCoder,\n  CONTRACT_ID_LEN,\n} from '@fuel-ts/abi-coder';\nimport type {\n  CallResult,\n  TransactionResultCallReceipt,\n  TransactionResultReturnDataReceipt,\n  TransactionResultReturnReceipt,\n} from '@fuel-ts/account';\nimport type { Address } from '@fuel-ts/address';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport { ReceiptType } from '@fuel-ts/transactions';\nimport { concat, arrayify } from '@fuel-ts/utils';\nimport * as asm from '@fuels/vm-asm';\n\nimport { InstructionSet } from './instruction-set';\nimport type { EncodedScriptCall, ScriptResult } from './script-request';\nimport { decodeCallResult, ScriptRequest, calculateScriptDataBaseOffset } from './script-request';\nimport type { ContractCall, InvocationScopeLike } from './types';\n\ntype CallOpcodeParamsOffset = {\n  callDataOffset: number;\n  gasForwardedOffset: number;\n  amountOffset: number;\n  assetIdOffset: number;\n};\n\nconst DEFAULT_OPCODE_PARAMS: CallOpcodeParamsOffset = {\n  assetIdOffset: 0,\n  amountOffset: 0,\n  gasForwardedOffset: 0,\n  callDataOffset: 0,\n};\n\n// During a script execution, this script's contract id is the **null** contract id\nconst SCRIPT_WRAPPER_CONTRACT_ID = ZeroBytes32;\n\n// Returns the VM instructions for calling a contract method\n// We use the [`Opcode`] to call a contract: [`CALL`](Opcode::CALL)\n// pointing at the following registers:\n//\n// 0x10 Script data offset\n// 0x11 Coin amount\n// 0x12 Asset ID\n// 0x13 Gas forwarded\n//\n// These are arbitrary non-reserved registers, no special meaning\nconst getSingleCallInstructions = ({\n  callDataOffset,\n  gasForwardedOffset,\n  amountOffset,\n  assetIdOffset,\n}: CallOpcodeParamsOffset): InstructionSet => {\n  const inst = new InstructionSet(\n    asm.movi(0x10, callDataOffset),\n    asm.movi(0x11, amountOffset),\n    asm.lw(0x11, 0x11, 0),\n    asm.movi(0x12, assetIdOffset)\n  );\n\n  if (gasForwardedOffset) {\n    inst.push(\n      asm.movi(0x13, gasForwardedOffset),\n      asm.lw(0x13, 0x13, 0),\n      asm.call(0x10, 0x11, 0x12, 0x13)\n    );\n  } else {\n    inst.push(asm.call(0x10, 0x11, 0x12, asm.RegId.cgas().to_u8()));\n  }\n\n  return inst;\n};\n// Given a list of contract calls, create the actual opcodes used to call the contract\nfunction getInstructions(offsets: CallOpcodeParamsOffset[]): Uint8Array {\n  if (!offsets.length) {\n    return new Uint8Array();\n  }\n\n  const multiCallInstructions = new InstructionSet();\n  for (let i = 0; i < offsets.length; i += 1) {\n    multiCallInstructions.extend(getSingleCallInstructions(offsets[i]).entries());\n  }\n\n  multiCallInstructions.push(asm.ret(0x01));\n  return multiCallInstructions.toBytes();\n}\n\ntype ReturnReceipt = TransactionResultReturnReceipt | TransactionResultReturnDataReceipt;\n\nconst isReturnType = (type: ReturnReceipt['type']) =>\n  type === ReceiptType.Return || type === ReceiptType.ReturnData;\n\nconst getMainCallReceipt = (\n  receipts: TransactionResultCallReceipt[],\n  contractId: string\n): TransactionResultCallReceipt | undefined =>\n  receipts.find(\n    ({ type, id, to }) =>\n      type === ReceiptType.Call && id === SCRIPT_WRAPPER_CONTRACT_ID && to === contractId\n  );\n\nconst scriptResultDecoder = (contractId: Address) => (result: ScriptResult) => {\n  if (toNumber(result.code) !== 0) {\n    throw new FuelError(ErrorCode.SCRIPT_REVERTED, `Transaction reverted.`);\n  }\n\n  const mainCallResult = getMainCallReceipt(\n    result.receipts as TransactionResultCallReceipt[],\n    contractId.toB256()\n  );\n  const mainCallInstructionStart = bn(mainCallResult?.is);\n\n  const receipts = result.receipts as ReturnReceipt[];\n  return receipts\n    .filter(({ type }) => isReturnType(type))\n    .flatMap((receipt: ReturnReceipt) => {\n      if (!mainCallInstructionStart.eq(bn(receipt.is))) {\n        return [];\n      }\n      if (receipt.type === ReceiptType.Return) {\n        return [new BigNumberCoder('u64').encode((receipt as TransactionResultReturnReceipt).val)];\n      }\n      if (receipt.type === ReceiptType.ReturnData) {\n        const encodedScriptReturn = arrayify(receipt.data);\n\n        return [encodedScriptReturn];\n      }\n\n      return [new Uint8Array()];\n    });\n};\n\nexport const decodeContractCallScriptResult = (\n  callResult: CallResult,\n  contractId: Address,\n  logs: Array<any> = []\n): Uint8Array[] => decodeCallResult(callResult, scriptResultDecoder(contractId), logs);\n\nconst getCallInstructionsLength = (contractCalls: ContractCall[]): number =>\n  contractCalls.reduce(\n    (sum, call) => {\n      const offset: CallOpcodeParamsOffset = { ...DEFAULT_OPCODE_PARAMS };\n      if (call.gas) {\n        offset.gasForwardedOffset = 1;\n      }\n\n      return sum + getSingleCallInstructions(offset).byteLength();\n    },\n    asm.Instruction.size() // placeholder for single RET instruction which is added later\n  );\n\nexport const getContractCallScript = (\n  functionScopes: InvocationScopeLike[],\n  maxInputs: BN\n): ScriptRequest<ContractCall[], Uint8Array[]> =>\n  new ScriptRequest<ContractCall[], Uint8Array[]>(\n    // Script to call the contract, start with stub size matching length of calls\n    getInstructions(new Array(functionScopes.length).fill(DEFAULT_OPCODE_PARAMS)),\n    (contractCalls): EncodedScriptCall => {\n      const TOTAL_CALLS = contractCalls.length;\n\n      if (TOTAL_CALLS === 0) {\n        return { data: new Uint8Array(), script: new Uint8Array() };\n      }\n\n      // Get total data offset AFTER all scripts\n      const callInstructionsLength = getCallInstructionsLength(contractCalls);\n\n      // Pad length\n      const paddingLength = (8 - (callInstructionsLength % 8)) % 8;\n      const paddedInstructionsLength = callInstructionsLength + paddingLength;\n\n      // Base offset\n      const dataOffset =\n        calculateScriptDataBaseOffset(maxInputs.toNumber()) + paddedInstructionsLength;\n\n      // The data for each call is ordered into segments\n      const paramOffsets: CallOpcodeParamsOffset[] = [];\n      // the data about the contract output\n      let segmentOffset = dataOffset;\n\n      const scriptData: Uint8Array[] = [];\n      for (let i = 0; i < TOTAL_CALLS; i += 1) {\n        const call = contractCalls[i];\n\n        const amountOffset = segmentOffset;\n        const assetIdOffset = amountOffset + WORD_SIZE;\n        const callDataOffset = assetIdOffset + ASSET_ID_LEN;\n        const encodedSelectorOffset = callDataOffset + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;\n        const encodedArgsOffset = encodedSelectorOffset + call.fnSelectorBytes.byteLength;\n        const encodedArgs = arrayify(call.data);\n        let gasForwardedOffset = 0;\n\n        // 1. Amount\n        scriptData.push(new BigNumberCoder('u64').encode(call.amount || 0));\n        // 2. Asset ID\n        scriptData.push(new B256Coder().encode(call.assetId?.toString() || ZeroBytes32));\n        // 3. Contract ID\n        scriptData.push(call.contractId.toBytes());\n        // 4. Function selector offset\n        scriptData.push(new BigNumberCoder('u64').encode(encodedSelectorOffset));\n        // 5. Encoded argument offset\n        scriptData.push(new BigNumberCoder('u64').encode(encodedArgsOffset));\n        // 6. Encoded function selector\n        scriptData.push(call.fnSelectorBytes);\n        // 7. Encoded arguments\n        scriptData.push(encodedArgs);\n\n        // 8. Gas to be forwarded\n        if (call.gas) {\n          scriptData.push(new BigNumberCoder('u64').encode(call.gas));\n          gasForwardedOffset = encodedArgsOffset + encodedArgs.byteLength;\n        }\n\n        const callParamOffsets: CallOpcodeParamsOffset = {\n          amountOffset,\n          assetIdOffset,\n          gasForwardedOffset,\n          callDataOffset,\n        };\n\n        // store param offsets for asm instructions later\n        paramOffsets.push(callParamOffsets);\n        segmentOffset = dataOffset + concat(scriptData).byteLength;\n      }\n\n      // get asm instructions\n      const script = getInstructions(paramOffsets);\n      const finalScriptData = concat(scriptData);\n      return { data: finalScriptData, script };\n    },\n    () => [new Uint8Array()]\n  );\n","import { concat, hexlify } from '@fuel-ts/utils';\nimport type * as asm from '@fuels/vm-asm';\n\n/**\n * A wrapper around fuel-asm to make dynamic instructions and convert to different formats\n */\nexport class InstructionSet {\n  #operations: asm.Instruction[];\n\n  constructor(...args: asm.Instruction[]) {\n    this.#operations = args || [];\n  }\n\n  entries(): asm.Instruction[] {\n    return this.#operations;\n  }\n\n  push(...args: asm.Instruction[]) {\n    this.#operations.push(...args);\n  }\n\n  concat(ops: asm.Instruction[]): asm.Instruction[] {\n    return this.#operations.concat(ops);\n  }\n\n  extend(ops: asm.Instruction[]) {\n    this.#operations.push(...ops);\n  }\n\n  toBytes(): Uint8Array {\n    return concat(\n      this.#operations.reduce((instructions, line) => {\n        instructions.push(line.to_bytes());\n        return instructions;\n      }, [] as Uint8Array[])\n    );\n  }\n\n  toHex(): string {\n    return hexlify(this.toBytes());\n  }\n\n  toString() {\n    return `Program:\\n${JSON.stringify(this.#operations, null, 2)}`;\n  }\n\n  byteLength() {\n    return this.toBytes().byteLength;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  ASSET_ID_LEN,\n  CONTRACT_ID_LEN,\n  SCRIPT_FIXED_SIZE,\n  WORD_SIZE,\n  calculateVmTxMemory,\n} from '@fuel-ts/abi-coder';\nimport type {\n  TransactionResultReturnDataReceipt,\n  TransactionResultRevertReceipt,\n  CallResult,\n  TransactionResultReceipt,\n  TransactionResultReturnReceipt,\n  TransactionResultScriptResultReceipt,\n  DryRunFailureStatusFragment,\n} from '@fuel-ts/account';\nimport { extractTxError } from '@fuel-ts/account';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\nimport type { ReceiptScriptResult } from '@fuel-ts/transactions';\nimport { ReceiptType } from '@fuel-ts/transactions';\nimport type { BytesLike } from '@fuel-ts/utils';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport type { CallConfig } from './types';\n\nexport const calculateScriptDataBaseOffset = (maxInputs: number) =>\n  SCRIPT_FIXED_SIZE + calculateVmTxMemory({ maxInputs });\nexport const POINTER_DATA_OFFSET =\n  WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;\n/**\n * Represents a script result, containing information about the script execution.\n */\nexport type ScriptResult = {\n  code: BN;\n  gasUsed: BN;\n  receipts: TransactionResultReceipt[];\n  scriptResultReceipt: TransactionResultScriptResultReceipt;\n  returnReceipt:\n    | TransactionResultReturnReceipt\n    | TransactionResultReturnDataReceipt\n    | TransactionResultRevertReceipt;\n  callResult: CallResult;\n};\n\n/**\n * Converts a CallResult to a ScriptResult by extracting relevant information.\n *\n * @param callResult - The CallResult from the script call.\n * @returns The converted ScriptResult.\n */\nfunction callResultToScriptResult(callResult: CallResult): ScriptResult {\n  const receipts = [...callResult.receipts];\n\n  let scriptResultReceipt: ReceiptScriptResult | undefined;\n  let returnReceipt:\n    | TransactionResultReturnReceipt\n    | TransactionResultReturnDataReceipt\n    | TransactionResultRevertReceipt\n    | undefined;\n\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType.ScriptResult) {\n      scriptResultReceipt = receipt;\n    } else if (\n      receipt.type === ReceiptType.Return ||\n      receipt.type === ReceiptType.ReturnData ||\n      receipt.type === ReceiptType.Revert\n    ) {\n      returnReceipt = receipt;\n    }\n  });\n\n  if (!scriptResultReceipt || !returnReceipt) {\n    throw new FuelError(ErrorCode.SCRIPT_REVERTED, `Transaction reverted.`);\n  }\n\n  const scriptResult: ScriptResult = {\n    code: scriptResultReceipt.result,\n    gasUsed: scriptResultReceipt.gasUsed,\n    receipts,\n    scriptResultReceipt,\n    returnReceipt,\n    callResult,\n  };\n\n  return scriptResult;\n}\n\n/**\n * Decodes a CallResult using the provided decoder function.\n *\n * @param callResult - The CallResult to decode.\n * @param decoder - The decoding function to apply on the ScriptResult.\n * @param logs - Optional logs associated with the decoding.\n * @returns The decoded result.\n * @throws Throws an error if decoding fails.\n */\nexport function decodeCallResult<TResult>(\n  callResult: CallResult,\n  decoder: (scriptResult: ScriptResult) => TResult,\n  logs: Array<any> = []\n): TResult {\n  try {\n    const scriptResult = callResultToScriptResult(callResult);\n    return decoder(scriptResult);\n  } catch (error) {\n    if ((<FuelError>error).code === ErrorCode.SCRIPT_REVERTED) {\n      const statusReason = (<DryRunFailureStatusFragment>callResult?.dryRunStatus)?.reason;\n      throw extractTxError({\n        logs,\n        receipts: callResult.receipts,\n        statusReason,\n      });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Converts a CallResult to an invocation result based on the provided call configuration.\n *\n * @param callResult - The CallResult from the script call.\n * @param call - The call configuration.\n * @param logs - Optional logs associated with the decoding.\n * @returns The decoded invocation result.\n */\nexport function callResultToInvocationResult<TReturn>(\n  callResult: CallResult,\n  call: CallConfig,\n  logs?: unknown[]\n): TReturn {\n  return decodeCallResult(\n    callResult,\n    (scriptResult: ScriptResult) => {\n      if (scriptResult.returnReceipt.type === ReceiptType.Revert) {\n        throw new FuelError(\n          ErrorCode.SCRIPT_REVERTED,\n          `Script Reverted. Logs: ${JSON.stringify(logs)}`\n        );\n      }\n\n      if (\n        scriptResult.returnReceipt.type !== ReceiptType.Return &&\n        scriptResult.returnReceipt.type !== ReceiptType.ReturnData\n      ) {\n        const { type } = scriptResult.returnReceipt;\n        throw new FuelError(\n          ErrorCode.SCRIPT_REVERTED,\n          `Script Return Type [${type}] Invalid. Logs: ${JSON.stringify({\n            logs,\n            receipt: scriptResult.returnReceipt,\n          })}`\n        );\n      }\n\n      let value;\n      if (scriptResult.returnReceipt.type === ReceiptType.Return) {\n        value = scriptResult.returnReceipt.val;\n      }\n      if (scriptResult.returnReceipt.type === ReceiptType.ReturnData) {\n        const decoded = call.func.decodeOutput(scriptResult.returnReceipt.data);\n        value = decoded[0];\n      }\n\n      return value as TReturn;\n    },\n    logs\n  );\n}\n\nexport type EncodedScriptCall = Uint8Array | { data: Uint8Array; script: Uint8Array };\n\n/**\n * `ScriptRequest` provides functionality to encode and decode script data and results.\n *\n * @template TData - Type of the script data.\n * @template TResult - Type of the script result.\n */\nexport class ScriptRequest<TData = void, TResult = void> {\n  /**\n   * The bytes of the script.\n   */\n  bytes: Uint8Array;\n\n  /**\n   * A function to encode the script data.\n   */\n  scriptDataEncoder: (data: TData) => EncodedScriptCall;\n\n  /**\n   * A function to decode the script result.\n   */\n  scriptResultDecoder: (scriptResult: ScriptResult) => TResult;\n\n  /**\n   * Creates an instance of the ScriptRequest class.\n   *\n   * @param bytes - The bytes of the script.\n   * @param scriptDataEncoder - The script data encoder function.\n   * @param scriptResultDecoder - The script result decoder function.\n   */\n  constructor(\n    bytes: BytesLike,\n    scriptDataEncoder: (data: TData) => EncodedScriptCall,\n    scriptResultDecoder: (scriptResult: ScriptResult) => TResult\n  ) {\n    this.bytes = arrayify(bytes);\n    this.scriptDataEncoder = scriptDataEncoder;\n    this.scriptResultDecoder = scriptResultDecoder;\n  }\n\n  /**\n   * Gets the script data offset for the given bytes.\n   *\n   * @param byteLength - The byte length of the script.\n   * @param maxInputs - The maxInputs value from the chain's consensus params.\n   * @returns The script data offset.\n   */\n  static getScriptDataOffsetWithScriptBytes(byteLength: number, maxInputs: number): number {\n    const scriptDataBaseOffset = calculateVmTxMemory({ maxInputs }) + SCRIPT_FIXED_SIZE;\n    return scriptDataBaseOffset + byteLength;\n  }\n\n  /**\n   * Gets the script data offset.\n   *\n   * @param maxInputs - The maxInputs value from the chain's consensus params.\n   * @returns The script data offset.\n   */\n  getScriptDataOffset(maxInputs: number) {\n    return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);\n  }\n\n  /**\n   * Encodes the data for a script call.\n   *\n   * @param data - The script data.\n   * @returns The encoded data.\n   */\n  encodeScriptData(data: TData): Uint8Array {\n    const callScript = this.scriptDataEncoder(data);\n    // if Uint8Array\n    if (ArrayBuffer.isView(callScript)) {\n      return callScript;\n    }\n\n    // object\n    this.bytes = arrayify(callScript.script);\n    return callScript.data;\n  }\n\n  /**\n   * Decodes the result of a script call.\n   *\n   * @param callResult - The CallResult from the script call.\n   * @param logs - Optional logs associated with the decoding.\n   * @returns The decoded result.\n   */\n  decodeCallResult(callResult: CallResult, logs: Array<any> = []): TResult {\n    return decodeCallResult(callResult, this.scriptResultDecoder, logs);\n  }\n}\n","import type {\n  TransactionResultReceipt,\n  TransactionResponse,\n  TransactionResult,\n  CallResult,\n} from '@fuel-ts/account';\nimport { getGasUsedFromReceipts } from '@fuel-ts/account';\nimport type { TransactionType } from '@fuel-ts/transactions';\n\nimport { decodeContractCallScriptResult } from './contract-call-script';\nimport { callResultToInvocationResult } from './script-request';\nimport type {\n  AbstractContract,\n  AbstractProgram,\n  InvocationScopeLike,\n  FunctionResult,\n  DryRunResult,\n} from './types';\nimport { getResultLogs } from './utils';\n\n/** @hidden */\nexport const extractInvocationResult = <T>(\n  functionScopes: Array<InvocationScopeLike>,\n  receipts: TransactionResultReceipt[],\n  isMultiCall: boolean,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  logs: any[]\n) => {\n  const mainCallConfig = functionScopes[0]?.getCallConfig();\n\n  if (functionScopes.length === 1 && mainCallConfig && 'bytes' in mainCallConfig.program) {\n    return callResultToInvocationResult<T>({ receipts }, mainCallConfig, logs);\n  }\n  const encodedResults = decodeContractCallScriptResult(\n    { receipts },\n    (mainCallConfig?.program as AbstractContract).id,\n    logs\n  );\n\n  const decodedResults = encodedResults.map((encodedResult, i) => {\n    const { func } = functionScopes[i].getCallConfig();\n    return func.decodeOutput(encodedResult)?.[0];\n  });\n\n  return (isMultiCall ? decodedResults : decodedResults?.[0]) as T;\n};\n\ntype BuiltFunctionResultParams = {\n  funcScope: InvocationScopeLike | Array<InvocationScopeLike>;\n  transactionResponse: TransactionResponse;\n  isMultiCall: boolean;\n  program: AbstractProgram;\n};\n\n/** @hidden */\nexport const buildFunctionResult = async <T>(\n  params: BuiltFunctionResultParams\n): Promise<FunctionResult<T>> => {\n  const { funcScope, isMultiCall, program, transactionResponse } = params;\n\n  const txResult = await transactionResponse.waitForResult();\n\n  const { receipts } = txResult;\n\n  const functionScopes = Array.isArray(funcScope) ? funcScope : [funcScope];\n  const mainCallConfig = functionScopes[0]?.getCallConfig();\n\n  const logs = getResultLogs(receipts, mainCallConfig, functionScopes);\n  const value = extractInvocationResult<T>(functionScopes, receipts, isMultiCall, logs);\n  const gasUsed = getGasUsedFromReceipts(receipts);\n\n  const submitResult: FunctionResult<T> = {\n    isMultiCall,\n    functionScopes,\n    value,\n    program,\n    transactionResult: txResult as TransactionResult<TransactionType.Script>,\n    transactionResponse,\n    transactionId: transactionResponse.id,\n    logs,\n    gasUsed,\n  };\n\n  return submitResult;\n};\n\ntype BuiltDryRunResultParams = {\n  funcScopes: InvocationScopeLike | Array<InvocationScopeLike>;\n  callResult: CallResult;\n  isMultiCall: boolean;\n};\n\n/** @hidden * */\nexport const buildDryRunResult = <T>(params: BuiltDryRunResultParams): DryRunResult<T> => {\n  const { funcScopes, callResult, isMultiCall } = params;\n  const { receipts } = callResult;\n  const functionScopes = Array.isArray(funcScopes) ? funcScopes : [funcScopes];\n  const mainCallConfig = functionScopes[0]?.getCallConfig();\n\n  const logs = getResultLogs(receipts, mainCallConfig, functionScopes);\n  const value = extractInvocationResult<T>(functionScopes, receipts, isMultiCall, logs);\n  const gasUsed = getGasUsedFromReceipts(receipts);\n\n  const submitResult: DryRunResult<T> = {\n    functionScopes,\n    callResult,\n    isMultiCall,\n    gasUsed,\n    value,\n  };\n\n  return submitResult;\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { AbstractContract } from '../types';\n\nimport { BaseInvocationScope } from './base-invocation-scope';\nimport type { FunctionInvocationScope } from './invocation-scope';\n\n/**\n * Represents a scope for invoking multiple calls.\n *\n * @template TReturn - The type of the return value.\n */\nexport class MultiCallInvocationScope<TReturn = any> extends BaseInvocationScope<TReturn> {\n  /**\n   * Constructs an instance of MultiCallInvocationScope.\n   *\n   * @param contract - The contract.\n   * @param funcScopes - An array of function invocation scopes.\n   */\n  constructor(contract: AbstractContract, funcScopes: Array<FunctionInvocationScope>) {\n    super(contract, true);\n    this.addCalls(funcScopes);\n  }\n\n  /**\n   * Adds a single function invocation scope to the multi-call invocation scope.\n   *\n   * @param funcScope - The function invocation scope.\n   * @returns The instance of MultiCallInvocationScope.\n   */\n  override addCall(funcScope: FunctionInvocationScope) {\n    return super.addCalls([funcScope]);\n  }\n\n  /**\n   * Adds multiple function invocation scopes to the multi-call invocation scope.\n   *\n   * @param funcScopes - An array of function invocation scopes.\n   * @returns The instance of MultiCallInvocationScope.\n   */\n  override addCalls(funcScopes: Array<FunctionInvocationScope>) {\n    return super.addCalls(funcScopes);\n  }\n}\n","import type { FunctionFragment, JsonAbi } from '@fuel-ts/abi-coder';\nimport { Interface } from '@fuel-ts/abi-coder';\nimport type { Account, Provider } from '@fuel-ts/account';\nimport { Address } from '@fuel-ts/address';\nimport type { BytesLike } from '@fuel-ts/utils';\n\nimport { FunctionInvocationScope } from './functions/invocation-scope';\nimport { MultiCallInvocationScope } from './functions/multicall-scope';\nimport type { AbstractContract, InvokeFunction, InvokeFunctions } from './types';\n\n/**\n * `Contract` provides a way to interact with the contract program type.\n */\nexport default class Contract implements AbstractContract {\n  /**\n   * The unique contract identifier.\n   */\n  id!: Address;\n\n  /**\n   * The provider for interacting with the contract.\n   */\n  provider!: Provider;\n\n  /**\n   * The contract's ABI interface.\n   */\n  interface!: Interface;\n\n  /**\n   * The account associated with the contract, if available.\n   */\n  account!: Account | null;\n\n  /**\n   * A collection of functions available on the contract.\n   */\n  functions: InvokeFunctions = {};\n\n  /**\n   * Creates an instance of the Contract class.\n   *\n   * @param id - The contract's address.\n   * @param abi - The contract's ABI (JSON ABI or Interface instance).\n   * @param accountOrProvider - The account or provider for interaction.\n   */\n  constructor(\n    id: string | Address,\n    abi: JsonAbi | Interface,\n    accountOrProvider: Account | Provider\n  ) {\n    this.interface = abi instanceof Interface ? abi : new Interface(abi);\n    this.id = Address.fromAddressOrString(id);\n\n    /**\n      Instead of using `instanceof` to compare classes, we instead check\n      if `accountOrProvider` have a `provider` property inside. If yes,\n      than we assume it's a Wallet.\n\n      This approach is safer than using `instanceof` because it\n      there might be different versions and bundles of the library.\n\n      The same is done at:\n        - ./contract-factory.ts\n\n      @see ContractFactory\n    */\n    if (accountOrProvider && 'provider' in accountOrProvider) {\n      this.provider = accountOrProvider.provider;\n      this.account = accountOrProvider;\n    } else {\n      this.provider = accountOrProvider;\n      this.account = null;\n    }\n\n    Object.keys(this.interface.functions).forEach((name) => {\n      const fragment = this.interface.getFunction(name);\n      Object.defineProperty(this.functions, fragment.name, {\n        value: this.buildFunction(fragment),\n        writable: false,\n      });\n    });\n  }\n\n  /**\n   * Build a function invocation scope for the provided function fragment.\n   *\n   * @param func - The function fragment to build a scope for.\n   * @returns A function that creates a FunctionInvocationScope.\n   */\n  buildFunction(func: FunctionFragment) {\n    return (() => {\n      const funcInvocationScopeCreator = (...args: Array<unknown>) =>\n        new FunctionInvocationScope(this, func, args);\n\n      Object.defineProperty(funcInvocationScopeCreator, 'isReadOnly', {\n        value: () => func.isReadOnly(),\n        writable: false,\n      });\n\n      return funcInvocationScopeCreator;\n    })() as InvokeFunction;\n  }\n\n  /**\n   * Create a multi-call invocation scope for the provided function invocation scopes.\n   *\n   * @param calls - An array of FunctionInvocationScopes to execute in a batch.\n   * @returns A MultiCallInvocationScope instance.\n   */\n  multiCall(calls: Array<FunctionInvocationScope>) {\n    return new MultiCallInvocationScope(this, calls);\n  }\n\n  /**\n   * Get the balance for a given asset ID for this contract.\n   *\n   * @param assetId - The specified asset ID.\n   * @returns The balance of the contract for the specified asset.\n   */\n  getBalance(assetId: BytesLike) {\n    return this.provider.getContractBalance(this.id, assetId);\n  }\n}\n"],"mappings":"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","names":["ErrorCode","FuelError","ErrorCode","FuelError","bn","asm","WORD_SIZE","ASSET_ID_LEN","CONTRACT_ID_LEN","ErrorCode","FuelError","ReceiptType","concat","arrayify","ErrorCode","FuelError","call","scriptResultDecoder","ReceiptType","FuelError","ErrorCode","arrayify","call","WORD_SIZE","ASSET_ID_LEN","CONTRACT_ID_LEN","concat","call","bn","FuelError","ErrorCode","FuelError","ErrorCode","Address","Address"]}