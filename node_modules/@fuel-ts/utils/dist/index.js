"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DateTime: () => DateTime,
  arrayify: () => arrayify,
  assertUnreachable: () => assertUnreachable,
  capitalizeString: () => capitalizeString,
  chunkAndPadBytes: () => chunkAndPadBytes,
  compressBytecode: () => compressBytecode,
  concat: () => concat,
  concatBytes: () => concatBytes,
  dataSlice: () => dataSlice,
  decodeBase58: () => decodeBase58,
  decompressBytecode: () => decompressBytecode,
  defaultConsensusKey: () => defaultConsensusKey,
  defaultSnapshotConfigs: () => defaultSnapshotConfigs,
  encodeBase58: () => encodeBase58,
  hexlify: () => hexlify,
  isDefined: () => isDefined,
  normalizeString: () => normalizeString,
  sleep: () => sleep,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8String: () => toUtf8String
});
module.exports = __toCommonJS(src_exports);

// src/utils/capitalizeString.ts
var capitalizeString = (str) => {
  if (!str.length) {
    return str;
  }
  return str[0].toUpperCase() + str.slice(1);
};

// src/utils/chunkAndPadBytes.ts
var chunkAndPadBytes = (bytes, chunkSize) => {
  const chunks = [];
  for (let offset = 0; offset < bytes.length; offset += chunkSize) {
    const chunk = new Uint8Array(chunkSize);
    chunk.set(bytes.slice(offset, offset + chunkSize));
    chunks.push(chunk);
  }
  const lastChunk = chunks[chunks.length - 1];
  const remainingBytes = bytes.length % chunkSize;
  const paddedChunkLength = remainingBytes + (8 - remainingBytes % 8) % 8;
  const newChunk = lastChunk.slice(0, paddedChunkLength);
  chunks[chunks.length - 1] = newChunk;
  return chunks;
};

// src/utils/arrayify.ts
var import_errors = require("@fuel-ts/errors");
var arrayify = (value, name, copy = true) => {
  if (value instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  const nameMessage = name ? ` ${name} -` : "";
  const message = `invalid data:${nameMessage} ${value}
If you are attempting to transform a hex value, please make sure it is being passed as a string and wrapped in quotes.`;
  throw new import_errors.FuelError(import_errors.ErrorCode.INVALID_DATA, message);
};

// src/utils/concat.ts
var concatBytes = (arrays) => {
  const byteArrays = arrays.map((array) => {
    if (array instanceof Uint8Array) {
      return array;
    }
    return Uint8Array.from(array);
  });
  const totalSize = byteArrays.reduce((accum, item) => accum + item.length, 0);
  const concatenated = new Uint8Array(totalSize);
  byteArrays.reduce((offset, object) => {
    concatenated.set(object, offset);
    return offset + object.length;
  }, 0);
  return concatenated;
};
var concat = (arrays) => {
  const bytes = arrays.map((v) => arrayify(v));
  return concatBytes(bytes);
};

// src/utils/hexlify.ts
var HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes = arrayify(data);
  let result = "0x";
  for (let i = 0; i < bytes.length; i++) {
    const v = bytes[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}

// src/utils/normalizeString.ts
var import_errors2 = require("@fuel-ts/errors");
var normalizeString = (str) => {
  const transformations = [
    (s) => s.replace(/\s+/g, "-"),
    // spaces to -
    (s) => s.replace(/\./g, "-"),
    // dots to -
    (s) => s.replace(/_/g, "-"),
    // underscore to -
    (s) => s.replace(/-[a-z]/g, (match) => match.slice(-1).toUpperCase()),
    // delete '-' and capitalize the letter after them
    (s) => s.replace(/-/g, ""),
    // delete any '-' left
    (s) => s.replace(/^\d+/, ""),
    // removes leading digits
    (s) => s[0].toUpperCase() + s.slice(1)
    // capitalize first letter
  ];
  const output = transformations.reduce((s, t) => t(s), str);
  if (output === "") {
    const errMsg = `The provided string '${str}' results in an empty output after`.concat(
      ` normalization, therefore, it can't normalize string.`
    );
    throw new import_errors2.FuelError(import_errors2.ErrorCode.PARSE_FAILED, errMsg);
  }
  return output;
};

// src/utils/date-time.ts
var TAI64_LEAP_SECONDS = 37;
var TAI64_UNIX_OFFSET = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);
var msToSeconds = (ms) => Math.floor(ms / 1e3);
var secondsToMs = (seconds) => seconds * 1e3;
var tai64ToUnixSeconds = (tai64) => Number(BigInt(tai64) - TAI64_UNIX_OFFSET);
var unixSecondsToTai64 = (unixSeconds) => String(BigInt(unixSeconds) + TAI64_UNIX_OFFSET);
var tai64ToUnixMilliseconds = (tai64) => secondsToMs(tai64ToUnixSeconds(tai64));
var _DateTime = class extends Date {
  /**
   * Generates a new DateTime instance from a Tai64 timestamp.
   *
   * @param tai64 - Tai64 timestamp
   * @returns a new DateTime instance
   */
  static fromTai64(tai64) {
    return new _DateTime(tai64ToUnixMilliseconds(tai64));
  }
  /**
   * @param unixMilliseconds - unix milliseconds timestamp
   * @returns a new DateTime instance
   */
  static fromUnixMilliseconds(unixMilliseconds) {
    return new _DateTime(unixMilliseconds);
  }
  /**
   * @param unixSeconds - unix seconds timestamp
   * @returns a new DateTime instance
   */
  static fromUnixSeconds(unixSeconds) {
    return new _DateTime(secondsToMs(unixSeconds));
  }
  /**
   * Hide the constructor to prevent direct instantiation.
   */
  constructor(date) {
    super(date);
  }
  /**
   * Returns the Tai64 timestamp.
   *
   * @returns the Tai64 timestamp
   */
  toTai64() {
    return unixSecondsToTai64(this.toUnixSeconds());
  }
  /**
   * @returns the unix milliseconds timestamp
   */
  toUnixMilliseconds() {
    return this.getTime();
  }
  /**
   * @returns the unix seconds timestamp
   */
  toUnixSeconds() {
    return msToSeconds(this.getTime());
  }
};
var DateTime = _DateTime;
__publicField(DateTime, "TAI64_NULL", "");

// src/utils/sleep.ts
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(true);
    }, time);
  });
}

// src/utils/defaultSnapshots/chainConfig.json
var chainConfig_default = {
  chain_name: "local_testnet",
  consensus_parameters: {
    V2: {
      tx_params: {
        V1: {
          max_inputs: 255,
          max_outputs: 255,
          max_witnesses: 255,
          max_gas_per_tx: 3e7,
          max_size: 112640,
          max_bytecode_subsections: 256
        }
      },
      predicate_params: {
        V1: {
          max_predicate_length: 24576,
          max_predicate_data_length: 24576,
          max_message_data_length: 102400,
          max_gas_per_predicate: 1e6
        }
      },
      script_params: {
        V1: {
          max_script_length: 102400,
          max_script_data_length: 102400
        }
      },
      contract_params: {
        V1: {
          contract_max_size: 112640,
          max_storage_slots: 1760
        }
      },
      fee_params: {
        V1: {
          gas_price_factor: 115e4,
          gas_per_byte: 63
        }
      },
      chain_id: 0,
      gas_costs: {
        V4: {
          add: 2,
          addi: 2,
          and: 2,
          andi: 2,
          bal: 274,
          bhei: 2,
          bhsh: 2,
          burn: 7566,
          cb: 2,
          cfsi: 2,
          div: 2,
          divi: 2,
          eck1: 1489,
          ecr1: 20513,
          eq: 2,
          exp: 2,
          expi: 2,
          flag: 2,
          gm: 2,
          gt: 2,
          gtf: 3,
          ji: 2,
          jmp: 2,
          jne: 2,
          jnei: 2,
          jnzi: 2,
          jmpf: 2,
          jmpb: 2,
          jnzf: 2,
          jnzb: 2,
          jnef: 2,
          jneb: 2,
          lb: 2,
          log: 80,
          lt: 2,
          lw: 2,
          mint: 6566,
          mlog: 2,
          mod: 2,
          modi: 2,
          move: 2,
          movi: 1,
          mroo: 3,
          mul: 2,
          muli: 2,
          mldv: 3,
          noop: 1,
          not: 2,
          or: 1,
          ori: 2,
          poph: 2,
          popl: 2,
          pshh: 5,
          pshl: 5,
          ret_contract: 43,
          rvrt_contract: 39,
          sb: 2,
          sll: 2,
          slli: 2,
          srl: 2,
          srli: 2,
          srw: 237,
          sub: 2,
          subi: 2,
          sw: 2,
          sww: 5708,
          time: 106,
          tr: 9253,
          tro: 7199,
          wdcm: 2,
          wqcm: 2,
          wdop: 2,
          wqop: 3,
          wdml: 3,
          wqml: 3,
          wddv: 3,
          wqdv: 4,
          wdmd: 6,
          wqmd: 9,
          wdam: 6,
          wqam: 6,
          wdmm: 6,
          wqmm: 6,
          xor: 2,
          xori: 2,
          aloc: {
            LightOperation: {
              base: 2,
              units_per_gas: 35
            }
          },
          bsiz: {
            LightOperation: {
              base: 25,
              units_per_gas: 564
            }
          },
          bldd: {
            LightOperation: {
              base: 33,
              units_per_gas: 130
            }
          },
          cfe: {
            LightOperation: {
              base: 10,
              units_per_gas: 62
            }
          },
          cfei: {
            LightOperation: {
              base: 10,
              units_per_gas: 66
            }
          },
          call: {
            LightOperation: {
              base: 6934,
              units_per_gas: 14
            }
          },
          ccp: {
            LightOperation: {
              base: 21,
              units_per_gas: 155
            }
          },
          croo: {
            LightOperation: {
              base: 69,
              units_per_gas: 4
            }
          },
          csiz: {
            LightOperation: {
              base: 25,
              units_per_gas: 580
            }
          },
          ed19: {
            LightOperation: {
              base: 3232,
              units_per_gas: 7
            }
          },
          k256: {
            LightOperation: {
              base: 21,
              units_per_gas: 6
            }
          },
          ldc: {
            LightOperation: {
              base: 84,
              units_per_gas: 113
            }
          },
          logd: {
            LightOperation: {
              base: 278,
              units_per_gas: 5
            }
          },
          mcl: {
            LightOperation: {
              base: 2,
              units_per_gas: 1282
            }
          },
          mcli: {
            LightOperation: {
              base: 2,
              units_per_gas: 1250
            }
          },
          mcp: {
            LightOperation: {
              base: 3,
              units_per_gas: 385
            }
          },
          mcpi: {
            LightOperation: {
              base: 7,
              units_per_gas: 585
            }
          },
          meq: {
            LightOperation: {
              base: 2,
              units_per_gas: 1234
            }
          },
          retd_contract: {
            LightOperation: {
              base: 227,
              units_per_gas: 5
            }
          },
          s256: {
            LightOperation: {
              base: 25,
              units_per_gas: 5
            }
          },
          scwq: {
            HeavyOperation: {
              base: 5666,
              gas_per_unit: 6628
            }
          },
          smo: {
            LightOperation: {
              base: 14635,
              units_per_gas: 3
            }
          },
          srwq: {
            HeavyOperation: {
              base: 245,
              gas_per_unit: 243
            }
          },
          swwq: {
            HeavyOperation: {
              base: 5661,
              gas_per_unit: 5776
            }
          },
          contract_root: {
            LightOperation: {
              base: 24,
              units_per_gas: 3
            }
          },
          state_root: {
            HeavyOperation: {
              base: 189,
              gas_per_unit: 96
            }
          },
          new_storage_per_byte: 63,
          vm_initialization: {
            LightOperation: {
              base: 3127,
              units_per_gas: 61
            }
          }
        }
      },
      base_asset_id: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07",
      block_gas_limit: 3e7,
      block_transaction_size_limit: 260096,
      privileged_address: "0000000000000000000000000000000000000000000000000000000000000000"
    }
  },
  consensus: {
    PoA: {
      signing_key: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d"
    }
  }
};

// src/utils/defaultSnapshots/metadata.json
var metadata_default = {
  chain_config: "chainConfig.json",
  table_encoding: {
    Json: {
      filepath: "stateConfig.json"
    }
  }
};

// src/utils/defaultSnapshots/stateConfig.json
var stateConfig_default = {
  coins: [],
  messages: [],
  contracts: [],
  blobs: [],
  block_height: 0,
  da_block_height: 0
};

// src/utils/defaultSnapshotConfigs.ts
var defaultSnapshotConfigs = {
  chainConfig: chainConfig_default,
  metadata: metadata_default,
  stateConfig: stateConfig_default
};
var defaultConsensusKey = "0xa449b1ffee0e2205fa924c6740cc48b3b473aa28587df6dab12abc245d1f5298";

// src/utils/isDefined.ts
function isDefined(value) {
  return value !== void 0;
}

// src/utils/base58.ts
var import_errors3 = require("@fuel-ts/errors");
var import_math = require("@fuel-ts/math");
var BN_0 = (0, import_math.bn)(0);
var BN_58 = (0, import_math.bn)(58);
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = (0, import_math.bn)(i);
    }
  }
  const result = Lookup[letter];
  if (result == null) {
    throw new import_errors3.FuelError(import_errors3.ErrorCode.INVALID_DATA, `invalid base58 value ${letter}`);
  }
  return (0, import_math.bn)(result);
}
function encodeBase58(_value) {
  const bytes = arrayify(_value);
  let value = (0, import_math.bn)(bytes);
  let result = "";
  while (value.gt(BN_0)) {
    result = Alphabet[Number(value.mod(BN_58))] + result;
    value = value.div(BN_58);
  }
  for (let i = 0; i < bytes.length; i++) {
    if (bytes[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_0;
  for (let i = 0; i < value.length; i++) {
    result = result.mul(BN_58);
    result = result.add(getAlpha(value[i].toString()));
  }
  return result;
}

// src/utils/dataSlice.ts
var import_errors4 = require("@fuel-ts/errors");
function dataSlice(data, start, end) {
  const bytes = arrayify(data);
  if (end != null && end > bytes.length) {
    throw new import_errors4.FuelError(import_errors4.ErrorCode.INVALID_DATA, "cannot slice beyond data bounds");
  }
  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
}

// src/utils/toUtf8Bytes.ts
var import_errors5 = require("@fuel-ts/errors");
function toUtf8Bytes(stri, form = true) {
  let str = stri;
  if (form) {
    str = stri.normalize("NFC");
  }
  const result = [];
  for (let i = 0; i < str.length; i += 1) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) === 55296) {
      i += 1;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new import_errors5.FuelError(
          import_errors5.ErrorCode.INVALID_INPUT_PARAMETERS,
          "Invalid UTF-8 in the input string."
        );
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}

// src/utils/toUtf8String.ts
function onError(reason, offset, bytes, output, badCodepoint) {
  console.log(`invalid codepoint at offset ${offset}; ${reason}, bytes: ${bytes}`);
  return offset;
}
function helper(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode(
      (codePoint >> 10 & 1023) + 55296,
      (codePoint & 1023) + 56320
    );
  }).join("");
}
function getUtf8CodePoints(_bytes) {
  const bytes = arrayify(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError("OVERRUN", i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      const nextChar = bytes[i];
      if ((nextChar & 192) !== 128) {
        i += onError("MISSING_CONTINUE", i, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8String(bytes) {
  return helper(getUtf8CodePoints(bytes));
}

// src/utils/bytecode.ts
var import_fflate = require("fflate");
var compressBytecode = (bytecodeAsBinary) => {
  if (!bytecodeAsBinary) {
    return "";
  }
  const bytecodeCompressBytes = arrayify(bytecodeAsBinary);
  const bytecodeCompressGzipped = (0, import_fflate.gzipSync)(bytecodeCompressBytes, { mtime: 0 });
  const bytecodeCompressBinary = String.fromCharCode.apply(
    null,
    new Uint8Array(bytecodeCompressGzipped)
  );
  const bytecodeCompressEncoded = btoa(bytecodeCompressBinary);
  return bytecodeCompressEncoded;
};
var decompressBytecode = (bytecodeAsBase64) => {
  const bytecodeDecompressBinary = atob(bytecodeAsBase64);
  const bytecodeDecompressDecoded = new Uint8Array(bytecodeDecompressBinary.length).map(
    (_, i) => bytecodeDecompressBinary.charCodeAt(i)
  );
  const bytecodeDecompressBytes = (0, import_fflate.gunzipSync)(bytecodeDecompressDecoded);
  return bytecodeDecompressBytes;
};

// src/index.ts
function assertUnreachable(_x) {
  throw new Error("Didn't expect to get here");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DateTime,
  arrayify,
  assertUnreachable,
  capitalizeString,
  chunkAndPadBytes,
  compressBytecode,
  concat,
  concatBytes,
  dataSlice,
  decodeBase58,
  decompressBytecode,
  defaultConsensusKey,
  defaultSnapshotConfigs,
  encodeBase58,
  hexlify,
  isDefined,
  normalizeString,
  sleep,
  toUtf8Bytes,
  toUtf8String
});
//# sourceMappingURL=index.js.map