import { Coder } from '@fuel-ts/abi-coder';
import { type BN } from '@fuel-ts/math';
import type { Input, InputContract } from './input';
import type { Output, OutputContract } from './output';
import type { Policy } from './policy';
import type { StorageSlot } from './storage-slot';
import type { TxPointer } from './tx-pointer';
import { type UpgradePurpose } from './upgrade-purpose';
import type { Witness } from './witness';
export declare enum TransactionType {
    Script = 0,
    Create = 1,
    Mint = 2,
    Upgrade = 3,
    Upload = 4,
    Blob = 5
}
/** @hidden */
export type BaseTransactionType = {
    /** The type of the transaction */
    type: TransactionType;
    /** List of witnesses (Witness[]) */
    witnesses: Witness[];
    /** Number of witnesses (u16) */
    witnessesCount: number;
    /** List of outputs (Output[]) */
    outputs: Output[];
    /** List of inputs (Input[]) */
    inputs: Input[];
    /** List of policies. */
    policies: Policy[];
    /** Bitfield of used policy types (u32) */
    policyTypes: number;
    /** Number of inputs (u16) */
    inputsCount: number;
    /** Number of outputs (u16) */
    outputsCount: number;
};
export type TransactionScript = BaseTransactionType & {
    type: TransactionType.Script;
    /** Gas limit for transaction (u64) */
    scriptGasLimit: BN;
    /** Merkle root of receipts (b256) */
    receiptsRoot: string;
    /** Script length, in instructions (u64) */
    scriptLength: BN;
    /** Length of script input data, in bytes (u64) */
    scriptDataLength: BN;
    /** Script to execute (byte[]) */
    script: string;
    /** Script input data (parameters) (byte[]) */
    scriptData: string;
};
export declare class TransactionScriptCoder extends Coder<TransactionScript, TransactionScript> {
    constructor();
    encode(value: TransactionScript): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionScript, number];
}
export type TransactionCreate = BaseTransactionType & {
    type: TransactionType.Create;
    /** Witness index of contract bytecode to create (u8) */
    bytecodeWitnessIndex: number;
    /** Salt (b256) */
    salt: string;
    /** Number of storage slots to initialize (u16) */
    storageSlotsCount: BN;
    /** List of inputs (StorageSlot[]) */
    storageSlots: StorageSlot[];
};
export declare class TransactionCreateCoder extends Coder<TransactionCreate, TransactionCreate> {
    constructor();
    encode(value: TransactionCreate): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionCreate, number];
}
export type TransactionMint = {
    type: TransactionType.Mint;
    /** The location of the Mint transaction in the block. */
    txPointer: TxPointer;
    /** The contract utxo that assets are minted to. */
    inputContract: InputContract;
    /** The contract utxo that assets are being minted to. */
    outputContract: OutputContract;
    /** The amount of funds minted. */
    mintAmount: BN;
    /** The asset ID corresponding to the minted amount. */
    mintAssetId: string;
    gasPrice: BN;
};
export declare class TransactionMintCoder extends Coder<TransactionMint, TransactionMint> {
    constructor();
    encode(value: TransactionMint): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionMint, number];
}
export type TransactionUpgrade = BaseTransactionType & {
    type: TransactionType.Upgrade;
    /** The purpose of the upgrade. */
    upgradePurpose: UpgradePurpose;
};
export declare class TransactionUpgradeCoder extends Coder<TransactionUpgrade, TransactionUpgrade> {
    constructor();
    encode(value: TransactionUpgrade): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionUpgrade, number];
}
export type TransactionUpload = BaseTransactionType & {
    type: TransactionType.Upload;
    /** The root of the Merkle tree is created over the bytecode. (b256) */
    root: string;
    /** Index of witness that authorizes spending the coin (u16) */
    witnessIndex: number;
    /** The index of the subsection of the bytecode. (u16) */
    subsectionIndex: number;
    /** The total number of subsections on which bytecode was divided. (u16) */
    subsectionsNumber: number;
    /** Number of Merkle nodes in the proof. (u16) */
    proofSetCount: number;
    /** List of proof nodes (b256[]) */
    proofSet: string[];
};
export declare class TransactionUploadCoder extends Coder<TransactionUpload, TransactionUpload> {
    constructor();
    encode(value: TransactionUpload): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionUpload, number];
}
export type TransactionBlob = BaseTransactionType & {
    type: TransactionType.Blob;
    /** Hash of the bytecode. (b256) */
    blobId: string;
    /** Witness index of contract bytecode (u16) */
    witnessIndex: number;
};
export declare class TransactionBlobCoder extends Coder<TransactionBlob, TransactionBlob> {
    constructor();
    encode(value: TransactionBlob): Uint8Array;
    decode(data: Uint8Array, offset: number): [TransactionBlob, number];
}
type PossibleTransactions = TransactionScript | TransactionCreate | TransactionMint | TransactionUpgrade | TransactionUpload | TransactionBlob;
export type Transaction<TTransactionType = void> = TTransactionType extends TransactionType ? Extract<PossibleTransactions, {
    type: TTransactionType;
}> : Partial<Omit<TransactionScript, 'type'>> & Partial<Omit<TransactionCreate, 'type'>> & Partial<Omit<TransactionMint, 'type'>> & Partial<Omit<TransactionUpgrade, 'type'>> & Partial<Omit<TransactionUpload, 'type'>> & Partial<Omit<TransactionBlob, 'type'>> & {
    type: TransactionType;
};
export declare class TransactionCoder extends Coder<Transaction, Transaction> {
    constructor();
    encode(value: Transaction): Uint8Array;
    decode(data: Uint8Array, offset: number): [Transaction, number];
}
export {};
//# sourceMappingURL=transaction.d.ts.map