{"version":3,"sources":["../src/index.ts","../src/coders/input.ts","../src/coders/byte-array.ts","../src/coders/tx-pointer.ts","../src/coders/output.ts","../src/coders/policy.ts","../src/receipt.ts","../src/coders/storage-slot.ts","../src/coders/transaction.ts","../src/coders/upgrade-purpose.ts","../src/coders/witness.ts","../src/coders/utxo-id.ts"],"sourcesContent":["export * from './coders/input';\nexport * from './coders/output';\nexport * from './coders/policy';\nexport * from './receipt';\nexport * from './coders/storage-slot';\nexport * from './coders/transaction';\nexport * from './coders/witness';\nexport * from './coders/tx-pointer';\nexport * from './coders/utxo-id';\nexport * from './coders/byte-array';\nexport {\n  UpgradePurpose,\n  UpgradePurposeTypeEnum,\n  UpgradePurposeCoder,\n  ConsensusParameters as UpgradeConsensusParameters,\n  StateTransition,\n} from './coders/upgrade-purpose';\n","/* eslint-disable max-classes-per-file */\nimport { Coder, B256Coder, NumberCoder, BigNumberCoder } from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { sha256 } from '@fuel-ts/hasher';\nimport type { BN } from '@fuel-ts/math';\nimport type { BytesLike } from '@fuel-ts/utils';\nimport { concat, arrayify } from '@fuel-ts/utils';\n\nimport { ByteArrayCoder } from './byte-array';\nimport type { TxPointer } from './tx-pointer';\nimport { TxPointerCoder } from './tx-pointer';\n\nexport enum InputType {\n  Coin = 0,\n  Contract = 1,\n  Message = 2,\n}\n\nexport type InputCoin = {\n  type: InputType.Coin;\n\n  /** Hash of transaction (b256) */\n  txID: string;\n\n  /** Index of transaction output (u16) */\n  outputIndex: number;\n\n  /** Owning address or script hash (b256) */\n  owner: string;\n\n  /** Amount of coins (u64) */\n  amount: BN;\n\n  /** Asset ID of the coins (b256) */\n  assetId: string;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: TxPointer;\n\n  /** Index of witness that authorizes spending the coin (u16) */\n  witnessIndex: number;\n\n  /** Gas used by predicate (u64) */\n  predicateGasUsed: BN;\n\n  /** Length of predicate, in instructions (u64) */\n  predicateLength: BN;\n\n  /** Length of predicate input data, in bytes (u64) */\n  predicateDataLength: BN;\n\n  /** Predicate bytecode (byte[]) */\n  predicate: string;\n\n  /** Predicate input data (parameters) (byte[]) */\n  predicateData: string;\n};\n\nexport class InputCoinCoder extends Coder<InputCoin, InputCoin> {\n  constructor() {\n    super('InputCoin', 'struct InputCoin', 0);\n  }\n\n  encode(value: InputCoin): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.txID));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.outputIndex));\n    parts.push(new B256Coder().encode(value.owner));\n    parts.push(new BigNumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n    parts.push(new TxPointerCoder().encode(value.txPointer));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessIndex));\n    parts.push(new BigNumberCoder('u64').encode(value.predicateGasUsed));\n    parts.push(new BigNumberCoder('u64').encode(value.predicateLength));\n    parts.push(new BigNumberCoder('u64').encode(value.predicateDataLength));\n    parts.push(new ByteArrayCoder(value.predicateLength.toNumber()).encode(value.predicate));\n    parts.push(\n      new ByteArrayCoder(value.predicateDataLength.toNumber()).encode(value.predicateData)\n    );\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [InputCoin, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const txID = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const outputIndex = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const owner = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n    [decoded, o] = new TxPointerCoder().decode(data, o);\n    const txPointer = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessIndex = Number(decoded);\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const predicateGasUsed = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const predicateLength = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const predicateDataLength = decoded;\n    [decoded, o] = new ByteArrayCoder(predicateLength.toNumber()).decode(data, o);\n    const predicate = decoded;\n    [decoded, o] = new ByteArrayCoder(predicateDataLength.toNumber()).decode(data, o);\n    const predicateData = decoded;\n\n    return [\n      {\n        type: InputType.Coin,\n        txID,\n        outputIndex,\n        owner,\n        amount,\n        assetId,\n        txPointer,\n        witnessIndex,\n        predicateGasUsed,\n        predicateLength,\n        predicateDataLength,\n        predicate,\n        predicateData,\n      },\n      o,\n    ];\n  }\n}\n\nexport type InputContract = {\n  type: InputType.Contract;\n\n  /** Hash of transaction (b256) */\n  txID: string;\n\n  /** Index of transaction output (u16) */\n  outputIndex: number;\n\n  /** Root of amount of coins owned by contract before transaction execution (b256) */\n  balanceRoot: string;\n\n  /** State root of contract before transaction execution (b256) */\n  stateRoot: string;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: TxPointer;\n\n  /** Contract ID (b256) */\n  contractID: string;\n};\n\nexport class InputContractCoder extends Coder<InputContract, InputContract> {\n  constructor() {\n    super('InputContract', 'struct InputContract', 0);\n  }\n\n  encode(value: InputContract): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.txID));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.outputIndex));\n    parts.push(new B256Coder().encode(value.balanceRoot));\n    parts.push(new B256Coder().encode(value.stateRoot));\n    parts.push(new TxPointerCoder().encode(value.txPointer));\n    parts.push(new B256Coder().encode(value.contractID));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [InputContract, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const txID = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const outputIndex = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const balanceRoot = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const stateRoot = decoded;\n    [decoded, o] = new TxPointerCoder().decode(data, o);\n    const txPointer = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const contractID = decoded;\n\n    return [\n      {\n        type: InputType.Contract,\n        txID,\n        outputIndex,\n        balanceRoot,\n        stateRoot,\n        txPointer,\n        contractID,\n      },\n      o,\n    ];\n  }\n}\n\nexport type InputMessage = {\n  type: InputType.Message;\n\n  /** Address of sender */\n  sender: string;\n\n  /** Address of recipient */\n  recipient: string;\n\n  /** Amount of coins */\n  amount: BN;\n\n  /** Unique nonce of message */\n  nonce: string;\n\n  /** Index of witness that authorizes message (u16) */\n  witnessIndex: number;\n\n  /** Gas used by predicate (u64) */\n  predicateGasUsed: BN;\n\n  /** Length of data (u64) */\n  dataLength?: number;\n\n  /** Length of predicate, in instructions (u64) */\n  predicateLength: BN;\n\n  /** Length of predicate input data, in bytes (u64) */\n  predicateDataLength: BN;\n\n  /** data of message */\n  data?: string;\n\n  /** Predicate bytecode (byte[]) */\n  predicate: string;\n\n  /** Predicate input data (parameters) (byte[]) */\n  predicateData: string;\n};\n\nexport class InputMessageCoder extends Coder<InputMessage, InputMessage> {\n  constructor() {\n    super('InputMessage', 'struct InputMessage', 0);\n  }\n\n  static getMessageId(\n    value: Pick<InputMessage, 'sender' | 'recipient' | 'nonce' | 'amount' | 'data'>\n  ): string {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new ByteArrayCoder(32).encode(value.sender));\n    parts.push(new ByteArrayCoder(32).encode(value.recipient));\n    parts.push(new ByteArrayCoder(32).encode(value.nonce));\n    parts.push(new BigNumberCoder('u64').encode(value.amount));\n    parts.push(arrayify(value.data || '0x'));\n\n    return sha256(concat(parts));\n  }\n\n  static encodeData(messageData?: BytesLike): Uint8Array {\n    const bytes = arrayify(messageData || '0x');\n    const dataLength = bytes.length;\n    return new ByteArrayCoder(dataLength).encode(bytes);\n  }\n\n  encode(value: InputMessage): Uint8Array {\n    const parts: Uint8Array[] = [];\n    const data = InputMessageCoder.encodeData(value.data);\n\n    parts.push(new ByteArrayCoder(32).encode(value.sender));\n    parts.push(new ByteArrayCoder(32).encode(value.recipient));\n    parts.push(new BigNumberCoder('u64').encode(value.amount));\n    parts.push(new ByteArrayCoder(32).encode(value.nonce));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessIndex));\n    parts.push(new BigNumberCoder('u64').encode(value.predicateGasUsed));\n    parts.push(new BigNumberCoder('u64').encode(data.length));\n    parts.push(new BigNumberCoder('u64').encode(value.predicateLength));\n    parts.push(new BigNumberCoder('u64').encode(value.predicateDataLength));\n    parts.push(new ByteArrayCoder(data.length).encode(data));\n    parts.push(new ByteArrayCoder(value.predicateLength.toNumber()).encode(value.predicate));\n    parts.push(\n      new ByteArrayCoder(value.predicateDataLength.toNumber()).encode(value.predicateData)\n    );\n\n    return concat(parts);\n  }\n\n  static decodeData(messageData: BytesLike): Uint8Array {\n    const bytes = arrayify(messageData);\n    const dataLength = bytes.length;\n    const [data] = new ByteArrayCoder(dataLength).decode(bytes, 0);\n\n    return arrayify(data);\n  }\n\n  decode(data: Uint8Array, offset: number): [InputMessage, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const sender = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const recipient = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const nonce = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessIndex = Number(decoded);\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const predicateGasUsed = decoded;\n    [decoded, o] = new NumberCoder('u32', { padToWordSize: true }).decode(data, o);\n    const dataLength = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const predicateLength = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const predicateDataLength = decoded;\n    [decoded, o] = new ByteArrayCoder(dataLength).decode(data, o);\n    const messageData = decoded;\n    [decoded, o] = new ByteArrayCoder(predicateLength.toNumber()).decode(data, o);\n    const predicate = decoded;\n    [decoded, o] = new ByteArrayCoder(predicateDataLength.toNumber()).decode(data, o);\n    const predicateData = decoded;\n\n    return [\n      {\n        type: InputType.Message,\n        sender,\n        recipient,\n        amount,\n        witnessIndex,\n        nonce,\n        predicateGasUsed,\n        dataLength,\n        predicateLength,\n        predicateDataLength,\n        data: messageData,\n        predicate,\n        predicateData,\n      },\n      o,\n    ];\n  }\n}\n\nexport type Input = InputCoin | InputContract | InputMessage;\n\nexport class InputCoder extends Coder<Input, Input> {\n  constructor() {\n    super('Input', 'struct Input', 0);\n  }\n\n  encode(value: Input): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8', { padToWordSize: true }).encode(value.type));\n\n    const { type } = value;\n\n    switch (type) {\n      case InputType.Coin: {\n        parts.push(new InputCoinCoder().encode(value));\n        break;\n      }\n      case InputType.Contract: {\n        parts.push(new InputContractCoder().encode(value));\n        break;\n      }\n      case InputType.Message: {\n        parts.push(new InputMessageCoder().encode(value));\n        break;\n      }\n      default: {\n        throw new FuelError(\n          ErrorCode.INVALID_TRANSACTION_INPUT,\n          `Invalid transaction input type: ${type}.`\n        );\n      }\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Input, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8', { padToWordSize: true }).decode(data, o);\n    const type = decoded as InputType;\n    switch (type) {\n      case InputType.Coin: {\n        [decoded, o] = new InputCoinCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case InputType.Contract: {\n        [decoded, o] = new InputContractCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case InputType.Message: {\n        [decoded, o] = new InputMessageCoder().decode(data, o);\n        return [decoded, o];\n      }\n      default: {\n        throw new FuelError(\n          ErrorCode.INVALID_TRANSACTION_INPUT,\n          `Invalid transaction input type: ${type}.`\n        );\n      }\n    }\n  }\n}\n","import { Coder } from '@fuel-ts/abi-coder';\nimport type { BytesLike } from '@fuel-ts/utils';\nimport { concat, hexlify, arrayify } from '@fuel-ts/utils';\n\nexport class ByteArrayCoder extends Coder<BytesLike, string> {\n  length: number;\n  #paddingLength: number;\n\n  constructor(length: number) {\n    const paddingLength = (8 - (length % 8)) % 8;\n    const encodedLength = length + paddingLength;\n    super(\n      'ByteArray',\n      // While this might sound like a [u8; N] coder it's actually not.\n      // A [u8; N] coder would pad every u8 to 8 bytes which would\n      // make every u8 have the same size as a u64.\n      // We are packing four u8s into u64s here, avoiding this padding.\n      `[u64; ${encodedLength / 4}]`,\n      encodedLength\n    );\n    this.length = length;\n    this.#paddingLength = paddingLength;\n  }\n\n  encode(value: BytesLike): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    const data = arrayify(value);\n    parts.push(data);\n    // Write padding\n    if (this.#paddingLength) {\n      parts.push(new Uint8Array(this.#paddingLength));\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = [hexlify(data.slice(o, o + this.length)), o + this.length];\n    const value = decoded;\n    // Read padding\n    if (this.#paddingLength) {\n      [decoded, o] = [null, o + this.#paddingLength];\n    }\n\n    return [value, o];\n  }\n}\n","import { NumberCoder, StructCoder } from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nexport type TxPointer = {\n  /** Block height (u32) */\n  blockHeight: number;\n\n  /** Transaction index (u16) */\n  txIndex: number;\n};\n\nexport class TxPointerCoder extends StructCoder<{\n  blockHeight: NumberCoder;\n  txIndex: NumberCoder;\n}> {\n  constructor() {\n    super('TxPointer', {\n      blockHeight: new NumberCoder('u32', { padToWordSize: true }),\n      txIndex: new NumberCoder('u16', { padToWordSize: true }),\n    });\n  }\n\n  public static decodeFromGqlScalar(value: string) {\n    // taken from https://github.com/FuelLabs/fuel-vm/blob/7366db6955589cb3444c9b2bb46e45c8539f19f5/fuel-tx/src/tx_pointer.rs#L87\n    if (value.length !== 12) {\n      throw new FuelError(\n        ErrorCode.DECODE_ERROR,\n        `Invalid TxPointer scalar string length ${value.length}. It must have length 12.`\n      );\n    }\n    const [blockHeight, txIndex] = [value.substring(0, 8), value.substring(8)];\n    return {\n      blockHeight: parseInt(blockHeight, 16),\n      txIndex: parseInt(txIndex, 16),\n    };\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { Coder, B256Coder, NumberCoder, BigNumberCoder } from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\n\nexport enum OutputType /* u8 */ {\n  Coin = 0,\n  Contract = 1,\n  Change = 2,\n  Variable = 3,\n  ContractCreated = 4,\n}\n\nexport type OutputCoin = {\n  type: OutputType.Coin;\n  /** Receiving address or script hash (b256) */\n  to: string;\n  /** Amount of coins to send (u64) */\n  amount: BN;\n  /** Asset ID of coins (b256) */\n  assetId: string;\n};\n\nexport class OutputCoinCoder extends Coder<OutputCoin, OutputCoin> {\n  constructor() {\n    super('OutputCoin', 'struct OutputCoin', 0);\n  }\n\n  encode(value: OutputCoin): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new BigNumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputCoin, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n\n    return [\n      {\n        type: OutputType.Coin,\n        to,\n        amount,\n        assetId,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputContract = {\n  type: OutputType.Contract;\n  /** Index of input contract (u8) */\n  inputIndex: number;\n  /** Root of amount of coins owned by contract after transaction execution (b256) */\n  balanceRoot: string;\n  /** State root of contract after transaction execution (b256) */\n  stateRoot: string;\n};\n\nexport class OutputContractCoder extends Coder<OutputContract, OutputContract> {\n  constructor() {\n    super('OutputContract', 'struct OutputContract', 0);\n  }\n\n  encode(value: OutputContract): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8', { padToWordSize: true }).encode(value.inputIndex));\n    parts.push(new B256Coder().encode(value.balanceRoot));\n    parts.push(new B256Coder().encode(value.stateRoot));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputContract, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8', { padToWordSize: true }).decode(data, o);\n    const inputIndex = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const balanceRoot = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const stateRoot = decoded;\n\n    return [\n      {\n        type: OutputType.Contract,\n        inputIndex,\n        balanceRoot,\n        stateRoot,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputChange = {\n  type: OutputType.Change;\n  /** Receiving address or script hash (b256) */\n  to: string;\n  /** Amount of coins to send (u64) */\n  amount: BN;\n  /** Asset ID of coins (b256) */\n  assetId: string;\n};\n\nexport class OutputChangeCoder extends Coder<OutputChange, OutputChange> {\n  constructor() {\n    super('OutputChange', 'struct OutputChange', 0);\n  }\n\n  encode(value: OutputChange): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new BigNumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputChange, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n\n    return [\n      {\n        type: OutputType.Change,\n        to,\n        amount,\n        assetId,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputVariable = {\n  type: OutputType.Variable;\n  /** Receiving address or script hash (b256) */\n  to: string;\n  /** Amount of coins to send (u64) */\n  amount: BN;\n  /** Asset ID of coins (b256) */\n  assetId: string;\n};\n\nexport class OutputVariableCoder extends Coder<OutputVariable, OutputVariable> {\n  constructor() {\n    super('OutputVariable', 'struct OutputVariable', 0);\n  }\n\n  encode(value: OutputVariable): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.to));\n    parts.push(new BigNumberCoder('u64').encode(value.amount));\n    parts.push(new B256Coder().encode(value.assetId));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputVariable, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const to = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const amount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const assetId = decoded;\n\n    return [\n      {\n        type: OutputType.Variable,\n        to,\n        amount,\n        assetId,\n      },\n      o,\n    ];\n  }\n}\n\nexport type OutputContractCreated = {\n  type: OutputType.ContractCreated;\n  /** Contract ID (b256) */\n  contractId: string;\n  /** State root of contract (b256) */\n  stateRoot: string;\n};\n\nexport class OutputContractCreatedCoder extends Coder<\n  OutputContractCreated,\n  OutputContractCreated\n> {\n  constructor() {\n    super('OutputContractCreated', 'struct OutputContractCreated', 0);\n  }\n\n  encode(value: OutputContractCreated): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.contractId));\n    parts.push(new B256Coder().encode(value.stateRoot));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [OutputContractCreated, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const contractId = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const stateRoot = decoded;\n\n    return [\n      {\n        type: OutputType.ContractCreated,\n        contractId,\n        stateRoot,\n      },\n      o,\n    ];\n  }\n}\n\nexport type Output =\n  | OutputCoin\n  | OutputContract\n  | OutputChange\n  | OutputVariable\n  | OutputContractCreated;\n\nexport class OutputCoder extends Coder<Output, Output> {\n  constructor() {\n    super('Output', ' struct Output', 0);\n  }\n\n  encode(value: Output): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8', { padToWordSize: true }).encode(value.type));\n\n    const { type } = value;\n\n    switch (type) {\n      case OutputType.Coin: {\n        parts.push(new OutputCoinCoder().encode(value));\n        break;\n      }\n      case OutputType.Contract: {\n        parts.push(new OutputContractCoder().encode(value));\n        break;\n      }\n      case OutputType.Change: {\n        parts.push(new OutputChangeCoder().encode(value));\n        break;\n      }\n      case OutputType.Variable: {\n        parts.push(new OutputVariableCoder().encode(value));\n        break;\n      }\n      case OutputType.ContractCreated: {\n        parts.push(new OutputContractCreatedCoder().encode(value));\n        break;\n      }\n      default: {\n        throw new FuelError(\n          ErrorCode.INVALID_TRANSACTION_OUTPUT,\n          `Invalid transaction output type: ${type}.`\n        );\n      }\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Output, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8', { padToWordSize: true }).decode(data, o);\n    const type = decoded as OutputType;\n    switch (type) {\n      case OutputType.Coin: {\n        [decoded, o] = new OutputCoinCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.Contract: {\n        [decoded, o] = new OutputContractCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.Change: {\n        [decoded, o] = new OutputChangeCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.Variable: {\n        [decoded, o] = new OutputVariableCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case OutputType.ContractCreated: {\n        [decoded, o] = new OutputContractCreatedCoder().decode(data, o);\n        return [decoded, o];\n      }\n      default: {\n        throw new FuelError(\n          ErrorCode.INVALID_TRANSACTION_OUTPUT,\n          `Invalid transaction output type: ${type}.`\n        );\n      }\n    }\n  }\n}\n","import { BigNumberCoder, Coder, NumberCoder } from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\n\n// Bitfield of used policy types.\nexport enum PolicyType {\n  Tip = 1,\n  WitnessLimit = 2,\n  Maturity = 4,\n  MaxFee = 8,\n}\n\nexport type Policy = PolicyTip | PolicyWitnessLimit | PolicyMaturity | PolicyMaxFee;\n\nexport type PolicyTip = {\n  type: PolicyType.Tip;\n  data: BN;\n};\n\nexport type PolicyWitnessLimit = {\n  type: PolicyType.WitnessLimit;\n  data: BN;\n};\n\nexport type PolicyMaturity = {\n  type: PolicyType.Maturity;\n  data: number;\n};\n\nexport type PolicyMaxFee = {\n  type: PolicyType.MaxFee;\n  data: BN;\n};\n\nexport const sortPolicies = (policies: Policy[]): Policy[] =>\n  policies.sort((a, b) => a.type - b.type);\n\nfunction validateDuplicatedPolicies(policies: Policy[]): void {\n  const seenTypes = new Set<PolicyType>();\n\n  policies.forEach((policy) => {\n    if (seenTypes.has(policy.type)) {\n      throw new FuelError(\n        ErrorCode.DUPLICATED_POLICY,\n        `Duplicate policy type found: ${PolicyType.MaxFee}`\n      );\n    }\n    seenTypes.add(policy.type);\n  });\n}\n\nexport class PoliciesCoder extends Coder<Policy[], Policy[]> {\n  constructor() {\n    super('Policies', 'array Policy', 0);\n  }\n\n  encode(policies: Policy[]): Uint8Array {\n    validateDuplicatedPolicies(policies);\n    const sortedPolicies = sortPolicies(policies);\n\n    const parts: Uint8Array[] = [];\n\n    sortedPolicies.forEach(({ data, type }) => {\n      switch (type) {\n        case PolicyType.MaxFee:\n        case PolicyType.Tip:\n        case PolicyType.WitnessLimit:\n          parts.push(new BigNumberCoder('u64').encode(data));\n          break;\n\n        case PolicyType.Maturity:\n          parts.push(new NumberCoder('u32', { padToWordSize: true }).encode(data));\n          break;\n\n        default: {\n          throw new FuelError(ErrorCode.INVALID_POLICY_TYPE, `Invalid policy type: ${type}`);\n        }\n      }\n    });\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number, policyTypes: number): [Policy[], number] {\n    let o = offset;\n    const policies: Policy[] = [];\n\n    if (policyTypes & PolicyType.Tip) {\n      const [tip, nextOffset] = new BigNumberCoder('u64').decode(data, o);\n      o = nextOffset;\n      policies.push({ type: PolicyType.Tip, data: tip });\n    }\n\n    if (policyTypes & PolicyType.WitnessLimit) {\n      const [witnessLimit, nextOffset] = new BigNumberCoder('u64').decode(data, o);\n      o = nextOffset;\n      policies.push({ type: PolicyType.WitnessLimit, data: witnessLimit });\n    }\n\n    if (policyTypes & PolicyType.Maturity) {\n      const [maturity, nextOffset] = new NumberCoder('u32', { padToWordSize: true }).decode(\n        data,\n        o\n      );\n      o = nextOffset;\n      policies.push({ type: PolicyType.Maturity, data: maturity });\n    }\n\n    if (policyTypes & PolicyType.MaxFee) {\n      const [maxFee, nextOffset] = new BigNumberCoder('u64').decode(data, o);\n      o = nextOffset;\n      policies.push({ type: PolicyType.MaxFee, data: maxFee });\n    }\n\n    return [policies, o];\n  }\n}\n","import { BigNumberCoder } from '@fuel-ts/abi-coder';\nimport type { AssetId } from '@fuel-ts/address';\nimport { sha256 } from '@fuel-ts/hasher';\nimport type { BN } from '@fuel-ts/math';\nimport { arrayify, concat } from '@fuel-ts/utils';\n\nimport { ByteArrayCoder } from './coders/byte-array';\n\nexport enum ReceiptType /* u8 */ {\n  Call = 0,\n  Return = 1,\n  ReturnData = 2,\n  Panic = 3,\n  Revert = 4,\n  Log = 5,\n  LogData = 6,\n  Transfer = 7,\n  TransferOut = 8,\n  ScriptResult = 9,\n  MessageOut = 10,\n  Mint = 11,\n  Burn = 12,\n}\n\nexport type ReceiptCall = {\n  type: ReceiptType.Call;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Contract ID of called contract (b256) */\n  to: string;\n  /** Amount of coins to forward, i.e. $rB (u64) */\n  amount: BN;\n  /** Asset ID of coins to forward, i.e. MEM[$rC, 32] (b256) */\n  assetId: string;\n  /** Gas to forward, i.e. $rD (u64) */\n  gas: BN;\n  /** First parameter (u64) */\n  param1: BN;\n  /** Second parameter (u64) */\n  param2: BN;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptReturn = {\n  type: ReceiptType.Return;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  val: BN;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptReturnData = {\n  type: ReceiptType.ReturnData;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  ptr: BN;\n  /** Value of register $rB (u64) */\n  len: BN;\n  /** Hash of MEM[$rA, $rB] (b256) */\n  digest: string;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of the memory range MEM[$rA, $rB]. */\n  data: string;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptPanic = {\n  type: ReceiptType.Panic;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Panic reason (u64) */\n  reason: BN;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n  /** Value of optional contract ID */\n  contractId: string;\n};\n\nexport type ReceiptRevert = {\n  type: ReceiptType.Revert;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  val: BN;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptLog = {\n  type: ReceiptType.Log;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  ra: BN;\n  /** Value of register $rB (u64) */\n  rb: BN;\n  /** Value of register $rC (u64) */\n  rc: BN;\n  /** Value of register $rD (u64) */\n  rd: BN;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptLogData = {\n  type: ReceiptType.LogData;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Value of register $rA (u64) */\n  ra: BN;\n  /** Value of register $rB (u64) */\n  rb: BN;\n  /** Value of register $rC (u64) */\n  ptr: BN;\n  /** Value of register $rD (u64) */\n  len: BN;\n  /** Hash of MEM[$rC, $rD] (b256) */\n  digest: string;\n  /** Value of the memory range MEM[$rC, $rD]. */\n  data: string;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptTransfer = {\n  type: ReceiptType.Transfer;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Contract ID of contract to transfer coins to (b256) */\n  to: string;\n  /** Amount of coins transferred (u64) */\n  amount: BN;\n  /** Asset ID of coins transferred (b256) */\n  assetId: string;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptTransferOut = {\n  type: ReceiptType.TransferOut;\n  /** Contract ID of current context if in an internal context, zero otherwise (b256) */\n  id: string;\n  /** Address to transfer coins to (b256) */\n  to: string;\n  /** Amount of coins transferred (u64) */\n  amount: BN;\n  /** Asset ID of coins transferred (b256) */\n  assetId: string;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptScriptResult = {\n  type: ReceiptType.ScriptResult;\n  /** Result variant with embedded `PanicReason` in first 8 bits and `instr` (u64) */\n  result: BN;\n  /** Gas consumed by the script (u64) */\n  gasUsed: BN;\n};\n\nexport type ReceiptMessageOut = {\n  type: ReceiptType.MessageOut;\n  /** Hexadecimal string representation of the 256-bit (32-byte) message ID */\n  messageId: string;\n  /** Hexadecimal string representation of the 256-bit (32-byte) address of the message sender: MEM[$fp, 32] */\n  sender: string;\n  /** Hexadecimal string representation of the 256-bit (32-byte) address of the message recipient: MEM[$rA, 32] */\n  recipient: string;\n  /** Hexadecimal string representation of a 64-bit unsigned integer; value of register $rD */\n  amount: BN;\n  /** Hexadecimal string representation of the 256-bit (32-byte) message nonce */\n  nonce: string;\n  /** Decimal string representation of a 16-bit unsigned integer; value of register $rC. */\n  len: number;\n  /** Hexadecimal string representation of 256-bit (32-byte), hash of MEM[$rA + 32, $rB] */\n  digest: string;\n  /** Hexadecimal string representation of the value of the memory range MEM[$rA + 32, $rB] */\n  data: Uint8Array;\n};\n\nexport type ReceiptMint = {\n  type: ReceiptType.Mint;\n\n  subId: string;\n\n  contractId: string;\n\n  assetId: string;\n\n  val: BN;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type ReceiptBurn = {\n  type: ReceiptType.Burn;\n\n  subId: string;\n\n  contractId: string;\n\n  assetId: string;\n\n  val: BN;\n  /** Value of register $pc (u64) */\n  pc: BN;\n  /** Value of register $is (u64) */\n  is: BN;\n};\n\nexport type Receipt =\n  | ReceiptCall\n  | ReceiptReturn\n  | ReceiptReturnData\n  | ReceiptPanic\n  | ReceiptRevert\n  | ReceiptLog\n  | ReceiptLogData\n  | ReceiptTransfer\n  | ReceiptTransferOut\n  | ReceiptScriptResult\n  | ReceiptMessageOut\n  | ReceiptMint\n  | ReceiptBurn;\n\nexport const getMintedAssetId = (contractId: string, subId: string): string => {\n  const contractIdBytes = arrayify(contractId);\n  const subIdBytes = arrayify(subId);\n\n  return sha256(concat([contractIdBytes, subIdBytes]));\n};\n\nexport const createAssetId = (contractId: string, subId: string): AssetId => ({\n  bits: getMintedAssetId(contractId, subId),\n});\n\nexport const getMessageId = (\n  value: Pick<ReceiptMessageOut, 'sender' | 'recipient' | 'nonce' | 'amount' | 'data'>\n): string => {\n  const parts: Uint8Array[] = [];\n\n  parts.push(new ByteArrayCoder(32).encode(value.sender));\n  parts.push(new ByteArrayCoder(32).encode(value.recipient));\n  parts.push(new ByteArrayCoder(32).encode(value.nonce));\n  parts.push(new BigNumberCoder('u64').encode(value.amount));\n  parts.push(arrayify(value.data || '0x'));\n\n  return sha256(concat(parts));\n};\n","import { B256Coder, StructCoder } from '@fuel-ts/abi-coder';\n\nexport type StorageSlot = {\n  /** Key (b256) */\n  key: string;\n  /** Value (b256) */\n  value: string;\n};\n\nexport class StorageSlotCoder extends StructCoder<{\n  key: B256Coder;\n  value: B256Coder;\n}> {\n  constructor() {\n    super('StorageSlot', {\n      key: new B256Coder(),\n      value: new B256Coder(),\n    });\n  }\n}\n","/* eslint-disable max-classes-per-file */\n\nimport { Coder, ArrayCoder, B256Coder, NumberCoder, BigNumberCoder } from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { type BN } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\n\nimport { ByteArrayCoder } from './byte-array';\nimport type { Input, InputContract } from './input';\nimport { InputCoder, InputContractCoder } from './input';\nimport type { Output, OutputContract } from './output';\nimport { OutputCoder, OutputContractCoder } from './output';\nimport type { Policy } from './policy';\nimport { PoliciesCoder } from './policy';\nimport { StorageSlotCoder } from './storage-slot';\nimport type { StorageSlot } from './storage-slot';\nimport type { TxPointer } from './tx-pointer';\nimport { TxPointerCoder } from './tx-pointer';\nimport { UpgradePurposeCoder, type UpgradePurpose } from './upgrade-purpose';\nimport type { Witness } from './witness';\nimport { WitnessCoder } from './witness';\n\nexport enum TransactionType /* u8 */ {\n  Script = 0,\n  Create = 1,\n  Mint = 2,\n  Upgrade = 3,\n  Upload = 4,\n  Blob = 5,\n}\n\n/** @hidden */\nexport type BaseTransactionType = {\n  /** The type of the transaction */\n  type: TransactionType;\n  /** List of witnesses (Witness[]) */\n  witnesses: Witness[];\n\n  /** Number of witnesses (u16) */\n  witnessesCount: number;\n\n  /** List of outputs (Output[]) */\n  outputs: Output[];\n\n  /** List of inputs (Input[]) */\n  inputs: Input[];\n\n  /** List of policies. */\n  policies: Policy[];\n\n  /** Bitfield of used policy types (u32) */\n  policyTypes: number;\n\n  /** Number of inputs (u16) */\n  inputsCount: number;\n\n  /** Number of outputs (u16) */\n  outputsCount: number;\n};\n\nexport type TransactionScript = BaseTransactionType & {\n  type: TransactionType.Script;\n\n  /** Gas limit for transaction (u64) */\n  scriptGasLimit: BN;\n\n  /** Merkle root of receipts (b256) */\n  receiptsRoot: string;\n\n  /** Script length, in instructions (u64) */\n  scriptLength: BN;\n\n  /** Length of script input data, in bytes (u64) */\n  scriptDataLength: BN;\n\n  /** Script to execute (byte[]) */\n  script: string;\n\n  /** Script input data (parameters) (byte[]) */\n  scriptData: string;\n};\n\nexport class TransactionScriptCoder extends Coder<TransactionScript, TransactionScript> {\n  constructor() {\n    super('TransactionScript', 'struct TransactionScript', 0);\n  }\n\n  encode(value: TransactionScript): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new BigNumberCoder('u64').encode(value.scriptGasLimit));\n    parts.push(new B256Coder().encode(value.receiptsRoot));\n    parts.push(new BigNumberCoder('u64').encode(value.scriptLength));\n    parts.push(new BigNumberCoder('u64').encode(value.scriptDataLength));\n    parts.push(new NumberCoder('u32', { padToWordSize: true }).encode(value.policyTypes));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.inputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.outputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessesCount));\n    parts.push(new ByteArrayCoder(value.scriptLength.toNumber()).encode(value.script));\n    parts.push(new ByteArrayCoder(value.scriptDataLength.toNumber()).encode(value.scriptData));\n    parts.push(new PoliciesCoder().encode(value.policies));\n    parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));\n    parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));\n    parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [TransactionScript, number] {\n    let decoded;\n    let o = offset;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const scriptGasLimit = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const receiptsRoot = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const scriptLength = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const scriptDataLength = decoded;\n    [decoded, o] = new NumberCoder('u32', { padToWordSize: true }).decode(data, o);\n    const policyTypes = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const inputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const outputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessesCount = decoded;\n    [decoded, o] = new ByteArrayCoder(scriptLength.toNumber()).decode(data, o);\n    const script = decoded;\n    [decoded, o] = new ByteArrayCoder(scriptDataLength.toNumber()).decode(data, o);\n    const scriptData = decoded;\n    [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);\n    const policies = decoded;\n    [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);\n    const inputs = decoded;\n    [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);\n    const outputs = decoded;\n    [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);\n    const witnesses = decoded;\n\n    return [\n      {\n        type: TransactionType.Script,\n        scriptGasLimit,\n        scriptLength,\n        scriptDataLength,\n        policyTypes,\n        inputsCount,\n        outputsCount,\n        witnessesCount,\n        receiptsRoot,\n        script,\n        scriptData,\n        policies,\n        inputs,\n        outputs,\n        witnesses,\n      },\n      o,\n    ];\n  }\n}\n\nexport type TransactionCreate = BaseTransactionType & {\n  type: TransactionType.Create;\n\n  /** Witness index of contract bytecode to create (u8) */\n  bytecodeWitnessIndex: number;\n\n  /** Salt (b256) */\n  salt: string;\n\n  /** Number of storage slots to initialize (u16) */\n  storageSlotsCount: BN;\n\n  /** List of inputs (StorageSlot[]) */\n  storageSlots: StorageSlot[];\n};\n\nexport class TransactionCreateCoder extends Coder<TransactionCreate, TransactionCreate> {\n  constructor() {\n    super('TransactionCreate', 'struct TransactionCreate', 0);\n  }\n\n  encode(value: TransactionCreate): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.bytecodeWitnessIndex));\n    parts.push(new B256Coder().encode(value.salt));\n    parts.push(new BigNumberCoder('u64').encode(value.storageSlotsCount));\n    parts.push(new NumberCoder('u32', { padToWordSize: true }).encode(value.policyTypes));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.inputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.outputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessesCount));\n    parts.push(\n      new ArrayCoder(new StorageSlotCoder(), value.storageSlotsCount.toNumber()).encode(\n        value.storageSlots\n      )\n    );\n    parts.push(new PoliciesCoder().encode(value.policies));\n    parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));\n    parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));\n    parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [TransactionCreate, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const bytecodeWitnessIndex = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const salt = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const storageSlotsCount = decoded;\n    [decoded, o] = new NumberCoder('u32', { padToWordSize: true }).decode(data, o);\n    const policyTypes = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const inputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const outputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessesCount = decoded;\n    [decoded, o] = new ArrayCoder(new StorageSlotCoder(), storageSlotsCount.toNumber()).decode(\n      data,\n      o\n    );\n    const storageSlots = decoded;\n    [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);\n    const policies = decoded;\n    [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);\n    const inputs = decoded;\n    [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);\n    const outputs = decoded;\n    [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);\n    const witnesses = decoded;\n\n    return [\n      {\n        type: TransactionType.Create,\n        bytecodeWitnessIndex,\n        policyTypes,\n        storageSlotsCount,\n        inputsCount,\n        outputsCount,\n        witnessesCount,\n        salt,\n        policies,\n        storageSlots,\n        inputs,\n        outputs,\n        witnesses,\n      },\n      o,\n    ];\n  }\n}\n\nexport type TransactionMint = {\n  type: TransactionType.Mint;\n\n  /** The location of the Mint transaction in the block. */\n  txPointer: TxPointer;\n\n  /** The contract utxo that assets are minted to. */\n  inputContract: InputContract;\n\n  /** The contract utxo that assets are being minted to. */\n  outputContract: OutputContract;\n\n  /** The amount of funds minted. */\n  mintAmount: BN;\n\n  /** The asset ID corresponding to the minted amount. */\n  mintAssetId: string;\n\n  gasPrice: BN;\n};\n\nexport class TransactionMintCoder extends Coder<TransactionMint, TransactionMint> {\n  constructor() {\n    super('TransactionMint', 'struct TransactionMint', 0);\n  }\n\n  encode(value: TransactionMint): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new TxPointerCoder().encode(value.txPointer));\n    parts.push(new InputContractCoder().encode(value.inputContract));\n    parts.push(new OutputContractCoder().encode(value.outputContract));\n    parts.push(new BigNumberCoder('u64').encode(value.mintAmount));\n    parts.push(new B256Coder().encode(value.mintAssetId));\n    parts.push(new BigNumberCoder('u64').encode(value.gasPrice));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [TransactionMint, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new TxPointerCoder().decode(data, o);\n    const txPointer = decoded;\n    [decoded, o] = new InputContractCoder().decode(data, o);\n    const inputContract = decoded;\n    [decoded, o] = new OutputContractCoder().decode(data, o);\n    const outputContract = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const mintAmount = decoded;\n    [decoded, o] = new B256Coder().decode(data, o);\n    const mintAssetId = decoded;\n    [decoded, o] = new BigNumberCoder('u64').decode(data, o);\n    const gasPrice = decoded;\n\n    return [\n      {\n        type: TransactionType.Mint,\n        txPointer,\n        inputContract,\n        outputContract,\n        mintAmount,\n        mintAssetId,\n        gasPrice,\n      },\n      o,\n    ];\n  }\n}\n\nexport type TransactionUpgrade = BaseTransactionType & {\n  type: TransactionType.Upgrade;\n\n  /** The purpose of the upgrade. */\n  upgradePurpose: UpgradePurpose;\n};\n\nexport class TransactionUpgradeCoder extends Coder<TransactionUpgrade, TransactionUpgrade> {\n  constructor() {\n    super('TransactionUpgrade', 'struct TransactionUpgrade', 0);\n  }\n\n  encode(value: TransactionUpgrade): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new UpgradePurposeCoder().encode(value.upgradePurpose));\n    parts.push(new NumberCoder('u32', { padToWordSize: true }).encode(value.policyTypes));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.inputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.outputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessesCount));\n    parts.push(new PoliciesCoder().encode(value.policies));\n    parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));\n    parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));\n    parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [TransactionUpgrade, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new UpgradePurposeCoder().decode(data, o);\n    const upgradePurpose = decoded;\n    [decoded, o] = new NumberCoder('u32', { padToWordSize: true }).decode(data, o);\n    const policyTypes = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const inputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const outputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessesCount = decoded;\n    [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);\n    const policies = decoded;\n    [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);\n    const inputs = decoded;\n    [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);\n    const outputs = decoded;\n    [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);\n    const witnesses = decoded;\n\n    return [\n      {\n        type: TransactionType.Upgrade,\n        upgradePurpose,\n        policyTypes,\n        inputsCount,\n        outputsCount,\n        witnessesCount,\n        policies,\n        inputs,\n        outputs,\n        witnesses,\n      },\n      o,\n    ];\n  }\n}\n\nexport type TransactionUpload = BaseTransactionType & {\n  type: TransactionType.Upload;\n\n  /** The root of the Merkle tree is created over the bytecode. (b256) */\n  root: string;\n\n  /** Index of witness that authorizes spending the coin (u16) */\n  witnessIndex: number;\n\n  /** The index of the subsection of the bytecode. (u16) */\n  subsectionIndex: number;\n\n  /** The total number of subsections on which bytecode was divided. (u16) */\n  subsectionsNumber: number;\n\n  /** Number of Merkle nodes in the proof. (u16) */\n  proofSetCount: number;\n\n  /** List of proof nodes (b256[]) */\n  proofSet: string[];\n};\n\nexport class TransactionUploadCoder extends Coder<TransactionUpload, TransactionUpload> {\n  constructor() {\n    super('TransactionUpload', 'struct TransactionUpload', 0);\n  }\n\n  encode(value: TransactionUpload): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.root));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessIndex));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.subsectionIndex));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.subsectionsNumber));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.proofSetCount));\n    parts.push(new NumberCoder('u32', { padToWordSize: true }).encode(value.policyTypes));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.inputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.outputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessesCount));\n    parts.push(new ArrayCoder(new B256Coder(), value.proofSetCount).encode(value.proofSet));\n    parts.push(new PoliciesCoder().encode(value.policies));\n    parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));\n    parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));\n    parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [TransactionUpload, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const root = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessIndex = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const subsectionIndex = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const subsectionsNumber = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const proofSetCount = decoded;\n    [decoded, o] = new NumberCoder('u32', { padToWordSize: true }).decode(data, o);\n    const policyTypes = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const inputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const outputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessesCount = decoded;\n    [decoded, o] = new ArrayCoder(new B256Coder(), proofSetCount).decode(data, o);\n    const proofSet = decoded;\n    [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);\n    const policies = decoded;\n    [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);\n    const inputs = decoded;\n    [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);\n    const outputs = decoded;\n    [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);\n    const witnesses = decoded;\n\n    return [\n      {\n        type: TransactionType.Upload,\n        root,\n        witnessIndex,\n        subsectionIndex,\n        subsectionsNumber,\n        proofSetCount,\n        policyTypes,\n        inputsCount,\n        outputsCount,\n        witnessesCount,\n        proofSet,\n        policies,\n        inputs,\n        outputs,\n        witnesses,\n      },\n      o,\n    ];\n  }\n}\n\nexport type TransactionBlob = BaseTransactionType & {\n  type: TransactionType.Blob;\n\n  /** Hash of the bytecode. (b256) */\n  blobId: string;\n\n  /** Witness index of contract bytecode (u16) */\n  witnessIndex: number;\n};\n\nexport class TransactionBlobCoder extends Coder<TransactionBlob, TransactionBlob> {\n  constructor() {\n    super('TransactionBlob', 'struct TransactionBlob', 0);\n  }\n\n  encode(value: TransactionBlob): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new B256Coder().encode(value.blobId));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessIndex));\n    parts.push(new NumberCoder('u32', { padToWordSize: true }).encode(value.policyTypes));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.inputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.outputsCount));\n    parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(value.witnessesCount));\n    parts.push(new PoliciesCoder().encode(value.policies));\n    parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));\n    parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));\n    parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [TransactionBlob, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new B256Coder().decode(data, o);\n    const blobId = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessIndex = decoded;\n    [decoded, o] = new NumberCoder('u32', { padToWordSize: true }).decode(data, o);\n    const policyTypes = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const inputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const outputsCount = decoded;\n    [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n    const witnessesCount = decoded;\n    [decoded, o] = new PoliciesCoder().decode(data, o, policyTypes);\n    const policies = decoded;\n    [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);\n    const inputs = decoded;\n    [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);\n    const outputs = decoded;\n    [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);\n    const witnesses = decoded;\n\n    return [\n      {\n        type: TransactionType.Blob,\n        blobId,\n        witnessIndex,\n        policyTypes,\n        inputsCount,\n        outputsCount,\n        witnessesCount,\n        policies,\n        inputs,\n        outputs,\n        witnesses,\n      },\n      o,\n    ];\n  }\n}\n\ntype PossibleTransactions =\n  | TransactionScript\n  | TransactionCreate\n  | TransactionMint\n  | TransactionUpgrade\n  | TransactionUpload\n  | TransactionBlob;\n\nexport type Transaction<TTransactionType = void> = TTransactionType extends TransactionType\n  ? Extract<PossibleTransactions, { type: TTransactionType }>\n  : Partial<Omit<TransactionScript, 'type'>> &\n      Partial<Omit<TransactionCreate, 'type'>> &\n      Partial<Omit<TransactionMint, 'type'>> &\n      Partial<Omit<TransactionUpgrade, 'type'>> &\n      Partial<Omit<TransactionUpload, 'type'>> &\n      Partial<Omit<TransactionBlob, 'type'>> & {\n        type: TransactionType;\n      };\n\nexport class TransactionCoder extends Coder<Transaction, Transaction> {\n  constructor() {\n    super('Transaction', 'struct Transaction', 0);\n  }\n\n  encode(value: Transaction): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u8', { padToWordSize: true }).encode(value.type));\n\n    const { type } = value;\n\n    switch (value.type) {\n      case TransactionType.Script: {\n        parts.push(\n          new TransactionScriptCoder().encode(value as Transaction<TransactionType.Script>)\n        );\n        break;\n      }\n      case TransactionType.Create: {\n        parts.push(\n          new TransactionCreateCoder().encode(value as Transaction<TransactionType.Create>)\n        );\n        break;\n      }\n      case TransactionType.Mint: {\n        parts.push(new TransactionMintCoder().encode(value as Transaction<TransactionType.Mint>));\n        break;\n      }\n      case TransactionType.Upgrade: {\n        parts.push(\n          new TransactionUpgradeCoder().encode(value as Transaction<TransactionType.Upgrade>)\n        );\n        break;\n      }\n      case TransactionType.Upload: {\n        parts.push(\n          new TransactionUploadCoder().encode(value as Transaction<TransactionType.Upload>)\n        );\n        break;\n      }\n      case TransactionType.Blob: {\n        parts.push(new TransactionBlobCoder().encode(value as Transaction<TransactionType.Blob>));\n        break;\n      }\n      default: {\n        throw new FuelError(\n          ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,\n          `Unsupported transaction type: ${type}`\n        );\n      }\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Transaction, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u8', { padToWordSize: true }).decode(data, o);\n    const type = decoded as TransactionType;\n\n    switch (type) {\n      case TransactionType.Script: {\n        [decoded, o] = new TransactionScriptCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case TransactionType.Create: {\n        [decoded, o] = new TransactionCreateCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case TransactionType.Mint: {\n        [decoded, o] = new TransactionMintCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case TransactionType.Upgrade: {\n        [decoded, o] = new TransactionUpgradeCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case TransactionType.Upload: {\n        [decoded, o] = new TransactionUploadCoder().decode(data, o);\n        return [decoded, o];\n      }\n      case TransactionType.Blob: {\n        [decoded, o] = new TransactionBlobCoder().decode(data, o);\n        return [decoded, o];\n      }\n      default: {\n        throw new FuelError(\n          ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,\n          `Unsupported transaction type: ${type}`\n        );\n      }\n    }\n  }\n}\n","import { B256Coder, Coder, NumberCoder } from '@fuel-ts/abi-coder';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concat } from '@fuel-ts/utils';\n\nexport enum UpgradePurposeTypeEnum {\n  ConsensusParameters = 0,\n  StateTransition = 1,\n}\n\nexport type UpgradePurpose =\n  | {\n      type: UpgradePurposeTypeEnum.ConsensusParameters;\n      data: ConsensusParameters;\n    }\n  | {\n      type: UpgradePurposeTypeEnum.StateTransition;\n      data: StateTransition;\n    };\n\nexport interface ConsensusParameters {\n  /** Index of witness that contains a serialized(with postcard) consensus parameters. (u16) */\n  witnessIndex: number;\n\n  /** The hash of the serialized consensus parameters. */\n  checksum: string;\n}\n\nexport interface StateTransition {\n  /** The root of the new bytecode of the state transition function. */\n  bytecodeRoot: string;\n}\n\nexport class UpgradePurposeCoder extends Coder<UpgradePurpose, UpgradePurpose> {\n  constructor() {\n    super('UpgradePurpose', 'UpgradePurpose', 0);\n  }\n\n  encode(upgradePurposeType: UpgradePurpose): Uint8Array {\n    const parts: Uint8Array[] = [];\n    const { type } = upgradePurposeType;\n\n    parts.push(new NumberCoder('u8', { padToWordSize: true }).encode(type));\n\n    switch (type) {\n      case UpgradePurposeTypeEnum.ConsensusParameters: {\n        const data = upgradePurposeType.data as ConsensusParameters;\n\n        parts.push(new NumberCoder('u16', { padToWordSize: true }).encode(data.witnessIndex));\n        parts.push(new B256Coder().encode(data.checksum));\n        break;\n      }\n\n      case UpgradePurposeTypeEnum.StateTransition: {\n        const data = upgradePurposeType.data as StateTransition;\n\n        parts.push(new B256Coder().encode(data.bytecodeRoot));\n        break;\n      }\n\n      default: {\n        throw new FuelError(\n          ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,\n          `Unsupported transaction type: ${type}`\n        );\n      }\n    }\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [UpgradePurpose, number] {\n    let o = offset;\n    let decoded;\n\n    [decoded, o] = new NumberCoder('u8', { padToWordSize: true }).decode(data, o);\n    const type = decoded as UpgradePurposeTypeEnum;\n\n    switch (type) {\n      case UpgradePurposeTypeEnum.ConsensusParameters: {\n        [decoded, o] = new NumberCoder('u16', { padToWordSize: true }).decode(data, o);\n        const witnessIndex = decoded;\n        [decoded, o] = new B256Coder().decode(data, o);\n        const checksum = decoded;\n\n        return [{ type, data: { witnessIndex, checksum } }, o];\n      }\n\n      case UpgradePurposeTypeEnum.StateTransition: {\n        [decoded, o] = new B256Coder().decode(data, o);\n        const bytecodeRoot = decoded;\n\n        return [{ type, data: { bytecodeRoot } }, o];\n      }\n\n      default: {\n        throw new FuelError(\n          ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,\n          `Unsupported transaction type: ${type}`\n        );\n      }\n    }\n  }\n}\n","import { Coder, NumberCoder } from '@fuel-ts/abi-coder';\nimport { concat } from '@fuel-ts/utils';\n\nimport { ByteArrayCoder } from './byte-array';\n\nexport type Witness = {\n  /** Length of witness data byte array */\n  dataLength: number;\n  /** Witness data (byte[]) */\n  data: string;\n};\n\nexport class WitnessCoder extends Coder<Witness, Witness> {\n  constructor() {\n    super(\n      'Witness',\n      // Types of dynamic length are not supported in the ABI\n      'unknown',\n      0\n    );\n  }\n\n  encode(value: Witness): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    parts.push(new NumberCoder('u32', { padToWordSize: true }).encode(value.dataLength));\n    parts.push(new ByteArrayCoder(value.dataLength).encode(value.data));\n\n    return concat(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [Witness, number] {\n    let decoded;\n    let o = offset;\n\n    [decoded, o] = new NumberCoder('u32', { padToWordSize: true }).decode(data, o);\n    const dataLength = decoded;\n    [decoded, o] = new ByteArrayCoder(dataLength).decode(data, o);\n    const witnessData = decoded;\n\n    return [\n      {\n        dataLength,\n        data: witnessData,\n      },\n      o,\n    ];\n  }\n}\n","import { B256Coder, NumberCoder, StructCoder } from '@fuel-ts/abi-coder';\n\nexport type UtxoId = {\n  /** Transaction ID (b256) */\n  transactionId: string;\n  /** Output index (u8) */\n  outputIndex: number;\n};\n\nexport class UtxoIdCoder extends StructCoder<{\n  transactionId: B256Coder;\n  outputIndex: NumberCoder;\n}> {\n  constructor() {\n    super('UtxoId', {\n      transactionId: new B256Coder(),\n      outputIndex: new NumberCoder('u16', { padToWordSize: true }),\n    });\n  }\n}\n"],"mappings":"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","names":["import_abi_coder","import_errors","import_utils","import_abi_coder","InputType","import_abi_coder","import_errors","import_utils","OutputType","import_abi_coder","import_errors","import_utils","PolicyType","import_abi_coder","import_hasher","import_utils","ReceiptType","import_abi_coder","import_abi_coder","import_errors","import_utils","import_abi_coder","import_errors","import_utils","UpgradePurposeTypeEnum","import_abi_coder","import_utils","TransactionType","import_abi_coder"]}