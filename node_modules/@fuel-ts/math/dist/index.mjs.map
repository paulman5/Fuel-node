{"version":3,"sources":["../src/bn.ts","../src/configs.ts","../src/decimal.ts","../src/functional.ts","../src/math.ts"],"sourcesContent":["import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport BnJs from 'bn.js';\n\nimport { DEFAULT_DECIMAL_UNITS, DEFAULT_MIN_PRECISION, DEFAULT_PRECISION } from './configs';\nimport type { FormatConfig } from './types';\n\ntype CompareResult = -1 | 0 | 1;\nexport type BNInput = number | string | number[] | Uint8Array | Buffer | BnJs;\n\ninterface BNHelper {\n  caller(v: BNInput, methodName: string): BN | boolean | CompareResult;\n  toHex: (bytesPadding?: number) => string;\n  toBytes: (bytesPadding?: number) => Uint8Array;\n  toJSON: () => string;\n}\ninterface BNInputOverrides {\n  add: (v: BNInput) => BN;\n  pow: (v: BNInput) => BN;\n  sub: (v: BNInput) => BN;\n  div: (v: BNInput) => BN;\n  mul: (v: BNInput) => BN;\n  mod: (v: BNInput) => BN;\n  divRound: (v: BNInput) => BN;\n  lt: (v: BNInput) => boolean;\n  lte: (v: BNInput) => boolean;\n  gt: (v: BNInput) => boolean;\n  gte: (v: BNInput) => boolean;\n  eq: (v: BNInput) => boolean;\n  cmp: (v: BNInput) => CompareResult;\n}\ninterface BNOverrides {\n  sqr: () => BN;\n  neg: () => BN;\n  abs: () => BN;\n  toTwos: (width: number) => BN;\n  fromTwos: (width: number) => BN;\n}\ninterface BNHiddenTypes {\n  mulTo: (num: BN, out: BN) => BN;\n  divmod: (num: BNInput, mode?: string, positive?: boolean) => { mod: BN; div: BN };\n}\ntype BNInputOverridesKeys = keyof BNInputOverrides;\n\nexport class BN extends BnJs implements BNInputOverrides, BNHiddenTypes, BNHelper, BNOverrides {\n  MAX_U64 = '0xFFFFFFFFFFFFFFFF';\n\n  constructor(value?: BNInput | null, base?: number | 'hex', endian?: BnJs.Endianness) {\n    let bnValue = value;\n    let bnBase = base;\n\n    if (BN.isBN(value)) {\n      bnValue = value.toArray();\n    }\n    // trim '0x' from hex strings as BN doesn't support it - https://github.com/ChainSafe/web3.js/issues/3847\n    else if (typeof value === 'string' && value.slice(0, 2) === '0x') {\n      bnValue = value.substring(2);\n      bnBase = base || 'hex';\n    }\n\n    super(bnValue == null ? 0 : bnValue, bnBase, endian);\n  }\n\n  // ANCHOR: HELPERS\n  // make sure we always include `0x` in hex strings\n  override toString(base?: number | 'hex', length?: number) {\n    const output = super.toString(base, length);\n\n    if (base === 16 || base === 'hex') {\n      return `0x${output}`;\n    }\n\n    return output;\n  }\n\n  toHex(bytesPadding?: number): string {\n    const bytes = bytesPadding || 0;\n    const bytesLength = bytes * 2;\n\n    if (this.isNeg()) {\n      throw new FuelError(ErrorCode.CONVERTING_FAILED, 'Cannot convert negative value to hex.');\n    }\n    if (bytesPadding && this.byteLength() > bytesPadding) {\n      throw new FuelError(\n        ErrorCode.CONVERTING_FAILED,\n        `Provided value ${this} is too large. It should fit within ${bytesPadding} bytes.`\n      );\n    }\n\n    return this.toString(16, bytesLength);\n  }\n\n  toBytes(bytesPadding?: number): Uint8Array {\n    if (this.isNeg()) {\n      throw new FuelError(ErrorCode.CONVERTING_FAILED, 'Cannot convert negative value to bytes.');\n    }\n\n    return Uint8Array.from(this.toArray(undefined, bytesPadding));\n  }\n\n  override toJSON(): string {\n    return this.toString(16);\n  }\n\n  override valueOf(): string {\n    return this.toString();\n  }\n\n  format(options?: FormatConfig): string {\n    const {\n      units = DEFAULT_DECIMAL_UNITS,\n      precision: initialPrecision = DEFAULT_PRECISION,\n      minPrecision: initialMinPrecision = DEFAULT_MIN_PRECISION,\n    } = options || {};\n\n    // If units is 0, return the whole number formatted with commas\n    if (units === 0) {\n      return this.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n    }\n\n    // Adjust precision and minPrecision\n    // TODO: This really should throw an error because you can't have a precision less than the minPrecision but this would be a breaking change\n    const minPrecision =\n      initialMinPrecision > initialPrecision ? initialPrecision : initialMinPrecision;\n    const precision =\n      initialPrecision > initialMinPrecision ? initialPrecision : initialMinPrecision;\n\n    const formattedUnits = this.formatUnits(units);\n    const [integerPart, fractionalPart = ''] = formattedUnits.split('.');\n\n    const formattedInteger = integerPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n\n    // If precision is 0, return only the integer part\n    if (precision === 0) {\n      return formattedInteger;\n    }\n\n    // Remove trailing zeros and apply precision\n    let formattedFractional = fractionalPart.replace(/0+$/, '');\n\n    // Always return the first non-zero number if it exceeds the precision and the integer part is zero\n    if (formattedFractional.length > precision) {\n      if (integerPart === '0') {\n        const firstNonZeroIndex = formattedFractional.search(/[1-9]/);\n        if (firstNonZeroIndex >= 0 && firstNonZeroIndex < precision) {\n          formattedFractional = formattedFractional.slice(0, precision);\n        } else {\n          formattedFractional = formattedFractional.slice(0, firstNonZeroIndex + 1);\n        }\n      } else {\n        formattedFractional = formattedFractional.slice(0, precision);\n      }\n    } else {\n      formattedFractional = formattedFractional.slice(0, precision);\n    }\n\n    // Ensure we meet the minimum precision\n    if (formattedFractional.length < minPrecision) {\n      formattedFractional = formattedFractional.padEnd(minPrecision, '0');\n    }\n\n    // If after removing trailing zeros, the fractional part is empty and minPrecision is 0, return only the integer part\n    if (formattedFractional === '' && minPrecision === 0) {\n      return formattedInteger;\n    }\n\n    // Only add the decimal point and fractional part if there's a fractional part\n    return formattedFractional ? `${formattedInteger}.${formattedFractional}` : formattedInteger;\n  }\n\n  formatUnits(units: number = DEFAULT_DECIMAL_UNITS): string {\n    const valueString = this.toString();\n    const valueLength = valueString.length;\n\n    if (valueLength <= units) {\n      const paddedZeros = '0'.repeat(units - valueLength);\n      return `0.${paddedZeros}${valueString}`;\n    }\n\n    const integerPart = valueString.slice(0, valueLength - units);\n    const fractionalPart = valueString.slice(valueLength - units);\n\n    return `${integerPart}.${fractionalPart}`;\n  }\n  // END ANCHOR: HELPERS\n\n  // ANCHOR: OVERRIDES to accept better inputs\n  override add(v: BNInput): BN {\n    return this.caller(v, 'add') as BN;\n  }\n\n  override pow(v: BNInput): BN {\n    return this.caller(v, 'pow') as BN;\n  }\n\n  override sub(v: BNInput): BN {\n    return this.caller(v, 'sub') as BN;\n  }\n\n  override div(v: BNInput): BN {\n    return this.caller(v, 'div') as BN;\n  }\n\n  override mul(v: BNInput): BN {\n    return this.caller(v, 'mul') as BN;\n  }\n\n  override mod(v: BNInput): BN {\n    return this.caller(v, 'mod') as BN;\n  }\n\n  override divRound(v: BNInput): BN {\n    return this.caller(v, 'divRound') as BN;\n  }\n\n  override lt(v: BNInput): boolean {\n    return this.caller(v, 'lt') as boolean;\n  }\n\n  override lte(v: BNInput): boolean {\n    return this.caller(v, 'lte') as boolean;\n  }\n\n  override gt(v: BNInput): boolean {\n    return this.caller(v, 'gt') as boolean;\n  }\n\n  override gte(v: BNInput): boolean {\n    return this.caller(v, 'gte') as boolean;\n  }\n\n  override eq(v: BNInput): boolean {\n    return this.caller(v, 'eq') as boolean;\n  }\n\n  override cmp(v: BNInput): CompareResult {\n    return this.caller(v, 'cmp') as CompareResult;\n  }\n  // END ANCHOR: OVERRIDES to accept better inputs\n\n  // ANCHOR: OVERRIDES to output our BN type\n  override sqr(): BN {\n    return new BN(super.sqr().toArray());\n  }\n\n  override neg(): BN {\n    return new BN(super.neg().toArray());\n  }\n\n  override abs(): BN {\n    return new BN(super.abs().toArray());\n  }\n\n  override toTwos(width: number): BN {\n    return new BN(super.toTwos(width).toArray());\n  }\n\n  override fromTwos(width: number): BN {\n    return new BN(super.fromTwos(width).toArray());\n  }\n  // END ANCHOR: OVERRIDES to output our BN type\n\n  // ANCHOR: OVERRIDES to avoid losing references\n  caller(v: BNInput, methodName: BNInputOverridesKeys): BN | boolean | CompareResult {\n    const output = super[methodName](new BN(v));\n\n    if (BN.isBN(output)) {\n      return new BN(output.toArray());\n    }\n\n    if (typeof output === 'boolean') {\n      return output as boolean;\n    }\n\n    return output as CompareResult;\n  }\n\n  override clone() {\n    return new BN(this.toArray());\n  }\n\n  mulTo(num: BN, out: BN) {\n    const output: BnJs = (new BnJs(this.toArray()) as BN).mulTo(num, out);\n\n    return new BN(output.toArray());\n  }\n\n  override egcd(p: BnJs) {\n    const { a, b, gcd } = new BnJs(this.toArray()).egcd(p);\n\n    return {\n      a: new BN(a.toArray()),\n      b: new BN(b.toArray()),\n      gcd: new BN(gcd.toArray()),\n    };\n  }\n\n  override divmod(num: BNInput, mode?: string, positive?: boolean): { mod: BN; div: BN } {\n    const { div, mod } = (new BnJs(this.toArray()) as BN).divmod(new BN(num), mode, positive);\n\n    return {\n      div: new BN(div?.toArray()),\n      mod: new BN(mod?.toArray()),\n    };\n  }\n\n  maxU64(): BN {\n    return this.gte(this.MAX_U64) ? new BN(this.MAX_U64) : this;\n  }\n\n  max(num: BNInput): BN {\n    return this.gte(num) ? new BN(num) : this;\n  }\n\n  normalizeZeroToOne(): BN {\n    return this.isZero() ? new BN(1) : this;\n  }\n  // END ANCHOR: OVERRIDES to avoid losing references\n}\n\n// functional shortcut to create BN\nexport const bn = (value?: BNInput | null, base?: number | 'hex', endian?: BnJs.Endianness) =>\n  new BN(value, base, endian);\n\nbn.parseUnits = (value: string, units: number = DEFAULT_DECIMAL_UNITS): BN => {\n  const valueToParse = value === '.' ? '0.' : value;\n  const [valueUnits = '0', valueDecimals = '0'] = valueToParse.split('.');\n  const length = valueDecimals.length;\n\n  if (units === 0) {\n    const valueWithoutDecimals = valueToParse.replace(',', '').split('.')[0];\n    return bn(valueWithoutDecimals);\n  }\n\n  if (length > units) {\n    throw new FuelError(\n      ErrorCode.CONVERTING_FAILED,\n      `Decimal can't have more than ${units} digits.`\n    );\n  }\n\n  const decimals = Array.from({ length: units }).fill('0');\n  decimals.splice(0, length, valueDecimals);\n  const amount = `${valueUnits.replaceAll(',', '')}${decimals.join('')}`;\n  return bn(amount);\n};\n","export const DEFAULT_PRECISION = 9;\nexport const DEFAULT_MIN_PRECISION = 3;\nexport const DEFAULT_DECIMAL_UNITS = 9;\n\n// Decimal units on the Fuel Network\nexport const DECIMAL_FUEL = 9;\n\n// Decimal units on the Ethereum network\nexport const DECIMAL_WEI = 18;\nexport const DECIMAL_KWEI = 15;\nexport const DECIMAL_MWEI = 12;\nexport const DECIMAL_GWEI = 9;\n","import { DEFAULT_PRECISION, DEFAULT_MIN_PRECISION } from './configs';\nimport type { ToFixedConfig } from './types';\n\nexport function toFixed(value?: string | number, options?: ToFixedConfig) {\n  const { precision = DEFAULT_PRECISION, minPrecision = DEFAULT_MIN_PRECISION } = options || {};\n\n  const [valueUnits = '0', valueDecimals = '0'] = String(value || '0.0').split('.');\n  const groupRegex = /(\\d)(?=(\\d{3})+\\b)/g;\n  const units = valueUnits.replace(groupRegex, '$1,');\n  let decimals = valueDecimals.slice(0, precision);\n\n  // strip traling zeros limited by minPrecision\n  if (minPrecision < precision) {\n    const trimmedDecimal = decimals.match(/.*[1-9]{1}/);\n    const lastNonZeroIndex = trimmedDecimal?.[0].length || 0;\n    const keepChars = Math.max(minPrecision, lastNonZeroIndex);\n    decimals = decimals.slice(0, keepChars);\n  }\n\n  const decimalPortion = decimals ? `.${decimals}` : '';\n  return `${units}${decimalPortion}`;\n}\n","import type { BNInput } from './bn';\nimport { bn } from './bn';\nimport type { FormatConfig } from './types';\n\n/**\n * Functional shortcuts\n */\n\n// Shortcut to bn(value).toNumber\nexport function toNumber(value: BNInput): number {\n  return bn(value).toNumber();\n}\n\n// Shortcut to bn(value).toHex\nexport function toHex(value: BNInput, bytesPadding?: number): string {\n  return bn(value).toHex(bytesPadding);\n}\n\n// Shortcut to bn(value).toBytes\nexport function toBytes(value: BNInput, bytesPadding?: number): Uint8Array {\n  return bn(value).toBytes(bytesPadding);\n}\n\n// Shortcut to bn.(value).formatUnits\nexport function formatUnits(value: BNInput, units?: number): string {\n  return bn(value).formatUnits(units);\n}\n\n// Shortcut to bn.(value).format\nexport function format(value: BNInput, options?: FormatConfig): string {\n  return bn(value).format(options);\n}\n","import type { BN } from './bn';\nimport { bn } from './bn';\nimport type { BigNumberish } from './types';\n\nexport function max(...numbers: Array<BigNumberish>): BN {\n  return numbers.reduce<BN>((prev, cur) => (bn(cur).gt(prev) ? bn(cur) : prev), bn(0));\n}\n\nexport function multiply(...numbers: Array<BigNumberish>): BN {\n  return bn(Math.ceil(numbers.reduce<BN>((a, b) => bn(a).mul(b), bn(1)).toNumber()));\n}\n"],"mappings":"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","names":[]}