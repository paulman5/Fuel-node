var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/contract-factory.ts
import { Interface, WORD_SIZE as WORD_SIZE2 } from "@fuel-ts/abi-coder";
import {
  CreateTransactionRequest,
  BlobTransactionRequest,
  TransactionStatus,
  calculateGasFee
} from "@fuel-ts/account";
import { randomBytes } from "@fuel-ts/crypto";
import { ErrorCode, FuelError } from "@fuel-ts/errors";
import { hash } from "@fuel-ts/hasher";
import { bn } from "@fuel-ts/math";
import { Contract } from "@fuel-ts/program";
import { arrayify as arrayify3, isDefined } from "@fuel-ts/utils";

// src/loader/loader-script.ts
import { BYTES_32 } from "@fuel-ts/abi-coder";
import { InstructionSet } from "@fuel-ts/program";
import { arrayify, concat } from "@fuel-ts/utils";
import * as asm from "@fuels/vm-asm";
var getLoaderInstructions = (blobIds) => {
  const { RegId, Instruction } = asm;
  const numberOfInstructions = 12;
  const numberOfBlobs = blobIds.length;
  const blobIdSize = BYTES_32;
  const blobIdBytes = concat(blobIds.map((b) => arrayify(b)));
  const instructionBytes = new InstructionSet(
    // 1. load the blob contents into memory
    // find the start of the hardcoded blob ids, which are located after the code ends
    asm.move_(16, RegId.pc().to_u8()),
    // 0x10 to hold the address of the current blob id
    asm.addi(16, 16, numberOfInstructions * Instruction.size()),
    // The contract is going to be loaded from the current value of SP onwards, save
    // the location into 0x16 so we can jump into it later on
    asm.move_(22, RegId.sp().to_u8()),
    // loop counter
    asm.movi(19, numberOfBlobs),
    // LOOP starts here
    // 0x11 to hold the size of the current blob
    asm.bsiz(17, 16),
    // push the blob contents onto the stack
    asm.ldc(16, 0, 17, 1),
    // move on to the next blob
    asm.addi(16, 16, blobIdSize),
    // decrement the loop counter
    asm.subi(19, 19, 1),
    // Jump backwards (3+1) instructions if the counter has not reached 0
    asm.jnzb(19, RegId.zero().to_u8(), 3),
    // Jump into the memory where the contract is loaded
    // what follows is called _jmp_mem by the sway compiler
    // subtract the address contained in IS because jmp will add it back
    asm.sub(22, 22, RegId.is().to_u8()),
    // jmp will multiply by 4 so we need to divide to cancel that out
    asm.divi(22, 22, 4),
    // jump to the start of the contract we loaded
    asm.jmp(22)
  ).toBytes();
  return concat([instructionBytes, blobIdBytes]);
};

// src/loader/utils.ts
import { WORD_SIZE } from "@fuel-ts/abi-coder";
import { concat as concat2 } from "@fuel-ts/utils";
var getContractChunks = (bytecode, chunkSize) => {
  const chunks = [];
  for (let offset = 0, index = 0; offset < bytecode.length; offset += chunkSize, index++) {
    let chunk = bytecode.slice(offset, offset + chunkSize);
    let length = chunk.length;
    if (length % WORD_SIZE !== 0) {
      chunk = concat2([chunk, new Uint8Array(chunkSize - chunk.length)]);
      length = chunk.length;
    }
    chunks.push({ id: index, size: length, bytecode: chunk });
  }
  return chunks;
};

// src/util.ts
var util_exports = {};
__export(util_exports, {
  getContractId: () => getContractId,
  getContractRoot: () => getContractRoot,
  getContractStorageRoot: () => getContractStorageRoot,
  hexlifyWithPrefix: () => hexlifyWithPrefix
});
import { sha256 } from "@fuel-ts/hasher";
import { calcRoot, SparseMerkleTree } from "@fuel-ts/merkle";
import { chunkAndPadBytes, hexlify, concat as concat3, arrayify as arrayify2 } from "@fuel-ts/utils";
var getContractRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes = arrayify2(bytecode);
  const chunks = chunkAndPadBytes(bytes, chunkSize);
  return calcRoot(chunks.map((c) => hexlify(c)));
};
var getContractStorageRoot = (storageSlots) => {
  const tree = new SparseMerkleTree();
  storageSlots.forEach(({ key, value }) => tree.update(sha256(key), value));
  return tree.root;
};
var getContractId = (bytecode, salt, stateRoot) => {
  const root = getContractRoot(arrayify2(bytecode));
  const contractId = sha256(concat3(["0x4655454C", salt, root, stateRoot]));
  return contractId;
};
var hexlifyWithPrefix = (value) => hexlify(value.startsWith("0x") ? value : `0x${value}`);

// src/contract-factory.ts
var CHUNK_SIZE_MULTIPLIER = 0.95;
var ContractFactory = class {
  bytecode;
  interface;
  provider;
  account;
  storageSlots;
  /**
   * Create a ContractFactory instance.
   *
   * @param bytecode - The bytecode of the contract.
   * @param abi - The contract's ABI (Application Binary Interface).
   * @param accountOrProvider - An account or provider to be associated with the factory.
   */
  constructor(bytecode, abi, accountOrProvider = null, storageSlots = []) {
    this.bytecode = arrayify3(bytecode);
    if (abi instanceof Interface) {
      this.interface = abi;
    } else {
      this.interface = new Interface(abi);
    }
    if (accountOrProvider && "provider" in accountOrProvider) {
      this.provider = accountOrProvider.provider;
      this.account = accountOrProvider;
    } else {
      this.provider = accountOrProvider;
      this.account = null;
    }
    this.storageSlots = storageSlots;
  }
  /**
   * Connect the factory to a provider.
   *
   * @param provider - The provider to be associated with the factory.
   * @returns A new ContractFactory instance.
   */
  connect(provider) {
    return new ContractFactory(this.bytecode, this.interface, provider);
  }
  /**
   * Create a transaction request to deploy a contract with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns The CreateTransactionRequest object for deploying the contract.
   */
  createTransactionRequest(deployOptions) {
    const storageSlots = (deployOptions?.storageSlots ?? []).concat(this.storageSlots).map(({ key, value }) => ({
      key: hexlifyWithPrefix(key),
      value: hexlifyWithPrefix(value)
    })).filter((el, index, self) => self.findIndex((s) => s.key === el.key) === index).sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));
    const options = {
      salt: randomBytes(32),
      ...deployOptions ?? {},
      storageSlots
    };
    if (!this.provider) {
      throw new FuelError(
        ErrorCode.MISSING_PROVIDER,
        "Cannot create transaction request without provider"
      );
    }
    const bytecode = deployOptions?.bytecode || this.bytecode;
    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);
    const contractId = getContractId(bytecode, options.salt, stateRoot);
    const transactionRequest = new CreateTransactionRequest({
      bytecodeWitnessIndex: 0,
      witnesses: [bytecode],
      ...options
    });
    transactionRequest.addContractCreatedOutput(contractId, stateRoot);
    return {
      contractId,
      transactionRequest
    };
  }
  /**
   * Takes a transaction request, estimates it and funds it.
   *
   * @param request - the request to fund.
   * @param options - options for funding the request.
   * @returns a funded transaction request.
   */
  async fundTransactionRequest(request, options = {}) {
    const account = this.getAccount();
    const { maxFee: setMaxFee } = options;
    const txCost = await account.getTransactionCost(request);
    if (isDefined(setMaxFee)) {
      if (txCost.maxFee.gt(setMaxFee)) {
        throw new FuelError(
          ErrorCode.MAX_FEE_TOO_LOW,
          `Max fee '${options.maxFee}' is lower than the required: '${txCost.maxFee}'.`
        );
      }
    } else {
      request.maxFee = txCost.maxFee;
    }
    await account.fund(request, txCost);
    return request;
  }
  /**
   * Deploy a contract of any length with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deploy(deployOptions = {}) {
    const account = this.getAccount();
    const { consensusParameters } = await account.provider.getChain();
    const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();
    return this.bytecode.length > maxContractSize ? this.deployAsBlobTx(deployOptions) : this.deployAsCreateTx(deployOptions);
  }
  /**
   * Deploy a contract with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployAsCreateTx(deployOptions = {}) {
    const account = this.getAccount();
    const { consensusParameters } = await account.provider.getChain();
    const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();
    if (this.bytecode.length > maxContractSize) {
      throw new FuelError(
        ErrorCode.CONTRACT_SIZE_EXCEEDS_LIMIT,
        "Contract bytecode is too large. Please use `deployAsBlobTx` instead."
      );
    }
    const { contractId, transactionRequest } = await this.prepareDeploy(deployOptions);
    const transactionResponse = await account.sendTransaction(transactionRequest);
    const waitForResult = async () => {
      const transactionResult = await transactionResponse.waitForResult();
      const contract = new Contract(contractId, this.interface, account);
      return { contract, transactionResult };
    };
    return {
      contractId,
      waitForTransactionId: () => Promise.resolve(transactionResponse.id),
      waitForResult
    };
  }
  /**
   * Chunks and deploys a contract via a loader contract. Suitable for deploying contracts larger than the max contract size.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployAsBlobTx(deployOptions = {
    chunkSizeMultiplier: CHUNK_SIZE_MULTIPLIER
  }) {
    const account = this.getAccount();
    const { configurableConstants, chunkSizeMultiplier } = deployOptions;
    if (configurableConstants) {
      this.setConfigurableConstants(configurableConstants);
    }
    const chunkSize = await this.getMaxChunkSize(deployOptions, chunkSizeMultiplier);
    const chunks = getContractChunks(arrayify3(this.bytecode), chunkSize).map((c) => {
      const transactionRequest = this.blobTransactionRequest({
        ...deployOptions,
        bytecode: c.bytecode
      });
      return {
        ...c,
        transactionRequest,
        blobId: transactionRequest.blobId
      };
    });
    const blobIds = chunks.map(({ blobId }) => blobId);
    const loaderBytecode = getLoaderInstructions(blobIds);
    const { contractId, transactionRequest: createRequest } = this.createTransactionRequest({
      bytecode: loaderBytecode,
      ...deployOptions
    });
    const uniqueBlobIds = [...new Set(blobIds)];
    const uploadedBlobIds = await account.provider.getBlobs(uniqueBlobIds);
    const blobIdsToUpload = uniqueBlobIds.filter((id) => !uploadedBlobIds.includes(id));
    let totalCost = bn(0);
    const chainInfo = await account.provider.getChain();
    const gasPrice = await account.provider.estimateGasPrice(10);
    const priceFactor = chainInfo.consensusParameters.feeParameters.gasPriceFactor;
    for (const { transactionRequest, blobId } of chunks) {
      if (blobIdsToUpload.includes(blobId)) {
        const minGas = transactionRequest.calculateMinGas(chainInfo);
        const minFee = calculateGasFee({
          gasPrice,
          gas: minGas,
          priceFactor,
          tip: transactionRequest.tip
        }).add(1);
        totalCost = totalCost.add(minFee);
      }
      const createMinGas = createRequest.calculateMinGas(chainInfo);
      const createMinFee = calculateGasFee({
        gasPrice,
        gas: createMinGas,
        priceFactor,
        tip: createRequest.tip
      }).add(1);
      totalCost = totalCost.add(createMinFee);
    }
    if (totalCost.gt(await account.getBalance())) {
      throw new FuelError(ErrorCode.FUNDS_TOO_LOW, "Insufficient balance to deploy contract.");
    }
    let txIdResolver;
    const txIdPromise = new Promise((resolve) => {
      txIdResolver = resolve;
    });
    const waitForResult = async () => {
      const uploadedBlobs = [];
      for (const { blobId, transactionRequest } of chunks) {
        if (!uploadedBlobs.includes(blobId) && blobIdsToUpload.includes(blobId)) {
          const fundedBlobRequest = await this.fundTransactionRequest(
            transactionRequest,
            deployOptions
          );
          let result;
          try {
            const blobTx = await account.sendTransaction(fundedBlobRequest);
            result = await blobTx.waitForResult();
          } catch (err) {
            if (err.message.indexOf(`BlobId is already taken ${blobId}`) > -1) {
              uploadedBlobs.push(blobId);
              continue;
            }
            throw new FuelError(ErrorCode.TRANSACTION_FAILED, "Failed to deploy contract chunk");
          }
          if (!result.status || result.status !== TransactionStatus.success) {
            throw new FuelError(ErrorCode.TRANSACTION_FAILED, "Failed to deploy contract chunk");
          }
          uploadedBlobs.push(blobId);
        }
      }
      await this.fundTransactionRequest(createRequest, deployOptions);
      txIdResolver(createRequest.getTransactionId(await account.provider.getChainId()));
      const transactionResponse = await account.sendTransaction(createRequest);
      const transactionResult = await transactionResponse.waitForResult();
      const contract = new Contract(contractId, this.interface, account);
      return { contract, transactionResult };
    };
    const waitForTransactionId = () => txIdPromise;
    return { waitForResult, contractId, waitForTransactionId };
  }
  /**
   * Set configurable constants of the contract with the specified values.
   *
   * @param configurableConstants - An object containing configurable names and their values.
   */
  setConfigurableConstants(configurableConstants) {
    try {
      const hasConfigurable = Object.keys(this.interface.configurables).length;
      if (!hasConfigurable) {
        throw new FuelError(
          ErrorCode.CONFIGURABLE_NOT_FOUND,
          "Contract does not have configurables to be set"
        );
      }
      Object.entries(configurableConstants).forEach(([key, value]) => {
        if (!this.interface.configurables[key]) {
          throw new FuelError(
            ErrorCode.CONFIGURABLE_NOT_FOUND,
            `Contract does not have a configurable named: '${key}'`
          );
        }
        const { offset } = this.interface.configurables[key];
        const encoded = this.interface.encodeConfigurable(key, value);
        const bytes = arrayify3(this.bytecode);
        bytes.set(encoded, offset);
        this.bytecode = bytes;
      });
    } catch (err) {
      throw new FuelError(
        ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants on contract: ${err.message}.`
      );
    }
  }
  getAccount() {
    if (!this.account) {
      throw new FuelError(ErrorCode.ACCOUNT_REQUIRED, "Account not assigned to contract.");
    }
    return this.account;
  }
  async prepareDeploy(deployOptions) {
    const { configurableConstants } = deployOptions;
    if (configurableConstants) {
      this.setConfigurableConstants(configurableConstants);
    }
    const { contractId, transactionRequest } = this.createTransactionRequest(deployOptions);
    await this.fundTransactionRequest(transactionRequest, deployOptions);
    return {
      contractId,
      transactionRequest
    };
  }
  /**
   * Create a blob transaction request, used for deploying contract chunks.
   *
   * @param options - options for creating a blob transaction request.
   * @returns a populated BlobTransactionRequest.
   */
  blobTransactionRequest(options) {
    const { bytecode } = options;
    return new BlobTransactionRequest({
      blobId: hash(bytecode),
      witnessIndex: 0,
      witnesses: [bytecode],
      ...options
    });
  }
  /**
   * Get the maximum chunk size for deploying a contract by chunks.
   */
  async getMaxChunkSize(deployOptions, chunkSizeMultiplier = CHUNK_SIZE_MULTIPLIER) {
    if (chunkSizeMultiplier < 0 || chunkSizeMultiplier > 1) {
      throw new FuelError(
        ErrorCode.INVALID_CHUNK_SIZE_MULTIPLIER,
        "Chunk size multiplier must be between 0 and 1"
      );
    }
    const account = this.getAccount();
    const { consensusParameters } = await account.provider.getChain();
    const contractSizeLimit = consensusParameters.contractParameters.contractMaxSize.toNumber();
    const transactionSizeLimit = consensusParameters.txParameters.maxSize.toNumber();
    const maxLimit = 64e3;
    const chainLimit = transactionSizeLimit < contractSizeLimit ? transactionSizeLimit : contractSizeLimit;
    const sizeLimit = chainLimit < maxLimit ? chainLimit : maxLimit;
    const blobTx = this.blobTransactionRequest({
      ...deployOptions,
      bytecode: randomBytes(32)
    }).addResources(
      account.generateFakeResources([
        { assetId: await account.provider.getBaseAssetId(), amount: bn(1) }
      ])
    );
    const maxChunkSize = (sizeLimit - blobTx.byteLength() - WORD_SIZE2) * chunkSizeMultiplier;
    return Math.round(maxChunkSize / WORD_SIZE2) * WORD_SIZE2;
  }
};
export {
  ContractFactory,
  util_exports as ContractUtils
};
//# sourceMappingURL=index.mjs.map