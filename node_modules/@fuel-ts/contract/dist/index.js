"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ContractFactory: () => ContractFactory,
  ContractUtils: () => util_exports
});
module.exports = __toCommonJS(src_exports);

// src/contract-factory.ts
var import_abi_coder3 = require("@fuel-ts/abi-coder");
var import_account = require("@fuel-ts/account");
var import_crypto = require("@fuel-ts/crypto");
var import_errors = require("@fuel-ts/errors");
var import_hasher2 = require("@fuel-ts/hasher");
var import_math = require("@fuel-ts/math");
var import_program2 = require("@fuel-ts/program");
var import_utils4 = require("@fuel-ts/utils");

// src/loader/loader-script.ts
var import_abi_coder = require("@fuel-ts/abi-coder");
var import_program = require("@fuel-ts/program");
var import_utils = require("@fuel-ts/utils");
var asm = __toESM(require("@fuels/vm-asm"));
var getLoaderInstructions = (blobIds) => {
  const { RegId, Instruction } = asm;
  const numberOfInstructions = 12;
  const numberOfBlobs = blobIds.length;
  const blobIdSize = import_abi_coder.BYTES_32;
  const blobIdBytes = (0, import_utils.concat)(blobIds.map((b) => (0, import_utils.arrayify)(b)));
  const instructionBytes = new import_program.InstructionSet(
    // 1. load the blob contents into memory
    // find the start of the hardcoded blob ids, which are located after the code ends
    asm.move_(16, RegId.pc().to_u8()),
    // 0x10 to hold the address of the current blob id
    asm.addi(16, 16, numberOfInstructions * Instruction.size()),
    // The contract is going to be loaded from the current value of SP onwards, save
    // the location into 0x16 so we can jump into it later on
    asm.move_(22, RegId.sp().to_u8()),
    // loop counter
    asm.movi(19, numberOfBlobs),
    // LOOP starts here
    // 0x11 to hold the size of the current blob
    asm.bsiz(17, 16),
    // push the blob contents onto the stack
    asm.ldc(16, 0, 17, 1),
    // move on to the next blob
    asm.addi(16, 16, blobIdSize),
    // decrement the loop counter
    asm.subi(19, 19, 1),
    // Jump backwards (3+1) instructions if the counter has not reached 0
    asm.jnzb(19, RegId.zero().to_u8(), 3),
    // Jump into the memory where the contract is loaded
    // what follows is called _jmp_mem by the sway compiler
    // subtract the address contained in IS because jmp will add it back
    asm.sub(22, 22, RegId.is().to_u8()),
    // jmp will multiply by 4 so we need to divide to cancel that out
    asm.divi(22, 22, 4),
    // jump to the start of the contract we loaded
    asm.jmp(22)
  ).toBytes();
  return (0, import_utils.concat)([instructionBytes, blobIdBytes]);
};

// src/loader/utils.ts
var import_abi_coder2 = require("@fuel-ts/abi-coder");
var import_utils2 = require("@fuel-ts/utils");
var getContractChunks = (bytecode, chunkSize) => {
  const chunks = [];
  for (let offset = 0, index = 0; offset < bytecode.length; offset += chunkSize, index++) {
    let chunk = bytecode.slice(offset, offset + chunkSize);
    let length = chunk.length;
    if (length % import_abi_coder2.WORD_SIZE !== 0) {
      chunk = (0, import_utils2.concat)([chunk, new Uint8Array(chunkSize - chunk.length)]);
      length = chunk.length;
    }
    chunks.push({ id: index, size: length, bytecode: chunk });
  }
  return chunks;
};

// src/util.ts
var util_exports = {};
__export(util_exports, {
  getContractId: () => getContractId,
  getContractRoot: () => getContractRoot,
  getContractStorageRoot: () => getContractStorageRoot,
  hexlifyWithPrefix: () => hexlifyWithPrefix
});
var import_hasher = require("@fuel-ts/hasher");
var import_merkle = require("@fuel-ts/merkle");
var import_utils3 = require("@fuel-ts/utils");
var getContractRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes = (0, import_utils3.arrayify)(bytecode);
  const chunks = (0, import_utils3.chunkAndPadBytes)(bytes, chunkSize);
  return (0, import_merkle.calcRoot)(chunks.map((c) => (0, import_utils3.hexlify)(c)));
};
var getContractStorageRoot = (storageSlots) => {
  const tree = new import_merkle.SparseMerkleTree();
  storageSlots.forEach(({ key, value }) => tree.update((0, import_hasher.sha256)(key), value));
  return tree.root;
};
var getContractId = (bytecode, salt, stateRoot) => {
  const root = getContractRoot((0, import_utils3.arrayify)(bytecode));
  const contractId = (0, import_hasher.sha256)((0, import_utils3.concat)(["0x4655454C", salt, root, stateRoot]));
  return contractId;
};
var hexlifyWithPrefix = (value) => (0, import_utils3.hexlify)(value.startsWith("0x") ? value : `0x${value}`);

// src/contract-factory.ts
var CHUNK_SIZE_MULTIPLIER = 0.95;
var ContractFactory = class {
  bytecode;
  interface;
  provider;
  account;
  storageSlots;
  /**
   * Create a ContractFactory instance.
   *
   * @param bytecode - The bytecode of the contract.
   * @param abi - The contract's ABI (Application Binary Interface).
   * @param accountOrProvider - An account or provider to be associated with the factory.
   */
  constructor(bytecode, abi, accountOrProvider = null, storageSlots = []) {
    this.bytecode = (0, import_utils4.arrayify)(bytecode);
    if (abi instanceof import_abi_coder3.Interface) {
      this.interface = abi;
    } else {
      this.interface = new import_abi_coder3.Interface(abi);
    }
    if (accountOrProvider && "provider" in accountOrProvider) {
      this.provider = accountOrProvider.provider;
      this.account = accountOrProvider;
    } else {
      this.provider = accountOrProvider;
      this.account = null;
    }
    this.storageSlots = storageSlots;
  }
  /**
   * Connect the factory to a provider.
   *
   * @param provider - The provider to be associated with the factory.
   * @returns A new ContractFactory instance.
   */
  connect(provider) {
    return new ContractFactory(this.bytecode, this.interface, provider);
  }
  /**
   * Create a transaction request to deploy a contract with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns The CreateTransactionRequest object for deploying the contract.
   */
  createTransactionRequest(deployOptions) {
    const storageSlots = (deployOptions?.storageSlots ?? []).concat(this.storageSlots).map(({ key, value }) => ({
      key: hexlifyWithPrefix(key),
      value: hexlifyWithPrefix(value)
    })).filter((el, index, self) => self.findIndex((s) => s.key === el.key) === index).sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));
    const options = {
      salt: (0, import_crypto.randomBytes)(32),
      ...deployOptions ?? {},
      storageSlots
    };
    if (!this.provider) {
      throw new import_errors.FuelError(
        import_errors.ErrorCode.MISSING_PROVIDER,
        "Cannot create transaction request without provider"
      );
    }
    const bytecode = deployOptions?.bytecode || this.bytecode;
    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);
    const contractId = getContractId(bytecode, options.salt, stateRoot);
    const transactionRequest = new import_account.CreateTransactionRequest({
      bytecodeWitnessIndex: 0,
      witnesses: [bytecode],
      ...options
    });
    transactionRequest.addContractCreatedOutput(contractId, stateRoot);
    return {
      contractId,
      transactionRequest
    };
  }
  /**
   * Takes a transaction request, estimates it and funds it.
   *
   * @param request - the request to fund.
   * @param options - options for funding the request.
   * @returns a funded transaction request.
   */
  async fundTransactionRequest(request, options = {}) {
    const account = this.getAccount();
    const { maxFee: setMaxFee } = options;
    const txCost = await account.getTransactionCost(request);
    if ((0, import_utils4.isDefined)(setMaxFee)) {
      if (txCost.maxFee.gt(setMaxFee)) {
        throw new import_errors.FuelError(
          import_errors.ErrorCode.MAX_FEE_TOO_LOW,
          `Max fee '${options.maxFee}' is lower than the required: '${txCost.maxFee}'.`
        );
      }
    } else {
      request.maxFee = txCost.maxFee;
    }
    await account.fund(request, txCost);
    return request;
  }
  /**
   * Deploy a contract of any length with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deploy(deployOptions = {}) {
    const account = this.getAccount();
    const { consensusParameters } = await account.provider.getChain();
    const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();
    return this.bytecode.length > maxContractSize ? this.deployAsBlobTx(deployOptions) : this.deployAsCreateTx(deployOptions);
  }
  /**
   * Deploy a contract with the specified options.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployAsCreateTx(deployOptions = {}) {
    const account = this.getAccount();
    const { consensusParameters } = await account.provider.getChain();
    const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();
    if (this.bytecode.length > maxContractSize) {
      throw new import_errors.FuelError(
        import_errors.ErrorCode.CONTRACT_SIZE_EXCEEDS_LIMIT,
        "Contract bytecode is too large. Please use `deployAsBlobTx` instead."
      );
    }
    const { contractId, transactionRequest } = await this.prepareDeploy(deployOptions);
    const transactionResponse = await account.sendTransaction(transactionRequest);
    const waitForResult = async () => {
      const transactionResult = await transactionResponse.waitForResult();
      const contract = new import_program2.Contract(contractId, this.interface, account);
      return { contract, transactionResult };
    };
    return {
      contractId,
      waitForTransactionId: () => Promise.resolve(transactionResponse.id),
      waitForResult
    };
  }
  /**
   * Chunks and deploys a contract via a loader contract. Suitable for deploying contracts larger than the max contract size.
   *
   * @param deployOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployAsBlobTx(deployOptions = {
    chunkSizeMultiplier: CHUNK_SIZE_MULTIPLIER
  }) {
    const account = this.getAccount();
    const { configurableConstants, chunkSizeMultiplier } = deployOptions;
    if (configurableConstants) {
      this.setConfigurableConstants(configurableConstants);
    }
    const chunkSize = await this.getMaxChunkSize(deployOptions, chunkSizeMultiplier);
    const chunks = getContractChunks((0, import_utils4.arrayify)(this.bytecode), chunkSize).map((c) => {
      const transactionRequest = this.blobTransactionRequest({
        ...deployOptions,
        bytecode: c.bytecode
      });
      return {
        ...c,
        transactionRequest,
        blobId: transactionRequest.blobId
      };
    });
    const blobIds = chunks.map(({ blobId }) => blobId);
    const loaderBytecode = getLoaderInstructions(blobIds);
    const { contractId, transactionRequest: createRequest } = this.createTransactionRequest({
      bytecode: loaderBytecode,
      ...deployOptions
    });
    const uniqueBlobIds = [...new Set(blobIds)];
    const uploadedBlobIds = await account.provider.getBlobs(uniqueBlobIds);
    const blobIdsToUpload = uniqueBlobIds.filter((id) => !uploadedBlobIds.includes(id));
    let totalCost = (0, import_math.bn)(0);
    const chainInfo = await account.provider.getChain();
    const gasPrice = await account.provider.estimateGasPrice(10);
    const priceFactor = chainInfo.consensusParameters.feeParameters.gasPriceFactor;
    for (const { transactionRequest, blobId } of chunks) {
      if (blobIdsToUpload.includes(blobId)) {
        const minGas = transactionRequest.calculateMinGas(chainInfo);
        const minFee = (0, import_account.calculateGasFee)({
          gasPrice,
          gas: minGas,
          priceFactor,
          tip: transactionRequest.tip
        }).add(1);
        totalCost = totalCost.add(minFee);
      }
      const createMinGas = createRequest.calculateMinGas(chainInfo);
      const createMinFee = (0, import_account.calculateGasFee)({
        gasPrice,
        gas: createMinGas,
        priceFactor,
        tip: createRequest.tip
      }).add(1);
      totalCost = totalCost.add(createMinFee);
    }
    if (totalCost.gt(await account.getBalance())) {
      throw new import_errors.FuelError(import_errors.ErrorCode.FUNDS_TOO_LOW, "Insufficient balance to deploy contract.");
    }
    let txIdResolver;
    const txIdPromise = new Promise((resolve) => {
      txIdResolver = resolve;
    });
    const waitForResult = async () => {
      const uploadedBlobs = [];
      for (const { blobId, transactionRequest } of chunks) {
        if (!uploadedBlobs.includes(blobId) && blobIdsToUpload.includes(blobId)) {
          const fundedBlobRequest = await this.fundTransactionRequest(
            transactionRequest,
            deployOptions
          );
          let result;
          try {
            const blobTx = await account.sendTransaction(fundedBlobRequest);
            result = await blobTx.waitForResult();
          } catch (err) {
            if (err.message.indexOf(`BlobId is already taken ${blobId}`) > -1) {
              uploadedBlobs.push(blobId);
              continue;
            }
            throw new import_errors.FuelError(import_errors.ErrorCode.TRANSACTION_FAILED, "Failed to deploy contract chunk");
          }
          if (!result.status || result.status !== import_account.TransactionStatus.success) {
            throw new import_errors.FuelError(import_errors.ErrorCode.TRANSACTION_FAILED, "Failed to deploy contract chunk");
          }
          uploadedBlobs.push(blobId);
        }
      }
      await this.fundTransactionRequest(createRequest, deployOptions);
      txIdResolver(createRequest.getTransactionId(await account.provider.getChainId()));
      const transactionResponse = await account.sendTransaction(createRequest);
      const transactionResult = await transactionResponse.waitForResult();
      const contract = new import_program2.Contract(contractId, this.interface, account);
      return { contract, transactionResult };
    };
    const waitForTransactionId = () => txIdPromise;
    return { waitForResult, contractId, waitForTransactionId };
  }
  /**
   * Set configurable constants of the contract with the specified values.
   *
   * @param configurableConstants - An object containing configurable names and their values.
   */
  setConfigurableConstants(configurableConstants) {
    try {
      const hasConfigurable = Object.keys(this.interface.configurables).length;
      if (!hasConfigurable) {
        throw new import_errors.FuelError(
          import_errors.ErrorCode.CONFIGURABLE_NOT_FOUND,
          "Contract does not have configurables to be set"
        );
      }
      Object.entries(configurableConstants).forEach(([key, value]) => {
        if (!this.interface.configurables[key]) {
          throw new import_errors.FuelError(
            import_errors.ErrorCode.CONFIGURABLE_NOT_FOUND,
            `Contract does not have a configurable named: '${key}'`
          );
        }
        const { offset } = this.interface.configurables[key];
        const encoded = this.interface.encodeConfigurable(key, value);
        const bytes = (0, import_utils4.arrayify)(this.bytecode);
        bytes.set(encoded, offset);
        this.bytecode = bytes;
      });
    } catch (err) {
      throw new import_errors.FuelError(
        import_errors.ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants on contract: ${err.message}.`
      );
    }
  }
  getAccount() {
    if (!this.account) {
      throw new import_errors.FuelError(import_errors.ErrorCode.ACCOUNT_REQUIRED, "Account not assigned to contract.");
    }
    return this.account;
  }
  async prepareDeploy(deployOptions) {
    const { configurableConstants } = deployOptions;
    if (configurableConstants) {
      this.setConfigurableConstants(configurableConstants);
    }
    const { contractId, transactionRequest } = this.createTransactionRequest(deployOptions);
    await this.fundTransactionRequest(transactionRequest, deployOptions);
    return {
      contractId,
      transactionRequest
    };
  }
  /**
   * Create a blob transaction request, used for deploying contract chunks.
   *
   * @param options - options for creating a blob transaction request.
   * @returns a populated BlobTransactionRequest.
   */
  blobTransactionRequest(options) {
    const { bytecode } = options;
    return new import_account.BlobTransactionRequest({
      blobId: (0, import_hasher2.hash)(bytecode),
      witnessIndex: 0,
      witnesses: [bytecode],
      ...options
    });
  }
  /**
   * Get the maximum chunk size for deploying a contract by chunks.
   */
  async getMaxChunkSize(deployOptions, chunkSizeMultiplier = CHUNK_SIZE_MULTIPLIER) {
    if (chunkSizeMultiplier < 0 || chunkSizeMultiplier > 1) {
      throw new import_errors.FuelError(
        import_errors.ErrorCode.INVALID_CHUNK_SIZE_MULTIPLIER,
        "Chunk size multiplier must be between 0 and 1"
      );
    }
    const account = this.getAccount();
    const { consensusParameters } = await account.provider.getChain();
    const contractSizeLimit = consensusParameters.contractParameters.contractMaxSize.toNumber();
    const transactionSizeLimit = consensusParameters.txParameters.maxSize.toNumber();
    const maxLimit = 64e3;
    const chainLimit = transactionSizeLimit < contractSizeLimit ? transactionSizeLimit : contractSizeLimit;
    const sizeLimit = chainLimit < maxLimit ? chainLimit : maxLimit;
    const blobTx = this.blobTransactionRequest({
      ...deployOptions,
      bytecode: (0, import_crypto.randomBytes)(32)
    }).addResources(
      account.generateFakeResources([
        { assetId: await account.provider.getBaseAssetId(), amount: (0, import_math.bn)(1) }
      ])
    );
    const maxChunkSize = (sizeLimit - blobTx.byteLength() - import_abi_coder3.WORD_SIZE) * chunkSizeMultiplier;
    return Math.round(maxChunkSize / import_abi_coder3.WORD_SIZE) * import_abi_coder3.WORD_SIZE;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ContractFactory,
  ContractUtils
});
//# sourceMappingURL=index.js.map