{"version":3,"sources":["../src/index.ts","../src/contract-factory.ts","../src/loader/loader-script.ts","../src/loader/utils.ts","../src/util.ts"],"sourcesContent":["export {\n  default as ContractFactory,\n  DeployContractOptions,\n  DeployContractResult,\n} from './contract-factory';\n/**\n * @hidden\n */\nexport * as ContractUtils from './util';\n","import { Interface, WORD_SIZE } from '@fuel-ts/abi-coder';\nimport type { JsonAbi, InputValue } from '@fuel-ts/abi-coder';\nimport type {\n  Account,\n  CreateTransactionRequestLike,\n  Provider,\n  TransactionRequest,\n  TransactionResult,\n  TransactionType,\n} from '@fuel-ts/account';\nimport {\n  CreateTransactionRequest,\n  BlobTransactionRequest,\n  TransactionStatus,\n  calculateGasFee,\n} from '@fuel-ts/account';\nimport { randomBytes } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { hash } from '@fuel-ts/hasher';\nimport { bn } from '@fuel-ts/math';\nimport { Contract } from '@fuel-ts/program';\nimport type { StorageSlot } from '@fuel-ts/transactions';\nimport type { BytesLike } from '@fuel-ts/utils';\nimport { arrayify, isDefined } from '@fuel-ts/utils';\n\nimport { getLoaderInstructions, getContractChunks } from './loader';\nimport { getContractId, getContractStorageRoot, hexlifyWithPrefix } from './util';\n\n/** Amount of percentage override for chunk sizes in blob transactions */\nconst CHUNK_SIZE_MULTIPLIER = 0.95;\n\n/**\n * Options for deploying a contract.\n */\nexport type DeployContractOptions = {\n  salt?: BytesLike;\n  storageSlots?: StorageSlot[];\n  stateRoot?: BytesLike;\n  configurableConstants?: { [name: string]: unknown };\n  chunkSizeMultiplier?: number;\n} & CreateTransactionRequestLike;\n\nexport type DeployContractResult<TContract extends Contract = Contract> = {\n  contractId: string;\n  waitForTransactionId: () => Promise<string>;\n  waitForResult: () => Promise<{\n    contract: TContract;\n    transactionResult: TransactionResult<TransactionType.Create>;\n  }>;\n};\n\n/**\n * `ContractFactory` provides utilities for deploying and configuring contracts.\n */\nexport default class ContractFactory<TContract extends Contract = Contract> {\n  bytecode: BytesLike;\n  interface: Interface;\n  provider!: Provider | null;\n  account!: Account | null;\n  storageSlots: StorageSlot[];\n\n  /**\n   * Create a ContractFactory instance.\n   *\n   * @param bytecode - The bytecode of the contract.\n   * @param abi - The contract's ABI (Application Binary Interface).\n   * @param accountOrProvider - An account or provider to be associated with the factory.\n   */\n  constructor(\n    bytecode: BytesLike,\n    abi: JsonAbi | Interface,\n    accountOrProvider: Account | Provider | null = null,\n    storageSlots: StorageSlot[] = []\n  ) {\n    // Force the bytecode to be a byte array\n    this.bytecode = arrayify(bytecode);\n\n    if (abi instanceof Interface) {\n      this.interface = abi;\n    } else {\n      this.interface = new Interface(abi);\n    }\n\n    /**\n     Instead of using `instanceof` to compare classes, we instead check\n      if `accountOrProvider` has a `provider` property inside. If yes,\n      than we assume it's a Wallet.\n\n      This approach is safer than using `instanceof` because it\n      there might be different versions and bundles of the library.\n\n      The same is done at:\n      - ./contract.ts\n\n      @see Contract\n      */\n    if (accountOrProvider && 'provider' in accountOrProvider) {\n      this.provider = accountOrProvider.provider;\n      this.account = accountOrProvider;\n    } else {\n      this.provider = accountOrProvider;\n      this.account = null;\n    }\n\n    this.storageSlots = storageSlots;\n  }\n\n  /**\n   * Connect the factory to a provider.\n   *\n   * @param provider - The provider to be associated with the factory.\n   * @returns A new ContractFactory instance.\n   */\n  connect(provider: Provider) {\n    return new ContractFactory(this.bytecode, this.interface, provider);\n  }\n\n  /**\n   * Create a transaction request to deploy a contract with the specified options.\n   *\n   * @param deployOptions - Options for deploying the contract.\n   * @returns The CreateTransactionRequest object for deploying the contract.\n   */\n  createTransactionRequest(deployOptions?: DeployContractOptions & { bytecode?: BytesLike }) {\n    const storageSlots = (deployOptions?.storageSlots ?? [])\n      .concat(this.storageSlots)\n      .map(({ key, value }) => ({\n        key: hexlifyWithPrefix(key),\n        value: hexlifyWithPrefix(value),\n      }))\n      .filter((el, index, self) => self.findIndex((s) => s.key === el.key) === index)\n      .sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));\n\n    const options = {\n      salt: randomBytes(32),\n      ...(deployOptions ?? {}),\n      storageSlots,\n    };\n\n    if (!this.provider) {\n      throw new FuelError(\n        ErrorCode.MISSING_PROVIDER,\n        'Cannot create transaction request without provider'\n      );\n    }\n\n    const bytecode = deployOptions?.bytecode || this.bytecode;\n    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);\n    const contractId = getContractId(bytecode, options.salt, stateRoot);\n    const transactionRequest = new CreateTransactionRequest({\n      bytecodeWitnessIndex: 0,\n      witnesses: [bytecode],\n      ...options,\n    });\n    transactionRequest.addContractCreatedOutput(contractId, stateRoot);\n\n    return {\n      contractId,\n      transactionRequest,\n    };\n  }\n\n  /**\n   * Takes a transaction request, estimates it and funds it.\n   *\n   * @param request - the request to fund.\n   * @param options - options for funding the request.\n   * @returns a funded transaction request.\n   */\n  private async fundTransactionRequest(\n    request: TransactionRequest,\n    options: DeployContractOptions = {}\n  ) {\n    const account = this.getAccount();\n    const { maxFee: setMaxFee } = options;\n\n    const txCost = await account.getTransactionCost(request);\n\n    if (isDefined(setMaxFee)) {\n      if (txCost.maxFee.gt(setMaxFee)) {\n        throw new FuelError(\n          ErrorCode.MAX_FEE_TOO_LOW,\n          `Max fee '${options.maxFee}' is lower than the required: '${txCost.maxFee}'.`\n        );\n      }\n    } else {\n      request.maxFee = txCost.maxFee;\n    }\n\n    await account.fund(request, txCost);\n\n    return request;\n  }\n\n  /**\n   * Deploy a contract of any length with the specified options.\n   *\n   * @param deployOptions - Options for deploying the contract.\n   * @returns A promise that resolves to the deployed contract instance.\n   */\n  async deploy<T extends Contract = TContract>(\n    deployOptions: DeployContractOptions = {}\n  ): Promise<DeployContractResult<T>> {\n    const account = this.getAccount();\n    const { consensusParameters } = await account.provider.getChain();\n    const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();\n\n    return this.bytecode.length > maxContractSize\n      ? this.deployAsBlobTx(deployOptions)\n      : this.deployAsCreateTx<T>(deployOptions);\n  }\n\n  /**\n   * Deploy a contract with the specified options.\n   *\n   * @param deployOptions - Options for deploying the contract.\n   * @returns A promise that resolves to the deployed contract instance.\n   */\n  async deployAsCreateTx<T extends Contract = TContract>(\n    deployOptions: DeployContractOptions = {}\n  ): Promise<DeployContractResult<T>> {\n    const account = this.getAccount();\n    const { consensusParameters } = await account.provider.getChain();\n    const maxContractSize = consensusParameters.contractParameters.contractMaxSize.toNumber();\n\n    if (this.bytecode.length > maxContractSize) {\n      throw new FuelError(\n        ErrorCode.CONTRACT_SIZE_EXCEEDS_LIMIT,\n        'Contract bytecode is too large. Please use `deployAsBlobTx` instead.'\n      );\n    }\n\n    const { contractId, transactionRequest } = await this.prepareDeploy(deployOptions);\n\n    const transactionResponse = await account.sendTransaction(transactionRequest);\n\n    const waitForResult = async () => {\n      const transactionResult = await transactionResponse.waitForResult<TransactionType.Create>();\n      const contract = new Contract(contractId, this.interface, account) as T;\n\n      return { contract, transactionResult };\n    };\n\n    return {\n      contractId,\n      waitForTransactionId: () => Promise.resolve(transactionResponse.id),\n      waitForResult,\n    };\n  }\n\n  /**\n   * Chunks and deploys a contract via a loader contract. Suitable for deploying contracts larger than the max contract size.\n   *\n   * @param deployOptions - Options for deploying the contract.\n   * @returns A promise that resolves to the deployed contract instance.\n   */\n  async deployAsBlobTx<T extends Contract = TContract>(\n    deployOptions: DeployContractOptions = {\n      chunkSizeMultiplier: CHUNK_SIZE_MULTIPLIER,\n    }\n  ): Promise<DeployContractResult<T>> {\n    const account = this.getAccount();\n    const { configurableConstants, chunkSizeMultiplier } = deployOptions;\n    if (configurableConstants) {\n      this.setConfigurableConstants(configurableConstants);\n    }\n\n    // Generate the chunks based on the maximum chunk size and create blob txs\n    const chunkSize = await this.getMaxChunkSize(deployOptions, chunkSizeMultiplier);\n    const chunks = getContractChunks(arrayify(this.bytecode), chunkSize).map((c) => {\n      const transactionRequest = this.blobTransactionRequest({\n        ...deployOptions,\n        bytecode: c.bytecode,\n      });\n      return {\n        ...c,\n        transactionRequest,\n        blobId: transactionRequest.blobId,\n      };\n    });\n\n    // Generate the associated create tx for the loader contract\n    const blobIds = chunks.map(({ blobId }) => blobId);\n    const loaderBytecode = getLoaderInstructions(blobIds);\n    const { contractId, transactionRequest: createRequest } = this.createTransactionRequest({\n      bytecode: loaderBytecode,\n      ...deployOptions,\n    });\n\n    // BlobIDs only need to be uploaded once and we can check if they exist on chain\n    const uniqueBlobIds = [...new Set(blobIds)];\n    const uploadedBlobIds = await account.provider.getBlobs(uniqueBlobIds);\n    const blobIdsToUpload = uniqueBlobIds.filter((id) => !uploadedBlobIds.includes(id));\n\n    // Check the account can afford to deploy all chunks and loader\n    let totalCost = bn(0);\n    const chainInfo = await account.provider.getChain();\n    const gasPrice = await account.provider.estimateGasPrice(10);\n    const priceFactor = chainInfo.consensusParameters.feeParameters.gasPriceFactor;\n\n    for (const { transactionRequest, blobId } of chunks) {\n      if (blobIdsToUpload.includes(blobId)) {\n        const minGas = transactionRequest.calculateMinGas(chainInfo);\n        const minFee = calculateGasFee({\n          gasPrice,\n          gas: minGas,\n          priceFactor,\n          tip: transactionRequest.tip,\n        }).add(1);\n\n        totalCost = totalCost.add(minFee);\n      }\n      const createMinGas = createRequest.calculateMinGas(chainInfo);\n      const createMinFee = calculateGasFee({\n        gasPrice,\n        gas: createMinGas,\n        priceFactor,\n        tip: createRequest.tip,\n      }).add(1);\n      totalCost = totalCost.add(createMinFee);\n    }\n    if (totalCost.gt(await account.getBalance())) {\n      throw new FuelError(ErrorCode.FUNDS_TOO_LOW, 'Insufficient balance to deploy contract.');\n    }\n\n    // Transaction id is unset until we have funded the create tx, which is dependent on the blob txs\n    let txIdResolver: (value: string | PromiseLike<string>) => void;\n    const txIdPromise = new Promise<string>((resolve) => {\n      txIdResolver = resolve;\n    });\n\n    const waitForResult = async () => {\n      // Upload the blob if it hasn't been uploaded yet. Duplicate blob IDs will fail gracefully.\n      const uploadedBlobs: string[] = [];\n      // Deploy the chunks as blob txs\n      for (const { blobId, transactionRequest } of chunks) {\n        if (!uploadedBlobs.includes(blobId) && blobIdsToUpload.includes(blobId)) {\n          const fundedBlobRequest = await this.fundTransactionRequest(\n            transactionRequest,\n            deployOptions\n          );\n\n          let result: TransactionResult<TransactionType.Blob>;\n\n          try {\n            const blobTx = await account.sendTransaction(fundedBlobRequest);\n            result = await blobTx.waitForResult();\n          } catch (err: unknown) {\n            // Core will throw for blobs that have already been uploaded, but the blobId\n            // is still valid so we can use this for the loader contract\n            if ((<Error>err).message.indexOf(`BlobId is already taken ${blobId}`) > -1) {\n              uploadedBlobs.push(blobId);\n              continue;\n            }\n\n            throw new FuelError(ErrorCode.TRANSACTION_FAILED, 'Failed to deploy contract chunk');\n          }\n\n          if (!result.status || result.status !== TransactionStatus.success) {\n            throw new FuelError(ErrorCode.TRANSACTION_FAILED, 'Failed to deploy contract chunk');\n          }\n\n          uploadedBlobs.push(blobId);\n        }\n      }\n\n      await this.fundTransactionRequest(createRequest, deployOptions);\n      txIdResolver(createRequest.getTransactionId(await account.provider.getChainId()));\n      const transactionResponse = await account.sendTransaction(createRequest);\n      const transactionResult = await transactionResponse.waitForResult<TransactionType.Create>();\n      const contract = new Contract(contractId, this.interface, account) as T;\n\n      return { contract, transactionResult };\n    };\n\n    const waitForTransactionId = () => txIdPromise;\n\n    return { waitForResult, contractId, waitForTransactionId };\n  }\n\n  /**\n   * Set configurable constants of the contract with the specified values.\n   *\n   * @param configurableConstants - An object containing configurable names and their values.\n   */\n  setConfigurableConstants(configurableConstants: { [name: string]: unknown }) {\n    try {\n      const hasConfigurable = Object.keys(this.interface.configurables).length;\n\n      if (!hasConfigurable) {\n        throw new FuelError(\n          ErrorCode.CONFIGURABLE_NOT_FOUND,\n          'Contract does not have configurables to be set'\n        );\n      }\n\n      Object.entries(configurableConstants).forEach(([key, value]) => {\n        if (!this.interface.configurables[key]) {\n          throw new FuelError(\n            ErrorCode.CONFIGURABLE_NOT_FOUND,\n            `Contract does not have a configurable named: '${key}'`\n          );\n        }\n\n        const { offset } = this.interface.configurables[key];\n\n        const encoded = this.interface.encodeConfigurable(key, value as InputValue);\n\n        const bytes = arrayify(this.bytecode);\n\n        bytes.set(encoded, offset);\n\n        this.bytecode = bytes;\n      });\n    } catch (err) {\n      throw new FuelError(\n        ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,\n        `Error setting configurable constants on contract: ${(<Error>err).message}.`\n      );\n    }\n  }\n\n  private getAccount(): Account {\n    if (!this.account) {\n      throw new FuelError(ErrorCode.ACCOUNT_REQUIRED, 'Account not assigned to contract.');\n    }\n    return this.account;\n  }\n\n  private async prepareDeploy(deployOptions: DeployContractOptions) {\n    const { configurableConstants } = deployOptions;\n\n    if (configurableConstants) {\n      this.setConfigurableConstants(configurableConstants);\n    }\n\n    const { contractId, transactionRequest } = this.createTransactionRequest(deployOptions);\n\n    await this.fundTransactionRequest(transactionRequest, deployOptions);\n\n    return {\n      contractId,\n      transactionRequest,\n    };\n  }\n\n  /**\n   * Create a blob transaction request, used for deploying contract chunks.\n   *\n   * @param options - options for creating a blob transaction request.\n   * @returns a populated BlobTransactionRequest.\n   */\n  private blobTransactionRequest(options: { bytecode: BytesLike } & DeployContractOptions) {\n    const { bytecode } = options;\n    return new BlobTransactionRequest({\n      blobId: hash(bytecode),\n      witnessIndex: 0,\n      witnesses: [bytecode],\n      ...options,\n    });\n  }\n\n  /**\n   * Get the maximum chunk size for deploying a contract by chunks.\n   */\n  private async getMaxChunkSize(\n    deployOptions: DeployContractOptions,\n    chunkSizeMultiplier: number = CHUNK_SIZE_MULTIPLIER\n  ) {\n    if (chunkSizeMultiplier < 0 || chunkSizeMultiplier > 1) {\n      throw new FuelError(\n        ErrorCode.INVALID_CHUNK_SIZE_MULTIPLIER,\n        'Chunk size multiplier must be between 0 and 1'\n      );\n    }\n\n    const account = this.getAccount();\n    const { consensusParameters } = await account.provider.getChain();\n    const contractSizeLimit = consensusParameters.contractParameters.contractMaxSize.toNumber();\n    const transactionSizeLimit = consensusParameters.txParameters.maxSize.toNumber();\n    const maxLimit = 64000;\n    const chainLimit =\n      transactionSizeLimit < contractSizeLimit ? transactionSizeLimit : contractSizeLimit;\n    const sizeLimit = chainLimit < maxLimit ? chainLimit : maxLimit;\n\n    // Get an estimate base tx length\n\n    const blobTx = this.blobTransactionRequest({\n      ...deployOptions,\n      bytecode: randomBytes(32),\n    }).addResources(\n      account.generateFakeResources([\n        { assetId: await account.provider.getBaseAssetId(), amount: bn(1) },\n      ])\n    );\n    // Given above, calculate the maximum chunk size\n    const maxChunkSize = (sizeLimit - blobTx.byteLength() - WORD_SIZE) * chunkSizeMultiplier;\n\n    // Ensure chunksize is byte aligned\n    return Math.round(maxChunkSize / WORD_SIZE) * WORD_SIZE;\n  }\n}\n","import { BYTES_32 } from '@fuel-ts/abi-coder';\nimport { InstructionSet } from '@fuel-ts/program';\nimport { arrayify, concat } from '@fuel-ts/utils';\nimport * as asm from '@fuels/vm-asm';\n\nexport const getLoaderInstructions = (blobIds: string[]): Uint8Array => {\n  const { RegId, Instruction } = asm;\n\n  const numberOfInstructions = 12;\n  const numberOfBlobs = blobIds.length;\n  const blobIdSize = BYTES_32;\n\n  // Bytes for the Blob Ids\n  const blobIdBytes = concat(blobIds.map((b) => arrayify(b)));\n\n  // Reference: https://github.com/FuelLabs/fuels-rs/blob/master/packages/fuels-programs/src/contract/loader.rs\n  // There are 2 main steps:\n  // 1. Load the blob contents into memory\n  // 2. Jump to the beginning of the memory where the blobs were loaded\n  // After that the execution continues normally with the loaded contract reading our\n  // prepared fn selector and jumps to the selected contract method.\n  const instructionBytes = new InstructionSet(\n    // 1. load the blob contents into memory\n    // find the start of the hardcoded blob ids, which are located after the code ends\n    asm.move_(0x10, RegId.pc().to_u8()),\n    // 0x10 to hold the address of the current blob id\n    asm.addi(0x10, 0x10, numberOfInstructions * Instruction.size()),\n    // The contract is going to be loaded from the current value of SP onwards, save\n    // the location into 0x16 so we can jump into it later on\n    asm.move_(0x16, RegId.sp().to_u8()),\n    // loop counter\n    asm.movi(0x13, numberOfBlobs),\n    // LOOP starts here\n    // 0x11 to hold the size of the current blob\n    asm.bsiz(0x11, 0x10),\n    // push the blob contents onto the stack\n    asm.ldc(0x10, 0, 0x11, 1),\n    // move on to the next blob\n    asm.addi(0x10, 0x10, blobIdSize),\n    // decrement the loop counter\n    asm.subi(0x13, 0x13, 1),\n    // Jump backwards (3+1) instructions if the counter has not reached 0\n    asm.jnzb(0x13, RegId.zero().to_u8(), 3),\n    // Jump into the memory where the contract is loaded\n    // what follows is called _jmp_mem by the sway compiler\n    // subtract the address contained in IS because jmp will add it back\n    asm.sub(0x16, 0x16, RegId.is().to_u8()),\n    // jmp will multiply by 4 so we need to divide to cancel that out\n    asm.divi(0x16, 0x16, 4),\n    // jump to the start of the contract we loaded\n    asm.jmp(0x16)\n  ).toBytes();\n\n  return concat([instructionBytes, blobIdBytes]);\n};\n","import { WORD_SIZE } from '@fuel-ts/abi-coder';\nimport { concat } from '@fuel-ts/utils';\n\nexport const getContractChunks = (bytecode: Uint8Array, chunkSize: number) => {\n  const chunks = [];\n\n  for (let offset = 0, index = 0; offset < bytecode.length; offset += chunkSize, index++) {\n    let chunk = bytecode.slice(offset, offset + chunkSize);\n    let length = chunk.length;\n\n    // Align chunks by word size\n    if (length % WORD_SIZE !== 0) {\n      chunk = concat([chunk, new Uint8Array(chunkSize - chunk.length)]);\n      length = chunk.length;\n    }\n\n    chunks.push({ id: index, size: length, bytecode: chunk });\n  }\n\n  return chunks;\n};\n","import { sha256 } from '@fuel-ts/hasher';\nimport { calcRoot, SparseMerkleTree } from '@fuel-ts/merkle';\nimport type { StorageSlot } from '@fuel-ts/transactions';\nimport type { BytesLike } from '@fuel-ts/utils';\nimport { chunkAndPadBytes, hexlify, concat, arrayify } from '@fuel-ts/utils';\n\n/**\n * @hidden\n *\n * Get the Merkle root of a contract's bytecode.\n *\n * @param bytecode - The bytecode of the contract.\n * @returns The Merkle root of the contract's bytecode.\n */\nexport const getContractRoot = (bytecode: BytesLike): string => {\n  const chunkSize = 16 * 1024;\n  const bytes = arrayify(bytecode);\n  const chunks = chunkAndPadBytes(bytes, chunkSize);\n\n  return calcRoot(chunks.map((c) => hexlify(c)));\n};\n\n/**\n * @hidden\n *\n * Get the Merkle root of a contract's storage slots.\n *\n * @param storageSlots - An array of storage slots containing key-value pairs.\n * @returns The Merkle root of the contract's storage slots.\n */\nexport const getContractStorageRoot = (storageSlots: StorageSlot[]): string => {\n  const tree = new SparseMerkleTree();\n\n  storageSlots.forEach(({ key, value }) => tree.update(sha256(key), value));\n\n  return tree.root;\n};\n\n/**\n * @hidden\n *\n * Get the contract ID of a contract based on its bytecode, salt,\n * and state root.\n *\n * @param bytecode - The bytecode of the contract.\n * @param salt - The salt value used for contract creation.\n * @param stateRoot - The state root of the contract.\n * @returns The contract ID of the contract.\n */\nexport const getContractId = (\n  bytecode: BytesLike,\n  salt: BytesLike,\n  stateRoot: BytesLike\n): string => {\n  const root = getContractRoot(arrayify(bytecode));\n  const contractId = sha256(concat(['0x4655454C', salt, root, stateRoot]));\n  return contractId;\n};\n\n/**\n * @hidden\n *\n * Ensures that a string is hexlified.\n *\n * @param value - The value to be hexlified.\n *\n * @returns The input value hexlified with prefix.\n */\nexport const hexlifyWithPrefix = (value: string) =>\n  hexlify(value.startsWith('0x') ? value : `0x${value}`);\n"],"mappings":"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","names":["import_abi_coder","import_hasher","import_program","import_utils","import_abi_coder","import_utils","import_utils"]}