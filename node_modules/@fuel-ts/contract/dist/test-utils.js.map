{"version":3,"sources":["../src/test-utils.ts","../src/test-utils/launch-test-node.ts"],"sourcesContent":["export * from './test-utils/launch-test-node';\n","import type { Account, WalletUnlocked } from '@fuel-ts/account';\nimport { setupTestProviderAndWallets } from '@fuel-ts/account/test-utils';\nimport type {\n  LaunchCustomProviderAndGetWalletsOptions,\n  SetupTestProviderAndWalletsReturn,\n} from '@fuel-ts/account/test-utils';\nimport { FuelError } from '@fuel-ts/errors';\nimport type { SnapshotConfigs } from '@fuel-ts/utils';\nimport { readFileSync } from 'fs';\nimport * as path from 'path';\nimport { mergeDeepRight } from 'ramda';\n\nimport type { DeployContractOptions, DeployContractResult } from '../contract-factory';\n\nexport interface DeployableContractFactory {\n  deploy(wallet: Account, options?: DeployContractOptions): Promise<DeployContractResult>;\n}\n\nexport type DeployContractConfig =\n  | DeployableContractFactory\n  | {\n      /**\n       * Contract factory class outputted by `pnpm fuels typegen`.\n       */\n      factory: DeployableContractFactory;\n      /**\n       * Options for contract deployment taken from `ContractFactory`.\n       */\n      options?: DeployContractOptions;\n      /**\n       * Index of wallet to be used for deployment. Defaults to `0` (first wallet).\n       */\n      walletIndex?: number;\n    };\n\nexport interface LaunchTestNodeOptions<TContractConfigs extends DeployContractConfig[]>\n  extends LaunchCustomProviderAndGetWalletsOptions {\n  /**\n   * Pass in either the path to the contract's root directory to deploy the contract or use `DeployContractConfig` for more control.\n   */\n  contractsConfigs: TContractConfigs;\n}\n\ntype ExtractDeployedContract<\n  T extends DeployContractConfig,\n  Deploy extends DeployableContractFactory['deploy'] = T extends DeployableContractFactory\n    ? T['deploy']\n    : T extends {\n          factory: DeployableContractFactory;\n        }\n      ? T['factory']['deploy']\n      : never,\n  WaitForResult extends DeployContractResult['waitForResult'] = Awaited<\n    ReturnType<Deploy>\n  >['waitForResult'],\n> = Awaited<ReturnType<WaitForResult>>['contract'];\n\nexport type TContracts<T extends DeployContractConfig[]> = {\n  [K in keyof T]: ExtractDeployedContract<T[K]>;\n};\nexport interface LaunchTestNodeReturn<TFactories extends DeployContractConfig[]>\n  extends SetupTestProviderAndWalletsReturn {\n  contracts: TContracts<TFactories>;\n}\n\nfunction getChainSnapshot<TFactories extends DeployContractConfig[]>(\n  nodeOptions: LaunchTestNodeOptions<TFactories>['nodeOptions']\n) {\n  let envChainMetadata: SnapshotConfigs['metadata'] | undefined;\n  let chainConfig: SnapshotConfigs['chainConfig'] | undefined;\n  let stateConfig: SnapshotConfigs['stateConfig'] | undefined;\n\n  if (process.env.DEFAULT_CHAIN_SNAPSHOT_DIR) {\n    const dirname = process.env.DEFAULT_CHAIN_SNAPSHOT_DIR;\n\n    envChainMetadata = JSON.parse(\n      readFileSync(path.join(dirname, 'metadata.json'), 'utf-8')\n    ) as SnapshotConfigs['metadata'];\n\n    chainConfig = JSON.parse(\n      readFileSync(path.join(dirname, envChainMetadata.chain_config), 'utf-8')\n    );\n\n    stateConfig = JSON.parse(\n      readFileSync(path.join(dirname, envChainMetadata.table_encoding.Json.filepath), 'utf-8')\n    );\n  }\n\n  const obj = [envChainMetadata, chainConfig, stateConfig].reduce((acc, val, idx) => {\n    if (val === undefined) {\n      return acc;\n    }\n    switch (idx) {\n      case 0:\n        acc.metadata = val as SnapshotConfigs['metadata'];\n        break;\n      case 1:\n        acc.chainConfig = val as SnapshotConfigs['chainConfig'];\n        break;\n      case 2:\n        acc.stateConfig = val as SnapshotConfigs['stateConfig'];\n        break;\n      default:\n        return acc;\n    }\n    return acc;\n  }, {} as SnapshotConfigs);\n\n  return mergeDeepRight(obj, nodeOptions?.snapshotConfig ?? {});\n}\n\nfunction getFuelCoreArgs<TFactories extends DeployContractConfig[]>(\n  nodeOptions: LaunchTestNodeOptions<TFactories>['nodeOptions']\n) {\n  const envArgs = process.env.DEFAULT_FUEL_CORE_ARGS\n    ? process.env.DEFAULT_FUEL_CORE_ARGS.split(' ')\n    : undefined;\n\n  return nodeOptions?.args ?? envArgs;\n}\n\nfunction getWalletForDeployment(config: DeployContractConfig, wallets: WalletUnlocked[]) {\n  if (!('walletIndex' in config) || !config.walletIndex) {\n    return wallets[0];\n  }\n\n  const validWalletIndex = config.walletIndex >= 0 && config.walletIndex < wallets.length;\n\n  if (!validWalletIndex) {\n    throw new FuelError(\n      FuelError.CODES.INVALID_INPUT_PARAMETERS,\n      `Invalid walletIndex ${config.walletIndex}; wallets array contains ${wallets.length} elements.`\n    );\n  }\n\n  return wallets[config.walletIndex];\n}\n\nexport async function launchTestNode<const TFactories extends DeployContractConfig[]>({\n  providerOptions = {},\n  walletsConfig = {},\n  nodeOptions = {},\n  contractsConfigs,\n}: Partial<LaunchTestNodeOptions<TFactories>> = {}): Promise<LaunchTestNodeReturn<TFactories>> {\n  const snapshotConfig = getChainSnapshot(nodeOptions);\n  const args = getFuelCoreArgs(nodeOptions);\n  const { provider, wallets, cleanup } = await setupTestProviderAndWallets({\n    walletsConfig,\n    providerOptions,\n    nodeOptions: {\n      ...nodeOptions,\n      snapshotConfig,\n      args,\n    },\n  });\n\n  const contracts: TContracts<TFactories> = [] as TContracts<TFactories>;\n  const configs = contractsConfigs ?? [];\n  try {\n    for (let i = 0; i < configs.length; i++) {\n      const config = configs[i];\n      const deploy = 'factory' in config ? config.factory.deploy : config.deploy;\n      const options = 'factory' in config ? (config.options ?? {}) : {};\n      const { waitForResult } = await deploy(getWalletForDeployment(config, wallets), options);\n      const { contract } = await waitForResult();\n      contracts.push(contract);\n    }\n  } catch (err) {\n    cleanup();\n    throw err;\n  }\n  return {\n    provider,\n    wallets,\n    contracts,\n    cleanup,\n    [Symbol.dispose]: cleanup,\n  };\n}\n"],"mappings":"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","names":[]}