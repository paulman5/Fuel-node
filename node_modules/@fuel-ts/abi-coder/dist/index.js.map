{"version":3,"sources":["../src/index.ts","../src/encoding/coders/AbstractCoder.ts","../src/encoding/coders/ArrayCoder.ts","../src/utils/constants.ts","../src/utils/utilities.ts","../src/encoding/coders/B256Coder.ts","../src/encoding/coders/B512Coder.ts","../src/encoding/coders/BigNumberCoder.ts","../src/encoding/coders/BooleanCoder.ts","../src/encoding/coders/ByteCoder.ts","../src/encoding/coders/EnumCoder.ts","../src/encoding/coders/NumberCoder.ts","../src/encoding/coders/OptionCoder.ts","../src/encoding/coders/RawSliceCoder.ts","../src/encoding/coders/StdStringCoder.ts","../src/encoding/coders/StrSliceCoder.ts","../src/encoding/coders/StringCoder.ts","../src/encoding/coders/StructCoder.ts","../src/encoding/coders/TupleCoder.ts","../src/encoding/coders/VecCoder.ts","../src/Interface.ts","../src/ResolvedAbiType.ts","../src/utils/json-abi.ts","../src/encoding/strategies/getCoderForEncoding.ts","../src/encoding/strategies/getCoderV1.ts","../src/encoding/coders/VoidCoder.ts","../src/encoding/strategies/getCoders.ts","../src/AbiCoder.ts","../src/FunctionFragment.ts","../src/utils/getFunctionInputs.ts","../src/utils/padValuesWithUndefined.ts","../src/utils/transpile-abi.ts"],"sourcesContent":["export { Coder, InputValue, DecodedValue } from './encoding/coders/AbstractCoder';\nexport type { FunctionFragment } from './FunctionFragment';\nexport * from './encoding/coders';\nexport { Interface } from './Interface';\nexport type { JsonAbi } from './types/JsonAbiNew';\nexport {\n  SCRIPT_FIXED_SIZE,\n  INPUT_COIN_FIXED_SIZE,\n  WORD_SIZE,\n  ASSET_ID_LEN,\n  CONTRACT_ID_LEN,\n  UTXO_ID_LEN,\n  BYTES_32,\n  calculateVmTxMemory,\n  ENCODING_V1,\n} from './utils/constants';\nexport type { Bytes, RawSlice, StdString, StrSlice } from './utils/types';\n","import type { BN } from '@fuel-ts/math';\nimport type { BytesLike } from '@fuel-ts/utils';\n\nimport type { Option } from './OptionCoder';\n\ntype Primitive = string | number | boolean;\n\n/**\n * The type of value you can provide to `Coder.encode`\n */\nexport type InputValue<T = void> =\n  | Primitive\n  | BN\n  | Option<T>\n  | BytesLike\n  | InputValue[]\n  | { [key: string]: InputValue }\n  | Record<string, Primitive | BytesLike>;\n\n/**\n * The type of value you can get from `Coder.decode`\n */\nexport type DecodedValue =\n  | Primitive\n  | DecodedValue[]\n  | { [key: string]: DecodedValue }\n  | Record<string, Primitive>;\n\nexport type TypesOfCoder<TCoder> =\n  TCoder extends Coder<infer TInput, infer TDecoded> ? { Input: TInput; Decoded: TDecoded } : never;\n\nexport abstract class Coder<TInput = unknown, TDecoded = unknown> {\n  readonly name: string;\n  readonly type: string;\n  readonly encodedLength: number;\n\n  constructor(name: string, type: string, encodedLength: number) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n\n  abstract encode(value: TInput, length?: number): Uint8Array;\n\n  abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concat } from '@fuel-ts/utils';\n\nimport { MAX_BYTES } from '../../utils/constants';\nimport { hasNestedOption } from '../../utils/utilities';\n\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { Coder } from './AbstractCoder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class ArrayCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  length: number;\n  #hasNestedOption: boolean;\n\n  constructor(coder: TCoder, length: number) {\n    super('array', `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n    this.#hasNestedOption = hasNestedOption([coder]);\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    if (this.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concat(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if ((!this.#hasNestedOption && data.length < this.encodedLength) || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid array data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Array(this.length)\n      .fill(0)\n      .map(() => {\n        let decoded;\n        [decoded, newOffset] = this.coder.decode(data, newOffset);\n        return decoded;\n      });\n\n    return [decodedValue as DecodedValueOf<TCoder>, newOffset];\n  }\n}\n","/**\n * Types and Type Regex\n */\nexport const U8_CODER_TYPE = 'u8';\nexport const U16_CODER_TYPE = 'u16';\nexport const U32_CODER_TYPE = 'u32';\nexport const U64_CODER_TYPE = 'u64';\nexport const U256_CODER_TYPE = 'u256';\nexport const RAW_PTR_CODER_TYPE = 'raw untyped ptr';\nexport const RAW_SLICE_CODER_TYPE = 'raw untyped slice';\nexport const BOOL_CODER_TYPE = 'bool';\nexport const B256_CODER_TYPE = 'b256';\nexport const B512_CODER_TYPE = 'struct std::b512::B512';\nexport const OPTION_CODER_TYPE = 'enum std::option::Option';\nexport const VEC_CODER_TYPE = 'struct std::vec::Vec';\nexport const BYTES_CODER_TYPE = 'struct std::bytes::Bytes';\nexport const STD_STRING_CODER_TYPE = 'struct std::string::String';\nexport const STR_SLICE_CODER_TYPE = 'str';\nexport const VOID_TYPE = '()';\n\nexport const optionRegEx: RegExp = /^enum (std::option::)?Option$/m;\nexport const stringRegEx = /^str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /^\\[(?<item>[\\w\\s\\\\[\\]]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct.+/;\nexport const enumRegEx = /^enum.+$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\nexport const genericRegEx = /^generic.+$/;\n\nexport const fullNameRegExMatch = /([^\\s]+)$/m;\n\n/**\n * Encoding versions\n */\nexport const ENCODING_V1 = '1';\nexport type EncodingVersion = typeof ENCODING_V1;\n\n/**\n * Property space and config constants\n */\nexport const WORD_SIZE = 8;\nexport const BYTES_32 = 32;\nexport const UTXO_ID_LEN = BYTES_32 + 2;\nexport const MAX_INPUTS = 255;\nexport const ASSET_ID_LEN = BYTES_32;\nexport const CONTRACT_ID_LEN = BYTES_32;\nexport const ADDRESS_LEN = BYTES_32;\nexport const NONCE_LEN = BYTES_32;\nexport const TX_LEN = WORD_SIZE * 4;\nexport const TX_POINTER_LEN = WORD_SIZE * 2;\nexport const MAX_BYTES = 2 ** 32 - 1; // Max u32\n\nexport const calculateVmTxMemory = ({ maxInputs }: { maxInputs: number }) =>\n  BYTES_32 + // Tx ID\n  ASSET_ID_LEN + // Base asset ID\n  // Asset ID/Balance coin input pairs\n  maxInputs * (ASSET_ID_LEN + WORD_SIZE) +\n  WORD_SIZE; // Tx size\n\n// SCRIPT_FIXED_SIZE = 104\nexport const SCRIPT_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  WORD_SIZE + // Gas limit\n  WORD_SIZE + // Script size\n  WORD_SIZE + // Script data size\n  WORD_SIZE + // Policies\n  WORD_SIZE + // Inputs size\n  WORD_SIZE + // Outputs size\n  WORD_SIZE + // Witnesses size\n  BYTES_32; // Receipts root\n\n// INPUT_COIN_FIXED_SIZE = 176\nexport const INPUT_COIN_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  TX_LEN + // Utxo Length\n  WORD_SIZE + // Output Index\n  ADDRESS_LEN + // Owner\n  WORD_SIZE + // Amount\n  ASSET_ID_LEN + // Asset id\n  TX_POINTER_LEN + // TxPointer\n  WORD_SIZE + // Witnesses index\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n\n// INPUT_MESSAGE_FIXED_SIZE = 168\nexport const INPUT_MESSAGE_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  ADDRESS_LEN + // Sender\n  ADDRESS_LEN + // Recipient\n  WORD_SIZE + // Amount\n  NONCE_LEN + // Nonce\n  WORD_SIZE + // witness_index\n  WORD_SIZE + // Data size\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n","import type { Coder } from '../encoding/coders/AbstractCoder';\n\nimport { OPTION_CODER_TYPE, WORD_SIZE } from './constants';\n\n/**\n * Turns:\n  Uint8Array(24) [\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 24\n  ]\n\n  Into:\n  Array [\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 1\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 2\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 24\n    ]\n  ]\n *\n */\nexport const chunkByLength = (data: Uint8Array, length = WORD_SIZE): Uint8Array[] => {\n  const chunks = [];\n  let offset = 0;\n  let chunk = data.slice(offset, offset + length);\n  while (chunk.length) {\n    chunks.push(chunk);\n    offset += length;\n    chunk = data.slice(offset, offset + length);\n  }\n\n  return chunks;\n};\n\nexport const isUint8Array = (value: unknown): value is Uint8Array => value instanceof Uint8Array;\n\nexport type TCoders = Record<string, Coder>;\n\n/**\n * Finds a deeply nested option in a coders object.\n *\n * @param coders - the coders object to search.\n * @returns - whether the coder has been found.\n */\nexport const hasNestedOption = (coders: Record<string, Coder> | Coder[]): boolean => {\n  const array = Array.isArray(coders) ? coders : Object.values(coders);\n\n  for (const node of array) {\n    if (node.type === OPTION_CODER_TYPE) {\n      return true;\n    }\n\n    if ('coder' in node && (node.coder as Coder).type === OPTION_CODER_TYPE) {\n      return true;\n    }\n\n    if ('coders' in node) {\n      const child = hasNestedOption(node.coders as TCoders);\n      if (child) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\nexport class B256Coder extends Coder<string, string> {\n  constructor() {\n    super('b256', 'b256', WORD_SIZE * 4);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(32);\n    }\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 byte data size.`);\n    }\n\n    return [toHex(bytes, 32), offset + 32];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\nexport class B512Coder extends Coder<string, string> {\n  constructor() {\n    super('b512', 'struct B512', WORD_SIZE * 8);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(64);\n    }\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 byte data size.`);\n    }\n\n    return [toHex(bytes, this.encodedLength), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { type BNInput, type BN, toBytes, bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\ntype BigNumberCoderType = 'u64' | 'u256';\n\nconst encodedLengths: { [key in BigNumberCoderType]: number } = {\n  u64: WORD_SIZE,\n  u256: WORD_SIZE * 4,\n};\n\nexport class BigNumberCoder extends Coder<BNInput, BN> {\n  constructor(baseType: BigNumberCoderType) {\n    super('bigNumber', baseType, encodedLengths[baseType]);\n  }\n\n  encode(value: BNInput): Uint8Array {\n    let bytes;\n\n    // We throw an error if the value is a number and it's more than the max safe integer\n    // This is because we can experience some odd behavior with integers more than the max safe integer\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER#description\n    if (typeof value === 'number' && value > Number.MAX_SAFE_INTEGER) {\n      throw new FuelError(\n        ErrorCode.ENCODE_ERROR,\n        `Invalid ${this.type} type - number value is too large. Number can only safely handle up to 53 bits.`\n      );\n    }\n\n    try {\n      bytes = toBytes(value, this.encodedLength);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n\n    return bytes;\n  }\n\n  decode(data: Uint8Array, offset: number): [BN, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n    bytes = bytes.slice(0, this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} byte data size.`);\n    }\n\n    return [bn(bytes), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\nexport class BooleanCoder extends Coder<boolean, boolean> {\n  options: EncodingOptions;\n\n  constructor(\n    options: EncodingOptions = {\n      padToWordSize: false,\n    }\n  ) {\n    const encodedLength = options.padToWordSize ? WORD_SIZE : 1;\n    super('boolean', 'boolean', encodedLength);\n\n    this.options = options;\n  }\n\n  encode(value: boolean): Uint8Array {\n    const isTrueBool = value === true || value === false;\n\n    if (!isTrueBool) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return toBytes(value ? 1 : 0, this.encodedLength);\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);\n    }\n\n    const bytes = bn(data.slice(offset, offset + this.encodedLength));\n\n    if (bytes.isZero()) {\n      return [false, offset + this.encodedLength];\n    }\n\n    if (!bytes.eq(bn(1))) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return [true, offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport class ByteCoder extends Coder<number[], Uint8Array> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct Bytes', WORD_SIZE);\n  }\n\n  encode(value: number[] | Uint8Array): Uint8Array {\n    const bytes = value instanceof Uint8Array ? value : new Uint8Array(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(bytes.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [Uint8Array, number] {\n    if (data.length < WORD_SIZE) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);\n    }\n\n    return [dataBytes, offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport { OPTION_CODER_TYPE, optionRegEx, VOID_TYPE } from '../../utils/constants';\nimport { hasNestedOption } from '../../utils/utilities';\n\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { Coder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport type InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\nexport type DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nexport class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  override name: string;\n  coders: TCoders;\n  #caseIndexCoder: BigNumberCoder;\n  #encodedValueSize: number;\n  #shouldValidateLength: boolean;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new BigNumberCoder('u64');\n    const encodedValueSize = Object.values(coders).reduce(\n      (min, coder) => Math.min(min, coder.encodedLength),\n      0\n    );\n    super(`enum ${name}`, `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n    this.#shouldValidateLength = !(optionRegEx.test(this.type) || hasNestedOption(coders));\n  }\n\n  // Checks that we're handling a native enum that is of type void.\n  #isNativeEnum(coder: Coder): boolean {\n    return this.type !== OPTION_CODER_TYPE && coder.type === VOID_TYPE;\n  }\n\n  #encodeNativeEnum(value: string): Uint8Array {\n    const valueCoder = this.coders[value];\n    const encodedValue = valueCoder.encode([]);\n    const caseIndex = Object.keys(this.coders).indexOf(value);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (typeof value === 'string' && this.coders[value]) {\n      return this.#encodeNativeEnum(value);\n    }\n\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'A field for the case must be provided.');\n    }\n    if (empty.length !== 0) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'Only one field must be provided.');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    if (caseIndex === -1) {\n      const validCases = Object.keys(this.coders)\n        .map((v) => `'${v}'`)\n        .join(', ');\n      throw new FuelError(\n        ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid case '${caseKey}'. Valid cases: ${validCases}.`\n      );\n    }\n\n    const encodedValue = valueCoder.encode(value[caseKey]);\n\n    return new Uint8Array([...this.#caseIndexCoder.encode(caseIndex), ...encodedValue]);\n  }\n\n  #decodeNativeEnum(caseKey: string, newOffset: number): [DecodedValueOf<TCoders>, number] {\n    return [caseKey as unknown as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (this.#shouldValidateLength && data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n\n    const caseBytes = new BigNumberCoder('u64').decode(data, offset)[0];\n    const caseIndex = toNumber(caseBytes);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new FuelError(\n        ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}.`\n      );\n    }\n    const valueCoder = this.coders[caseKey];\n    const offsetAndCase = offset + this.#caseIndexCoder.encodedLength;\n\n    if (this.#shouldValidateLength && data.length < offsetAndCase + valueCoder.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n\n    const [decoded, newOffset] = valueCoder.decode(data, offsetAndCase);\n\n    if (this.#isNativeEnum(this.coders[caseKey])) {\n      return this.#decodeNativeEnum(caseKey, newOffset);\n    }\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber, toBytes } from '@fuel-ts/math';\n\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32';\n\nconst getLength = (baseType: NumberCoderType): number => {\n  switch (baseType) {\n    case 'u8':\n      return 1;\n    case 'u16':\n      return 2;\n    case 'u32':\n      return 4;\n    default:\n      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Invalid number type: ${baseType}`);\n  }\n};\n\nexport class NumberCoder extends Coder<number, number> {\n  baseType: NumberCoderType;\n  options: EncodingOptions;\n\n  constructor(\n    baseType: NumberCoderType,\n    options: EncodingOptions = {\n      padToWordSize: false,\n    }\n  ) {\n    const length = options.padToWordSize ? WORD_SIZE : getLength(baseType);\n    super('number', baseType, length);\n    this.baseType = baseType;\n    this.options = options;\n  }\n\n  encode(value: number | string): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);\n    }\n\n    if (bytes.length > this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);\n    }\n\n    return toBytes(bytes, this.encodedLength);\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);\n    }\n\n    return [toNumber(bytes), offset + this.encodedLength];\n  }\n}\n","import type { Coder } from './AbstractCoder';\nimport type { InputValueOf, DecodedValueOf } from './EnumCoder';\nimport { EnumCoder } from './EnumCoder';\n\ntype SwayOption<T> = { None: [] } | { Some: T };\nexport type Option<T> = T | undefined;\n\nexport class OptionCoder<TCoders extends Record<string, Coder>> extends EnumCoder<TCoders> {\n  override encode(value?: Option<unknown>): Uint8Array {\n    const result = super.encode(this.toSwayOption(value) as unknown as InputValueOf<TCoders>);\n    return result;\n  }\n\n  private toSwayOption(input?: Option<unknown>): SwayOption<unknown> {\n    if (input !== undefined) {\n      return { Some: input };\n    }\n\n    return { None: [] };\n  }\n\n  override decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    const [decoded, newOffset] = super.decode(data, offset);\n    return [this.toOption(decoded) as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  private toOption(output?: DecodedValueOf<TCoders>): Option<unknown> {\n    if (output && 'Some' in output) {\n      return output.Some;\n    }\n\n    return undefined;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\nimport { ArrayCoder } from './ArrayCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\nimport { NumberCoder } from './NumberCoder';\n\nexport class RawSliceCoder extends Coder<number[], number[]> {\n  constructor() {\n    super('raw untyped slice', 'raw untyped slice', WORD_SIZE);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const internalCoder = new ArrayCoder(new NumberCoder('u8'), value.length);\n    const bytes = internalCoder.encode(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(bytes.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [number[], number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice byte data size.`);\n    }\n\n    const internalCoder = new ArrayCoder(new NumberCoder('u8'), length);\n    const [decodedValue] = internalCoder.decode(dataBytes, 0);\n\n    return [decodedValue, offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { toUtf8Bytes, toUtf8String } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport class StdStringCoder extends Coder<string, string> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct String', WORD_SIZE);\n  }\n\n  encode(value: string): Uint8Array {\n    const bytes = toUtf8Bytes(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);\n    }\n\n    return [toUtf8String(dataBytes), offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { toUtf8Bytes, toUtf8String } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport class StrSliceCoder extends Coder<string, string> {\n  static memorySize = 1;\n  constructor() {\n    super('strSlice', 'str', WORD_SIZE);\n  }\n\n  encode(value: string): Uint8Array {\n    const bytes = toUtf8Bytes(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string slice data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const bytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (bytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string slice byte data size.`);\n    }\n\n    return [toUtf8String(bytes), offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toUtf8Bytes, toUtf8String } from '@fuel-ts/utils';\n\nimport { Coder } from './AbstractCoder';\n\nexport class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  constructor(length: TLength) {\n    super('string', `str[${length}]`, length);\n  }\n\n  encode(value: string): Uint8Array {\n    if (value.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);\n    }\n\n    return toUtf8Bytes(value);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);\n    }\n\n    return [toUtf8String(bytes), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport { hasNestedOption } from '../../utils/utilities';\n\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { Coder } from './AbstractCoder';\nimport { OptionCoder } from './OptionCoder';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  override name: string;\n  coders: TCoders;\n  #hasNestedOption: boolean;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n    this.#hasNestedOption = hasNestedOption(coders);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    return concatBytes(\n      Object.keys(this.coders).map((fieldName) => {\n        const fieldCoder = this.coders[fieldName];\n        const fieldValue = value[fieldName];\n\n        if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {\n          throw new FuelError(\n            ErrorCode.ENCODE_ERROR,\n            `Invalid ${this.type}. Field \"${fieldName}\" not present.`\n          );\n        }\n\n        return fieldCoder.encode(fieldValue);\n      })\n    );\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (!this.#hasNestedOption && data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport { hasNestedOption } from '../../utils/utilities';\n\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { Coder } from './AbstractCoder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n  #hasNestedOption: boolean;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n    this.#hasNestedOption = hasNestedOption(coders);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatBytes(this.coders.map((coder, i) => coder.encode(value[i])));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (!this.#hasNestedOption && data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport { MAX_BYTES, WORD_SIZE } from '../../utils/constants';\nimport { hasNestedOption, isUint8Array } from '../../utils/utilities';\n\nimport { Coder } from './AbstractCoder';\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']> | Uint8Array;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class VecCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  #hasNestedOption: boolean;\n\n  constructor(coder: TCoder) {\n    super('struct', `struct Vec`, WORD_SIZE);\n    this.coder = coder;\n    this.#hasNestedOption = hasNestedOption([coder]);\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value) && !isUint8Array(value)) {\n      throw new FuelError(\n        ErrorCode.ENCODE_ERROR,\n        `Expected array value, or a Uint8Array. You can use arrayify to convert a value to a Uint8Array.`\n      );\n    }\n\n    const lengthCoder = new BigNumberCoder('u64');\n\n    if (isUint8Array(value)) {\n      return new Uint8Array([...lengthCoder.encode(value.length), ...value]);\n    }\n\n    const bytes = value.map((v) => this.coder.encode(v));\n    const lengthBytes = lengthCoder.encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...concatBytes(bytes)]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if ((!this.#hasNestedOption && data.length < this.encodedLength) || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataLength = length * this.coder.encodedLength;\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + dataLength);\n\n    if (!this.#hasNestedOption && dataBytes.length !== dataLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);\n    }\n\n    let newOffset = offsetAndLength;\n    const chunks = [];\n    for (let i = 0; i < length; i++) {\n      const [decoded, optionOffset] = this.coder.decode(data, newOffset);\n      chunks.push(decoded);\n      newOffset = optionOffset;\n    }\n\n    return [chunks, newOffset];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/utils';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { AbiCoder } from './AbiCoder';\nimport { FunctionFragment } from './FunctionFragment';\nimport type { DecodedValue, InputValue } from './encoding/coders/AbstractCoder';\nimport type { JsonAbiArgument, JsonAbiOld } from './types/JsonAbi';\nimport type { Configurable, JsonAbi } from './types/JsonAbiNew';\nimport { type EncodingVersion } from './utils/constants';\nimport { getEncodingVersion } from './utils/json-abi';\nimport { parseConcreteType, transpileAbi } from './utils/transpile-abi';\n\nexport class Interface {\n  readonly functions!: Record<string, FunctionFragment>;\n  readonly configurables: Record<string, Configurable>;\n  readonly jsonAbi: JsonAbi;\n  readonly encoding: EncodingVersion;\n  private readonly jsonAbiOld: JsonAbiOld;\n\n  constructor(jsonAbi: JsonAbi) {\n    this.jsonAbi = jsonAbi;\n    this.encoding = getEncodingVersion(jsonAbi.encodingVersion);\n    this.jsonAbiOld = transpileAbi(jsonAbi) as JsonAbiOld;\n    this.functions = Object.fromEntries(\n      this.jsonAbi.functions.map((fn) => [fn.name, new FunctionFragment(this.jsonAbiOld, fn)])\n    );\n\n    this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));\n  }\n\n  /**\n   * Returns function fragment for a dynamic input.\n   * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment\n   */\n  getFunction(nameOrSignatureOrSelector: string): FunctionFragment {\n    const fn = Object.values<FunctionFragment>(this.functions).find(\n      (f) =>\n        f.name === nameOrSignatureOrSelector ||\n        f.signature === nameOrSignatureOrSelector ||\n        f.selector === nameOrSignatureOrSelector\n    );\n\n    if (fn !== undefined) {\n      return fn;\n    }\n\n    throw new FuelError(\n      ErrorCode.FUNCTION_NOT_FOUND,\n      `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`\n    );\n  }\n\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    return fragment.decodeOutput(data);\n  }\n\n  decodeLog(data: BytesLike, logId: string): any {\n    const loggedType = this.jsonAbiOld.loggedTypes.find((type) => type.logId === logId);\n    if (!loggedType) {\n      throw new FuelError(\n        ErrorCode.LOG_TYPE_NOT_FOUND,\n        `Log type with logId '${logId}' doesn't exist in the ABI.`\n      );\n    }\n\n    return AbiCoder.decode(this.jsonAbiOld, loggedType.loggedType, arrayify(data), 0, {\n      encoding: this.encoding,\n    });\n  }\n\n  encodeConfigurable(name: string, value: InputValue) {\n    const configurable = this.jsonAbiOld.configurables.find((c) => c.name === name);\n    if (!configurable) {\n      throw new FuelError(\n        ErrorCode.CONFIGURABLE_NOT_FOUND,\n        `A configurable with the '${name}' was not found in the ABI.`\n      );\n    }\n\n    return AbiCoder.encode(this.jsonAbiOld, configurable.configurableType, value, {\n      encoding: this.encoding,\n    });\n  }\n\n  encodeType(concreteTypeId: string, value: InputValue): Uint8Array {\n    const typeArg = parseConcreteType(\n      this.jsonAbi,\n      this.jsonAbiOld.types,\n      concreteTypeId,\n      ''\n    ) as JsonAbiArgument;\n    return AbiCoder.encode(this.jsonAbiOld, typeArg, value, {\n      encoding: this.encoding,\n    });\n  }\n\n  decodeType(concreteTypeId: string, data: Uint8Array): [DecodedValue | undefined, number] {\n    const typeArg = parseConcreteType(\n      this.jsonAbi,\n      this.jsonAbiOld.types,\n      concreteTypeId,\n      ''\n    ) as JsonAbiArgument;\n\n    return AbiCoder.decode(this.jsonAbiOld, typeArg, data, 0, { encoding: this.encoding });\n  }\n}\n","import { FuelError, ErrorCode } from '@fuel-ts/errors';\n\nimport type { JsonAbiOld, JsonAbiArgument } from './types/JsonAbi';\nimport { arrayRegEx, enumRegEx, genericRegEx, stringRegEx, structRegEx } from './utils/constants';\nimport { findTypeById } from './utils/json-abi';\n\nexport class ResolvedAbiType {\n  readonly abi: JsonAbiOld;\n  name: string;\n  readonly type: string;\n  readonly originalTypeArguments: readonly JsonAbiArgument[] | null;\n  readonly components: readonly ResolvedAbiType[] | null;\n\n  constructor(abi: JsonAbiOld, argument: JsonAbiArgument) {\n    this.abi = abi;\n\n    this.name = argument.name;\n\n    const jsonABIType = findTypeById(abi, argument.type);\n\n    if (jsonABIType.type.length > 256) {\n      throw new FuelError(\n        ErrorCode.INVALID_COMPONENT,\n        `The provided ABI type is too long: ${jsonABIType.type}.`\n      );\n    }\n\n    this.type = jsonABIType.type;\n    this.originalTypeArguments = argument.typeArguments;\n    this.components = ResolvedAbiType.getResolvedGenericComponents(\n      abi,\n      argument,\n      jsonABIType.components,\n      jsonABIType.typeParameters ??\n        ResolvedAbiType.getImplicitGenericTypeParameters(abi, jsonABIType.components)\n    );\n  }\n\n  private static getResolvedGenericComponents(\n    abi: JsonAbiOld,\n    arg: JsonAbiArgument,\n    components: readonly JsonAbiArgument[] | null,\n    typeParameters: readonly number[] | null\n  ) {\n    if (components === null) {\n      return null;\n    }\n    if (typeParameters === null || typeParameters.length === 0) {\n      return components.map((c) => new ResolvedAbiType(abi, c));\n    }\n\n    const typeParametersAndArgsMap = typeParameters.reduce(\n      (obj, typeParameter, typeParameterIndex) => {\n        const o: Record<number, JsonAbiArgument> = { ...obj };\n        o[typeParameter] = structuredClone(\n          arg.typeArguments?.[typeParameterIndex]\n        ) as JsonAbiArgument;\n        return o;\n      },\n      {} as Record<number, JsonAbiArgument>\n    );\n\n    const resolvedComponents = this.resolveGenericArgTypes(\n      abi,\n      components,\n      typeParametersAndArgsMap\n    );\n\n    return resolvedComponents.map((c) => new ResolvedAbiType(abi, c));\n  }\n\n  private static resolveGenericArgTypes(\n    abi: JsonAbiOld,\n    args: readonly JsonAbiArgument[],\n    typeParametersAndArgsMap: Record<number, JsonAbiArgument>\n  ): readonly JsonAbiArgument[] {\n    return args.map((arg) => {\n      if (typeParametersAndArgsMap[arg.type] !== undefined) {\n        return {\n          ...typeParametersAndArgsMap[arg.type],\n          name: arg.name,\n        };\n      }\n\n      if (arg.typeArguments) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: this.resolveGenericArgTypes(\n            abi,\n            arg.typeArguments,\n            typeParametersAndArgsMap\n          ),\n        };\n      }\n\n      const argType = findTypeById(abi, arg.type);\n      const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);\n\n      if (implicitTypeParameters && implicitTypeParameters.length > 0) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp]),\n        };\n      }\n\n      return arg;\n    });\n  }\n\n  private static getImplicitGenericTypeParameters(\n    abi: JsonAbiOld,\n    args: readonly JsonAbiArgument[] | null,\n    implicitGenericParametersParam?: number[]\n  ) {\n    if (!Array.isArray(args)) {\n      return null;\n    }\n\n    const implicitGenericParameters: number[] = implicitGenericParametersParam ?? [];\n\n    args.forEach((a) => {\n      const argType = findTypeById(abi, a.type);\n\n      if (genericRegEx.test(argType.type)) {\n        implicitGenericParameters.push(argType.typeId);\n        return;\n      }\n\n      if (!Array.isArray(a.typeArguments)) {\n        return;\n      }\n      this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);\n    });\n\n    return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;\n  }\n\n  getSignature(): string {\n    const prefix = this.getArgSignaturePrefix();\n    const content = this.getArgSignatureContent();\n\n    return `${prefix}${content}`;\n  }\n\n  private getArgSignaturePrefix(): string {\n    const structMatch = structRegEx.test(this.type);\n    if (structMatch) {\n      return 's';\n    }\n\n    const arrayMatch = arrayRegEx.test(this.type);\n    if (arrayMatch) {\n      return 'a';\n    }\n\n    const enumMatch = enumRegEx.test(this.type);\n    if (enumMatch) {\n      return 'e';\n    }\n\n    return '';\n  }\n\n  private getArgSignatureContent(): string {\n    if (this.type === 'raw untyped ptr') {\n      return 'rawptr';\n    }\n\n    if (this.type === 'raw untyped slice') {\n      return 'rawslice';\n    }\n\n    const strMatch = stringRegEx.exec(this.type)?.groups;\n    if (strMatch) {\n      return `str[${strMatch.length}]`;\n    }\n\n    if (this.components === null) {\n      return this.type;\n    }\n\n    const arrayMatch = arrayRegEx.exec(this.type)?.groups;\n\n    if (arrayMatch) {\n      return `[${this.components[0].getSignature()};${arrayMatch.length}]`;\n    }\n\n    const typeArgumentsSignature =\n      this.originalTypeArguments !== null\n        ? `<${this.originalTypeArguments\n            .map((a) => new ResolvedAbiType(this.abi, a).getSignature())\n            .join(',')}>`\n        : '';\n\n    const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(',')})`;\n\n    return `${typeArgumentsSignature}${componentsSignature}`;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { ResolvedAbiType } from '../ResolvedAbiType';\nimport type { JsonAbiOld, JsonAbiArgument, JsonAbiType } from '../types/JsonAbi';\nimport type { AbiFunction, JsonAbi } from '../types/JsonAbiNew';\n\nimport { ENCODING_V1, VOID_TYPE, type EncodingVersion } from './constants';\n\n/**\n * Asserts that the encoding version is supported by the ABI coder.\n *\n * @param encoding - the encoding version to check\n * @returns the encoding version\n * @throws FuelError if the encoding version is not supported\n */\nexport const getEncodingVersion = (encoding?: string): EncodingVersion => {\n  switch (encoding) {\n    case undefined:\n    case ENCODING_V1:\n      return ENCODING_V1;\n\n    default:\n      throw new FuelError(\n        ErrorCode.UNSUPPORTED_ENCODING_VERSION,\n        `Encoding version '${encoding}' is unsupported.`\n      );\n  }\n};\n\n/**\n * Find a function by name in the ABI.\n *\n * @param abi - the JsonAbi object\n * @param name - the name of the function to find\n * @returns the JsonAbi function object\n */\nexport const findFunctionByName = (abi: JsonAbi, name: string): AbiFunction => {\n  const fn = abi.functions.find((f) => f.name === name);\n  if (!fn) {\n    throw new FuelError(\n      ErrorCode.FUNCTION_NOT_FOUND,\n      `Function with name '${name}' doesn't exist in the ABI`\n    );\n  }\n  return fn;\n};\n\n/**\n * Find a type by its typeId in the ABI.\n *\n * @param abi - the JsonAbi object\n * @param typeId - the typeId of the type to find\n * @returns the JsonAbi type object\n */\nexport const findTypeById = (abi: JsonAbiOld, typeId: number): JsonAbiType => {\n  const type = abi.types.find((t) => t.typeId === typeId);\n  if (!type) {\n    throw new FuelError(\n      ErrorCode.TYPE_NOT_FOUND,\n      `Type with typeId '${typeId}' doesn't exist in the ABI.`\n    );\n  }\n  return type;\n};\n\n/**\n * Find all non-void inputs in a list of inputs.\n * i.e. all inputs that are not of the type '()'.\n *\n * @param abi - the JsonAbi object\n * @param inputs - the list of inputs to filter\n * @returns the list of non-void inputs\n */\nexport const findNonVoidInputs = (\n  abi: JsonAbiOld,\n  inputs: readonly JsonAbiArgument[]\n): JsonAbiArgument[] => inputs.filter((input) => findTypeById(abi, input.type).type !== VOID_TYPE);\n\n/**\n * Find the vector buffer argument in a list of components.\n *\n * @param components - the list of components to search\n * @returns the vector buffer argument\n */\nexport const findVectorBufferArgument = (\n  components: readonly ResolvedAbiType[]\n): JsonAbiArgument => {\n  const bufferComponent = components.find((c) => c.name === 'buf');\n  const bufferTypeArgument = bufferComponent?.originalTypeArguments?.[0];\n  if (!bufferComponent || !bufferTypeArgument) {\n    throw new FuelError(\n      ErrorCode.INVALID_COMPONENT,\n      `The Vec type provided is missing or has a malformed 'buf' component.`\n    );\n  }\n  return bufferTypeArgument;\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport type { EncodingVersion } from '../../utils/constants';\nimport { ENCODING_V1 } from '../../utils/constants';\n\nimport { getCoder as getCoderV1 } from './getCoderV1';\n\n/**\n * Retrieves the appropriate encoding function for a given encoding version.\n *\n * @param encoding - the version to provide a strategy for.\n * @throws for an unsupported encoding version.\n * @returns the appropriate encoding strategy.\n */\nexport function getCoderForEncoding(encoding: EncodingVersion = ENCODING_V1): GetCoderFn {\n  switch (encoding) {\n    case ENCODING_V1:\n      return getCoderV1;\n    default:\n      throw new FuelError(\n        ErrorCode.UNSUPPORTED_ENCODING_VERSION,\n        `Encoding version ${encoding} is unsupported.`\n      );\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { ResolvedAbiType } from '../../ResolvedAbiType';\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport {\n  B256_CODER_TYPE,\n  B512_CODER_TYPE,\n  BOOL_CODER_TYPE,\n  BYTES_CODER_TYPE,\n  ENCODING_V1,\n  OPTION_CODER_TYPE,\n  RAW_PTR_CODER_TYPE,\n  RAW_SLICE_CODER_TYPE,\n  STD_STRING_CODER_TYPE,\n  STR_SLICE_CODER_TYPE,\n  U16_CODER_TYPE,\n  U256_CODER_TYPE,\n  U32_CODER_TYPE,\n  U64_CODER_TYPE,\n  U8_CODER_TYPE,\n  VEC_CODER_TYPE,\n  VOID_TYPE,\n  arrayRegEx,\n  enumRegEx,\n  fullNameRegExMatch,\n  stringRegEx,\n  structRegEx,\n  tupleRegEx,\n} from '../../utils/constants';\nimport { findVectorBufferArgument } from '../../utils/json-abi';\nimport type { Coder } from '../coders/AbstractCoder';\nimport { ArrayCoder } from '../coders/ArrayCoder';\nimport { B256Coder } from '../coders/B256Coder';\nimport { B512Coder } from '../coders/B512Coder';\nimport { BigNumberCoder } from '../coders/BigNumberCoder';\nimport { BooleanCoder } from '../coders/BooleanCoder';\nimport { ByteCoder } from '../coders/ByteCoder';\nimport { EnumCoder } from '../coders/EnumCoder';\nimport { NumberCoder } from '../coders/NumberCoder';\nimport { OptionCoder } from '../coders/OptionCoder';\nimport { RawSliceCoder } from '../coders/RawSliceCoder';\nimport { StdStringCoder } from '../coders/StdStringCoder';\nimport { StrSliceCoder } from '../coders/StrSliceCoder';\nimport { StringCoder } from '../coders/StringCoder';\nimport { StructCoder } from '../coders/StructCoder';\nimport { TupleCoder } from '../coders/TupleCoder';\nimport { VecCoder } from '../coders/VecCoder';\nimport { VoidCoder } from '../coders/VoidCoder';\n\nimport { getCoders } from './getCoders';\n\n/**\n * Retrieves coders that adhere to the v0 spec.\n *\n * @param resolvedAbiType - the resolved type to return a coder for.\n * @param options - options to be utilized during the encoding process.\n * @returns the coder for a given type.\n */\nexport const getCoder: GetCoderFn = (\n  resolvedAbiType: ResolvedAbiType,\n  _options?: EncodingOptions\n): Coder => {\n  switch (resolvedAbiType.type) {\n    case U8_CODER_TYPE:\n    case U16_CODER_TYPE:\n    case U32_CODER_TYPE:\n      return new NumberCoder(resolvedAbiType.type);\n    case U64_CODER_TYPE:\n    case RAW_PTR_CODER_TYPE:\n      return new BigNumberCoder('u64');\n    case U256_CODER_TYPE:\n      return new BigNumberCoder('u256');\n    case RAW_SLICE_CODER_TYPE:\n      return new RawSliceCoder();\n    case BOOL_CODER_TYPE:\n      return new BooleanCoder();\n    case B256_CODER_TYPE:\n      return new B256Coder();\n    case B512_CODER_TYPE:\n      return new B512Coder();\n    case BYTES_CODER_TYPE:\n      return new ByteCoder();\n    case STD_STRING_CODER_TYPE:\n      return new StdStringCoder();\n    case STR_SLICE_CODER_TYPE:\n      return new StrSliceCoder();\n    case VOID_TYPE:\n      return new VoidCoder();\n    default:\n      break;\n  }\n\n  const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;\n  if (stringMatch) {\n    const length = parseInt(stringMatch.length, 10);\n\n    return new StringCoder(length);\n  }\n\n  // ABI types underneath MUST have components by definition\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const components = resolvedAbiType.components!;\n\n  const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;\n\n  if (arrayMatch) {\n    const length = parseInt(arrayMatch.length, 10);\n    const arg = components[0];\n    if (!arg) {\n      throw new FuelError(\n        ErrorCode.INVALID_COMPONENT,\n        `The provided Array type is missing an item of 'component'.`\n      );\n    }\n\n    const arrayElementCoder = getCoder(arg);\n    return new ArrayCoder(arrayElementCoder as Coder, length);\n  }\n\n  if (resolvedAbiType.type === VEC_CODER_TYPE) {\n    const arg = findVectorBufferArgument(components);\n    const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);\n\n    const itemCoder = getCoder(argType, { encoding: ENCODING_V1 });\n    return new VecCoder(itemCoder as Coder);\n  }\n\n  // component name\n  const coderName = resolvedAbiType.type.match(fullNameRegExMatch)?.[0];\n\n  const structMatch = structRegEx.test(resolvedAbiType.type);\n  if (structMatch && coderName) {\n    const coders = getCoders(components, { getCoder });\n    return new StructCoder(coderName, coders);\n  }\n\n  const enumMatch = enumRegEx.test(resolvedAbiType.type);\n  if (enumMatch && coderName) {\n    const coders = getCoders(components, { getCoder });\n    const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;\n    if (isOptionEnum) {\n      return new OptionCoder(coderName, coders);\n    }\n    return new EnumCoder(coderName, coders);\n  }\n\n  const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;\n  if (tupleMatch) {\n    const coders = components.map((component) => getCoder(component, { encoding: ENCODING_V1 }));\n    return new TupleCoder(coders as Coder[]);\n  }\n\n  throw new FuelError(\n    ErrorCode.CODER_NOT_FOUND,\n    `Coder not found: ${JSON.stringify(resolvedAbiType)}.`\n  );\n};\n","import { VOID_TYPE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\nexport class VoidCoder extends Coder<undefined, undefined> {\n  constructor() {\n    super('void', VOID_TYPE, 0);\n  }\n\n  encode(_value: undefined): Uint8Array {\n    return new Uint8Array([]);\n  }\n\n  decode(_data: Uint8Array, offset: number): [undefined, number] {\n    return [undefined, offset];\n  }\n}\n","import type { ResolvedAbiType } from '../../ResolvedAbiType';\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport type { Coder } from '../coders/AbstractCoder';\n\n/**\n * @param components - types array to create coders for.\n * @param options - options - options to be utilized during the encoding process.\n * @returns an object containing types and an appropriate coder.\n */\nexport function getCoders(\n  components: readonly ResolvedAbiType[],\n  options: EncodingOptions & { getCoder: GetCoderFn }\n) {\n  const { getCoder } = options;\n  return components.reduce((obj, component) => {\n    const o: Record<string, Coder> = obj;\n\n    o[component.name] = getCoder(component, options);\n    return o;\n  }, {});\n}\n","import { ResolvedAbiType } from './ResolvedAbiType';\nimport type { DecodedValue, InputValue, Coder } from './encoding/coders/AbstractCoder';\nimport { getCoderForEncoding } from './encoding/strategies/getCoderForEncoding';\nimport type { EncodingOptions } from './types/EncodingOptions';\nimport type { JsonAbiOld, JsonAbiArgument } from './types/JsonAbi';\n\nexport abstract class AbiCoder {\n  static getCoder(\n    abi: JsonAbiOld,\n    argument: JsonAbiArgument,\n    options: EncodingOptions = {\n      padToWordSize: false,\n    }\n  ): Coder {\n    const resolvedAbiType = new ResolvedAbiType(abi, argument);\n    return getCoderForEncoding(options.encoding)(resolvedAbiType, options);\n  }\n\n  static encode(\n    abi: JsonAbiOld,\n    argument: JsonAbiArgument,\n    value: InputValue,\n    options?: EncodingOptions\n  ) {\n    return this.getCoder(abi, argument, options).encode(value);\n  }\n\n  static decode(\n    abi: JsonAbiOld,\n    argument: JsonAbiArgument,\n    data: Uint8Array,\n    offset: number,\n    options?: EncodingOptions\n  ): [DecodedValue | undefined, number] {\n    return this.getCoder(abi, argument, options).decode(data, offset) as [\n      DecodedValue | undefined,\n      number,\n    ];\n  }\n}\n","import { bufferFromString } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { sha256 } from '@fuel-ts/hasher';\nimport { bn } from '@fuel-ts/math';\nimport type { BytesLike } from '@fuel-ts/utils';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { AbiCoder } from './AbiCoder';\nimport { ResolvedAbiType } from './ResolvedAbiType';\nimport type { DecodedValue, InputValue } from './encoding/coders/AbstractCoder';\nimport { StdStringCoder } from './encoding/coders/StdStringCoder';\nimport { TupleCoder } from './encoding/coders/TupleCoder';\nimport type { JsonAbiOld, JsonAbiFunction } from './types/JsonAbi';\nimport type { AbiFunction, AbiFunctionAttribute } from './types/JsonAbiNew';\nimport type { EncodingVersion } from './utils/constants';\nimport { getFunctionInputs } from './utils/getFunctionInputs';\nimport { findNonVoidInputs, getEncodingVersion } from './utils/json-abi';\nimport { padValuesWithUndefined } from './utils/padValuesWithUndefined';\n\nexport class FunctionFragment {\n  readonly signature: string;\n  readonly selector: string;\n  readonly selectorBytes: Uint8Array;\n  readonly encoding: EncodingVersion;\n  readonly name: string;\n  readonly jsonFn: AbiFunction;\n  readonly attributes: readonly AbiFunctionAttribute[];\n\n  private readonly jsonAbiOld: JsonAbiOld;\n  private readonly jsonFnOld: JsonAbiFunction;\n\n  constructor(jsonAbi: JsonAbiOld, fn: AbiFunction) {\n    this.jsonFn = fn;\n    this.jsonAbiOld = jsonAbi;\n    this.jsonFnOld = jsonAbi.functions.find((f) => f.name === fn.name) as JsonAbiFunction;\n    this.name = fn.name;\n    this.signature = FunctionFragment.getSignature(this.jsonAbiOld, this.jsonFnOld);\n    this.selector = FunctionFragment.getFunctionSelector(this.signature);\n    this.selectorBytes = new StdStringCoder().encode(this.name);\n    this.encoding = getEncodingVersion(jsonAbi.encoding);\n\n    this.attributes = this.jsonFn.attributes ?? [];\n  }\n\n  private static getSignature(abi: JsonAbiOld, fn: JsonAbiFunction): string {\n    const inputsSignatures = fn.inputs.map((input) =>\n      new ResolvedAbiType(abi, input).getSignature()\n    );\n    return `${fn.name}(${inputsSignatures.join(',')})`;\n  }\n\n  private static getFunctionSelector(functionSignature: string) {\n    const hashedFunctionSignature = sha256(bufferFromString(functionSignature, 'utf-8'));\n    // get first 4 bytes of signature + 0x prefix. then left-pad it to 8 bytes using toHex(8)\n    return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);\n  }\n\n  encodeArguments(values: InputValue[]): Uint8Array {\n    const inputs = getFunctionInputs({ jsonAbi: this.jsonAbiOld, inputs: this.jsonFnOld.inputs });\n    const mandatoryInputLength = inputs.filter((i) => !i.isOptional).length;\n    if (values.length < mandatoryInputLength) {\n      throw new FuelError(\n        ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH,\n        `Invalid number of arguments. Expected a minimum of ${mandatoryInputLength} arguments, received ${values.length}`\n      );\n    }\n\n    const coders = this.jsonFnOld.inputs.map((t) =>\n      AbiCoder.getCoder(this.jsonAbiOld, t, {\n        encoding: this.encoding,\n      })\n    );\n\n    const argumentValues = padValuesWithUndefined(values, this.jsonFn.inputs);\n    return new TupleCoder(coders).encode(argumentValues);\n  }\n\n  decodeArguments(data: BytesLike) {\n    const bytes = arrayify(data);\n    const nonVoidInputs = findNonVoidInputs(this.jsonAbiOld, this.jsonFnOld.inputs);\n\n    if (nonVoidInputs.length === 0) {\n      // The VM is current return 0x0000000000000000, but we should treat it as undefined / void\n      if (bytes.length === 0) {\n        return undefined;\n      }\n\n      throw new FuelError(\n        ErrorCode.DECODE_ERROR,\n        `Types/values length mismatch during decode. ${JSON.stringify({\n          count: {\n            types: this.jsonFn.inputs.length,\n            nonVoidInputs: nonVoidInputs.length,\n            values: bytes.length,\n          },\n          value: {\n            args: this.jsonFn.inputs,\n            nonVoidInputs,\n            values: bytes,\n          },\n        })}`\n      );\n    }\n\n    const result = this.jsonFnOld.inputs.reduce(\n      (obj: { decoded: unknown[]; offset: number }, input) => {\n        const coder = AbiCoder.getCoder(this.jsonAbiOld, input, { encoding: this.encoding });\n        const [decodedValue, decodedValueByteSize] = coder.decode(bytes, obj.offset);\n\n        return {\n          decoded: [...obj.decoded, decodedValue],\n          offset: obj.offset + decodedValueByteSize,\n        };\n      },\n      { decoded: [], offset: 0 }\n    );\n\n    return result.decoded;\n  }\n\n  decodeOutput(data: BytesLike): [DecodedValue | undefined, number] {\n    const bytes = arrayify(data);\n    const coder = AbiCoder.getCoder(this.jsonAbiOld, this.jsonFnOld.output, {\n      encoding: this.encoding,\n    });\n\n    return coder.decode(bytes, 0) as [DecodedValue | undefined, number];\n  }\n\n  /**\n   * Checks if the function is read-only i.e. it only reads from storage, does not write to it.\n   *\n   * @returns True if the function is read-only or pure, false otherwise.\n   */\n  isReadOnly(): boolean {\n    const storageAttribute = this.attributes.find((attr) => attr.name === 'storage');\n    return !storageAttribute?.arguments?.includes('write');\n  }\n}\n","import type { JsonAbiOld, JsonAbiArgument } from '../types/JsonAbi';\n\nimport { optionRegEx, VOID_TYPE } from './constants';\nimport { findTypeById } from './json-abi';\n\nexport type FunctionInput<TArg extends JsonAbiArgument = JsonAbiArgument> = TArg & {\n  isOptional: boolean;\n};\n\nexport const getFunctionInputs = (params: {\n  jsonAbi: JsonAbiOld;\n  inputs: readonly JsonAbiArgument[];\n}): Array<FunctionInput> => {\n  const { jsonAbi, inputs } = params;\n  let isMandatory = false;\n\n  return inputs.reduceRight((result, input) => {\n    const type = findTypeById(jsonAbi, input.type);\n    isMandatory = isMandatory || (type.type !== VOID_TYPE && !optionRegEx.test(type.type));\n    return [{ ...input, isOptional: !isMandatory }, ...result];\n  }, [] as FunctionInput[]);\n};\n","import type { InputValue } from '../encoding/coders/AbstractCoder';\n\nexport const padValuesWithUndefined = (values: InputValue[], inputs: ArrayLike<unknown>) => {\n  if (values.length >= inputs.length) {\n    return values;\n  }\n\n  const paddedValues = values.slice();\n  paddedValues.length = inputs.length;\n  paddedValues.fill(undefined, values.length);\n  return paddedValues;\n};\n","/* eslint-disable no-restricted-globals */\n/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-use-before-define */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nconst findTypeByConcreteId = (types, id) => types.find((x) => x.concreteTypeId === id);\n\nconst findConcreteTypeById = (abi, id) => abi.concreteTypes.find((x) => x.concreteTypeId === id);\n\nfunction finsertTypeIdByConcreteTypeId(abi, types, id) {\n  const concreteType = findConcreteTypeById(abi, id);\n\n  if (concreteType.metadataTypeId !== undefined) {\n    return concreteType.metadataTypeId;\n  }\n\n  const type = findTypeByConcreteId(types, id);\n  if (type) {\n    return type.typeId;\n  }\n\n  types.push({\n    typeId: types.length,\n    type: concreteType.type,\n    components: parseComponents(concreteType.components),\n    concreteTypeId: id,\n    typeParameters: concreteType.typeParameters ?? null,\n    originalConcreteTypeId: concreteType?.concreteTypeId,\n  });\n\n  return types.length - 1;\n}\n\nfunction parseFunctionTypeArguments(abi, types, concreteType) {\n  return (\n    concreteType.typeArguments?.map((cTypeId) => {\n      const self = findConcreteTypeById(abi, cTypeId);\n      const type = !isNaN(cTypeId) ? cTypeId : finsertTypeIdByConcreteTypeId(abi, types, cTypeId);\n      return {\n        name: '',\n        type,\n        // originalTypeId: cTypeId,\n        typeArguments: parseFunctionTypeArguments(abi, types, self),\n      };\n    }) ?? null\n  );\n}\n\nexport function parseConcreteType(abi, types, concreteTypeId, name) {\n  const type = finsertTypeIdByConcreteTypeId(abi, types, concreteTypeId);\n  const concrete = findConcreteTypeById(abi, concreteTypeId);\n  return {\n    name: name ?? '',\n    type,\n    // concreteTypeId,\n    typeArguments: parseFunctionTypeArguments(abi, types, concrete),\n  };\n}\n\nfunction parseComponents(abi, types, components) {\n  return (\n    components?.map((component) => {\n      const { typeId, name, typeArguments } = component;\n      const type = !isNaN(typeId) ? typeId : finsertTypeIdByConcreteTypeId(abi, types, typeId);\n      return {\n        name,\n        type,\n        // originalTypeId: typeId,\n        typeArguments: parseComponents(abi, types, typeArguments),\n      };\n    }) ?? null\n  );\n}\n\n/**\n * This will transpile new ABIs (spec: \"1\") to the old format.\n *\n * The new format got these new props:\n *    - `specVersion`,\n *    - `concreteTypes`\n *    - `metadataTypes`\n *\n * The old format contains only:\n *    - `types`\n */\nexport function transpileAbi(abi) {\n  // do not transpile older versions\n  if (!abi.specVersion) {\n    return abi;\n  }\n\n  // 0. define empty types array\n  const types = [];\n\n  // 1. root level of metadata types\n  abi.metadataTypes.forEach((m) => {\n    const t = {\n      typeId: m.metadataTypeId,\n      type: m.type,\n      components: m.components ?? (m.type === '()' ? [] : null),\n      typeParameters: m.typeParameters ?? null,\n    };\n    types.push(t);\n  });\n\n  // 2. the metadata's components\n  types.forEach((t) => {\n    t.components = parseComponents(abi, types, t.components);\n  });\n\n  // 3. functions inputs/outputs\n  const functions = abi.functions.map((fn) => {\n    const inputs = fn.inputs.map(({ concreteTypeId, name }) =>\n      parseConcreteType(abi, types, concreteTypeId, name)\n    );\n    const output = parseConcreteType(abi, types, fn.output, '');\n    return { ...fn, inputs, output };\n  });\n\n  // 4. configurables\n  const configurables = abi.configurables.map((conf) => ({\n    name: conf.name,\n    configurableType: parseConcreteType(abi, types, conf.concreteTypeId),\n    offset: conf.offset,\n  }));\n\n  // 5. loggedTypes\n  const loggedTypes = abi.loggedTypes.map((log) => ({\n    logId: log.logId,\n    loggedType: parseConcreteType(abi, types, log.concreteTypeId),\n  }));\n\n  // transpiled ABI\n  const transpiled = {\n    encoding: abi.encodingVersion,\n    types,\n    functions,\n    loggedTypes,\n    messagesTypes: abi.messagesTypes,\n    configurables,\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return transpiled as any;\n}\n"],"mappings":"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","names":["import_errors","import_utils","import_errors","import_math","import_utils","import_errors","import_math","import_errors","import_math","import_errors","import_math","import_errors","import_math","import_utils","import_errors","import_math","import_errors","import_math","import_errors","import_math","import_utils","import_errors","import_math","import_utils","import_errors","import_utils","import_errors","import_utils","import_errors","import_utils","import_errors","import_math","import_utils","import_errors","import_utils","import_errors","import_errors","import_errors","import_errors","getCoder","import_errors","import_math","import_utils"]}