import type { BytesLike } from '@fuel-ts/utils';
import type { DecodedValue, InputValue } from './encoding/coders/AbstractCoder';
import type { JsonAbiOld } from './types/JsonAbi';
import type { AbiFunction, AbiFunctionAttribute } from './types/JsonAbiNew';
import type { EncodingVersion } from './utils/constants';
export declare class FunctionFragment {
    readonly signature: string;
    readonly selector: string;
    readonly selectorBytes: Uint8Array;
    readonly encoding: EncodingVersion;
    readonly name: string;
    readonly jsonFn: AbiFunction;
    readonly attributes: readonly AbiFunctionAttribute[];
    private readonly jsonAbiOld;
    private readonly jsonFnOld;
    constructor(jsonAbi: JsonAbiOld, fn: AbiFunction);
    private static getSignature;
    private static getFunctionSelector;
    encodeArguments(values: InputValue[]): Uint8Array;
    decodeArguments(data: BytesLike): unknown[] | undefined;
    decodeOutput(data: BytesLike): [DecodedValue | undefined, number];
    /**
     * Checks if the function is read-only i.e. it only reads from storage, does not write to it.
     *
     * @returns True if the function is read-only or pure, false otherwise.
     */
    isReadOnly(): boolean;
}
//# sourceMappingURL=FunctionFragment.d.ts.map