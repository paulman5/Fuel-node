{"version":3,"sources":["../src/address.ts","../src/utils.ts"],"sourcesContent":["import { FuelError } from '@fuel-ts/errors';\nimport { arrayify, hexlify } from '@fuel-ts/utils';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport type { B256Address, EvmAddress, AssetId, ChecksumAddress } from './types';\nimport {\n  getRandomB256,\n  isPublicKey,\n  isB256,\n  isEvmAddress,\n  padFirst12BytesOfEvmAddress,\n  toB256AddressEvm,\n  normalizeB256,\n} from './utils';\n\n/**\n * `Address` provides a type safe wrapper for converting between different address formats\n * ands comparing them for equality.\n */\nexport class Address {\n  // #region address-2\n  readonly b256Address: B256Address;\n  // #endregion address-2\n\n  /**\n   * @param address - A B256 address\n   */\n  constructor(address: B256Address) {\n    if (!isB256(address)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_B256_ADDRESS,\n        `Invalid B256 Address: ${address}.`\n      );\n    }\n\n    this.b256Address = normalizeB256(address);\n  }\n\n  /**\n   * Takes an B256 Address and returns back an checksum address.\n   * The implementation follows the ERC-55 https://github.com/ethereum/ercs/blob/master/ERCS/erc-55.md.\n   *\n   * @returns A new `ChecksumAddress` instance\n   */\n  toChecksum(): ChecksumAddress {\n    return Address.toChecksum(this.b256Address);\n  }\n\n  /**\n   * Returns the `b256Address` property\n   */\n  toAddress(): B256Address {\n    return this.b256Address;\n  }\n\n  /**\n   * Returns the B256 hash address as a string\n   *\n   * @returns The B256 address\n   */\n  toB256(): B256Address {\n    return this.b256Address;\n  }\n\n  /**\n   * Returns the B256 hash address as a Uint8Array\n   *\n   * @returns The B256 address as a Uint8Array\n   */\n  toBytes(): Uint8Array {\n    return arrayify(this.b256Address);\n  }\n\n  /**\n   * Returns the B256 hash address as a string\n   *\n   * @returns The B256 address\n   */\n  toHexString(): B256Address {\n    return this.toB256();\n  }\n\n  /**\n   * returns the address `checksum` as a string\n   *\n   * @returns The `b256Address` property as a string\n   */\n  toString(): string {\n    return this.toChecksum();\n  }\n\n  /**\n   * Converts and returns the `b256Address` property as a string\n   * @returns The `b256Address` property as a JSON string\n   */\n  toJSON(): string {\n    return this.b256Address;\n  }\n\n  /**\n   * Converts to an EVM address\n   *\n   * @returns an {@link EvmAddress | `EvmAddress`} representation of the address\n   */\n  toEvmAddress(): EvmAddress {\n    return {\n      bits: toB256AddressEvm(this.b256Address),\n    } as EvmAddress;\n  }\n\n  /**\n   * Wraps the B256 property and returns as an `AssetId`.\n   * @returns The B256 property as an {@link AssetId | `AssetId`}\n   */\n  toAssetId(): AssetId {\n    return {\n      bits: this.b256Address,\n    } as AssetId;\n  }\n\n  /**\n   * Wraps the B256 address `checksum` and returns it as a string\n   * @returns The B256 address `checksum` as a string\n   */\n  valueOf(): string {\n    return this.toChecksum();\n  }\n\n  /**\n   * Compares this the `b256Address` property to another for direct equality\n   * @param other - Another address to compare against\n   * @returns The equality of the comparison\n   */\n  equals(other: Address): boolean {\n    return this.toChecksum() === other.toChecksum();\n  }\n\n  /**\n   * Takes a Public Key, hashes it, and creates an `Address`\n   *\n   * @param publicKey - A wallets public key\n   * @returns A new `Address` instance\n   */\n  static fromPublicKey(publicKey: string): Address {\n    if (!isPublicKey(publicKey)) {\n      throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);\n    }\n\n    const b256Address = hexlify(sha256(arrayify(publicKey)));\n    return new Address(b256Address);\n  }\n\n  /**\n   * Takes a B256 Address and creates an `Address`\n   *\n   * @param b256Address - A b256 hash\n   * @returns A new `Address` instance\n   */\n  static fromB256(b256Address: string): Address {\n    if (!isB256(b256Address)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_B256_ADDRESS,\n        `Invalid B256 Address: ${b256Address}.`\n      );\n    }\n\n    return new Address(b256Address);\n  }\n\n  /**\n   * Creates an `Address` with a randomized `b256Address` property\n   *\n   * @returns A new `Address` instance\n   */\n  static fromRandom(): Address {\n    return this.fromB256(getRandomB256());\n  }\n\n  /**\n   * Takes an ambiguous string and attempts to create an `Address`\n   *\n   * @param address - An ambiguous string\n   * @returns A new `Address` instance\n   */\n  static fromString(address: string): Address {\n    return this.fromB256(address);\n  }\n\n  /**\n   * Takes an ambiguous string or address and creates an `Address`\n   *\n   * @returns a new `Address` instance\n   */\n  static fromAddressOrString(address: string | Address): Address {\n    return typeof address === 'string' ? this.fromString(address) : address;\n  }\n\n  /**\n   * Takes a dynamic string or `Address` and creates an `Address`\n   *\n   * @param addressId - A string containing B256, or Public Key\n   * @throws Error - Unknown address if the format is not recognised\n   * @returns A new `Address` instance\n   */\n  static fromDynamicInput(address: string | Address): Address {\n    // If address is a object than we assume it's a Address\n    // we don't check by instanceof because it's possible to\n    // the host app to have a different reference to this same class type\n    if (typeof address !== 'string' && 'toB256' in address) {\n      return Address.fromB256(address.toB256());\n    }\n    if (isPublicKey(address)) {\n      return Address.fromPublicKey(address);\n    }\n\n    if (isB256(address)) {\n      return Address.fromB256(address);\n    }\n\n    if (isEvmAddress(address)) {\n      return Address.fromEvmAddress(address);\n    }\n\n    throw new FuelError(\n      FuelError.CODES.PARSE_FAILED,\n      `Unknown address format: only 'B256', or 'Public Key (512)' are supported.`\n    );\n  }\n\n  /**\n   * Takes an Evm Address and returns back an `Address`\n   *\n   * @returns A new `Address` instance\n   */\n  static fromEvmAddress(evmAddress: string): Address {\n    if (!isEvmAddress(evmAddress)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_EVM_ADDRESS,\n        `Invalid Evm Address: ${evmAddress}.`\n      );\n    }\n\n    const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);\n    return new Address(paddedAddress);\n  }\n\n  /**\n   * Takes an ChecksumAddress and validates if it is a valid checksum address.\n   *\n   * @returns A `boolean` instance indicating if the address is valid.\n   */\n  static isChecksumValid(address: ChecksumAddress): boolean {\n    let addressParsed = address;\n\n    if (!address.startsWith('0x')) {\n      addressParsed = `0x${address}`;\n    }\n    if (addressParsed.trim().length !== 66) {\n      return false;\n    }\n\n    return Address.toChecksum(hexlify(addressParsed)) === addressParsed;\n  }\n\n  /** @hidden */\n  private static toChecksum(address: string) {\n    if (!isB256(address)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_B256_ADDRESS,\n        `Invalid B256 Address: ${address}.`\n      );\n    }\n\n    const addressHex = hexlify(address).toLowerCase().slice(2);\n    const checksum = sha256(addressHex);\n\n    let ret = '0x';\n    for (let i = 0; i < 32; ++i) {\n      const byte = checksum[i];\n      const ha = addressHex.charAt(i * 2);\n      const hb = addressHex.charAt(i * 2 + 1);\n      ret += (byte & 0xf0) >= 0x80 ? ha.toUpperCase() : ha;\n      ret += (byte & 0x0f) >= 0x08 ? hb.toUpperCase() : hb;\n    }\n\n    return ret;\n  }\n}\n","import { randomBytes } from '@fuel-ts/crypto';\nimport { FuelError } from '@fuel-ts/errors';\nimport { arrayify, concat, hexlify } from '@fuel-ts/utils';\n\nimport type { Address } from './address';\nimport type { AddressLike, ContractIdLike, B256Address, B256AddressEvm } from './types';\n\n/**\n * Determines if a given string is B256 format\n *\n * @hidden\n */\nexport function isB256(address: string): boolean {\n  return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);\n}\n\n/**\n * Determines if a given string is in Public Key format (512 bits)\n *\n * @hidden\n */\nexport function isPublicKey(address: string): boolean {\n  return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);\n}\n\n/**\n * Determines if a given string is in EVM Address format\n *\n * @hidden\n */\nexport function isEvmAddress(address: string): boolean {\n  return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);\n}\n\nexport function normalizeB256(address: B256Address): B256Address {\n  return address.toLowerCase();\n}\n\n/**\n * A simple type guard to check if an object is an Address\n *\n * @hidden\n */\nexport function isAddress(address: object): address is Address {\n  return 'b256Address' in address;\n}\n\n/**\n * Takes an indeterminate address type and returns an address\n *\n * @hidden\n */\nexport const addressify = (addressLike: AddressLike | ContractIdLike): Address => {\n  if (isAddress(addressLike)) {\n    return addressLike;\n  }\n\n  if ('address' in addressLike && isAddress(addressLike.address)) {\n    return addressLike.address;\n  }\n\n  if ('id' in addressLike && isAddress(addressLike.id)) {\n    return addressLike.id;\n  }\n\n  throw new FuelError(FuelError.CODES.INVALID_ADDRESS, 'Invalid address');\n};\n\n/**\n * @hidden\n */\nexport const getRandomB256 = () => hexlify(randomBytes(32));\n\n/**\n * Takes a B256 address and clears the first 12 bytes, this is required for an EVM Address\n *\n * @param b256 - the address to clear\n * @returns b256 with first 12 bytes cleared\n *\n * @hidden\n */\nexport const toB256AddressEvm = (b256: B256Address): B256AddressEvm => {\n  try {\n    if (!isB256(b256)) {\n      throw new FuelError(FuelError.CODES.INVALID_B256_ADDRESS, `Invalid B256 Address: ${b256}.`);\n    }\n\n    const evmBytes = arrayify(b256).slice(12);\n    const paddedBytes = new Uint8Array(12).fill(0);\n    return hexlify(concat([paddedBytes, evmBytes])) as B256AddressEvm;\n  } catch (error) {\n    throw new FuelError(\n      FuelError.CODES.PARSE_FAILED,\n      `Cannot generate EVM Address B256 from: ${b256}.`\n    );\n  }\n};\n\n/**\n * Pads the first 12 bytes of an Evm address. This is useful for padding addresses returned from\n * the EVM to interact with the Sway EVM Address Type.\n *\n * @param address - Evm address to be padded\n * @returns Evm address padded to a b256 address\n *\n * @hidden\n */\nexport const padFirst12BytesOfEvmAddress = (address: string): B256AddressEvm => {\n  if (!isEvmAddress(address)) {\n    throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, 'Invalid EVM address format.');\n  }\n\n  return address.replace('0x', '0x000000000000000000000000') as B256AddressEvm;\n};\n"],"mappings":"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","names":["FuelError","arrayify","hexlify","FuelError","arrayify","hexlify"]}