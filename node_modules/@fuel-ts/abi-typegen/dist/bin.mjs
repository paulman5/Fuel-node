var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/cli.ts
import { versions as builtinVersion } from "@fuel-ts/versions";
import { Command, Option } from "commander";

// src/runTypegen.ts
import { ErrorCode as ErrorCode9, FuelError as FuelError9 } from "@fuel-ts/errors";
import { versions as builtinVersions } from "@fuel-ts/versions";
import { readFileSync as readFileSync3, writeFileSync } from "fs";
import { globSync } from "glob";
import { mkdirp } from "mkdirp";
import { basename } from "path";
import { rimrafSync } from "rimraf";

// src/AbiTypeGen.ts
import { ErrorCode as ErrorCode8, FuelError as FuelError8 } from "@fuel-ts/errors";

// src/abi/Abi.ts
import { ErrorCode as ErrorCode4, FuelError as FuelError4 } from "@fuel-ts/errors";
import { normalizeString } from "@fuel-ts/utils";

// src/abi/types/AType.ts
var AType = class {
  rawAbiType;
  attributes;
  requiredFuelsMembersImports;
  constructor(params) {
    this.rawAbiType = params.rawAbiType;
    this.attributes = {
      inputLabel: "unknown",
      outputLabel: "unknown"
    };
    this.requiredFuelsMembersImports = [];
  }
};

// src/abi/types/EmptyType.ts
var _EmptyType = class extends AType {
  name = "empty";
  constructor(params) {
    super(params);
    this.attributes = {
      inputLabel: "undefined",
      outputLabel: "void"
    };
  }
  static isSuitableFor(params) {
    return _EmptyType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    return this.attributes;
  }
};
var EmptyType = _EmptyType;
__publicField(EmptyType, "swayType", "()");
__publicField(EmptyType, "MATCH_REGEX", /^\(\)$/m);

// src/abi/types/OptionType.ts
var _OptionType = class extends AType {
  name = "option";
  static isSuitableFor(params) {
    return _OptionType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    this.attributes = {
      inputLabel: `Option`,
      outputLabel: `Option`
    };
    return this.attributes;
  }
};
var OptionType = _OptionType;
__publicField(OptionType, "swayType", "enum Option");
__publicField(OptionType, "MATCH_REGEX", /^enum (std::option::)?Option$/m);

// src/utils/findType.ts
import { ErrorCode, FuelError } from "@fuel-ts/errors";
function findType(params) {
  const { types, typeId } = params;
  const foundType = types.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
  if (!foundType) {
    throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
  }
  foundType.parseComponentsAttributes({ types });
  return foundType;
}

// src/utils/getFunctionInputs.ts
var getFunctionInputs = (params) => {
  const { types, inputs } = params;
  let isMandatory = false;
  return inputs.reduceRight((result, input) => {
    const type = findType({ types, typeId: input.type });
    const isTypeMandatory = !EmptyType.isSuitableFor({ type: type.rawAbiType.type }) && !OptionType.isSuitableFor({ type: type.rawAbiType.type });
    isMandatory = isMandatory || isTypeMandatory;
    return [{ ...input, isOptional: !isMandatory }, ...result];
  }, []);
};

// src/utils/parseTypeArguments.ts
function parseTypeArguments(params) {
  const { types, typeArguments, parentTypeId, target } = params;
  const attributeKey = `${target}Label`;
  const buffer = [];
  let parentType;
  let parentLabel;
  if (parentTypeId !== void 0) {
    parentType = findType({ types, typeId: parentTypeId });
    parentLabel = parentType.attributes[attributeKey];
  }
  typeArguments.forEach((typeArgument) => {
    const currentTypeId = typeArgument.type;
    const currentType = findType({ types, typeId: currentTypeId });
    const currentLabel = currentType.attributes[attributeKey];
    if (typeArgument.typeArguments) {
      const nestedParsed = parseTypeArguments({
        types,
        target,
        parentTypeId: typeArgument.type,
        typeArguments: typeArgument.typeArguments
      });
      buffer.push(nestedParsed);
    } else {
      buffer.push(`${currentLabel}`);
    }
  });
  let output = buffer.join(", ");
  if (parentLabel) {
    output = `${parentLabel}<${output}>`;
  }
  return output;
}

// src/utils/getTypeDeclaration.ts
function resolveInputLabel(types, typeId, typeArguments) {
  const type = findType({ types, typeId });
  let typeDecl;
  if (typeArguments?.length) {
    typeDecl = parseTypeArguments({
      types,
      target: "input" /* INPUT */,
      parentTypeId: typeId,
      typeArguments
    });
  } else {
    typeDecl = type.attributes.inputLabel;
  }
  return typeDecl;
}

// src/abi/functions/Function.ts
var Function = class {
  name;
  types;
  rawAbiFunction;
  attributes;
  constructor(params) {
    this.rawAbiFunction = params.rawAbiFunction;
    this.types = params.types;
    this.name = params.rawAbiFunction.name;
    this.attributes = {
      inputs: this.bundleInputTypes(),
      output: this.bundleOutputTypes(),
      prefixedInputs: this.bundleInputTypes(true)
    };
  }
  bundleInputTypes(shouldPrefixParams = false) {
    const { types } = this;
    const inputs = getFunctionInputs({ types, inputs: this.rawAbiFunction.inputs }).map(
      ({ isOptional, ...input }) => {
        const { name, type: typeId, typeArguments } = input;
        const typeDecl = resolveInputLabel(types, typeId, typeArguments);
        if (shouldPrefixParams) {
          const optionalSuffix = isOptional ? "?" : "";
          return `${name}${optionalSuffix}: ${typeDecl}`;
        }
        return typeDecl;
      }
    );
    return inputs.join(", ");
  }
  bundleOutputTypes() {
    return parseTypeArguments({
      types: this.types,
      target: "output" /* OUTPUT */,
      typeArguments: [this.rawAbiFunction.output]
    });
  }
  getDeclaration() {
    const { name } = this;
    const { prefixedInputs, output } = this.attributes;
    const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output}>`;
    return decl;
  }
};

// src/utils/makeFunction.ts
function makeFunction(params) {
  const { types, rawAbiFunction } = params;
  return new Function({ types, rawAbiFunction });
}

// src/utils/parseFunctions.ts
function parseFunctions(params) {
  const { types, rawAbiFunctions } = params;
  const functions = rawAbiFunctions.map(
    (rawAbiFunction) => makeFunction({ types, rawAbiFunction })
  );
  return functions;
}

// src/utils/makeType.ts
import { ErrorCode as ErrorCode3, FuelError as FuelError3 } from "@fuel-ts/errors";

// src/abi/types/ArrayType.ts
var _ArrayType = class extends AType {
  name = "array";
  static isSuitableFor(params) {
    return _ArrayType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(params) {
    const { types } = params;
    const { type } = this.rawAbiType;
    const arrayLen = Number(type.match(_ArrayType.MATCH_REGEX)?.[1]);
    const inputs = [];
    const outputs = [];
    this.rawAbiType.components?.forEach((component) => {
      const { type: typeId, typeArguments } = component;
      if (!typeArguments) {
        const { attributes } = findType({ types, typeId });
        inputs.push(attributes.inputLabel);
        outputs.push(attributes.outputLabel);
      } else {
        const inputLabel = parseTypeArguments({
          types,
          typeArguments,
          parentTypeId: typeId,
          target: "input" /* INPUT */
        });
        const outputLabel = parseTypeArguments({
          types,
          typeArguments,
          parentTypeId: typeId,
          target: "output" /* OUTPUT */
        });
        inputs.push(inputLabel);
        outputs.push(outputLabel);
      }
    });
    const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
    const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
    this.attributes = {
      inputLabel: `[${inputTypes}]`,
      outputLabel: `[${outputTypes}]`
    };
    return this.attributes;
  }
};
var ArrayType = _ArrayType;
// Note: the array length expressed in '; 2]' could be any length
__publicField(ArrayType, "swayType", "[_; 2]");
__publicField(ArrayType, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);

// src/abi/types/StrType.ts
var _StrType = class extends AType {
  name = "str";
  static isSuitableFor(params) {
    return _StrType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    this.attributes = {
      inputLabel: "string",
      outputLabel: "string"
    };
    return this.attributes;
  }
};
var StrType = _StrType;
// Note: the str length expressed in '[3]' could be any length
__publicField(StrType, "swayType", "str[3]");
__publicField(StrType, "MATCH_REGEX", /^str\[(.+)\]$/m);

// src/abi/types/B256Type.ts
var _B256Type = class extends StrType {
  name = "b256";
  static isSuitableFor(params) {
    return _B256Type.MATCH_REGEX.test(params.type);
  }
};
var B256Type = _B256Type;
__publicField(B256Type, "swayType", "b256");
__publicField(B256Type, "MATCH_REGEX", /^b256$/m);

// src/abi/types/B512Type.ts
var _B512Type = class extends B256Type {
  name = "b512";
  static isSuitableFor(params) {
    return _B512Type.MATCH_REGEX.test(params.type);
  }
};
var B512Type = _B512Type;
__publicField(B512Type, "swayType", "struct B512");
__publicField(B512Type, "MATCH_REGEX", /^struct (std::b512::)?B512$/m);

// src/abi/types/BoolType.ts
var _BoolType = class extends AType {
  name = "bool";
  static isSuitableFor(params) {
    return _BoolType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    this.attributes = {
      inputLabel: "boolean",
      outputLabel: "boolean"
    };
    return this.attributes;
  }
};
var BoolType = _BoolType;
__publicField(BoolType, "swayType", "bool");
__publicField(BoolType, "MATCH_REGEX", /^bool$/m);

// src/abi/types/BytesType.ts
var _BytesType = class extends ArrayType {
  name = "bytes";
  static isSuitableFor(params) {
    return _BytesType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    const capitalizedName = "Bytes";
    this.attributes = {
      inputLabel: capitalizedName,
      outputLabel: capitalizedName
    };
    this.requiredFuelsMembersImports = [capitalizedName];
    return this.attributes;
  }
};
var BytesType = _BytesType;
__publicField(BytesType, "swayType", "struct Bytes");
__publicField(BytesType, "MATCH_REGEX", /^struct (std::bytes::)?Bytes/m);

// src/utils/extractStructName.ts
import { ErrorCode as ErrorCode2, FuelError as FuelError2 } from "@fuel-ts/errors";
function extractStructName(params) {
  const { rawAbiType, regex } = params;
  const matches = rawAbiType.type.match(regex);
  const match = matches?.[2] ?? matches?.[1];
  if (!match) {
    let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
    errorMessage += `Check your JSON ABI.

[source]
`;
    errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
    throw new FuelError2(ErrorCode2.JSON_ABI_ERROR, errorMessage);
  }
  return match;
}

// src/abi/types/ResultType.ts
var _ResultType = class extends AType {
  name = "result";
  static isSuitableFor(params) {
    return _ResultType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    this.attributes = {
      inputLabel: `Result`,
      outputLabel: `Result`
    };
    return this.attributes;
  }
};
var ResultType = _ResultType;
__publicField(ResultType, "swayType", "enum Result");
__publicField(ResultType, "MATCH_REGEX", /^enum (std::result::)?Result$/m);

// src/abi/types/EnumType.ts
var _EnumType = class extends AType {
  name = "enum";
  static isSuitableFor(params) {
    const isAMatch = _EnumType.MATCH_REGEX.test(params.type);
    const shouldBeIgnored = _EnumType.IGNORE_REGEXES.some((r) => r.test(params.type));
    return isAMatch && !shouldBeIgnored;
  }
  parseComponentsAttributes(_params) {
    const structName = this.getStructName();
    this.attributes = {
      structName,
      inputLabel: `${structName}Input`,
      outputLabel: `${structName}Output`
    };
    return this.attributes;
  }
  getStructName() {
    const name = extractStructName({
      rawAbiType: this.rawAbiType,
      regex: _EnumType.MATCH_REGEX
    });
    return name;
  }
  getNativeEnum(params) {
    const { types } = params;
    const typeHash = types.reduce(
      (hash, row) => ({
        ...hash,
        [row.rawAbiType.typeId]: row.rawAbiType.type
      }),
      {}
    );
    const { components } = this.rawAbiType;
    const enumComponents = components;
    if (!enumComponents.every(({ type }) => typeHash[type] === EmptyType.swayType)) {
      return void 0;
    }
    return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
  }
  getStructContents(params) {
    const { types, target } = params;
    const { components } = this.rawAbiType;
    const enumComponents = components;
    const attributeKey = `${target}Label`;
    const contents = enumComponents.map((component) => {
      const { name, type: typeId, typeArguments } = component;
      if (typeId === 0) {
        return `${name}: []`;
      }
      const type = findType({ types, typeId });
      let typeDecl;
      if (typeArguments) {
        typeDecl = parseTypeArguments({
          types,
          target,
          parentTypeId: typeId,
          typeArguments
        });
      } else {
        typeDecl = type.attributes[attributeKey];
      }
      return `${name}: ${typeDecl}`;
    });
    return contents.join(", ");
  }
  getStructDeclaration(params) {
    const { types } = params;
    const { typeParameters } = this.rawAbiType;
    if (typeParameters) {
      const structs = typeParameters.map((typeId) => findType({ types, typeId }));
      const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
      return `<${labels.join(", ")}>`;
    }
    return "";
  }
};
var EnumType = _EnumType;
__publicField(EnumType, "swayType", "enum MyEnumName");
__publicField(EnumType, "MATCH_REGEX", /^enum (.+::)?(.+)$/m);
__publicField(EnumType, "IGNORE_REGEXES", [OptionType.MATCH_REGEX, ResultType.MATCH_REGEX]);

// src/abi/types/EvmAddressType.ts
var _EvmAddressType = class extends AType {
  name = "evmAddress";
  static isSuitableFor(params) {
    return _EvmAddressType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    const capitalizedName = "EvmAddress";
    this.attributes = {
      inputLabel: capitalizedName,
      outputLabel: capitalizedName
    };
    this.requiredFuelsMembersImports = [capitalizedName];
    return this.attributes;
  }
};
var EvmAddressType = _EvmAddressType;
__publicField(EvmAddressType, "swayType", "struct EvmAddress");
__publicField(EvmAddressType, "MATCH_REGEX", /^struct (std::vm::evm::evm_address::)?EvmAddress$/m);

// src/abi/types/GenericType.ts
var _GenericType = class extends AType {
  name = "generic";
  static isSuitableFor(params) {
    return _GenericType.MATCH_REGEX.test(params.type);
  }
  getStructName() {
    const name = extractStructName({
      rawAbiType: this.rawAbiType,
      regex: _GenericType.MATCH_REGEX
    });
    return name;
  }
  parseComponentsAttributes(_params) {
    const label = this.getStructName();
    this.attributes = {
      inputLabel: label,
      outputLabel: label
    };
    return this.attributes;
  }
};
var GenericType = _GenericType;
__publicField(GenericType, "swayType", "generic T");
__publicField(GenericType, "MATCH_REGEX", /^generic ([^\s]+)$/m);

// src/abi/types/U8Type.ts
var _U8Type = class extends AType {
  name = "u8";
  constructor(params) {
    super(params);
    this.attributes = {
      inputLabel: `BigNumberish`,
      outputLabel: `number`
    };
    this.requiredFuelsMembersImports = [this.attributes.inputLabel];
  }
  static isSuitableFor(params) {
    return _U8Type.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    return this.attributes;
  }
};
var U8Type = _U8Type;
__publicField(U8Type, "swayType", "u8");
__publicField(U8Type, "MATCH_REGEX", /^u8$/m);

// src/abi/types/U64Type.ts
var _U64Type = class extends U8Type {
  name = "u64";
  parseComponentsAttributes(_params) {
    this.attributes = {
      inputLabel: `BigNumberish`,
      outputLabel: `BN`
    };
    this.requiredFuelsMembersImports = Object.values(this.attributes);
    return this.attributes;
  }
  static isSuitableFor(params) {
    return _U64Type.MATCH_REGEX.test(params.type);
  }
};
var U64Type = _U64Type;
__publicField(U64Type, "swayType", "u64");
__publicField(U64Type, "MATCH_REGEX", /^u64$/m);

// src/abi/types/RawUntypedPtr.ts
var _RawUntypedPtr = class extends U64Type {
  name = "rawUntypedPtr";
  static isSuitableFor(params) {
    return _RawUntypedPtr.MATCH_REGEX.test(params.type);
  }
};
var RawUntypedPtr = _RawUntypedPtr;
__publicField(RawUntypedPtr, "swayType", "raw untyped ptr");
__publicField(RawUntypedPtr, "MATCH_REGEX", /^raw untyped ptr$/m);

// src/abi/types/RawUntypedSlice.ts
var _RawUntypedSlice = class extends ArrayType {
  name = "rawUntypedSlice";
  static isSuitableFor(params) {
    return _RawUntypedSlice.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    const capitalizedName = "RawSlice";
    this.attributes = {
      inputLabel: capitalizedName,
      outputLabel: capitalizedName
    };
    this.requiredFuelsMembersImports = [capitalizedName];
    return this.attributes;
  }
};
var RawUntypedSlice = _RawUntypedSlice;
__publicField(RawUntypedSlice, "swayType", "raw untyped slice");
__publicField(RawUntypedSlice, "MATCH_REGEX", /^raw untyped slice$/m);

// src/abi/types/StdStringType.ts
var _StdStringType = class extends AType {
  name = "stdString";
  static isSuitableFor(params) {
    return _StdStringType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    const capitalizedName = "StdString";
    this.attributes = {
      inputLabel: capitalizedName,
      outputLabel: capitalizedName
    };
    this.requiredFuelsMembersImports = [capitalizedName];
    return this.attributes;
  }
};
var StdStringType = _StdStringType;
__publicField(StdStringType, "swayType", "struct String");
__publicField(StdStringType, "MATCH_REGEX", /^struct (std::string::)?String/m);

// src/abi/types/StrSliceType.ts
var _StrSliceType = class extends AType {
  name = "strSlice";
  static isSuitableFor(params) {
    return _StrSliceType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(_params) {
    const capitalizedName = "StrSlice";
    this.attributes = {
      inputLabel: capitalizedName,
      outputLabel: capitalizedName
    };
    this.requiredFuelsMembersImports = [capitalizedName];
    return this.attributes;
  }
};
var StrSliceType = _StrSliceType;
__publicField(StrSliceType, "swayType", "str");
__publicField(StrSliceType, "MATCH_REGEX", /^str$/m);

// src/abi/types/StructType.ts
var _StructType = class extends AType {
  name = "struct";
  static isSuitableFor(params) {
    const isAMatch = _StructType.MATCH_REGEX.test(params.type);
    const shouldBeIgnored = _StructType.IGNORE_REGEX.test(params.type);
    return isAMatch && !shouldBeIgnored;
  }
  parseComponentsAttributes(_params) {
    const structName = this.getStructName();
    this.attributes = {
      structName,
      inputLabel: `${structName}Input`,
      outputLabel: `${structName}Output`
    };
    return this.attributes;
  }
  getStructName() {
    const name = extractStructName({
      rawAbiType: this.rawAbiType,
      regex: _StructType.MATCH_REGEX
    });
    return name;
  }
  getStructContents(params) {
    const { types, target } = params;
    const { components } = this.rawAbiType;
    const structComponents = components;
    const members = structComponents.map((component) => {
      const { name, type: typeId, typeArguments } = component;
      const type = findType({ types, typeId });
      let typeDecl;
      if (typeArguments) {
        typeDecl = parseTypeArguments({
          types,
          target,
          parentTypeId: typeId,
          typeArguments
        });
      } else {
        const attributeKey = `${target}Label`;
        typeDecl = type.attributes[attributeKey];
      }
      return `${name}: ${typeDecl}`;
    });
    return members.join(", ");
  }
  getStructDeclaration(params) {
    const { types } = params;
    const { typeParameters } = this.rawAbiType;
    if (typeParameters) {
      const structs = typeParameters.map((typeId) => findType({ types, typeId }));
      const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
      return `<${labels.join(", ")}>`;
    }
    return "";
  }
};
var StructType = _StructType;
__publicField(StructType, "swayType", "struct MyStruct");
__publicField(StructType, "MATCH_REGEX", /^struct (.+::)?(.+)$/m);
__publicField(StructType, "IGNORE_REGEX", /^struct (std::.*)?(Vec|RawVec|EvmAddress|Bytes|String|RawBytes)$/m);

// src/abi/types/TupleType.ts
var _TupleType = class extends AType {
  name = "tupple";
  static isSuitableFor(params) {
    return _TupleType.MATCH_REGEX.test(params.type);
  }
  parseComponentsAttributes(params) {
    const { types } = params;
    const inputs = [];
    const outputs = [];
    this.rawAbiType.components?.forEach((component) => {
      const { type: typeId, typeArguments } = component;
      if (!typeArguments) {
        const { attributes } = findType({ types, typeId });
        inputs.push(attributes.inputLabel);
        outputs.push(attributes.outputLabel);
      } else {
        const inputLabel = parseTypeArguments({
          types,
          typeArguments,
          parentTypeId: typeId,
          target: "input" /* INPUT */
        });
        const outputLabel = parseTypeArguments({
          types,
          typeArguments,
          parentTypeId: typeId,
          target: "output" /* OUTPUT */
        });
        inputs.push(inputLabel);
        outputs.push(outputLabel);
      }
    });
    this.attributes = {
      inputLabel: `[${inputs.join(", ")}]`,
      outputLabel: `[${outputs.join(", ")}]`
    };
    return this.attributes;
  }
};
var TupleType = _TupleType;
// Note: a tuple can have more/less than 3x items (like the one bellow)
__publicField(TupleType, "swayType", "(_, _, _)");
__publicField(TupleType, "MATCH_REGEX", /^\([_,\s]+\)$/m);

// src/abi/types/U16Type.ts
var _U16Type = class extends U8Type {
  name = "u16";
  static isSuitableFor(params) {
    return _U16Type.MATCH_REGEX.test(params.type);
  }
};
var U16Type = _U16Type;
__publicField(U16Type, "swayType", "u16");
__publicField(U16Type, "MATCH_REGEX", /^u16$/m);

// src/abi/types/U256Type.ts
var _U256Type = class extends U64Type {
  name = "u256";
  static isSuitableFor(params) {
    return _U256Type.MATCH_REGEX.test(params.type);
  }
};
var U256Type = _U256Type;
__publicField(U256Type, "swayType", "u256");
__publicField(U256Type, "MATCH_REGEX", /^u256$/m);

// src/abi/types/U32Type.ts
var _U32Type = class extends U8Type {
  name = "u32";
  static isSuitableFor(params) {
    return _U32Type.MATCH_REGEX.test(params.type);
  }
};
var U32Type = _U32Type;
__publicField(U32Type, "swayType", "u32");
__publicField(U32Type, "MATCH_REGEX", /^u32$/m);

// src/abi/types/VectorType.ts
var _VectorType = class extends ArrayType {
  name = "vector";
  static isSuitableFor(params) {
    const isAMatch = _VectorType.MATCH_REGEX.test(params.type);
    const shouldBeIgnored = _VectorType.IGNORE_REGEX.test(params.type);
    return isAMatch && !shouldBeIgnored;
  }
  parseComponentsAttributes(_params) {
    this.attributes = {
      inputLabel: `Vec`,
      outputLabel: `Vec`
    };
    return this.attributes;
  }
};
var VectorType = _VectorType;
__publicField(VectorType, "swayType", "struct Vec");
__publicField(VectorType, "MATCH_REGEX", /^struct (std::vec::)?Vec/m);
__publicField(VectorType, "IGNORE_REGEX", /^struct (std::vec::)?RawVec$/m);

// src/utils/supportedTypes.ts
var supportedTypes = [
  EmptyType,
  ArrayType,
  B256Type,
  B512Type,
  BoolType,
  BytesType,
  EnumType,
  GenericType,
  OptionType,
  RawUntypedPtr,
  RawUntypedSlice,
  StdStringType,
  StrType,
  StrSliceType,
  StructType,
  TupleType,
  U16Type,
  U32Type,
  U64Type,
  U256Type,
  U8Type,
  VectorType,
  EvmAddressType,
  ResultType
];

// src/utils/makeType.ts
function makeType(params) {
  const { rawAbiType } = params;
  const { type } = rawAbiType;
  const TypeClass = supportedTypes.find((tc) => tc.isSuitableFor({ type }));
  if (!TypeClass) {
    throw new FuelError3(ErrorCode3.TYPE_NOT_SUPPORTED, `Type not supported: ${type}`);
  }
  return new TypeClass(params);
}

// src/utils/shouldSkipAbiType.ts
function shouldSkipAbiType(params) {
  const ignoreList = [
    "struct RawVec",
    "struct std::vec::RawVec",
    "struct RawBytes",
    "struct std::bytes::RawBytes"
  ];
  const shouldSkip = ignoreList.indexOf(params.type) >= 0;
  return shouldSkip;
}

// src/utils/parseTypes.ts
function parseTypes(params) {
  const types = [];
  params.rawAbiTypes.forEach((rawAbiType) => {
    const { type } = rawAbiType;
    const skip = shouldSkipAbiType({ type });
    if (!skip) {
      const parsedType = makeType({ rawAbiType });
      types.push(parsedType);
    }
  });
  types.forEach((type) => {
    type.parseComponentsAttributes({ types });
  });
  return types;
}

// src/utils/transpile-abi.ts
var findTypeByConcreteId = (types, id) => types.find((x) => x.concreteTypeId === id);
var findConcreteTypeById = (abi, id) => abi.concreteTypes.find((x) => x.concreteTypeId === id);
function finsertTypeIdByConcreteTypeId(abi, types, id) {
  const concreteType = findConcreteTypeById(abi, id);
  if (concreteType.metadataTypeId !== void 0) {
    return concreteType.metadataTypeId;
  }
  const type = findTypeByConcreteId(types, id);
  if (type) {
    return type.typeId;
  }
  types.push({
    typeId: types.length,
    type: concreteType.type,
    components: parseComponents(concreteType.components),
    concreteTypeId: id,
    typeParameters: concreteType.typeParameters ?? null,
    originalConcreteTypeId: concreteType?.concreteTypeId
  });
  return types.length - 1;
}
function parseFunctionTypeArguments(abi, types, concreteType) {
  return concreteType.typeArguments?.map((cTypeId) => {
    const self = findConcreteTypeById(abi, cTypeId);
    const type = !isNaN(cTypeId) ? cTypeId : finsertTypeIdByConcreteTypeId(abi, types, cTypeId);
    return {
      name: "",
      type,
      // originalTypeId: cTypeId,
      typeArguments: parseFunctionTypeArguments(abi, types, self)
    };
  }) ?? null;
}
function parseConcreteType(abi, types, concreteTypeId, name) {
  const type = finsertTypeIdByConcreteTypeId(abi, types, concreteTypeId);
  const concrete = findConcreteTypeById(abi, concreteTypeId);
  return {
    name: name ?? "",
    type,
    // concreteTypeId,
    typeArguments: parseFunctionTypeArguments(abi, types, concrete)
  };
}
function parseComponents(abi, types, components) {
  return components?.map((component) => {
    const { typeId, name, typeArguments } = component;
    const type = !isNaN(typeId) ? typeId : finsertTypeIdByConcreteTypeId(abi, types, typeId);
    return {
      name,
      type,
      // originalTypeId: typeId,
      typeArguments: parseComponents(abi, types, typeArguments)
    };
  }) ?? null;
}
function transpileAbi(abi) {
  if (!abi.specVersion) {
    return abi;
  }
  const types = [];
  abi.metadataTypes.forEach((m) => {
    const t = {
      typeId: m.metadataTypeId,
      type: m.type,
      components: m.components ?? (m.type === "()" ? [] : null),
      typeParameters: m.typeParameters ?? null
    };
    types.push(t);
  });
  types.forEach((t) => {
    t.components = parseComponents(abi, types, t.components);
  });
  const functions = abi.functions.map((fn) => {
    const inputs = fn.inputs.map(
      ({ concreteTypeId, name }) => parseConcreteType(abi, types, concreteTypeId, name)
    );
    const output = parseConcreteType(abi, types, fn.output, "");
    return { ...fn, inputs, output };
  });
  const configurables = abi.configurables.map((conf) => ({
    name: conf.name,
    configurableType: parseConcreteType(abi, types, conf.concreteTypeId),
    offset: conf.offset
  }));
  const loggedTypes = abi.loggedTypes.map((log) => ({
    logId: log.logId,
    loggedType: parseConcreteType(abi, types, log.concreteTypeId)
  }));
  const transpiled = {
    encoding: abi.encodingVersion,
    types,
    functions,
    loggedTypes,
    messagesTypes: abi.messagesTypes,
    configurables
  };
  return transpiled;
}

// src/abi/configurable/Configurable.ts
var Configurable = class {
  name;
  inputLabel;
  constructor(params) {
    const {
      types,
      rawAbiConfigurable: {
        name,
        configurableType: { type, typeArguments }
      }
    } = params;
    this.name = name;
    this.inputLabel = resolveInputLabel(types, type, typeArguments);
  }
};

// src/abi/Abi.ts
var Abi = class {
  capitalizedName;
  camelizedName;
  programType;
  filepath;
  outputDir;
  commonTypesInUse = [];
  rawContents;
  hexlifiedBinContents;
  storageSlotsContents;
  types;
  functions;
  configurables;
  constructor(params) {
    const {
      filepath,
      outputDir,
      rawContents,
      hexlifiedBinContents,
      programType,
      storageSlotsContents
    } = params;
    const abiNameRegex = /([^/]+)-abi\.json$/m;
    const abiName = filepath.match(abiNameRegex);
    const couldNotParseName = !abiName || abiName.length === 0;
    if (couldNotParseName) {
      throw new FuelError4(
        ErrorCode4.PARSE_FAILED,
        `Could not parse name from ABI file: ${filepath}.`
      );
    }
    this.programType = programType;
    this.capitalizedName = `${normalizeString(abiName[1])}`;
    this.camelizedName = this.capitalizedName.replace(/^./m, (x) => x.toLowerCase());
    this.filepath = filepath;
    this.rawContents = rawContents;
    this.hexlifiedBinContents = hexlifiedBinContents;
    this.storageSlotsContents = storageSlotsContents;
    this.outputDir = outputDir;
    const { types, functions, configurables } = this.parse();
    this.types = types;
    this.functions = functions;
    this.configurables = configurables;
    this.computeCommonTypesInUse();
  }
  parse() {
    const transpiled = transpileAbi(this.rawContents);
    const {
      types: rawAbiTypes,
      functions: rawAbiFunctions,
      configurables: rawAbiConfigurables
    } = transpiled;
    const types = parseTypes({ rawAbiTypes });
    const functions = parseFunctions({ rawAbiFunctions, types });
    const configurables = rawAbiConfigurables.map(
      (rawAbiConfigurable) => new Configurable({ types, rawAbiConfigurable })
    );
    return {
      types,
      functions,
      configurables
    };
  }
  computeCommonTypesInUse() {
    const customTypesTable = {
      option: "Option",
      enum: "Enum",
      vector: "Vec",
      result: "Result"
    };
    this.commonTypesInUse = [];
    Object.keys(customTypesTable).forEach((typeName) => {
      const isInUse = !!this.types.find((t) => t.name === typeName);
      if (isInUse) {
        const commonTypeLabel = customTypesTable[typeName];
        this.commonTypesInUse.push(commonTypeLabel);
      }
    });
  }
};

// src/types/enums/ProgramTypeEnum.ts
var ProgramTypeEnum = /* @__PURE__ */ ((ProgramTypeEnum2) => {
  ProgramTypeEnum2["CONTRACT"] = "contract";
  ProgramTypeEnum2["SCRIPT"] = "script";
  ProgramTypeEnum2["PREDICATE"] = "predicate";
  return ProgramTypeEnum2;
})(ProgramTypeEnum || {});

// src/utils/assembleContracts.ts
import { join } from "path";

// src/templates/renderHbsTemplate.ts
import Handlebars from "handlebars";

// src/templates/common/_header.hbs
var header_default = "/* Autogenerated file. Do not edit manually. */\n\n/* eslint-disable max-classes-per-file */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/consistent-type-imports */\n\n\n/*\n  Fuels version: {{FUELS}}\n{{#if FORC}}\n  Forc version: {{FORC}}\n{{/if}}\n{{#if FUEL_CORE}}\n  Fuel-Core version: {{FUEL_CORE}}\n{{/if}}\n*/\n";

// src/templates/renderHbsTemplate.ts
function renderHbsTemplate(params) {
  const { data, template, versions } = params;
  const options = {
    strict: true,
    noEscape: true
  };
  const renderTemplate = Handlebars.compile(template, options);
  const renderHeaderTemplate = Handlebars.compile(header_default, options);
  const text = renderTemplate({
    ...data,
    header: renderHeaderTemplate(versions)
  });
  return text.replace(/[\n]{3,}/gm, "\n\n");
}

// src/templates/common/common.hbs
var common_default = "{{header}}\n\n/**\n * Mimics Sway Enum.\n * Requires one and only one Key-Value pair and raises error if more are provided.\n */\nexport type Enum<T> = {\n  [K in keyof T]: Pick<T, K> & { [P in Exclude<keyof T, K>]?: never };\n}[keyof T];\n\n/**\n * Mimics Sway Option and Vectors.\n * Vectors are treated like arrays in Typescript.\n */\nexport type Option<T> = T | undefined;\n\nexport type Vec<T> = T[];\n\n/**\n * Mimics Sway Result enum type.\n * Ok represents the success case, while Err represents the error case.\n */\nexport type Result<T, E> = Enum<{Ok: T, Err: E}>;\n";

// src/templates/common/common.ts
function renderCommonTemplate(params) {
  const { versions } = params;
  const text = renderHbsTemplate({ template: common_default, versions });
  return text;
}

// src/templates/common/index.hbs
var common_default2 = "{{header}}\n\n{{#each members}}\nexport { {{this}} } from './{{this}}';\n{{/each}}\n";

// src/templates/common/index.ts
function renderIndexTemplate(params) {
  const { files, versions } = params;
  const members = files.map((f) => f.path.match(/([^/]+)\.ts$/m)?.[1]);
  const text = renderHbsTemplate({
    template: common_default2,
    versions,
    data: {
      members
    }
  });
  return text;
}

// src/templates/contract/factory.ts
import { compressBytecode } from "@fuel-ts/utils";

// src/templates/contract/factory.hbs
var factory_default = '{{header}}\n\nimport { ContractFactory, decompressBytecode } from "fuels";\nimport type { Provider, Account, DeployContractOptions } from "fuels";\n\nimport { {{capitalizedName}} } from "./{{capitalizedName}}";\n\nconst bytecode = decompressBytecode("{{compressedBytecode}}");\n\nexport class {{capitalizedName}}Factory extends ContractFactory<{{capitalizedName}}> {\n\n  static readonly bytecode = bytecode;\n\n  constructor(accountOrProvider: Account | Provider) {\n    super(\n      bytecode,\n      {{capitalizedName}}.abi,\n      accountOrProvider,\n      {{capitalizedName}}.storageSlots\n    );\n  }\n\n  static deploy (\n    wallet: Account,\n    options: DeployContractOptions = {}\n  ) {\n    const factory = new {{capitalizedName}}Factory(wallet);\n    return factory.deploy(options);\n  }\n}\n';

// src/templates/contract/factory.ts
function renderFactoryTemplate(params) {
  const { versions, abi } = params;
  const {
    camelizedName,
    capitalizedName,
    rawContents,
    storageSlotsContents,
    hexlifiedBinContents: hexlifiedBinString
  } = abi;
  const abiJsonString = JSON.stringify(rawContents, null, 2);
  const storageSlotsJsonString = storageSlotsContents ?? "[]";
  const text = renderHbsTemplate({
    template: factory_default,
    versions,
    data: {
      camelizedName,
      capitalizedName,
      abiJsonString,
      storageSlotsJsonString,
      compressedBytecode: compressBytecode(hexlifiedBinString)
    }
  });
  return text;
}

// src/templates/utils/formatEnums.ts
function formatEnums(params) {
  const { types } = params;
  const enums = types.filter((t) => t.name === "enum").map((t) => {
    const et = t;
    const structName = et.getStructName();
    const inputValues = et.getStructContents({ types, target: "input" /* INPUT */ });
    const outputValues = et.getStructContents({ types, target: "output" /* OUTPUT */ });
    const inputNativeValues = et.getNativeEnum({ types });
    const outputNativeValues = et.getNativeEnum({ types });
    const typeAnnotations = et.getStructDeclaration({ types });
    return {
      structName,
      inputValues,
      outputValues,
      recycleRef: inputValues === outputValues,
      // reduces duplication
      inputNativeValues,
      outputNativeValues,
      typeAnnotations
    };
  }).sort((a, b) => a.structName < b.structName ? -1 : 1);
  return { enums };
}

// src/templates/utils/formatImports.ts
import { uniq } from "ramda";
var caseInsensitiveSort = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
function formatImports(params) {
  const { types, baseMembers = [] } = params;
  const members = types.flatMap((t) => t.requiredFuelsMembersImports);
  const imports = uniq(baseMembers.concat(members).sort(caseInsensitiveSort));
  return {
    imports: imports.length ? imports : void 0
  };
}

// src/templates/utils/formatStructs.ts
function formatStructs(params) {
  const { types } = params;
  const structs = types.filter((t) => t.name === "struct").map((t) => {
    const st = t;
    const structName = st.getStructName();
    const inputValues = st.getStructContents({ types, target: "input" /* INPUT */ });
    const outputValues = st.getStructContents({ types, target: "output" /* OUTPUT */ });
    const typeAnnotations = st.getStructDeclaration({ types });
    return {
      structName,
      typeAnnotations,
      inputValues,
      outputValues,
      recycleRef: inputValues === outputValues
      // reduces duplication
    };
  }).sort((a, b) => a.structName < b.structName ? -1 : 1);
  return { structs };
}

// src/templates/contract/main.hbs
var main_default = `{{header}}

import { Contract, Interface } from "fuels";
{{#if imports}}
import type {
  Provider,
  Account,
  StorageSlot,
  Address,
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
{{#each configurables}}
  {{name}}: {{inputLabel}};
{{/each}}
}>;
{{/if}}

const abi = {{abiJsonString}};

const storageSlots: StorageSlot[] = {{storageSlotsJsonString}};

export class {{capitalizedName}}Interface extends Interface {
  constructor() {
    super(abi);
  }

  declare functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };
}

export class {{capitalizedName}} extends Contract {
  static readonly abi = abi;
  static readonly storageSlots = storageSlots;

  declare interface: {{capitalizedName}}Interface;
  declare functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };

  constructor(
    id: string | Address,
    accountOrProvider: Account | Provider,
  ) {
    super(id, abi, accountOrProvider);
  }
}
`;

// src/templates/contract/main.ts
function renderMainTemplate(params) {
  const { versions, abi } = params;
  const { camelizedName, capitalizedName, types, functions, commonTypesInUse, configurables } = abi;
  const functionsTypedefs = functions.map((f) => f.getDeclaration());
  const functionsFragments = functions.map((f) => f.name);
  const encoders = functions.map((f) => ({
    functionName: f.name,
    input: f.attributes.inputs
  }));
  const decoders = functions.map((f) => ({
    functionName: f.name
  }));
  const { enums } = formatEnums({ types });
  const { structs } = formatStructs({ types });
  const { imports } = formatImports({
    types,
    baseMembers: ["FunctionFragment", "InvokeFunction"]
  });
  const { rawContents, storageSlotsContents } = params.abi;
  const abiJsonString = JSON.stringify(rawContents, null, 2);
  const storageSlotsJsonString = storageSlotsContents ?? "[]";
  const text = renderHbsTemplate({
    template: main_default,
    versions,
    data: {
      camelizedName,
      capitalizedName,
      commonTypesInUse: commonTypesInUse.join(", "),
      functionsTypedefs,
      functionsFragments,
      encoders,
      decoders,
      structs,
      enums,
      imports,
      abiJsonString,
      storageSlotsJsonString,
      configurables
    }
  });
  return text;
}

// src/utils/assembleContracts.ts
function assembleContracts(params) {
  const { abis, outputDir, versions } = params;
  const files = [];
  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
  abis.forEach((abi) => {
    const { capitalizedName } = abi;
    const mainFilepath = `${outputDir}/${capitalizedName}.ts`;
    const factoryFilepath = `${outputDir}/${capitalizedName}Factory.ts`;
    const main = {
      path: mainFilepath,
      contents: renderMainTemplate({ abi, versions })
    };
    const factory = {
      path: factoryFilepath,
      contents: renderFactoryTemplate({ abi, versions })
    };
    files.push(main);
    files.push(factory);
  });
  const indexFile = {
    path: `${outputDir}/index.ts`,
    contents: renderIndexTemplate({ files, versions })
  };
  files.push(indexFile);
  if (usesCommonTypes) {
    const commonsFilepath = join(outputDir, "common.d.ts");
    const file = {
      path: commonsFilepath,
      contents: renderCommonTemplate({ versions })
    };
    files.push(file);
  }
  return files;
}

// src/utils/assemblePredicates.ts
import { join as join2 } from "path";

// src/templates/predicate/main.ts
import { ErrorCode as ErrorCode5, FuelError as FuelError5 } from "@fuel-ts/errors";
import { compressBytecode as compressBytecode2 } from "@fuel-ts/utils";

// src/templates/predicate/main.hbs
var main_default2 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
  {{#each configurables}}
    {{name}}: {{inputLabel}};
  {{/each}}
}>;
{{else}}
export type {{capitalizedName}}Configurables = undefined;
{{/if}}

export type {{capitalizedName}}Inputs = [{{inputs}}];

export type {{capitalizedName}}Parameters = Omit<
  PredicateParams<{{capitalizedName}}Inputs, {{capitalizedName}}Configurables>,
  'abi' | 'bytecode'
>;

const abi = {{abiJsonString}};

const bytecode = decompressBytecode('{{compressedBytecode}}');

export class {{capitalizedName}} extends Predicate<
  {{capitalizedName}}Inputs,
  {{capitalizedName}}Configurables
> {
  static readonly abi = abi;
  static readonly bytecode = bytecode;

  constructor(params: {{capitalizedName}}Parameters) {
    super({ abi, bytecode, ...params });
  }
}
`;

// src/templates/predicate/main.ts
function renderMainTemplate2(params) {
  const { abi, versions } = params;
  const { types, configurables } = abi;
  const {
    rawContents,
    capitalizedName,
    hexlifiedBinContents: hexlifiedBinString,
    commonTypesInUse
  } = params.abi;
  const abiJsonString = JSON.stringify(rawContents, null, 2);
  const func = abi.functions.find((f) => f.name === "main");
  if (!func) {
    throw new FuelError5(ErrorCode5.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
  }
  const { enums } = formatEnums({ types });
  const { structs } = formatStructs({ types });
  const { imports } = formatImports({
    types,
    baseMembers: ["Predicate", "Provider", "InputValue", "PredicateParams", "decompressBytecode"]
  });
  const { prefixedInputs: inputs, output } = func.attributes;
  const text = renderHbsTemplate({
    template: main_default2,
    versions,
    data: {
      inputs,
      output,
      structs,
      enums,
      abiJsonString,
      compressedBytecode: compressBytecode2(hexlifiedBinString),
      capitalizedName,
      imports,
      configurables,
      commonTypesInUse: commonTypesInUse.join(", ")
    }
  });
  return text;
}

// src/utils/assemblePredicates.ts
function assemblePredicates(params) {
  const { abis, outputDir, versions } = params;
  const files = [];
  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
  abis.forEach((abi) => {
    const { capitalizedName: name } = abi;
    const factoryFilepath = `${outputDir}/${name}.ts`;
    const factory = {
      path: factoryFilepath,
      contents: renderMainTemplate2({ abi, versions })
    };
    files.push(factory);
  });
  const indexFile = {
    path: `${outputDir}/index.ts`,
    contents: renderIndexTemplate({ files, versions })
  };
  files.push(indexFile);
  if (usesCommonTypes) {
    const commonsFilepath = join2(outputDir, "common.d.ts");
    const file = {
      path: commonsFilepath,
      contents: renderCommonTemplate({ versions })
    };
    files.push(file);
  }
  return files;
}

// src/utils/assembleScripts.ts
import { join as join3 } from "path";

// src/templates/script/main.ts
import { ErrorCode as ErrorCode6, FuelError as FuelError6 } from "@fuel-ts/errors";
import { compressBytecode as compressBytecode3 } from "@fuel-ts/utils";

// src/templates/script/main.hbs
var main_default3 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

export type {{capitalizedName}}Inputs = [{{inputs}}];
export type {{capitalizedName}}Output = {{output}};

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
{{#each configurables}}
  {{name}}: {{inputLabel}};
{{/each}}
}>;
{{/if}}

const abi = {{abiJsonString}};

const bytecode = decompressBytecode('{{compressedBytecode}}');

export class {{capitalizedName}} extends Script<{{capitalizedName}}Inputs, {{capitalizedName}}Output> {

  static readonly abi = abi;
  static readonly bytecode = bytecode;

  constructor(wallet: Account) {
    super(bytecode, abi, wallet);
  }
}
`;

// src/templates/script/main.ts
function renderMainTemplate3(params) {
  const { abi, versions } = params;
  const { types, configurables } = abi;
  const {
    rawContents,
    capitalizedName,
    hexlifiedBinContents: hexlifiedBinString,
    commonTypesInUse
  } = params.abi;
  const abiJsonString = JSON.stringify(rawContents, null, 2);
  const func = abi.functions.find((f) => f.name === "main");
  if (!func) {
    throw new FuelError6(ErrorCode6.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
  }
  const { enums } = formatEnums({ types });
  const { structs } = formatStructs({ types });
  const { imports } = formatImports({
    types,
    baseMembers: ["Script", "Account", "decompressBytecode"]
  });
  const { prefixedInputs: inputs, output } = func.attributes;
  const text = renderHbsTemplate({
    template: main_default3,
    versions,
    data: {
      inputs,
      output,
      structs,
      enums,
      abiJsonString,
      compressedBytecode: compressBytecode3(hexlifiedBinString),
      capitalizedName,
      imports,
      configurables,
      commonTypesInUse: commonTypesInUse.join(", ")
    }
  });
  return text;
}

// src/utils/assembleScripts.ts
function assembleScripts(params) {
  const { abis, outputDir, versions } = params;
  const files = [];
  const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
  abis.forEach((abi) => {
    const { capitalizedName } = abi;
    const factoryFilepath = `${outputDir}/${capitalizedName}.ts`;
    const factory = {
      path: factoryFilepath,
      contents: renderMainTemplate3({ abi, versions })
    };
    files.push(factory);
  });
  const indexFile = {
    path: `${outputDir}/index.ts`,
    contents: renderIndexTemplate({ files, versions })
  };
  files.push(indexFile);
  if (usesCommonTypes) {
    const commonsFilepath = join3(outputDir, "common.d.ts");
    const file = {
      path: commonsFilepath,
      contents: renderCommonTemplate({ versions })
    };
    files.push(file);
  }
  return files;
}

// src/utils/validateBinFile.ts
import { ErrorCode as ErrorCode7, FuelError as FuelError7 } from "@fuel-ts/errors";
var upperFirst = (s) => s[0].toUpperCase() + s.slice(1);
function validateBinFile(params) {
  const { abiFilepath, binFilepath, binExists, programType } = params;
  const isScript = programType === "script" /* SCRIPT */;
  if (!binExists && isScript) {
    throw new FuelError7(
      ErrorCode7.BIN_FILE_NOT_FOUND,
      [
        `Could not find BIN file for counterpart ${upperFirst(programType)} ABI.`,
        `  - ABI: ${abiFilepath}`,
        `  - BIN: ${binFilepath}`,
        programType
      ].join("\n")
    );
  }
}

// src/AbiTypeGen.ts
var AbiTypeGen = class {
  abis;
  abiFiles;
  binFiles;
  storageSlotsFiles;
  outputDir;
  files;
  versions;
  constructor(params) {
    const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles, versions } = params;
    this.outputDir = outputDir;
    this.abiFiles = abiFiles;
    this.binFiles = binFiles;
    this.storageSlotsFiles = storageSlotsFiles;
    this.versions = versions;
    this.abis = this.abiFiles.map((abiFile) => {
      const binFilepath = abiFile.path.replace("-abi.json", ".bin");
      const relatedBinFile = this.binFiles.find(({ path }) => path === binFilepath);
      const storageSlotFilepath = abiFile.path.replace("-abi.json", "-storage_slots.json");
      const relatedStorageSlotsFile = this.storageSlotsFiles.find(
        ({ path }) => path === storageSlotFilepath
      );
      if (!relatedBinFile) {
        validateBinFile({
          abiFilepath: abiFile.path,
          binExists: !!relatedBinFile,
          binFilepath,
          programType
        });
      }
      const abi = new Abi({
        filepath: abiFile.path,
        rawContents: JSON.parse(abiFile.contents),
        hexlifiedBinContents: relatedBinFile?.contents,
        storageSlotsContents: relatedStorageSlotsFile?.contents,
        outputDir,
        programType
      });
      return abi;
    });
    this.files = this.getAssembledFiles({ programType });
  }
  getAssembledFiles(params) {
    const { abis, outputDir, versions } = this;
    const { programType } = params;
    switch (programType) {
      case "contract" /* CONTRACT */:
        return assembleContracts({ abis, outputDir, versions });
      case "script" /* SCRIPT */:
        return assembleScripts({ abis, outputDir, versions });
      case "predicate" /* PREDICATE */:
        return assemblePredicates({ abis, outputDir, versions });
      default:
        throw new FuelError8(
          ErrorCode8.INVALID_INPUT_PARAMETERS,
          `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(
            ProgramTypeEnum
          )}`
        );
    }
  }
};

// src/utils/collectBinFilePaths.ts
import { hexlify } from "@fuel-ts/utils";
import { existsSync, readFileSync } from "fs";
var collectBinFilepaths = (params) => {
  const { filepaths, programType } = params;
  const binFiles = filepaths.map((abiFilepath) => {
    const binFilepath = abiFilepath.replace("-abi.json", ".bin");
    const binExists = existsSync(binFilepath);
    validateBinFile({ abiFilepath, binFilepath, binExists, programType });
    const bin = {
      path: binFilepath,
      contents: hexlify(readFileSync(binFilepath))
    };
    return bin;
  });
  return binFiles;
};

// src/utils/collectStorageSlotsFilePaths.ts
import { existsSync as existsSync2, readFileSync as readFileSync2 } from "fs";
var collectStorageSlotsFilepaths = (params) => {
  const { filepaths, programType } = params;
  const storageSlotsFiles = [];
  if (programType !== "contract" /* CONTRACT */) {
    return storageSlotsFiles;
  }
  filepaths.forEach((abiFilepath) => {
    const storageSlotsFilepath = abiFilepath.replace("-abi.json", "-storage_slots.json");
    const storageSlotsExists = existsSync2(storageSlotsFilepath);
    if (storageSlotsExists) {
      const storageSlots = {
        path: storageSlotsFilepath,
        contents: readFileSync2(storageSlotsFilepath, "utf-8")
      };
      storageSlotsFiles.push(storageSlots);
    }
  });
  return storageSlotsFiles;
};

// src/runTypegen.ts
function runTypegen(params) {
  const { cwd, inputs, output, silent, programType, filepaths: inputFilepaths } = params;
  const versions = { FUELS: builtinVersions.FUELS, ...params.versions };
  const cwdBasename = basename(cwd);
  function log(...args) {
    if (!silent) {
      console.log(args.join(" "));
    }
  }
  let filepaths = [];
  if (!inputFilepaths?.length && inputs?.length) {
    filepaths = inputs.flatMap((i) => globSync(i, { cwd }));
  } else if (inputFilepaths?.length) {
    filepaths = inputFilepaths;
  } else {
    throw new FuelError9(
      ErrorCode9.MISSING_REQUIRED_PARAMETER,
      `At least one parameter should be supplied: 'input' or 'filepaths'.`
    );
  }
  const abiFiles = filepaths.map((filepath) => {
    const contents = readFileSync3(filepath, "utf-8");
    const abi = {
      path: filepath,
      contents
    };
    return abi;
  });
  if (!abiFiles.length) {
    throw new FuelError9(ErrorCode9.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);
  }
  const binFiles = collectBinFilepaths({ filepaths, programType });
  const storageSlotsFiles = collectStorageSlotsFilepaths({ filepaths, programType });
  const abiTypeGen = new AbiTypeGen({
    outputDir: output,
    abiFiles,
    binFiles,
    storageSlotsFiles,
    programType,
    versions
  });
  log("Generating files..\n");
  mkdirp.sync(`${output}`);
  abiTypeGen.files.forEach((file) => {
    rimrafSync(file.path);
    writeFileSync(file.path, file.contents);
    const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, "m");
    log(` - ${file.path.replace(trimPathRegex, "")}`);
  });
  log("\nDone.\u26A1");
}

// src/cli.ts
function resolveProgramType(params) {
  const { contract, script, predicate } = params;
  const noneSpecified = !contract && !script && !predicate;
  if (contract || noneSpecified) {
    return "contract" /* CONTRACT */;
  }
  if (predicate) {
    return "predicate" /* PREDICATE */;
  }
  return "script" /* SCRIPT */;
}
function runCliAction(options) {
  const { inputs, output, silent, contract, script, predicate } = options;
  const cwd = process.cwd();
  const programType = resolveProgramType({ contract, script, predicate });
  try {
    runTypegen({
      cwd,
      inputs,
      output,
      programType,
      silent: !!silent
    });
  } catch (err) {
    console.log(`error: ${err.message}`);
    process.exit(1);
  }
}
function configureCliOptions(program) {
  return program.requiredOption("-i, --inputs <path|glob...>", "Input paths/globals to your ABI JSON files").requiredOption("-o, --output <dir>", "Directory path for generated files").addOption(
    new Option("-c, --contract", "Generate types for Contracts [default]").conflicts(["script", "predicate"]).implies({ script: void 0, predicate: void 0 })
  ).addOption(
    new Option("-s, --script", "Generate types for Scripts").conflicts(["contract", "predicate"]).implies({ contract: void 0, predicate: void 0 })
  ).addOption(
    new Option("-p, --predicate", "Generate types for Predicates").conflicts(["contract", "script"]).implies({ contract: void 0, script: void 0 })
  ).option("-S, --silent", "Omit output messages").action(runCliAction);
}
function run(params) {
  const program = new Command();
  const { argv, programName } = params;
  program.name(programName);
  program.version(builtinVersion.FUELS);
  program.usage(`-i ../out/*-abi.json -o ./generated/`);
  configureCliOptions(program);
  program.parse(argv);
}

// src/bin.ts
run({
  argv: process.argv,
  programName: "fuels-typegen"
});
//# sourceMappingURL=bin.mjs.map