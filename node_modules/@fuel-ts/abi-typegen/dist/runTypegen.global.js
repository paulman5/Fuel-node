"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };

  // ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
      "use strict";
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
  var require_brace_expansion = __commonJS({
    "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module) {
      var balanced = require_balanced_match();
      module.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand2(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand2(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m)
          return [str];
        var pre = m.pre;
        var post = m.post.length ? expand2(m.post, false) : [""];
        if (/\$$/.test(m.pre)) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
          }
        } else {
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
              str = m.pre + "{" + m.body + escClose + m.post;
              return expand2(str);
            }
            return [str];
          }
          var n;
          if (isSequence) {
            n = m.body.split(/\.\./);
          } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
              n = expand2(n[0], false).map(embrace);
              if (n.length === 1) {
                return post.map(function(p) {
                  return m.pre + n[0] + p;
                });
              }
            }
          }
          var N;
          if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
              incr *= -1;
              test = gte;
            }
            var pad = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
              var c;
              if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\")
                  c = "";
              } else {
                c = String(i);
                if (pad) {
                  var need = width - c.length;
                  if (need > 0) {
                    var z = new Array(need + 1).join("0");
                    if (i < 0)
                      c = "-" + z + c.slice(1);
                    else
                      c = z + c;
                  }
                }
              }
              N.push(c);
            }
          } else {
            N = [];
            for (var j = 0; j < n.length; j++) {
              N.push.apply(N, expand2(n[j], false));
            }
          }
          for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + N[j] + post[k];
              if (!isTop || isSequence || expansion)
                expansions.push(expansion);
            }
          }
        }
        return expansions;
      }
    }
  });

  // ../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = __require("buffer").Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert(false, "Invalid character in " + string);
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
          } catch (e) {
            BN2.prototype.inspect = inspect2;
          }
        } else {
          BN2.prototype.inspect = inspect2;
        }
        function inspect2() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString2(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN2.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType2, size) {
          if (ArrayType2.allocUnsafe) {
            return ArrayType2.allocUnsafe(size);
          }
          return new ArrayType2(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType2, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self, num, out) {
          out.negative = num.negative ^ self.negative;
          var len = self.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self, num, out) {
          var a = self.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self, num, out) {
          out.negative = num.negative ^ self.negative;
          out.length = self.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self, num, out) {
          return bigMulTo(self, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/utils.js
  var require_utils = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/utils.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.extend = extend;
      exports.indexOf = indexOf;
      exports.escapeExpression = escapeExpression;
      exports.isEmpty = isEmpty;
      exports.createFrame = createFrame;
      exports.blockParams = blockParams;
      exports.appendContextPath = appendContextPath;
      var escape2 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      var badChars = /[&<>"'`=]/g;
      var possible = /[&<>"'`=]/;
      function escapeChar(chr) {
        return escape2[chr];
      }
      function extend(obj) {
        for (var i = 1; i < arguments.length; i++) {
          for (var key in arguments[i]) {
            if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
              obj[key] = arguments[i][key];
            }
          }
        }
        return obj;
      }
      var toString2 = Object.prototype.toString;
      exports.toString = toString2;
      var isFunction = function isFunction2(value) {
        return typeof value === "function";
      };
      if (isFunction(/x/)) {
        exports.isFunction = isFunction = function(value) {
          return typeof value === "function" && toString2.call(value) === "[object Function]";
        };
      }
      exports.isFunction = isFunction;
      var isArray = Array.isArray || function(value) {
        return value && typeof value === "object" ? toString2.call(value) === "[object Array]" : false;
      };
      exports.isArray = isArray;
      function indexOf(array, value) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      }
      function escapeExpression(string) {
        if (typeof string !== "string") {
          if (string && string.toHTML) {
            return string.toHTML();
          } else if (string == null) {
            return "";
          } else if (!string) {
            return string + "";
          }
          string = "" + string;
        }
        if (!possible.test(string)) {
          return string;
        }
        return string.replace(badChars, escapeChar);
      }
      function isEmpty(value) {
        if (!value && value !== 0) {
          return true;
        } else if (isArray(value) && value.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      function createFrame(object) {
        var frame = extend({}, object);
        frame._parent = object;
        return frame;
      }
      function blockParams(params, ids) {
        params.path = ids;
        return params;
      }
      function appendContextPath(contextPath, id) {
        return (contextPath ? contextPath + "." : "") + id;
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/exception.js
  var require_exception = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/exception.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
      function Exception(message, node) {
        var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
        if (loc) {
          line = loc.start.line;
          endLineNumber = loc.end.line;
          column = loc.start.column;
          endColumn = loc.end.column;
          message += " - " + line + ":" + column;
        }
        var tmp = Error.prototype.constructor.call(this, message);
        for (var idx = 0; idx < errorProps.length; idx++) {
          this[errorProps[idx]] = tmp[errorProps[idx]];
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, Exception);
        }
        try {
          if (loc) {
            this.lineNumber = line;
            this.endLineNumber = endLineNumber;
            if (Object.defineProperty) {
              Object.defineProperty(this, "column", {
                value: column,
                enumerable: true
              });
              Object.defineProperty(this, "endColumn", {
                value: endColumn,
                enumerable: true
              });
            } else {
              this.column = column;
              this.endColumn = endColumn;
            }
          }
        } catch (nop) {
        }
      }
      Exception.prototype = new Error();
      exports["default"] = Exception;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
  var require_block_helper_missing = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      exports["default"] = function(instance) {
        instance.registerHelper("blockHelperMissing", function(context, options) {
          var inverse = options.inverse, fn = options.fn;
          if (context === true) {
            return fn(this);
          } else if (context === false || context == null) {
            return inverse(this);
          } else if (_utils.isArray(context)) {
            if (context.length > 0) {
              if (options.ids) {
                options.ids = [options.name];
              }
              return instance.helpers.each(context, options);
            } else {
              return inverse(this);
            }
          } else {
            if (options.data && options.ids) {
              var data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
              options = { data };
            }
            return fn(context, options);
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
  var require_each = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/each.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("each", function(context, options) {
          if (!options) {
            throw new _exception2["default"]("Must pass iterator to #each");
          }
          var fn = options.fn, inverse = options.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
          if (options.data && options.ids) {
            contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
          }
          if (_utils.isFunction(context)) {
            context = context.call(this);
          }
          if (options.data) {
            data = _utils.createFrame(options.data);
          }
          function execIteration(field, index, last) {
            if (data) {
              data.key = field;
              data.index = index;
              data.first = index === 0;
              data.last = !!last;
              if (contextPath) {
                data.contextPath = contextPath + field;
              }
            }
            ret = ret + fn(context[field], {
              data,
              blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
            });
          }
          if (context && typeof context === "object") {
            if (_utils.isArray(context)) {
              for (var j = context.length; i < j; i++) {
                if (i in context) {
                  execIteration(i, i, i === context.length - 1);
                }
              }
            } else if (typeof Symbol === "function" && context[Symbol.iterator]) {
              var newContext = [];
              var iterator = context[Symbol.iterator]();
              for (var it = iterator.next(); !it.done; it = iterator.next()) {
                newContext.push(it.value);
              }
              context = newContext;
              for (var j = context.length; i < j; i++) {
                execIteration(i, i, i === context.length - 1);
              }
            } else {
              (function() {
                var priorKey = void 0;
                Object.keys(context).forEach(function(key) {
                  if (priorKey !== void 0) {
                    execIteration(priorKey, i - 1);
                  }
                  priorKey = key;
                  i++;
                });
                if (priorKey !== void 0) {
                  execIteration(priorKey, i - 1, true);
                }
              })();
            }
          }
          if (i === 0) {
            ret = inverse(this);
          }
          return ret;
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
  var require_helper_missing = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("helperMissing", function() {
          if (arguments.length === 1) {
            return void 0;
          } else {
            throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
  var require_if = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/if.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("if", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#if requires exactly one argument");
          }
          if (_utils.isFunction(conditional)) {
            conditional = conditional.call(this);
          }
          if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
            return options.inverse(this);
          } else {
            return options.fn(this);
          }
        });
        instance.registerHelper("unless", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#unless requires exactly one argument");
          }
          return instance.helpers["if"].call(this, conditional, {
            fn: options.inverse,
            inverse: options.fn,
            hash: options.hash
          });
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
  var require_log = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/log.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("log", function() {
          var args = [void 0], options = arguments[arguments.length - 1];
          for (var i = 0; i < arguments.length - 1; i++) {
            args.push(arguments[i]);
          }
          var level = 1;
          if (options.hash.level != null) {
            level = options.hash.level;
          } else if (options.data && options.data.level != null) {
            level = options.data.level;
          }
          args[0] = level;
          instance.log.apply(instance, args);
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
  var require_lookup = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("lookup", function(obj, field, options) {
          if (!obj) {
            return obj;
          }
          return options.lookupProperty(obj, field);
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
  var require_with = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers/with.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("with", function(context, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#with requires exactly one argument");
          }
          if (_utils.isFunction(context)) {
            context = context.call(this);
          }
          var fn = options.fn;
          if (!_utils.isEmpty(context)) {
            var data = options.data;
            if (options.data && options.ids) {
              data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
            }
            return fn(context, {
              data,
              blockParams: _utils.blockParams([context], [data && data.contextPath])
            });
          } else {
            return options.inverse(this);
          }
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers.js
  var require_helpers = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/helpers.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.registerDefaultHelpers = registerDefaultHelpers;
      exports.moveHelperToHooks = moveHelperToHooks;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _helpersBlockHelperMissing = require_block_helper_missing();
      var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
      var _helpersEach = require_each();
      var _helpersEach2 = _interopRequireDefault(_helpersEach);
      var _helpersHelperMissing = require_helper_missing();
      var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
      var _helpersIf = require_if();
      var _helpersIf2 = _interopRequireDefault(_helpersIf);
      var _helpersLog = require_log();
      var _helpersLog2 = _interopRequireDefault(_helpersLog);
      var _helpersLookup = require_lookup();
      var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
      var _helpersWith = require_with();
      var _helpersWith2 = _interopRequireDefault(_helpersWith);
      function registerDefaultHelpers(instance) {
        _helpersBlockHelperMissing2["default"](instance);
        _helpersEach2["default"](instance);
        _helpersHelperMissing2["default"](instance);
        _helpersIf2["default"](instance);
        _helpersLog2["default"](instance);
        _helpersLookup2["default"](instance);
        _helpersWith2["default"](instance);
      }
      function moveHelperToHooks(instance, helperName, keepHelper) {
        if (instance.helpers[helperName]) {
          instance.hooks[helperName] = instance.helpers[helperName];
          if (!keepHelper) {
            delete instance.helpers[helperName];
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
  var require_inline = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      exports["default"] = function(instance) {
        instance.registerDecorator("inline", function(fn, props, container, options) {
          var ret = fn;
          if (!props.partials) {
            props.partials = {};
            ret = function(context, options2) {
              var original = container.partials;
              container.partials = _utils.extend({}, original, props.partials);
              var ret2 = fn(context, options2);
              container.partials = original;
              return ret2;
            };
          }
          props.partials[options.args[0]] = options.fn;
          return ret;
        });
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/decorators.js
  var require_decorators = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/decorators.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.registerDefaultDecorators = registerDefaultDecorators;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _decoratorsInline = require_inline();
      var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
      function registerDefaultDecorators(instance) {
        _decoratorsInline2["default"](instance);
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/logger.js
  var require_logger = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/logger.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      var logger = {
        methodMap: ["debug", "info", "warn", "error"],
        level: "info",
        // Maps a given level value to the `methodMap` indexes above.
        lookupLevel: function lookupLevel(level) {
          if (typeof level === "string") {
            var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
            if (levelMap >= 0) {
              level = levelMap;
            } else {
              level = parseInt(level, 10);
            }
          }
          return level;
        },
        // Can be overridden in the host environment
        log: function log(level) {
          level = logger.lookupLevel(level);
          if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
            var method = logger.methodMap[level];
            if (!console[method]) {
              method = "log";
            }
            for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              message[_key - 1] = arguments[_key];
            }
            console[method].apply(console, message);
          }
        }
      };
      exports["default"] = logger;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
  var require_create_new_lookup_object = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.createNewLookupObject = createNewLookupObject;
      var _utils = require_utils();
      function createNewLookupObject() {
        for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
  var require_proto_access = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.createProtoAccessControl = createProtoAccessControl;
      exports.resultIsAllowed = resultIsAllowed;
      exports.resetLoggedProperties = resetLoggedProperties;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _createNewLookupObject = require_create_new_lookup_object();
      var _logger = require_logger();
      var _logger2 = _interopRequireDefault(_logger);
      var loggedProperties = /* @__PURE__ */ Object.create(null);
      function createProtoAccessControl(runtimeOptions) {
        var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
        defaultMethodWhiteList["constructor"] = false;
        defaultMethodWhiteList["__defineGetter__"] = false;
        defaultMethodWhiteList["__defineSetter__"] = false;
        defaultMethodWhiteList["__lookupGetter__"] = false;
        var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
        defaultPropertyWhiteList["__proto__"] = false;
        return {
          properties: {
            whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
            defaultValue: runtimeOptions.allowProtoPropertiesByDefault
          },
          methods: {
            whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
            defaultValue: runtimeOptions.allowProtoMethodsByDefault
          }
        };
      }
      function resultIsAllowed(result, protoAccessControl, propertyName) {
        if (typeof result === "function") {
          return checkWhiteList(protoAccessControl.methods, propertyName);
        } else {
          return checkWhiteList(protoAccessControl.properties, propertyName);
        }
      }
      function checkWhiteList(protoAccessControlForType, propertyName) {
        if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
          return protoAccessControlForType.whitelist[propertyName] === true;
        }
        if (protoAccessControlForType.defaultValue !== void 0) {
          return protoAccessControlForType.defaultValue;
        }
        logUnexpecedPropertyAccessOnce(propertyName);
        return false;
      }
      function logUnexpecedPropertyAccessOnce(propertyName) {
        if (loggedProperties[propertyName] !== true) {
          loggedProperties[propertyName] = true;
          _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
        }
      }
      function resetLoggedProperties() {
        Object.keys(loggedProperties).forEach(function(propertyName) {
          delete loggedProperties[propertyName];
        });
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/base.js
  var require_base = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.HandlebarsEnvironment = HandlebarsEnvironment;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _helpers = require_helpers();
      var _decorators = require_decorators();
      var _logger = require_logger();
      var _logger2 = _interopRequireDefault(_logger);
      var _internalProtoAccess = require_proto_access();
      var VERSION = "4.7.8";
      exports.VERSION = VERSION;
      var COMPILER_REVISION = 8;
      exports.COMPILER_REVISION = COMPILER_REVISION;
      var LAST_COMPATIBLE_COMPILER_REVISION = 7;
      exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
      var REVISION_CHANGES = {
        1: "<= 1.0.rc.2",
        // 1.0.rc.2 is actually rev2 but doesn't report it
        2: "== 1.0.0-rc.3",
        3: "== 1.0.0-rc.4",
        4: "== 1.x.x",
        5: "== 2.0.0-alpha.x",
        6: ">= 2.0.0-beta.1",
        7: ">= 4.0.0 <4.3.0",
        8: ">= 4.3.0"
      };
      exports.REVISION_CHANGES = REVISION_CHANGES;
      var objectType = "[object Object]";
      function HandlebarsEnvironment(helpers, partials, decorators) {
        this.helpers = helpers || {};
        this.partials = partials || {};
        this.decorators = decorators || {};
        _helpers.registerDefaultHelpers(this);
        _decorators.registerDefaultDecorators(this);
      }
      HandlebarsEnvironment.prototype = {
        constructor: HandlebarsEnvironment,
        logger: _logger2["default"],
        log: _logger2["default"].log,
        registerHelper: function registerHelper(name, fn) {
          if (_utils.toString.call(name) === objectType) {
            if (fn) {
              throw new _exception2["default"]("Arg not supported with multiple helpers");
            }
            _utils.extend(this.helpers, name);
          } else {
            this.helpers[name] = fn;
          }
        },
        unregisterHelper: function unregisterHelper(name) {
          delete this.helpers[name];
        },
        registerPartial: function registerPartial(name, partial) {
          if (_utils.toString.call(name) === objectType) {
            _utils.extend(this.partials, name);
          } else {
            if (typeof partial === "undefined") {
              throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
            }
            this.partials[name] = partial;
          }
        },
        unregisterPartial: function unregisterPartial(name) {
          delete this.partials[name];
        },
        registerDecorator: function registerDecorator(name, fn) {
          if (_utils.toString.call(name) === objectType) {
            if (fn) {
              throw new _exception2["default"]("Arg not supported with multiple decorators");
            }
            _utils.extend(this.decorators, name);
          } else {
            this.decorators[name] = fn;
          }
        },
        unregisterDecorator: function unregisterDecorator(name) {
          delete this.decorators[name];
        },
        /**
         * Reset the memory of illegal property accesses that have already been logged.
         * @deprecated should only be used in handlebars test-cases
         */
        resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
          _internalProtoAccess.resetLoggedProperties();
        }
      };
      var log = _logger2["default"].log;
      exports.log = log;
      exports.createFrame = _utils.createFrame;
      exports.logger = _logger2["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/safe-string.js
  var require_safe_string = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/safe-string.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function SafeString(string) {
        this.string = string;
      }
      SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
        return "" + this.string;
      };
      exports["default"] = SafeString;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
  var require_wrapHelper = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.wrapHelper = wrapHelper;
      function wrapHelper(helper, transformOptionsFn) {
        if (typeof helper !== "function") {
          return helper;
        }
        var wrapper = function wrapper2() {
          var options = arguments[arguments.length - 1];
          arguments[arguments.length - 1] = transformOptionsFn(options);
          return helper.apply(this, arguments);
        };
        return wrapper;
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/runtime.js
  var require_runtime = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/runtime.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.checkRevision = checkRevision;
      exports.template = template;
      exports.wrapProgram = wrapProgram;
      exports.resolvePartial = resolvePartial;
      exports.invokePartial = invokePartial;
      exports.noop = noop;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _utils = require_utils();
      var Utils = _interopRequireWildcard(_utils);
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _base = require_base();
      var _helpers = require_helpers();
      var _internalWrapHelper = require_wrapHelper();
      var _internalProtoAccess = require_proto_access();
      function checkRevision(compilerInfo) {
        var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
        if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
          return;
        }
        if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
          var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
          throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
        } else {
          throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
        }
      }
      function template(templateSpec, env) {
        if (!env) {
          throw new _exception2["default"]("No environment passed to template");
        }
        if (!templateSpec || !templateSpec.main) {
          throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
        }
        templateSpec.main.decorator = templateSpec.main_d;
        env.VM.checkRevision(templateSpec.compiler);
        var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
        function invokePartialWrapper(partial, context, options) {
          if (options.hash) {
            context = Utils.extend({}, context, options.hash);
            if (options.ids) {
              options.ids[0] = true;
            }
          }
          partial = env.VM.resolvePartial.call(this, partial, context, options);
          var extendedOptions = Utils.extend({}, options, {
            hooks: this.hooks,
            protoAccessControl: this.protoAccessControl
          });
          var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
          if (result == null && env.compile) {
            options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
            result = options.partials[options.name](context, extendedOptions);
          }
          if (result != null) {
            if (options.indent) {
              var lines = result.split("\n");
              for (var i = 0, l = lines.length; i < l; i++) {
                if (!lines[i] && i + 1 === l) {
                  break;
                }
                lines[i] = options.indent + lines[i];
              }
              result = lines.join("\n");
            }
            return result;
          } else {
            throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
          }
        }
        var container = {
          strict: function strict(obj, name, loc) {
            if (!obj || !(name in obj)) {
              throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
                loc
              });
            }
            return container.lookupProperty(obj, name);
          },
          lookupProperty: function lookupProperty(parent, propertyName) {
            var result = parent[propertyName];
            if (result == null) {
              return result;
            }
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return result;
            }
            if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
              return result;
            }
            return void 0;
          },
          lookup: function lookup(depths, name) {
            var len = depths.length;
            for (var i = 0; i < len; i++) {
              var result = depths[i] && container.lookupProperty(depths[i], name);
              if (result != null) {
                return depths[i][name];
              }
            }
          },
          lambda: function lambda(current, context) {
            return typeof current === "function" ? current.call(context) : current;
          },
          escapeExpression: Utils.escapeExpression,
          invokePartial: invokePartialWrapper,
          fn: function fn(i) {
            var ret2 = templateSpec[i];
            ret2.decorator = templateSpec[i + "_d"];
            return ret2;
          },
          programs: [],
          program: function program(i, data, declaredBlockParams, blockParams, depths) {
            var programWrapper = this.programs[i], fn = this.fn(i);
            if (data || depths || blockParams || declaredBlockParams) {
              programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
            } else if (!programWrapper) {
              programWrapper = this.programs[i] = wrapProgram(this, i, fn);
            }
            return programWrapper;
          },
          data: function data(value, depth) {
            while (value && depth--) {
              value = value._parent;
            }
            return value;
          },
          mergeIfNeeded: function mergeIfNeeded(param, common) {
            var obj = param || common;
            if (param && common && param !== common) {
              obj = Utils.extend({}, common, param);
            }
            return obj;
          },
          // An empty object to use as replacement for null-contexts
          nullContext: Object.seal({}),
          noop: env.VM.noop,
          compilerInfo: templateSpec.compiler
        };
        function ret(context) {
          var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          var data = options.data;
          ret._setup(options);
          if (!options.partial && templateSpec.useData) {
            data = initData(context, data);
          }
          var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
          if (templateSpec.useDepths) {
            if (options.depths) {
              depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
            } else {
              depths = [context];
            }
          }
          function main(context2) {
            return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
          }
          main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
          return main(context, options);
        }
        ret.isTop = true;
        ret._setup = function(options) {
          if (!options.partial) {
            var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
            wrapHelpersToPassLookupProperty(mergedHelpers, container);
            container.helpers = mergedHelpers;
            if (templateSpec.usePartial) {
              container.partials = container.mergeIfNeeded(options.partials, env.partials);
            }
            if (templateSpec.usePartial || templateSpec.useDecorators) {
              container.decorators = Utils.extend({}, env.decorators, options.decorators);
            }
            container.hooks = {};
            container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
            var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
            _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
            _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
          } else {
            container.protoAccessControl = options.protoAccessControl;
            container.helpers = options.helpers;
            container.partials = options.partials;
            container.decorators = options.decorators;
            container.hooks = options.hooks;
          }
        };
        ret._child = function(i, data, blockParams, depths) {
          if (templateSpec.useBlockParams && !blockParams) {
            throw new _exception2["default"]("must pass block params");
          }
          if (templateSpec.useDepths && !depths) {
            throw new _exception2["default"]("must pass parent depths");
          }
          return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
        };
        return ret;
      }
      function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
        function prog(context) {
          var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          var currentDepths = depths;
          if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
            currentDepths = [context].concat(depths);
          }
          return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
        }
        prog = executeDecorators(fn, prog, container, depths, data, blockParams);
        prog.program = i;
        prog.depth = depths ? depths.length : 0;
        prog.blockParams = declaredBlockParams || 0;
        return prog;
      }
      function resolvePartial(partial, context, options) {
        if (!partial) {
          if (options.name === "@partial-block") {
            partial = options.data["partial-block"];
          } else {
            partial = options.partials[options.name];
          }
        } else if (!partial.call && !options.name) {
          options.name = partial;
          partial = options.partials[partial];
        }
        return partial;
      }
      function invokePartial(partial, context, options) {
        var currentPartialBlock = options.data && options.data["partial-block"];
        options.partial = true;
        if (options.ids) {
          options.data.contextPath = options.ids[0] || options.data.contextPath;
        }
        var partialBlock = void 0;
        if (options.fn && options.fn !== noop) {
          (function() {
            options.data = _base.createFrame(options.data);
            var fn = options.fn;
            partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
              var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
              options2.data = _base.createFrame(options2.data);
              options2.data["partial-block"] = currentPartialBlock;
              return fn(context2, options2);
            };
            if (fn.partials) {
              options.partials = Utils.extend({}, options.partials, fn.partials);
            }
          })();
        }
        if (partial === void 0 && partialBlock) {
          partial = partialBlock;
        }
        if (partial === void 0) {
          throw new _exception2["default"]("The partial " + options.name + " could not be found");
        } else if (partial instanceof Function) {
          return partial(context, options);
        }
      }
      function noop() {
        return "";
      }
      function initData(context, data) {
        if (!data || !("root" in data)) {
          data = data ? _base.createFrame(data) : {};
          data.root = context;
        }
        return data;
      }
      function executeDecorators(fn, prog, container, depths, data, blockParams) {
        if (fn.decorator) {
          var props = {};
          prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
          Utils.extend(prog, props);
        }
        return prog;
      }
      function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
        Object.keys(mergedHelpers).forEach(function(helperName) {
          var helper = mergedHelpers[helperName];
          mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
        });
      }
      function passLookupPropertyOption(helper, container) {
        var lookupProperty = container.lookupProperty;
        return _internalWrapHelper.wrapHelper(helper, function(options) {
          return Utils.extend({ lookupProperty }, options);
        });
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
  var require_no_conflict = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/no-conflict.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(Handlebars2) {
        (function() {
          if (typeof globalThis === "object")
            return;
          Object.prototype.__defineGetter__("__magic__", function() {
            return this;
          });
          __magic__.globalThis = __magic__;
          delete Object.prototype.__magic__;
        })();
        var $Handlebars = globalThis.Handlebars;
        Handlebars2.noConflict = function() {
          if (globalThis.Handlebars === Handlebars2) {
            globalThis.Handlebars = $Handlebars;
          }
          return Handlebars2;
        };
      };
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars.runtime.js
  var require_handlebars_runtime = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars.runtime.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _handlebarsBase = require_base();
      var base = _interopRequireWildcard(_handlebarsBase);
      var _handlebarsSafeString = require_safe_string();
      var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
      var _handlebarsException = require_exception();
      var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
      var _handlebarsUtils = require_utils();
      var Utils = _interopRequireWildcard(_handlebarsUtils);
      var _handlebarsRuntime = require_runtime();
      var runtime = _interopRequireWildcard(_handlebarsRuntime);
      var _handlebarsNoConflict = require_no_conflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      function create() {
        var hb = new base.HandlebarsEnvironment();
        Utils.extend(hb, base);
        hb.SafeString = _handlebarsSafeString2["default"];
        hb.Exception = _handlebarsException2["default"];
        hb.Utils = Utils;
        hb.escapeExpression = Utils.escapeExpression;
        hb.VM = runtime;
        hb.template = function(spec) {
          return runtime.template(spec, hb);
        };
        return hb;
      }
      var inst = create();
      inst.create = create;
      _handlebarsNoConflict2["default"](inst);
      inst["default"] = inst;
      exports["default"] = inst;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
  var require_ast = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var AST2 = {
        // Public API used to evaluate derived attributes regarding AST nodes
        helpers: {
          // a mustache is definitely a helper if:
          // * it is an eligible helper, and
          // * it has at least one parameter or hash segment
          helperExpression: function helperExpression(node) {
            return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
          },
          scopedId: function scopedId(path2) {
            return /^\.|this\b/.test(path2.original);
          },
          // an ID is simple if it only has one part, and that part is not
          // `..` or `this`.
          simpleId: function simpleId(path2) {
            return path2.parts.length === 1 && !AST2.helpers.scopedId(path2) && !path2.depth;
          }
        }
      };
      exports["default"] = AST2;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
  var require_parser = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var handlebars = function() {
        var parser = {
          trace: function trace() {
          },
          yy: {},
          symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];
                break;
              case 2:
                this.$ = yy.prepareProgram($$[$0]);
                break;
              case 3:
                this.$ = $$[$0];
                break;
              case 4:
                this.$ = $$[$0];
                break;
              case 5:
                this.$ = $$[$0];
                break;
              case 6:
                this.$ = $$[$0];
                break;
              case 7:
                this.$ = $$[$0];
                break;
              case 8:
                this.$ = $$[$0];
                break;
              case 9:
                this.$ = {
                  type: "CommentStatement",
                  value: yy.stripComment($$[$0]),
                  strip: yy.stripFlags($$[$0], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 10:
                this.$ = {
                  type: "ContentStatement",
                  original: $$[$0],
                  value: $$[$0],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 11:
                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 12:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                break;
              case 13:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                break;
              case 14:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                break;
              case 15:
                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 16:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 17:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 18:
                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                break;
              case 19:
                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                program.chained = true;
                this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
                break;
              case 20:
                this.$ = $$[$0];
                break;
              case 21:
                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                break;
              case 22:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 23:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 24:
                this.$ = {
                  type: "PartialStatement",
                  name: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  indent: "",
                  strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 25:
                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 26:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                break;
              case 27:
                this.$ = $$[$0];
                break;
              case 28:
                this.$ = $$[$0];
                break;
              case 29:
                this.$ = {
                  type: "SubExpression",
                  path: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 30:
                this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 31:
                this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 32:
                this.$ = yy.id($$[$0 - 1]);
                break;
              case 33:
                this.$ = $$[$0];
                break;
              case 34:
                this.$ = $$[$0];
                break;
              case 35:
                this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 36:
                this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                break;
              case 37:
                this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
                break;
              case 38:
                this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
                break;
              case 39:
                this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
                break;
              case 40:
                this.$ = $$[$0];
                break;
              case 41:
                this.$ = $$[$0];
                break;
              case 42:
                this.$ = yy.preparePath(true, $$[$0], this._$);
                break;
              case 43:
                this.$ = yy.preparePath(false, $$[$0], this._$);
                break;
              case 44:
                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
                this.$ = $$[$0 - 2];
                break;
              case 45:
                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                break;
              case 46:
                this.$ = [];
                break;
              case 47:
                $$[$0 - 1].push($$[$0]);
                break;
              case 48:
                this.$ = [];
                break;
              case 49:
                $$[$0 - 1].push($$[$0]);
                break;
              case 50:
                this.$ = [];
                break;
              case 51:
                $$[$0 - 1].push($$[$0]);
                break;
              case 58:
                this.$ = [];
                break;
              case 59:
                $$[$0 - 1].push($$[$0]);
                break;
              case 64:
                this.$ = [];
                break;
              case 65:
                $$[$0 - 1].push($$[$0]);
                break;
              case 70:
                this.$ = [];
                break;
              case 71:
                $$[$0 - 1].push($$[$0]);
                break;
              case 78:
                this.$ = [];
                break;
              case 79:
                $$[$0 - 1].push($$[$0]);
                break;
              case 82:
                this.$ = [];
                break;
              case 83:
                $$[$0 - 1].push($$[$0]);
                break;
              case 86:
                this.$ = [];
                break;
              case 87:
                $$[$0 - 1].push($$[$0]);
                break;
              case 90:
                this.$ = [];
                break;
              case 91:
                $$[$0 - 1].push($$[$0]);
                break;
              case 94:
                this.$ = [];
                break;
              case 95:
                $$[$0 - 1].push($$[$0]);
                break;
              case 98:
                this.$ = [$$[$0]];
                break;
              case 99:
                $$[$0 - 1].push($$[$0]);
                break;
              case 100:
                this.$ = [$$[$0]];
                break;
              case 101:
                $$[$0 - 1].push($$[$0]);
                break;
            }
          },
          table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
          defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
          parseError: function parseError(str, hash) {
            throw new Error(str);
          },
          parse: function parse7(input) {
            var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF2 = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined")
              this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function")
              this.parseError = this.yy.parseError;
            function popStack(n) {
              stack.length = stack.length - 2 * n;
              vstack.length = vstack.length - n;
              lstack.length = lstack.length - n;
            }
            function lex() {
              var token;
              token = self.lexer.lex() || 1;
              if (typeof token !== "number") {
                token = self.symbols_[token] || token;
              }
              return token;
            }
            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while (true) {
              state = stack[stack.length - 1];
              if (this.defaultActions[state]) {
                action = this.defaultActions[state];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
                }
                action = table[state] && table[state][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push("'" + this.terminals_[p] + "'");
                    }
                  if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
                }
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(this.lexer.yytext);
                  lstack.push(this.lexer.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  if (!preErrorSymbol) {
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                      recovering--;
                  } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }
                  r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                  if (typeof r !== "undefined") {
                    return r;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            setInput: function setInput(input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
              if (this.options.ranges)
                this.yylloc.range = [0, 0];
              this.offset = 0;
              return this;
            },
            input: function input() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges)
                this.yylloc.range[1]++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function unput(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1)
                this.yylineno -= lines.length - 1;
              var r = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
              }
              return this;
            },
            more: function more() {
              this._more = true;
              return this;
            },
            less: function less(n) {
              this.unput(this.match.slice(n));
            },
            pastInput: function pastInput() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function upcomingInput() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            showPosition: function showPosition() {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function next() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match2, tempMatch, index, col, lines;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {
                  match2 = tempMatch;
                  index = i;
                  if (!this.options.flex)
                    break;
                }
              }
              if (match2) {
                lines = match2[0].match(/(?:\r\n?|\n).*/g);
                if (lines)
                  this.yylineno += lines.length;
                this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match2[0].length
                };
                this.yytext += match2[0];
                this.match += match2[0];
                this.matches = match2;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._input = this._input.slice(match2[0].length);
                this.matched += match2[0];
                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input)
                  this.done = false;
                if (token)
                  return token;
                else
                  return;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== "undefined") {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function topState() {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
          lexer2.options = {};
          lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            function strip(start, end) {
              return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
            }
            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
              case 0:
                if (yy_.yytext.slice(-2) === "\\\\") {
                  strip(0, 1);
                  this.begin("mu");
                } else if (yy_.yytext.slice(-1) === "\\") {
                  strip(0, 1);
                  this.begin("emu");
                } else {
                  this.begin("mu");
                }
                if (yy_.yytext)
                  return 15;
                break;
              case 1:
                return 15;
                break;
              case 2:
                this.popState();
                return 15;
                break;
              case 3:
                this.begin("raw");
                return 15;
                break;
              case 4:
                this.popState();
                if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                  return 15;
                } else {
                  strip(5, 9);
                  return "END_RAW_BLOCK";
                }
                break;
              case 5:
                return 15;
                break;
              case 6:
                this.popState();
                return 14;
                break;
              case 7:
                return 65;
                break;
              case 8:
                return 68;
                break;
              case 9:
                return 19;
                break;
              case 10:
                this.popState();
                this.begin("raw");
                return 23;
                break;
              case 11:
                return 55;
                break;
              case 12:
                return 60;
                break;
              case 13:
                return 29;
                break;
              case 14:
                return 47;
                break;
              case 15:
                this.popState();
                return 44;
                break;
              case 16:
                this.popState();
                return 44;
                break;
              case 17:
                return 34;
                break;
              case 18:
                return 39;
                break;
              case 19:
                return 51;
                break;
              case 20:
                return 48;
                break;
              case 21:
                this.unput(yy_.yytext);
                this.popState();
                this.begin("com");
                break;
              case 22:
                this.popState();
                return 14;
                break;
              case 23:
                return 48;
                break;
              case 24:
                return 73;
                break;
              case 25:
                return 72;
                break;
              case 26:
                return 72;
                break;
              case 27:
                return 87;
                break;
              case 28:
                break;
              case 29:
                this.popState();
                return 54;
                break;
              case 30:
                this.popState();
                return 33;
                break;
              case 31:
                yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                return 80;
                break;
              case 32:
                yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                return 80;
                break;
              case 33:
                return 85;
                break;
              case 34:
                return 82;
                break;
              case 35:
                return 82;
                break;
              case 36:
                return 83;
                break;
              case 37:
                return 84;
                break;
              case 38:
                return 81;
                break;
              case 39:
                return 75;
                break;
              case 40:
                return 77;
                break;
              case 41:
                return 72;
                break;
              case 42:
                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
                return 72;
                break;
              case 43:
                return "INVALID";
                break;
              case 44:
                return 5;
                break;
            }
          };
          lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
          lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
          return lexer2;
        }();
        parser.lexer = lexer;
        function Parser() {
          this.yy = {};
        }
        Parser.prototype = parser;
        parser.Parser = Parser;
        return new Parser();
      }();
      exports["default"] = handlebars;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
  var require_visitor = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      function Visitor() {
        this.parents = [];
      }
      Visitor.prototype = {
        constructor: Visitor,
        mutating: false,
        // Visits a given value. If mutating, will replace the value if necessary.
        acceptKey: function acceptKey(node, name) {
          var value = this.accept(node[name]);
          if (this.mutating) {
            if (value && !Visitor.prototype[value.type]) {
              throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
            }
            node[name] = value;
          }
        },
        // Performs an accept operation with added sanity check to ensure
        // required keys are not removed.
        acceptRequired: function acceptRequired(node, name) {
          this.acceptKey(node, name);
          if (!node[name]) {
            throw new _exception2["default"](node.type + " requires " + name);
          }
        },
        // Traverses a given array. If mutating, empty respnses will be removed
        // for child elements.
        acceptArray: function acceptArray(array) {
          for (var i = 0, l = array.length; i < l; i++) {
            this.acceptKey(array, i);
            if (!array[i]) {
              array.splice(i, 1);
              i--;
              l--;
            }
          }
        },
        accept: function accept(object) {
          if (!object) {
            return;
          }
          if (!this[object.type]) {
            throw new _exception2["default"]("Unknown type: " + object.type, object);
          }
          if (this.current) {
            this.parents.unshift(this.current);
          }
          this.current = object;
          var ret = this[object.type](object);
          this.current = this.parents.shift();
          if (!this.mutating || ret) {
            return ret;
          } else if (ret !== false) {
            return object;
          }
        },
        Program: function Program(program) {
          this.acceptArray(program.body);
        },
        MustacheStatement: visitSubExpression,
        Decorator: visitSubExpression,
        BlockStatement: visitBlock,
        DecoratorBlock: visitBlock,
        PartialStatement: visitPartial,
        PartialBlockStatement: function PartialBlockStatement(partial) {
          visitPartial.call(this, partial);
          this.acceptKey(partial, "program");
        },
        ContentStatement: function ContentStatement() {
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: visitSubExpression,
        PathExpression: function PathExpression() {
        },
        StringLiteral: function StringLiteral() {
        },
        NumberLiteral: function NumberLiteral() {
        },
        BooleanLiteral: function BooleanLiteral() {
        },
        UndefinedLiteral: function UndefinedLiteral() {
        },
        NullLiteral: function NullLiteral() {
        },
        Hash: function Hash(hash) {
          this.acceptArray(hash.pairs);
        },
        HashPair: function HashPair(pair) {
          this.acceptRequired(pair, "value");
        }
      };
      function visitSubExpression(mustache) {
        this.acceptRequired(mustache, "path");
        this.acceptArray(mustache.params);
        this.acceptKey(mustache, "hash");
      }
      function visitBlock(block) {
        visitSubExpression.call(this, block);
        this.acceptKey(block, "program");
        this.acceptKey(block, "inverse");
      }
      function visitPartial(partial) {
        this.acceptRequired(partial, "name");
        this.acceptArray(partial.params);
        this.acceptKey(partial, "hash");
      }
      exports["default"] = Visitor;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
  var require_whitespace_control = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = require_visitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function WhitespaceControl() {
        var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
        this.options = options;
      }
      WhitespaceControl.prototype = new _visitor2["default"]();
      WhitespaceControl.prototype.Program = function(program) {
        var doStandalone = !this.options.ignoreStandalone;
        var isRoot = !this.isRootSeen;
        this.isRootSeen = true;
        var body = program.body;
        for (var i = 0, l = body.length; i < l; i++) {
          var current = body[i], strip = this.accept(current);
          if (!strip) {
            continue;
          }
          var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
          if (strip.close) {
            omitRight(body, i, true);
          }
          if (strip.open) {
            omitLeft(body, i, true);
          }
          if (doStandalone && inlineStandalone) {
            omitRight(body, i);
            if (omitLeft(body, i)) {
              if (current.type === "PartialStatement") {
                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
              }
            }
          }
          if (doStandalone && openStandalone) {
            omitRight((current.program || current.inverse).body);
            omitLeft(body, i);
          }
          if (doStandalone && closeStandalone) {
            omitRight(body, i);
            omitLeft((current.inverse || current.program).body);
          }
        }
        return program;
      };
      WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
        this.accept(block.program);
        this.accept(block.inverse);
        var program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
        if (inverse && inverse.chained) {
          firstInverse = inverse.body[0].program;
          while (lastInverse.chained) {
            lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
          }
        }
        var strip = {
          open: block.openStrip.open,
          close: block.closeStrip.close,
          // Determine the standalone candiacy. Basically flag our content as being possibly standalone
          // so our parent can determine if we actually are standalone
          openStandalone: isNextWhitespace(program.body),
          closeStandalone: isPrevWhitespace((firstInverse || program).body)
        };
        if (block.openStrip.close) {
          omitRight(program.body, null, true);
        }
        if (inverse) {
          var inverseStrip = block.inverseStrip;
          if (inverseStrip.open) {
            omitLeft(program.body, null, true);
          }
          if (inverseStrip.close) {
            omitRight(firstInverse.body, null, true);
          }
          if (block.closeStrip.open) {
            omitLeft(lastInverse.body, null, true);
          }
          if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
            omitLeft(program.body);
            omitRight(firstInverse.body);
          }
        } else if (block.closeStrip.open) {
          omitLeft(program.body, null, true);
        }
        return strip;
      };
      WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
        return mustache.strip;
      };
      WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
        var strip = node.strip || {};
        return {
          inlineStandalone: true,
          open: strip.open,
          close: strip.close
        };
      };
      function isPrevWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = body.length;
        }
        var prev = body[i - 1], sibling = body[i - 2];
        if (!prev) {
          return isRoot;
        }
        if (prev.type === "ContentStatement") {
          return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
        }
      }
      function isNextWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = -1;
        }
        var next = body[i + 1], sibling = body[i + 2];
        if (!next) {
          return isRoot;
        }
        if (next.type === "ContentStatement") {
          return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
        }
      }
      function omitRight(body, i, multiple) {
        var current = body[i == null ? 0 : i + 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
        current.rightStripped = current.value !== original;
      }
      function omitLeft(body, i, multiple) {
        var current = body[i == null ? body.length - 1 : i - 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
        current.leftStripped = current.value !== original;
        return current.leftStripped;
      }
      exports["default"] = WhitespaceControl;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
  var require_helpers2 = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.SourceLocation = SourceLocation;
      exports.id = id;
      exports.stripFlags = stripFlags;
      exports.stripComment = stripComment;
      exports.preparePath = preparePath;
      exports.prepareMustache = prepareMustache;
      exports.prepareRawBlock = prepareRawBlock;
      exports.prepareBlock = prepareBlock;
      exports.prepareProgram = prepareProgram;
      exports.preparePartialBlock = preparePartialBlock;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      function validateClose(open, close) {
        close = close.path ? close.path.original : close;
        if (open.path.original !== close) {
          var errorNode = { loc: open.path.loc };
          throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
        }
      }
      function SourceLocation(source, locInfo) {
        this.source = source;
        this.start = {
          line: locInfo.first_line,
          column: locInfo.first_column
        };
        this.end = {
          line: locInfo.last_line,
          column: locInfo.last_column
        };
      }
      function id(token) {
        if (/^\[.*\]$/.test(token)) {
          return token.substring(1, token.length - 1);
        } else {
          return token;
        }
      }
      function stripFlags(open, close) {
        return {
          open: open.charAt(2) === "~",
          close: close.charAt(close.length - 3) === "~"
        };
      }
      function stripComment(comment) {
        return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
      }
      function preparePath(data, parts, loc) {
        loc = this.locInfo(loc);
        var original = data ? "@" : "", dig = [], depth = 0;
        for (var i = 0, l = parts.length; i < l; i++) {
          var part = parts[i].part, isLiteral = parts[i].original !== part;
          original += (parts[i].separator || "") + part;
          if (!isLiteral && (part === ".." || part === "." || part === "this")) {
            if (dig.length > 0) {
              throw new _exception2["default"]("Invalid path: " + original, { loc });
            } else if (part === "..") {
              depth++;
            }
          } else {
            dig.push(part);
          }
        }
        return {
          type: "PathExpression",
          data,
          depth,
          parts: dig,
          original,
          loc
        };
      }
      function prepareMustache(path2, params, hash, open, strip, locInfo) {
        var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
        var decorator = /\*/.test(open);
        return {
          type: decorator ? "Decorator" : "MustacheStatement",
          path: path2,
          params,
          hash,
          escaped,
          strip,
          loc: this.locInfo(locInfo)
        };
      }
      function prepareRawBlock(openRawBlock, contents, close, locInfo) {
        validateClose(openRawBlock, close);
        locInfo = this.locInfo(locInfo);
        var program = {
          type: "Program",
          body: contents,
          strip: {},
          loc: locInfo
        };
        return {
          type: "BlockStatement",
          path: openRawBlock.path,
          params: openRawBlock.params,
          hash: openRawBlock.hash,
          program,
          openStrip: {},
          inverseStrip: {},
          closeStrip: {},
          loc: locInfo
        };
      }
      function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
        if (close && close.path) {
          validateClose(openBlock, close);
        }
        var decorator = /\*/.test(openBlock.open);
        program.blockParams = openBlock.blockParams;
        var inverse = void 0, inverseStrip = void 0;
        if (inverseAndProgram) {
          if (decorator) {
            throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
          }
          if (inverseAndProgram.chain) {
            inverseAndProgram.program.body[0].closeStrip = close.strip;
          }
          inverseStrip = inverseAndProgram.strip;
          inverse = inverseAndProgram.program;
        }
        if (inverted) {
          inverted = inverse;
          inverse = program;
          program = inverted;
        }
        return {
          type: decorator ? "DecoratorBlock" : "BlockStatement",
          path: openBlock.path,
          params: openBlock.params,
          hash: openBlock.hash,
          program,
          inverse,
          openStrip: openBlock.strip,
          inverseStrip,
          closeStrip: close && close.strip,
          loc: this.locInfo(locInfo)
        };
      }
      function prepareProgram(statements, loc) {
        if (!loc && statements.length) {
          var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
          if (firstLoc && lastLoc) {
            loc = {
              source: firstLoc.source,
              start: {
                line: firstLoc.start.line,
                column: firstLoc.start.column
              },
              end: {
                line: lastLoc.end.line,
                column: lastLoc.end.column
              }
            };
          }
        }
        return {
          type: "Program",
          body: statements,
          strip: {},
          loc
        };
      }
      function preparePartialBlock(open, program, close, locInfo) {
        validateClose(open, close);
        return {
          type: "PartialBlockStatement",
          name: open.path,
          params: open.params,
          hash: open.hash,
          program,
          openStrip: open.strip,
          closeStrip: close && close.strip,
          loc: this.locInfo(locInfo)
        };
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
  var require_base2 = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.parseWithoutProcessing = parseWithoutProcessing;
      exports.parse = parse7;
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _parser = require_parser();
      var _parser2 = _interopRequireDefault(_parser);
      var _whitespaceControl = require_whitespace_control();
      var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
      var _helpers = require_helpers2();
      var Helpers = _interopRequireWildcard(_helpers);
      var _utils = require_utils();
      exports.parser = _parser2["default"];
      var yy = {};
      _utils.extend(yy, Helpers);
      function parseWithoutProcessing(input, options) {
        if (input.type === "Program") {
          return input;
        }
        _parser2["default"].yy = yy;
        yy.locInfo = function(locInfo) {
          return new yy.SourceLocation(options && options.srcName, locInfo);
        };
        var ast = _parser2["default"].parse(input);
        return ast;
      }
      function parse7(input, options) {
        var ast = parseWithoutProcessing(input, options);
        var strip = new _whitespaceControl2["default"](options);
        return strip.accept(ast);
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
  var require_compiler = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Compiler = Compiler;
      exports.precompile = precompile;
      exports.compile = compile;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = require_utils();
      var _ast = require_ast();
      var _ast2 = _interopRequireDefault(_ast);
      var slice = [].slice;
      function Compiler() {
      }
      Compiler.prototype = {
        compiler: Compiler,
        equals: function equals3(other) {
          var len = this.opcodes.length;
          if (other.opcodes.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
            if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
              return false;
            }
          }
          len = this.children.length;
          for (var i = 0; i < len; i++) {
            if (!this.children[i].equals(other.children[i])) {
              return false;
            }
          }
          return true;
        },
        guid: 0,
        compile: function compile2(program, options) {
          this.sourceNode = [];
          this.opcodes = [];
          this.children = [];
          this.options = options;
          this.stringParams = options.stringParams;
          this.trackIds = options.trackIds;
          options.blockParams = options.blockParams || [];
          options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
            helperMissing: true,
            blockHelperMissing: true,
            each: true,
            "if": true,
            unless: true,
            "with": true,
            log: true,
            lookup: true
          }, options.knownHelpers);
          return this.accept(program);
        },
        compileProgram: function compileProgram(program) {
          var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
          this.usePartial = this.usePartial || result.usePartial;
          this.children[guid] = result;
          this.useDepths = this.useDepths || result.useDepths;
          return guid;
        },
        accept: function accept(node) {
          if (!this[node.type]) {
            throw new _exception2["default"]("Unknown type: " + node.type, node);
          }
          this.sourceNode.unshift(node);
          var ret = this[node.type](node);
          this.sourceNode.shift();
          return ret;
        },
        Program: function Program(program) {
          this.options.blockParams.unshift(program.blockParams);
          var body = program.body, bodyLength = body.length;
          for (var i = 0; i < bodyLength; i++) {
            this.accept(body[i]);
          }
          this.options.blockParams.shift();
          this.isSimple = bodyLength === 1;
          this.blockParams = program.blockParams ? program.blockParams.length : 0;
          return this;
        },
        BlockStatement: function BlockStatement(block) {
          transformLiteralToPath(block);
          var program = block.program, inverse = block.inverse;
          program = program && this.compileProgram(program);
          inverse = inverse && this.compileProgram(inverse);
          var type3 = this.classifySexpr(block);
          if (type3 === "helper") {
            this.helperSexpr(block, program, inverse);
          } else if (type3 === "simple") {
            this.simpleSexpr(block);
            this.opcode("pushProgram", program);
            this.opcode("pushProgram", inverse);
            this.opcode("emptyHash");
            this.opcode("blockValue", block.path.original);
          } else {
            this.ambiguousSexpr(block, program, inverse);
            this.opcode("pushProgram", program);
            this.opcode("pushProgram", inverse);
            this.opcode("emptyHash");
            this.opcode("ambiguousBlockValue");
          }
          this.opcode("append");
        },
        DecoratorBlock: function DecoratorBlock(decorator) {
          var program = decorator.program && this.compileProgram(decorator.program);
          var params = this.setupFullMustacheParams(decorator, program, void 0), path2 = decorator.path;
          this.useDecorators = true;
          this.opcode("registerDecorator", params.length, path2.original);
        },
        PartialStatement: function PartialStatement(partial) {
          this.usePartial = true;
          var program = partial.program;
          if (program) {
            program = this.compileProgram(partial.program);
          }
          var params = partial.params;
          if (params.length > 1) {
            throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
          } else if (!params.length) {
            if (this.options.explicitPartialContext) {
              this.opcode("pushLiteral", "undefined");
            } else {
              params.push({ type: "PathExpression", parts: [], depth: 0 });
            }
          }
          var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
          if (isDynamic) {
            this.accept(partial.name);
          }
          this.setupFullMustacheParams(partial, program, void 0, true);
          var indent = partial.indent || "";
          if (this.options.preventIndent && indent) {
            this.opcode("appendContent", indent);
            indent = "";
          }
          this.opcode("invokePartial", isDynamic, partialName, indent);
          this.opcode("append");
        },
        PartialBlockStatement: function PartialBlockStatement(partialBlock) {
          this.PartialStatement(partialBlock);
        },
        MustacheStatement: function MustacheStatement(mustache) {
          this.SubExpression(mustache);
          if (mustache.escaped && !this.options.noEscape) {
            this.opcode("appendEscaped");
          } else {
            this.opcode("append");
          }
        },
        Decorator: function Decorator(decorator) {
          this.DecoratorBlock(decorator);
        },
        ContentStatement: function ContentStatement(content) {
          if (content.value) {
            this.opcode("appendContent", content.value);
          }
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: function SubExpression(sexpr) {
          transformLiteralToPath(sexpr);
          var type3 = this.classifySexpr(sexpr);
          if (type3 === "simple") {
            this.simpleSexpr(sexpr);
          } else if (type3 === "helper") {
            this.helperSexpr(sexpr);
          } else {
            this.ambiguousSexpr(sexpr);
          }
        },
        ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
          var path2 = sexpr.path, name = path2.parts[0], isBlock = program != null || inverse != null;
          this.opcode("getContext", path2.depth);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          path2.strict = true;
          this.accept(path2);
          this.opcode("invokeAmbiguous", name, isBlock);
        },
        simpleSexpr: function simpleSexpr(sexpr) {
          var path2 = sexpr.path;
          path2.strict = true;
          this.accept(path2);
          this.opcode("resolvePossibleLambda");
        },
        helperSexpr: function helperSexpr(sexpr, program, inverse) {
          var params = this.setupFullMustacheParams(sexpr, program, inverse), path2 = sexpr.path, name = path2.parts[0];
          if (this.options.knownHelpers[name]) {
            this.opcode("invokeKnownHelper", params.length, name);
          } else if (this.options.knownHelpersOnly) {
            throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
          } else {
            path2.strict = true;
            path2.falsy = true;
            this.accept(path2);
            this.opcode("invokeHelper", params.length, path2.original, _ast2["default"].helpers.simpleId(path2));
          }
        },
        PathExpression: function PathExpression(path2) {
          this.addDepth(path2.depth);
          this.opcode("getContext", path2.depth);
          var name = path2.parts[0], scoped = _ast2["default"].helpers.scopedId(path2), blockParamId = !path2.depth && !scoped && this.blockParamIndex(name);
          if (blockParamId) {
            this.opcode("lookupBlockParam", blockParamId, path2.parts);
          } else if (!name) {
            this.opcode("pushContext");
          } else if (path2.data) {
            this.options.data = true;
            this.opcode("lookupData", path2.depth, path2.parts, path2.strict);
          } else {
            this.opcode("lookupOnContext", path2.parts, path2.falsy, path2.strict, scoped);
          }
        },
        StringLiteral: function StringLiteral(string) {
          this.opcode("pushString", string.value);
        },
        NumberLiteral: function NumberLiteral(number) {
          this.opcode("pushLiteral", number.value);
        },
        BooleanLiteral: function BooleanLiteral(bool) {
          this.opcode("pushLiteral", bool.value);
        },
        UndefinedLiteral: function UndefinedLiteral() {
          this.opcode("pushLiteral", "undefined");
        },
        NullLiteral: function NullLiteral() {
          this.opcode("pushLiteral", "null");
        },
        Hash: function Hash(hash) {
          var pairs = hash.pairs, i = 0, l = pairs.length;
          this.opcode("pushHash");
          for (; i < l; i++) {
            this.pushParam(pairs[i].value);
          }
          while (i--) {
            this.opcode("assignToHash", pairs[i].key);
          }
          this.opcode("popHash");
        },
        // HELPERS
        opcode: function opcode(name) {
          this.opcodes.push({
            opcode: name,
            args: slice.call(arguments, 1),
            loc: this.sourceNode[0].loc
          });
        },
        addDepth: function addDepth(depth) {
          if (!depth) {
            return;
          }
          this.useDepths = true;
        },
        classifySexpr: function classifySexpr(sexpr) {
          var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
          var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
          var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
          var isEligible = !isBlockParam && (isHelper || isSimple);
          if (isEligible && !isHelper) {
            var _name = sexpr.path.parts[0], options = this.options;
            if (options.knownHelpers[_name]) {
              isHelper = true;
            } else if (options.knownHelpersOnly) {
              isEligible = false;
            }
          }
          if (isHelper) {
            return "helper";
          } else if (isEligible) {
            return "ambiguous";
          } else {
            return "simple";
          }
        },
        pushParams: function pushParams(params) {
          for (var i = 0, l = params.length; i < l; i++) {
            this.pushParam(params[i]);
          }
        },
        pushParam: function pushParam(val) {
          var value = val.value != null ? val.value : val.original || "";
          if (this.stringParams) {
            if (value.replace) {
              value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
            }
            if (val.depth) {
              this.addDepth(val.depth);
            }
            this.opcode("getContext", val.depth || 0);
            this.opcode("pushStringParam", value, val.type);
            if (val.type === "SubExpression") {
              this.accept(val);
            }
          } else {
            if (this.trackIds) {
              var blockParamIndex = void 0;
              if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
                blockParamIndex = this.blockParamIndex(val.parts[0]);
              }
              if (blockParamIndex) {
                var blockParamChild = val.parts.slice(1).join(".");
                this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
              } else {
                value = val.original || value;
                if (value.replace) {
                  value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
                }
                this.opcode("pushId", val.type, value);
              }
            }
            this.accept(val);
          }
        },
        setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
          var params = sexpr.params;
          this.pushParams(params);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          if (sexpr.hash) {
            this.accept(sexpr.hash);
          } else {
            this.opcode("emptyHash", omitEmpty);
          }
          return params;
        },
        blockParamIndex: function blockParamIndex(name) {
          for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
            var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
            if (blockParams && param >= 0) {
              return [depth, param];
            }
          }
        }
      };
      function precompile(input, options, env) {
        if (input == null || typeof input !== "string" && input.type !== "Program") {
          throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
        }
        options = options || {};
        if (!("data" in options)) {
          options.data = true;
        }
        if (options.compat) {
          options.useDepths = true;
        }
        var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
        return new env.JavaScriptCompiler().compile(environment, options);
      }
      function compile(input, options, env) {
        if (options === void 0)
          options = {};
        if (input == null || typeof input !== "string" && input.type !== "Program") {
          throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
        }
        options = _utils.extend({}, options);
        if (!("data" in options)) {
          options.data = true;
        }
        if (options.compat) {
          options.useDepths = true;
        }
        var compiled = void 0;
        function compileInput() {
          var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
          return env.template(templateSpec);
        }
        function ret(context, execOptions) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled.call(this, context, execOptions);
        }
        ret._setup = function(setupOptions) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled._setup(setupOptions);
        };
        ret._child = function(i, data, blockParams, depths) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled._child(i, data, blockParams, depths);
        };
        return ret;
      }
      function argEquals(a, b) {
        if (a === b) {
          return true;
        }
        if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
          for (var i = 0; i < a.length; i++) {
            if (!argEquals(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
      }
      function transformLiteralToPath(sexpr) {
        if (!sexpr.path.parts) {
          var literal = sexpr.path;
          sexpr.path = {
            type: "PathExpression",
            data: false,
            depth: 0,
            parts: [literal.original + ""],
            original: literal.original + "",
            loc: literal.loc
          };
        }
      }
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
  var require_base64 = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      exports.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
  var require_util = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match2 = aUrl.match(urlRegexp);
        if (!match2) {
          return null;
        }
        return {
          scheme: match2[1],
          auth: match2[2],
          host: match2[3],
          port: match2[4],
          path: match2[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize2(aPath) {
        var path2 = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path2 = url.path;
        }
        var isAbsolute = exports.isAbsolute(path2);
        var parts = path2.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path2 = parts.join("/");
        if (path2 === "") {
          path2 = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path2;
          return urlGenerate(url);
        }
        return path2;
      }
      exports.normalize = normalize2;
      function join4(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join4;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity2(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity2 : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity2 : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join4(urlGenerate(parsed), sourceURL);
        }
        return normalize2(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
  var require_array_set = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js"(exports) {
      var util = require_util();
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js"(exports) {
      var util = require_util();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util = require_util();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, "generated");
        var original = util.getArg(aArgs, "original", null);
        var source = util.getArg(aArgs, "source", null);
        var name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ",";
            }
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js
  var require_binary_search = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js"(exports) {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports.GREATEST_LOWER_BOUND
        );
        if (index < 0) {
          return -1;
        }
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
        return index;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js
  var require_quick_sort = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js"(exports) {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1;
          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }
      exports.quickSort = function(ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js
  var require_source_map_consumer = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js"(exports) {
      var util = require_util();
      var binarySearch = require_binary_search();
      var ArraySet = require_array_set().ArraySet;
      var base64VLQ = require_base64_vlq();
      var quickSort = require_quick_sort().quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };
      SourceMapConsumer.prototype._version = 3;
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function(mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context);
      };
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, "line");
        var needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (aArgs.column === void 0) {
            var originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      };
      exports.SourceMapConsumer = SourceMapConsumer;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version3 = util.getArg(sourceMap, "version");
        var sources = util.getArg(sourceMap, "sources");
        var names = util.getArg(sourceMap, "names", []);
        var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        var mappings = util.getArg(sourceMap, "mappings");
        var file = util.getArg(sourceMap, "file", null);
        if (version3 != this._version) {
          throw new Error("Unsupported version: " + version3);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util.normalize).map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function(s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
      BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        var i;
        for (i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      };
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(
          smc._sources.toArray(),
          smc.sourceRoot
        );
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function(s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
        return smc;
      };
      BasicSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function() {
          return this._absoluteSources.slice();
        }
      });
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        while (index < length) {
          if (aStr.charAt(index) === ";") {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
          } else if (aStr.charAt(index) === ",") {
            index++;
          } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index, end);
            segment = cachedSegments[str];
            if (segment) {
              index += str.length;
            } else {
              segment = [];
              while (index < end) {
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
              }
              if (segment.length === 2) {
                throw new Error("Found a source, but no line and column");
              }
              if (segment.length === 3) {
                throw new Error("Found a source and line, but no column");
              }
              cachedSegments[str] = segment;
            }
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
              if (segment.length > 4) {
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === "number") {
              originalMappings.push(mapping);
            }
          }
        }
        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
        quickSort(originalMappings, util.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = Infinity;
        }
      };
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util.compareByGeneratedPositionsDeflated,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      };
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version3 = util.getArg(sourceMap, "version");
        var sections = util.getArg(sourceMap, "sections");
        if (version3 != this._version) {
          throw new Error("Unsupported version: " + version3);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function(s) {
          if (s.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          var offset = util.getArg(s, "offset");
          var offsetLine = util.getArg(offset, "line");
          var offsetColumn = util.getArg(offset, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
      IndexedSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function() {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }
      });
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      };
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }
            var adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js
  var require_source_node = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js"(exports) {
      var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      var util = require_util();
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node = new SourceNode();
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map };
      };
      exports.SourceNode = SourceNode;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js
  var require_source_map = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js"(exports) {
      exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
      exports.SourceNode = require_source_node().SourceNode;
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
  var require_code_gen = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      var SourceNode = void 0;
      try {
        if (typeof define !== "function" || !define.amd) {
          SourceMap = require_source_map();
          SourceNode = SourceMap.SourceNode;
        }
      } catch (err) {
      }
      var SourceMap;
      if (!SourceNode) {
        SourceNode = function(line, column, srcFile, chunks) {
          this.src = "";
          if (chunks) {
            this.add(chunks);
          }
        };
        SourceNode.prototype = {
          add: function add(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src += chunks;
          },
          prepend: function prepend(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src = chunks + this.src;
          },
          toStringWithSourceMap: function toStringWithSourceMap() {
            return { code: this.toString() };
          },
          toString: function toString2() {
            return this.src;
          }
        };
      }
      function castChunk(chunk, codeGen, loc) {
        if (_utils.isArray(chunk)) {
          var ret = [];
          for (var i = 0, len = chunk.length; i < len; i++) {
            ret.push(codeGen.wrap(chunk[i], loc));
          }
          return ret;
        } else if (typeof chunk === "boolean" || typeof chunk === "number") {
          return chunk + "";
        }
        return chunk;
      }
      function CodeGen(srcFile) {
        this.srcFile = srcFile;
        this.source = [];
      }
      CodeGen.prototype = {
        isEmpty: function isEmpty() {
          return !this.source.length;
        },
        prepend: function prepend(source, loc) {
          this.source.unshift(this.wrap(source, loc));
        },
        push: function push(source, loc) {
          this.source.push(this.wrap(source, loc));
        },
        merge: function merge() {
          var source = this.empty();
          this.each(function(line) {
            source.add(["  ", line, "\n"]);
          });
          return source;
        },
        each: function each(iter) {
          for (var i = 0, len = this.source.length; i < len; i++) {
            iter(this.source[i]);
          }
        },
        empty: function empty() {
          var loc = this.currentLocation || { start: {} };
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
        },
        wrap: function wrap2(chunk) {
          var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
          if (chunk instanceof SourceNode) {
            return chunk;
          }
          chunk = castChunk(chunk, this, loc);
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
        },
        functionCall: function functionCall(fn, type3, params) {
          params = this.generateList(params);
          return this.wrap([fn, type3 ? "." + type3 + "(" : "(", params, ")"]);
        },
        quotedString: function quotedString(str) {
          return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
        },
        objectLiteral: function objectLiteral(obj) {
          var _this = this;
          var pairs = [];
          Object.keys(obj).forEach(function(key) {
            var value = castChunk(obj[key], _this);
            if (value !== "undefined") {
              pairs.push([_this.quotedString(key), ":", value]);
            }
          });
          var ret = this.generateList(pairs);
          ret.prepend("{");
          ret.add("}");
          return ret;
        },
        generateList: function generateList(entries) {
          var ret = this.empty();
          for (var i = 0, len = entries.length; i < len; i++) {
            if (i) {
              ret.add(",");
            }
            ret.add(castChunk(entries[i], this));
          }
          return ret;
        },
        generateArray: function generateArray(entries) {
          var ret = this.generateList(entries);
          ret.prepend("[");
          ret.add("]");
          return ret;
        }
      };
      exports["default"] = CodeGen;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
  var require_javascript_compiler = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _base = require_base();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = require_utils();
      var _codeGen = require_code_gen();
      var _codeGen2 = _interopRequireDefault(_codeGen);
      function Literal(value) {
        this.value = value;
      }
      function JavaScriptCompiler() {
      }
      JavaScriptCompiler.prototype = {
        // PUBLIC API: You can override these methods in a subclass to provide
        // alternative compiled forms for name lookup and buffering semantics
        nameLookup: function nameLookup(parent, name) {
          return this.internalNameLookup(parent, name);
        },
        depthedLookup: function depthedLookup(name) {
          return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
        },
        compilerInfo: function compilerInfo() {
          var revision = _base.COMPILER_REVISION, versions2 = _base.REVISION_CHANGES[revision];
          return [revision, versions2];
        },
        appendToBuffer: function appendToBuffer(source, location, explicit) {
          if (!_utils.isArray(source)) {
            source = [source];
          }
          source = this.source.wrap(source, location);
          if (this.environment.isSimple) {
            return ["return ", source, ";"];
          } else if (explicit) {
            return ["buffer += ", source, ";"];
          } else {
            source.appendToBuffer = true;
            return source;
          }
        },
        initializeBuffer: function initializeBuffer() {
          return this.quotedString("");
        },
        // END PUBLIC API
        internalNameLookup: function internalNameLookup(parent, name) {
          this.lookupPropertyFunctionIsUsed = true;
          return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
        },
        lookupPropertyFunctionIsUsed: false,
        compile: function compile(environment, options, context, asObject) {
          this.environment = environment;
          this.options = options;
          this.stringParams = this.options.stringParams;
          this.trackIds = this.options.trackIds;
          this.precompile = !asObject;
          this.name = this.environment.name;
          this.isChild = !!context;
          this.context = context || {
            decorators: [],
            programs: [],
            environments: []
          };
          this.preamble();
          this.stackSlot = 0;
          this.stackVars = [];
          this.aliases = {};
          this.registers = { list: [] };
          this.hashes = [];
          this.compileStack = [];
          this.inlineStack = [];
          this.blockParams = [];
          this.compileChildren(environment, options);
          this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
          this.useBlockParams = this.useBlockParams || environment.useBlockParams;
          var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
          for (i = 0, l = opcodes.length; i < l; i++) {
            opcode = opcodes[i];
            this.source.currentLocation = opcode.loc;
            firstLoc = firstLoc || opcode.loc;
            this[opcode.opcode].apply(this, opcode.args);
          }
          this.source.currentLocation = firstLoc;
          this.pushSource("");
          if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
            throw new _exception2["default"]("Compile completed with content left on stack");
          }
          if (!this.decorators.isEmpty()) {
            this.useDecorators = true;
            this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
            this.decorators.push("return fn;");
            if (asObject) {
              this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
            } else {
              this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
              this.decorators.push("}\n");
              this.decorators = this.decorators.merge();
            }
          } else {
            this.decorators = void 0;
          }
          var fn = this.createFunctionContext(asObject);
          if (!this.isChild) {
            var ret = {
              compiler: this.compilerInfo(),
              main: fn
            };
            if (this.decorators) {
              ret.main_d = this.decorators;
              ret.useDecorators = true;
            }
            var _context = this.context;
            var programs = _context.programs;
            var decorators = _context.decorators;
            for (i = 0, l = programs.length; i < l; i++) {
              if (programs[i]) {
                ret[i] = programs[i];
                if (decorators[i]) {
                  ret[i + "_d"] = decorators[i];
                  ret.useDecorators = true;
                }
              }
            }
            if (this.environment.usePartial) {
              ret.usePartial = true;
            }
            if (this.options.data) {
              ret.useData = true;
            }
            if (this.useDepths) {
              ret.useDepths = true;
            }
            if (this.useBlockParams) {
              ret.useBlockParams = true;
            }
            if (this.options.compat) {
              ret.compat = true;
            }
            if (!asObject) {
              ret.compiler = JSON.stringify(ret.compiler);
              this.source.currentLocation = { start: { line: 1, column: 0 } };
              ret = this.objectLiteral(ret);
              if (options.srcName) {
                ret = ret.toStringWithSourceMap({ file: options.destName });
                ret.map = ret.map && ret.map.toString();
              } else {
                ret = ret.toString();
              }
            } else {
              ret.compilerOptions = this.options;
            }
            return ret;
          } else {
            return fn;
          }
        },
        preamble: function preamble() {
          this.lastContext = 0;
          this.source = new _codeGen2["default"](this.options.srcName);
          this.decorators = new _codeGen2["default"](this.options.srcName);
        },
        createFunctionContext: function createFunctionContext(asObject) {
          var _this = this;
          var varDeclarations = "";
          var locals = this.stackVars.concat(this.registers.list);
          if (locals.length > 0) {
            varDeclarations += ", " + locals.join(", ");
          }
          var aliasCount = 0;
          Object.keys(this.aliases).forEach(function(alias) {
            var node = _this.aliases[alias];
            if (node.children && node.referenceCount > 1) {
              varDeclarations += ", alias" + ++aliasCount + "=" + alias;
              node.children[0] = "alias" + aliasCount;
            }
          });
          if (this.lookupPropertyFunctionIsUsed) {
            varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
          }
          var params = ["container", "depth0", "helpers", "partials", "data"];
          if (this.useBlockParams || this.useDepths) {
            params.push("blockParams");
          }
          if (this.useDepths) {
            params.push("depths");
          }
          var source = this.mergeSource(varDeclarations);
          if (asObject) {
            params.push(source);
            return Function.apply(this, params);
          } else {
            return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
          }
        },
        mergeSource: function mergeSource(varDeclarations) {
          var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
          this.source.each(function(line) {
            if (line.appendToBuffer) {
              if (bufferStart) {
                line.prepend("  + ");
              } else {
                bufferStart = line;
              }
              bufferEnd = line;
            } else {
              if (bufferStart) {
                if (!sourceSeen) {
                  appendFirst = true;
                } else {
                  bufferStart.prepend("buffer += ");
                }
                bufferEnd.add(";");
                bufferStart = bufferEnd = void 0;
              }
              sourceSeen = true;
              if (!isSimple) {
                appendOnly = false;
              }
            }
          });
          if (appendOnly) {
            if (bufferStart) {
              bufferStart.prepend("return ");
              bufferEnd.add(";");
            } else if (!sourceSeen) {
              this.source.push('return "";');
            }
          } else {
            varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
            if (bufferStart) {
              bufferStart.prepend("return buffer + ");
              bufferEnd.add(";");
            } else {
              this.source.push("return buffer;");
            }
          }
          if (varDeclarations) {
            this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
          }
          return this.source.merge();
        },
        lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
          return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
        },
        // [blockValue]
        //
        // On stack, before: hash, inverse, program, value
        // On stack, after: return value of blockHelperMissing
        //
        // The purpose of this opcode is to take a block of the form
        // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
        // replace it on the stack with the result of properly
        // invoking blockHelperMissing.
        blockValue: function blockValue(name) {
          var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs(name, 0, params);
          var blockName = this.popStack();
          params.splice(1, 0, blockName);
          this.push(this.source.functionCall(blockHelperMissing, "call", params));
        },
        // [ambiguousBlockValue]
        //
        // On stack, before: hash, inverse, program, value
        // Compiler value, before: lastHelper=value of last found helper, if any
        // On stack, after, if no lastHelper: same as [blockValue]
        // On stack, after, if lastHelper: value
        ambiguousBlockValue: function ambiguousBlockValue() {
          var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs("", 0, params, true);
          this.flushInline();
          var current = this.topStack();
          params.splice(1, 0, current);
          this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
        },
        // [appendContent]
        //
        // On stack, before: ...
        // On stack, after: ...
        //
        // Appends the string value of `content` to the current buffer
        appendContent: function appendContent(content) {
          if (this.pendingContent) {
            content = this.pendingContent + content;
          } else {
            this.pendingLocation = this.source.currentLocation;
          }
          this.pendingContent = content;
        },
        // [append]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Coerces `value` to a String and appends it to the current buffer.
        //
        // If `value` is truthy, or 0, it is coerced into a string and appended
        // Otherwise, the empty string is appended
        append: function append() {
          if (this.isInline()) {
            this.replaceStack(function(current) {
              return [" != null ? ", current, ' : ""'];
            });
            this.pushSource(this.appendToBuffer(this.popStack()));
          } else {
            var local = this.popStack();
            this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
            if (this.environment.isSimple) {
              this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
            }
          }
        },
        // [appendEscaped]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Escape `value` and append it to the buffer
        appendEscaped: function appendEscaped() {
          this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
        },
        // [getContext]
        //
        // On stack, before: ...
        // On stack, after: ...
        // Compiler value, after: lastContext=depth
        //
        // Set the value of the `lastContext` compiler value to the depth
        getContext: function getContext(depth) {
          this.lastContext = depth;
        },
        // [pushContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext, ...
        //
        // Pushes the value of the current context onto the stack.
        pushContext: function pushContext() {
          this.pushStackLiteral(this.contextName(this.lastContext));
        },
        // [lookupOnContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext[name], ...
        //
        // Looks up the value of `name` on the current context and pushes
        // it onto the stack.
        lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
          var i = 0;
          if (!scoped && this.options.compat && !this.lastContext) {
            this.push(this.depthedLookup(parts[i++]));
          } else {
            this.pushContext();
          }
          this.resolvePath("context", parts, i, falsy, strict);
        },
        // [lookupBlockParam]
        //
        // On stack, before: ...
        // On stack, after: blockParam[name], ...
        //
        // Looks up the value of `parts` on the given block param and pushes
        // it onto the stack.
        lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
          this.useBlockParams = true;
          this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
          this.resolvePath("context", parts, 1);
        },
        // [lookupData]
        //
        // On stack, before: ...
        // On stack, after: data, ...
        //
        // Push the data lookup operator
        lookupData: function lookupData(depth, parts, strict) {
          if (!depth) {
            this.pushStackLiteral("data");
          } else {
            this.pushStackLiteral("container.data(data, " + depth + ")");
          }
          this.resolvePath("data", parts, 0, true, strict);
        },
        resolvePath: function resolvePath(type3, parts, i, falsy, strict) {
          var _this2 = this;
          if (this.options.strict || this.options.assumeObjects) {
            this.push(strictLookup(this.options.strict && strict, this, parts, i, type3));
            return;
          }
          var len = parts.length;
          for (; i < len; i++) {
            this.replaceStack(function(current) {
              var lookup = _this2.nameLookup(current, parts[i], type3);
              if (!falsy) {
                return [" != null ? ", lookup, " : ", current];
              } else {
                return [" && ", lookup];
              }
            });
          }
        },
        // [resolvePossibleLambda]
        //
        // On stack, before: value, ...
        // On stack, after: resolved value, ...
        //
        // If the `value` is a lambda, replace it on the stack by
        // the return value of the lambda
        resolvePossibleLambda: function resolvePossibleLambda() {
          this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
        },
        // [pushStringParam]
        //
        // On stack, before: ...
        // On stack, after: string, currentContext, ...
        //
        // This opcode is designed for use in string mode, which
        // provides the string value of a parameter along with its
        // depth rather than resolving it immediately.
        pushStringParam: function pushStringParam(string, type3) {
          this.pushContext();
          this.pushString(type3);
          if (type3 !== "SubExpression") {
            if (typeof string === "string") {
              this.pushString(string);
            } else {
              this.pushStackLiteral(string);
            }
          }
        },
        emptyHash: function emptyHash(omitEmpty) {
          if (this.trackIds) {
            this.push("{}");
          }
          if (this.stringParams) {
            this.push("{}");
            this.push("{}");
          }
          this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
        },
        pushHash: function pushHash() {
          if (this.hash) {
            this.hashes.push(this.hash);
          }
          this.hash = { values: {}, types: [], contexts: [], ids: [] };
        },
        popHash: function popHash() {
          var hash = this.hash;
          this.hash = this.hashes.pop();
          if (this.trackIds) {
            this.push(this.objectLiteral(hash.ids));
          }
          if (this.stringParams) {
            this.push(this.objectLiteral(hash.contexts));
            this.push(this.objectLiteral(hash.types));
          }
          this.push(this.objectLiteral(hash.values));
        },
        // [pushString]
        //
        // On stack, before: ...
        // On stack, after: quotedString(string), ...
        //
        // Push a quoted version of `string` onto the stack
        pushString: function pushString(string) {
          this.pushStackLiteral(this.quotedString(string));
        },
        // [pushLiteral]
        //
        // On stack, before: ...
        // On stack, after: value, ...
        //
        // Pushes a value onto the stack. This operation prevents
        // the compiler from creating a temporary variable to hold
        // it.
        pushLiteral: function pushLiteral(value) {
          this.pushStackLiteral(value);
        },
        // [pushProgram]
        //
        // On stack, before: ...
        // On stack, after: program(guid), ...
        //
        // Push a program expression onto the stack. This takes
        // a compile-time guid and converts it into a runtime-accessible
        // expression.
        pushProgram: function pushProgram(guid) {
          if (guid != null) {
            this.pushStackLiteral(this.programExpression(guid));
          } else {
            this.pushStackLiteral(null);
          }
        },
        // [registerDecorator]
        //
        // On stack, before: hash, program, params..., ...
        // On stack, after: ...
        //
        // Pops off the decorator's parameters, invokes the decorator,
        // and inserts the decorator into the decorators list.
        registerDecorator: function registerDecorator(paramSize, name) {
          var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
          this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
        },
        // [invokeHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // Pops off the helper's parameters, invokes the helper,
        // and pushes the helper's return value onto the stack.
        //
        // If the helper is not found, `helperMissing` is called.
        invokeHelper: function invokeHelper(paramSize, name, isSimple) {
          var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
          var possibleFunctionCalls = [];
          if (isSimple) {
            possibleFunctionCalls.push(helper.name);
          }
          possibleFunctionCalls.push(nonHelper);
          if (!this.options.strict) {
            possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
          }
          var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
          var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
          this.push(functionCall);
        },
        itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
          var result = [];
          result.push(items[0]);
          for (var i = 1; i < items.length; i++) {
            result.push(separator, items[i]);
          }
          return result;
        },
        // [invokeKnownHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // This operation is used when the helper is known to exist,
        // so a `helperMissing` fallback is not required.
        invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
          var helper = this.setupHelper(paramSize, name);
          this.push(this.source.functionCall(helper.name, "call", helper.callParams));
        },
        // [invokeAmbiguous]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of disambiguation
        //
        // This operation is used when an expression like `{{foo}}`
        // is provided, but we don't know at compile-time whether it
        // is a helper or a path.
        //
        // This operation emits more code than the other options,
        // and can be avoided by passing the `knownHelpers` and
        // `knownHelpersOnly` flags at compile-time.
        invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
          this.useRegister("helper");
          var nonHelper = this.popStack();
          this.emptyHash();
          var helper = this.setupHelper(0, name, helperCall);
          var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
          var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
          if (!this.options.strict) {
            lookup[0] = "(helper = ";
            lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
          }
          this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
        },
        // [invokePartial]
        //
        // On stack, before: context, ...
        // On stack after: result of partial invocation
        //
        // This operation pops off a context, invokes a partial with that context,
        // and pushes the result of the invocation back.
        invokePartial: function invokePartial(isDynamic, name, indent) {
          var params = [], options = this.setupParams(name, 1, params);
          if (isDynamic) {
            name = this.popStack();
            delete options.name;
          }
          if (indent) {
            options.indent = JSON.stringify(indent);
          }
          options.helpers = "helpers";
          options.partials = "partials";
          options.decorators = "container.decorators";
          if (!isDynamic) {
            params.unshift(this.nameLookup("partials", name, "partial"));
          } else {
            params.unshift(name);
          }
          if (this.options.compat) {
            options.depths = "depths";
          }
          options = this.objectLiteral(options);
          params.push(options);
          this.push(this.source.functionCall("container.invokePartial", "", params));
        },
        // [assignToHash]
        //
        // On stack, before: value, ..., hash, ...
        // On stack, after: ..., hash, ...
        //
        // Pops a value off the stack and assigns it to the current hash
        assignToHash: function assignToHash(key) {
          var value = this.popStack(), context = void 0, type3 = void 0, id = void 0;
          if (this.trackIds) {
            id = this.popStack();
          }
          if (this.stringParams) {
            type3 = this.popStack();
            context = this.popStack();
          }
          var hash = this.hash;
          if (context) {
            hash.contexts[key] = context;
          }
          if (type3) {
            hash.types[key] = type3;
          }
          if (id) {
            hash.ids[key] = id;
          }
          hash.values[key] = value;
        },
        pushId: function pushId(type3, name, child) {
          if (type3 === "BlockParam") {
            this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
          } else if (type3 === "PathExpression") {
            this.pushString(name);
          } else if (type3 === "SubExpression") {
            this.pushStackLiteral("true");
          } else {
            this.pushStackLiteral("null");
          }
        },
        // HELPERS
        compiler: JavaScriptCompiler,
        compileChildren: function compileChildren(environment, options) {
          var children = environment.children, child = void 0, compiler = void 0;
          for (var i = 0, l = children.length; i < l; i++) {
            child = children[i];
            compiler = new this.compiler();
            var existing = this.matchExistingProgram(child);
            if (existing == null) {
              this.context.programs.push("");
              var index = this.context.programs.length;
              child.index = index;
              child.name = "program" + index;
              this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
              this.context.decorators[index] = compiler.decorators;
              this.context.environments[index] = child;
              this.useDepths = this.useDepths || compiler.useDepths;
              this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
              child.useDepths = this.useDepths;
              child.useBlockParams = this.useBlockParams;
            } else {
              child.index = existing.index;
              child.name = "program" + existing.index;
              this.useDepths = this.useDepths || existing.useDepths;
              this.useBlockParams = this.useBlockParams || existing.useBlockParams;
            }
          }
        },
        matchExistingProgram: function matchExistingProgram(child) {
          for (var i = 0, len = this.context.environments.length; i < len; i++) {
            var environment = this.context.environments[i];
            if (environment && environment.equals(child)) {
              return environment;
            }
          }
        },
        programExpression: function programExpression(guid) {
          var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
          if (this.useBlockParams || this.useDepths) {
            programParams.push("blockParams");
          }
          if (this.useDepths) {
            programParams.push("depths");
          }
          return "container.program(" + programParams.join(", ") + ")";
        },
        useRegister: function useRegister(name) {
          if (!this.registers[name]) {
            this.registers[name] = true;
            this.registers.list.push(name);
          }
        },
        push: function push(expr) {
          if (!(expr instanceof Literal)) {
            expr = this.source.wrap(expr);
          }
          this.inlineStack.push(expr);
          return expr;
        },
        pushStackLiteral: function pushStackLiteral(item) {
          this.push(new Literal(item));
        },
        pushSource: function pushSource(source) {
          if (this.pendingContent) {
            this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
            this.pendingContent = void 0;
          }
          if (source) {
            this.source.push(source);
          }
        },
        replaceStack: function replaceStack(callback) {
          var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
          if (!this.isInline()) {
            throw new _exception2["default"]("replaceStack on non-inline");
          }
          var top = this.popStack(true);
          if (top instanceof Literal) {
            stack = [top.value];
            prefix = ["(", stack];
            usedLiteral = true;
          } else {
            createdStack = true;
            var _name = this.incrStack();
            prefix = ["((", this.push(_name), " = ", top, ")"];
            stack = this.topStack();
          }
          var item = callback.call(this, stack);
          if (!usedLiteral) {
            this.popStack();
          }
          if (createdStack) {
            this.stackSlot--;
          }
          this.push(prefix.concat(item, ")"));
        },
        incrStack: function incrStack() {
          this.stackSlot++;
          if (this.stackSlot > this.stackVars.length) {
            this.stackVars.push("stack" + this.stackSlot);
          }
          return this.topStackName();
        },
        topStackName: function topStackName() {
          return "stack" + this.stackSlot;
        },
        flushInline: function flushInline() {
          var inlineStack = this.inlineStack;
          this.inlineStack = [];
          for (var i = 0, len = inlineStack.length; i < len; i++) {
            var entry = inlineStack[i];
            if (entry instanceof Literal) {
              this.compileStack.push(entry);
            } else {
              var stack = this.incrStack();
              this.pushSource([stack, " = ", entry, ";"]);
              this.compileStack.push(stack);
            }
          }
        },
        isInline: function isInline() {
          return this.inlineStack.length;
        },
        popStack: function popStack(wrapped) {
          var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
          if (!wrapped && item instanceof Literal) {
            return item.value;
          } else {
            if (!inline) {
              if (!this.stackSlot) {
                throw new _exception2["default"]("Invalid stack pop");
              }
              this.stackSlot--;
            }
            return item;
          }
        },
        topStack: function topStack() {
          var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
          if (item instanceof Literal) {
            return item.value;
          } else {
            return item;
          }
        },
        contextName: function contextName(context) {
          if (this.useDepths && context) {
            return "depths[" + context + "]";
          } else {
            return "depth" + context;
          }
        },
        quotedString: function quotedString(str) {
          return this.source.quotedString(str);
        },
        objectLiteral: function objectLiteral(obj) {
          return this.source.objectLiteral(obj);
        },
        aliasable: function aliasable(name) {
          var ret = this.aliases[name];
          if (ret) {
            ret.referenceCount++;
            return ret;
          }
          ret = this.aliases[name] = this.source.wrap(name);
          ret.aliasable = true;
          ret.referenceCount = 1;
          return ret;
        },
        setupHelper: function setupHelper(paramSize, name, blockHelper) {
          var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
          var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
          return {
            params,
            paramsInit,
            name: foundHelper,
            callParams: [callContext].concat(params)
          };
        },
        setupParams: function setupParams(helper, paramSize, params) {
          var options = {}, contexts = [], types2 = [], ids = [], objectArgs = !params, param = void 0;
          if (objectArgs) {
            params = [];
          }
          options.name = this.quotedString(helper);
          options.hash = this.popStack();
          if (this.trackIds) {
            options.hashIds = this.popStack();
          }
          if (this.stringParams) {
            options.hashTypes = this.popStack();
            options.hashContexts = this.popStack();
          }
          var inverse = this.popStack(), program = this.popStack();
          if (program || inverse) {
            options.fn = program || "container.noop";
            options.inverse = inverse || "container.noop";
          }
          var i = paramSize;
          while (i--) {
            param = this.popStack();
            params[i] = param;
            if (this.trackIds) {
              ids[i] = this.popStack();
            }
            if (this.stringParams) {
              types2[i] = this.popStack();
              contexts[i] = this.popStack();
            }
          }
          if (objectArgs) {
            options.args = this.source.generateArray(params);
          }
          if (this.trackIds) {
            options.ids = this.source.generateArray(ids);
          }
          if (this.stringParams) {
            options.types = this.source.generateArray(types2);
            options.contexts = this.source.generateArray(contexts);
          }
          if (this.options.data) {
            options.data = "data";
          }
          if (this.useBlockParams) {
            options.blockParams = "blockParams";
          }
          return options;
        },
        setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
          var options = this.setupParams(helper, paramSize, params);
          options.loc = JSON.stringify(this.source.currentLocation);
          options = this.objectLiteral(options);
          if (useRegister) {
            this.useRegister("options");
            params.push("options");
            return ["options=", options];
          } else if (params) {
            params.push(options);
            return "";
          } else {
            return options;
          }
        }
      };
      (function() {
        var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
        for (var i = 0, l = reservedWords.length; i < l; i++) {
          compilerWords[reservedWords[i]] = true;
        }
      })();
      JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
      };
      function strictLookup(requireTerminal, compiler, parts, i, type3) {
        var stack = compiler.popStack(), len = parts.length;
        if (requireTerminal) {
          len--;
        }
        for (; i < len; i++) {
          stack = compiler.nameLookup(stack, parts[i], type3);
        }
        if (requireTerminal) {
          return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
        } else {
          return stack;
        }
      }
      exports["default"] = JavaScriptCompiler;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars.js
  var require_handlebars = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars.js"(exports, module) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _handlebarsRuntime = require_handlebars_runtime();
      var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
      var _handlebarsCompilerAst = require_ast();
      var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
      var _handlebarsCompilerBase = require_base2();
      var _handlebarsCompilerCompiler = require_compiler();
      var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
      var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
      var _handlebarsCompilerVisitor = require_visitor();
      var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
      var _handlebarsNoConflict = require_no_conflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      var _create = _handlebarsRuntime2["default"].create;
      function create() {
        var hb = _create();
        hb.compile = function(input, options) {
          return _handlebarsCompilerCompiler.compile(input, options, hb);
        };
        hb.precompile = function(input, options) {
          return _handlebarsCompilerCompiler.precompile(input, options, hb);
        };
        hb.AST = _handlebarsCompilerAst2["default"];
        hb.Compiler = _handlebarsCompilerCompiler.Compiler;
        hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
        hb.Parser = _handlebarsCompilerBase.parser;
        hb.parse = _handlebarsCompilerBase.parse;
        hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
        return hb;
      }
      var inst = create();
      inst.create = create;
      _handlebarsNoConflict2["default"](inst);
      inst.Visitor = _handlebarsCompilerVisitor2["default"];
      inst["default"] = inst;
      exports["default"] = inst;
      module.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js
  var require_printer = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.print = print;
      exports.PrintVisitor = PrintVisitor;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = require_visitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function print(ast) {
        return new PrintVisitor().accept(ast);
      }
      function PrintVisitor() {
        this.padding = 0;
      }
      PrintVisitor.prototype = new _visitor2["default"]();
      PrintVisitor.prototype.pad = function(string) {
        var out = "";
        for (var i = 0, l = this.padding; i < l; i++) {
          out += "  ";
        }
        out += string + "\n";
        return out;
      };
      PrintVisitor.prototype.Program = function(program) {
        var out = "", body = program.body, i = void 0, l = void 0;
        if (program.blockParams) {
          var blockParams = "BLOCK PARAMS: [";
          for (i = 0, l = program.blockParams.length; i < l; i++) {
            blockParams += " " + program.blockParams[i];
          }
          blockParams += " ]";
          out += this.pad(blockParams);
        }
        for (i = 0, l = body.length; i < l; i++) {
          out += this.accept(body[i]);
        }
        this.padding--;
        return out;
      };
      PrintVisitor.prototype.MustacheStatement = function(mustache) {
        return this.pad("{{ " + this.SubExpression(mustache) + " }}");
      };
      PrintVisitor.prototype.Decorator = function(mustache) {
        return this.pad("{{ DIRECTIVE " + this.SubExpression(mustache) + " }}");
      };
      PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function(block) {
        var out = "";
        out += this.pad((block.type === "DecoratorBlock" ? "DIRECTIVE " : "") + "BLOCK:");
        this.padding++;
        out += this.pad(this.SubExpression(block));
        if (block.program) {
          out += this.pad("PROGRAM:");
          this.padding++;
          out += this.accept(block.program);
          this.padding--;
        }
        if (block.inverse) {
          if (block.program) {
            this.padding++;
          }
          out += this.pad("{{^}}");
          this.padding++;
          out += this.accept(block.inverse);
          this.padding--;
          if (block.program) {
            this.padding--;
          }
        }
        this.padding--;
        return out;
      };
      PrintVisitor.prototype.PartialStatement = function(partial) {
        var content = "PARTIAL:" + partial.name.original;
        if (partial.params[0]) {
          content += " " + this.accept(partial.params[0]);
        }
        if (partial.hash) {
          content += " " + this.accept(partial.hash);
        }
        return this.pad("{{> " + content + " }}");
      };
      PrintVisitor.prototype.PartialBlockStatement = function(partial) {
        var content = "PARTIAL BLOCK:" + partial.name.original;
        if (partial.params[0]) {
          content += " " + this.accept(partial.params[0]);
        }
        if (partial.hash) {
          content += " " + this.accept(partial.hash);
        }
        content += " " + this.pad("PROGRAM:");
        this.padding++;
        content += this.accept(partial.program);
        this.padding--;
        return this.pad("{{> " + content + " }}");
      };
      PrintVisitor.prototype.ContentStatement = function(content) {
        return this.pad("CONTENT[ '" + content.value + "' ]");
      };
      PrintVisitor.prototype.CommentStatement = function(comment) {
        return this.pad("{{! '" + comment.value + "' }}");
      };
      PrintVisitor.prototype.SubExpression = function(sexpr) {
        var params = sexpr.params, paramStrings = [], hash = void 0;
        for (var i = 0, l = params.length; i < l; i++) {
          paramStrings.push(this.accept(params[i]));
        }
        params = "[" + paramStrings.join(", ") + "]";
        hash = sexpr.hash ? " " + this.accept(sexpr.hash) : "";
        return this.accept(sexpr.path) + " " + params + hash;
      };
      PrintVisitor.prototype.PathExpression = function(id) {
        var path2 = id.parts.join("/");
        return (id.data ? "@" : "") + "PATH:" + path2;
      };
      PrintVisitor.prototype.StringLiteral = function(string) {
        return '"' + string.value + '"';
      };
      PrintVisitor.prototype.NumberLiteral = function(number) {
        return "NUMBER{" + number.value + "}";
      };
      PrintVisitor.prototype.BooleanLiteral = function(bool) {
        return "BOOLEAN{" + bool.value + "}";
      };
      PrintVisitor.prototype.UndefinedLiteral = function() {
        return "UNDEFINED";
      };
      PrintVisitor.prototype.NullLiteral = function() {
        return "NULL";
      };
      PrintVisitor.prototype.Hash = function(hash) {
        var pairs = hash.pairs, joinedPairs = [];
        for (var i = 0, l = pairs.length; i < l; i++) {
          joinedPairs.push(this.accept(pairs[i]));
        }
        return "HASH{" + joinedPairs.join(", ") + "}";
      };
      PrintVisitor.prototype.HashPair = function(pair) {
        return pair.key + "=" + this.accept(pair.value);
      };
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.8/node_modules/handlebars/lib/index.js"(exports, module) {
      var handlebars = require_handlebars()["default"];
      var printer = require_printer();
      handlebars.PrintVisitor = printer.PrintVisitor;
      handlebars.print = printer.print;
      module.exports = handlebars;
      function extension(module2, filename) {
        var fs2 = __require("fs");
        var templateString = fs2.readFileSync(filename, "utf8");
        module2.exports = handlebars.compile(templateString);
      }
      if (typeof __require !== "undefined" && __require.extensions) {
        __require.extensions[".handlebars"] = extension;
        __require.extensions[".hbs"] = extension;
      }
    }
  });

  // ../versions/dist/index.mjs
  function getBuiltinVersions() {
    return {
      FORC: "0.66.5",
      FUEL_CORE: "0.40.2",
      FUELS: "0.98.0"
    };
  }
  var versions = getBuiltinVersions();

  // ../errors/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
    ErrorCode2["NO_ABIS_FOUND"] = "no-abis-found";
    ErrorCode2["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
    ErrorCode2["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
    ErrorCode2["INVALID_COMPONENT"] = "invalid-component";
    ErrorCode2["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
    ErrorCode2["TYPE_NOT_FOUND"] = "type-not-found";
    ErrorCode2["LOG_TYPE_NOT_FOUND"] = "log-type-not-found";
    ErrorCode2["TYPE_NOT_SUPPORTED"] = "type-not-supported";
    ErrorCode2["INVALID_DECODE_VALUE"] = "invalid-decode-value";
    ErrorCode2["JSON_ABI_ERROR"] = "json-abi-error";
    ErrorCode2["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
    ErrorCode2["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
    ErrorCode2["CODER_NOT_FOUND"] = "coder-not-found";
    ErrorCode2["INVALID_DATA"] = "invalid-data";
    ErrorCode2["FUNCTION_NOT_FOUND"] = "function-not-found";
    ErrorCode2["UNSUPPORTED_ENCODING_VERSION"] = "unsupported-encoding-version";
    ErrorCode2["TIMEOUT_EXCEEDED"] = "timeout-exceeded";
    ErrorCode2["CONFIG_FILE_NOT_FOUND"] = "config-file-not-found";
    ErrorCode2["CONFIG_FILE_ALREADY_EXISTS"] = "config-file-already-exists";
    ErrorCode2["WORKSPACE_NOT_DETECTED"] = "workspace-not-detected";
    ErrorCode2["INVALID_ADDRESS"] = "invalid-address";
    ErrorCode2["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
    ErrorCode2["INVALID_B256_ADDRESS"] = "invalid-b256-address";
    ErrorCode2["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
    ErrorCode2["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
    ErrorCode2["MISSING_PROVIDER"] = "missing-provider";
    ErrorCode2["INVALID_PROVIDER"] = "invalid-provider";
    ErrorCode2["CONNECTION_REFUSED"] = "connection-refused";
    ErrorCode2["INVALID_URL"] = "invalid-url";
    ErrorCode2["INVALID_PUBLIC_KEY"] = "invalid-public-key";
    ErrorCode2["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
    ErrorCode2["HD_WALLET_ERROR"] = "hd-wallet-error";
    ErrorCode2["MISSING_CONNECTOR"] = "missing-connector";
    ErrorCode2["PARSE_FAILED"] = "parse-failed";
    ErrorCode2["ENCODE_ERROR"] = "encode-error";
    ErrorCode2["DECODE_ERROR"] = "decode-error";
    ErrorCode2["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
    ErrorCode2["INVALID_TTL"] = "invalid-ttl";
    ErrorCode2["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
    ErrorCode2["NOT_IMPLEMENTED"] = "not-implemented";
    ErrorCode2["NOT_SUPPORTED"] = "not-supported";
    ErrorCode2["CONVERTING_FAILED"] = "converting-error";
    ErrorCode2["ELEMENT_NOT_FOUND"] = "element-not-found";
    ErrorCode2["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
    ErrorCode2["INVALID_REQUEST"] = "invalid-request";
    ErrorCode2["INVALID_TRANSFER_AMOUNT"] = "invalid-transfer-amount";
    ErrorCode2["NOT_ENOUGH_FUNDS"] = "not-enough-funds";
    ErrorCode2["INVALID_CREDENTIALS"] = "invalid-credentials";
    ErrorCode2["HASHER_LOCKED"] = "hasher-locked";
    ErrorCode2["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
    ErrorCode2["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
    ErrorCode2["MAX_FEE_TOO_LOW"] = "max-fee-too-low";
    ErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
    ErrorCode2["TRANSACTION_FAILED"] = "transaction-failed";
    ErrorCode2["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
    ErrorCode2["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
    ErrorCode2["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
    ErrorCode2["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
    ErrorCode2["UNSUPPORTED_TRANSACTION_TYPE"] = "unsupported-transaction-type";
    ErrorCode2["TRANSACTION_ERROR"] = "transaction-error";
    ErrorCode2["INVALID_POLICY_TYPE"] = "invalid-policy-type";
    ErrorCode2["DUPLICATED_POLICY"] = "duplicated-policy";
    ErrorCode2["TRANSACTION_SQUEEZED_OUT"] = "transaction-squeezed-out";
    ErrorCode2["CONTRACT_SIZE_EXCEEDS_LIMIT"] = "contract-size-exceeds-limit";
    ErrorCode2["INVALID_CHUNK_SIZE_MULTIPLIER"] = "invalid-chunk-size-multiplier";
    ErrorCode2["MAX_INPUTS_EXCEEDED"] = "max-inputs-exceeded";
    ErrorCode2["FUNDS_TOO_LOW"] = "funds-too-low";
    ErrorCode2["MAX_OUTPUTS_EXCEEDED"] = "max-outputs-exceeded";
    ErrorCode2["MAX_COINS_REACHED"] = "max-coins-reached";
    ErrorCode2["ASSET_BURN_DETECTED"] = "asset-burn-detected";
    ErrorCode2["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
    ErrorCode2["INVALID_WORD_LIST"] = "invalid-word-list";
    ErrorCode2["INVALID_MNEMONIC"] = "invalid-mnemonic";
    ErrorCode2["INVALID_ENTROPY"] = "invalid-entropy";
    ErrorCode2["INVALID_SEED"] = "invalid-seed";
    ErrorCode2["INVALID_CHECKSUM"] = "invalid-checksum";
    ErrorCode2["INVALID_PASSWORD"] = "invalid-password";
    ErrorCode2["ACCOUNT_REQUIRED"] = "account-required";
    ErrorCode2["UNLOCKED_WALLET_REQUIRED"] = "unlocked-wallet-required";
    ErrorCode2["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
    ErrorCode2["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
    ErrorCode2["SCRIPT_REVERTED"] = "script-reverted";
    ErrorCode2["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
    ErrorCode2["STREAM_PARSING_ERROR"] = "stream-parsing-error";
    ErrorCode2["NODE_LAUNCH_FAILED"] = "node-launch-failed";
    ErrorCode2["UNKNOWN"] = "unknown";
    return ErrorCode2;
  })(ErrorCode || {});
  var _FuelError = class extends Error {
    VERSIONS = versions;
    metadata;
    rawError;
    static parse(e) {
      const error = e;
      if (error.code === void 0) {
        throw new _FuelError(
          "parse-failed",
          "Failed to parse the error object. The required 'code' property is missing."
        );
      }
      const enumValues = Object.values(ErrorCode);
      const codeIsKnown = enumValues.includes(error.code);
      if (!codeIsKnown) {
        throw new _FuelError(
          "parse-failed",
          `Unknown error code: ${error.code}. Accepted codes: ${enumValues.join(", ")}.`
        );
      }
      return new _FuelError(error.code, error.message);
    }
    code;
    constructor(code, message, metadata = {}, rawError = null) {
      super(message);
      this.code = code;
      this.name = "FuelError";
      this.metadata = metadata;
      this.rawError = rawError;
    }
    toObject() {
      const { code, name, message, metadata, VERSIONS, rawError } = this;
      return { code, name, message, metadata, VERSIONS, rawError };
    }
  };
  var FuelError = _FuelError;
  __publicField2(FuelError, "CODES", ErrorCode);

  // src/runTypegen.ts
  var import_fs16 = __require("fs");

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/index.js
  var import_brace_expansion = __toESM(require_brace_expansion(), 1);

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/assert-valid-pattern.js
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/brace-expressions.js
  var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
    "[:alpha:]": ["\\p{L}\\p{Nl}", true],
    "[:ascii:]": ["\\x00-\\x7f", false],
    "[:blank:]": ["\\p{Zs}\\t", true],
    "[:cntrl:]": ["\\p{Cc}", true],
    "[:digit:]": ["\\p{Nd}", true],
    "[:graph:]": ["\\p{Z}\\p{C}", true, true],
    "[:lower:]": ["\\p{Ll}", true],
    "[:print:]": ["\\p{C}", true],
    "[:punct:]": ["\\p{P}", true],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
    "[:upper:]": ["\\p{Lu}", true],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
    "[:xdigit:]": ["A-Fa-f0-9", false]
  };
  var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
  var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var rangesToString = (ranges) => ranges.join("");
  var parseClass = (glob2, position) => {
    const pos = position;
    if (glob2.charAt(pos) !== "[") {
      throw new Error("not in a brace expression");
    }
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = "";
    WHILE:
      while (i < glob2.length) {
        const c = glob2.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob2.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob2.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob2.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob2.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
    if (endPos < i) {
      return ["", false, 0, false];
    }
    if (!ranges.length && !negs.length) {
      return ["$.", false, glob2.length - pos, true];
    }
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
    const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
    return [comb, uflag, endPos - pos, true];
  };

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/unescape.js
  var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  };

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/ast.js
  var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
  var isExtglobType = (c) => types.has(c);
  var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
  var startNoDot = "(?!\\.)";
  var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
  var justDots = /* @__PURE__ */ new Set(["..", "."]);
  var reSpecials = new Set("().*{}+?[]^$\\!");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var qmark = "[^/]";
  var star = qmark + "*?";
  var starNoEmpty = qmark + "+?";
  var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
  var _AST = class {
    constructor(type3, parent, options = {}) {
      __privateAdd(this, _fillNegs);
      __privateAdd(this, _partsToRegExp);
      __publicField(this, "type");
      __privateAdd(this, _root, void 0);
      __privateAdd(this, _hasMagic, void 0);
      __privateAdd(this, _uflag, false);
      __privateAdd(this, _parts, []);
      __privateAdd(this, _parent, void 0);
      __privateAdd(this, _parentIndex, void 0);
      __privateAdd(this, _negs, void 0);
      __privateAdd(this, _filledNegs, false);
      __privateAdd(this, _options, void 0);
      __privateAdd(this, _toString, void 0);
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      __privateAdd(this, _emptyExt, false);
      this.type = type3;
      if (type3)
        __privateSet(this, _hasMagic, true);
      __privateSet(this, _parent, parent);
      __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
      __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
      __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
      if (type3 === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
        __privateGet(this, _negs).push(this);
      __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
    }
    get hasMagic() {
      if (__privateGet(this, _hasMagic) !== void 0)
        return __privateGet(this, _hasMagic);
      for (const p of __privateGet(this, _parts)) {
        if (typeof p === "string")
          continue;
        if (p.type || p.hasMagic)
          return __privateSet(this, _hasMagic, true);
      }
      return __privateGet(this, _hasMagic);
    }
    // reconstructs the pattern
    toString() {
      if (__privateGet(this, _toString) !== void 0)
        return __privateGet(this, _toString);
      if (!this.type) {
        return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
      } else {
        return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
      }
    }
    push(...parts) {
      for (const p of parts) {
        if (p === "")
          continue;
        if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
          throw new Error("invalid part: " + p);
        }
        __privateGet(this, _parts).push(p);
      }
    }
    toJSON() {
      const ret = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
      if (this.isStart() && !this.type)
        ret.unshift([]);
      if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!")) {
        ret.push({});
      }
      return ret;
    }
    isStart() {
      if (__privateGet(this, _root) === this)
        return true;
      if (!__privateGet(this, _parent)?.isStart())
        return false;
      if (__privateGet(this, _parentIndex) === 0)
        return true;
      const p = __privateGet(this, _parent);
      for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
        const pp = __privateGet(p, _parts)[i];
        if (!(pp instanceof _AST && pp.type === "!")) {
          return false;
        }
      }
      return true;
    }
    isEnd() {
      if (__privateGet(this, _root) === this)
        return true;
      if (__privateGet(this, _parent)?.type === "!")
        return true;
      if (!__privateGet(this, _parent)?.isEnd())
        return false;
      if (!this.type)
        return __privateGet(this, _parent)?.isEnd();
      const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
      return __privateGet(this, _parentIndex) === pl - 1;
    }
    copyIn(part) {
      if (typeof part === "string")
        this.push(part);
      else
        this.push(part.clone(this));
    }
    clone(parent) {
      const c = new _AST(this.type, parent);
      for (const p of __privateGet(this, _parts)) {
        c.copyIn(p);
      }
      return c;
    }
    static fromGlob(pattern, options = {}) {
      var _a2;
      const ast = new _AST(null, void 0, options);
      __privateMethod(_a2 = _AST, _parseAST, parseAST_fn).call(_a2, pattern, ast, 0, options);
      return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
      if (this !== __privateGet(this, _root))
        return __privateGet(this, _root).toMMPattern();
      const glob2 = this.toString();
      const [re, body, hasMagic2, uflag] = this.toRegExpSource();
      const anyMagic = hasMagic2 || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
      if (!anyMagic) {
        return body;
      }
      const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob2
      });
    }
    get options() {
      return __privateGet(this, _options);
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
      const dot = allowDot ?? !!__privateGet(this, _options).dot;
      if (__privateGet(this, _root) === this)
        __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
      if (!this.type) {
        const noEmpty = this.isStart() && this.isEnd();
        const src = __privateGet(this, _parts).map((p) => {
          var _a2;
          const [re, _, hasMagic2, uflag] = typeof p === "string" ? __privateMethod(_a2 = _AST, _parseGlob, parseGlob_fn).call(_a2, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
          __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic2);
          __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
          return re;
        }).join("");
        let start2 = "";
        if (this.isStart()) {
          if (typeof __privateGet(this, _parts)[0] === "string") {
            const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
            if (!dotTravAllowed) {
              const aps = addPatternStart;
              const needNoTrav = (
                // dots are allowed, and the pattern starts with [ or .
                dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                src.startsWith("\\.\\.") && aps.has(src.charAt(4))
              );
              const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
              start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
            }
          }
        }
        let end = "";
        if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!") {
          end = "(?:$|\\/)";
        }
        const final2 = start2 + src + end;
        return [
          final2,
          unescape(src),
          __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
          __privateGet(this, _uflag)
        ];
      }
      const repeated = this.type === "*" || this.type === "+";
      const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
      let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        const s = this.toString();
        __privateSet(this, _parts, [s]);
        this.type = null;
        __privateSet(this, _hasMagic, void 0);
        return [s, unescape(this.toString()), false, false];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
      if (bodyDotAllowed === body) {
        bodyDotAllowed = "";
      }
      if (bodyDotAllowed) {
        body = `(?:${body})(?:${bodyDotAllowed})*?`;
      }
      let final = "";
      if (this.type === "!" && __privateGet(this, _emptyExt)) {
        final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
      } else {
        const close = this.type === "!" ? (
          // !() must match something,but !(x) can match ''
          "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
        ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
        final = start + body + close;
      }
      return [
        final,
        unescape(body),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
  };
  var AST = _AST;
  _root = new WeakMap();
  _hasMagic = new WeakMap();
  _uflag = new WeakMap();
  _parts = new WeakMap();
  _parent = new WeakMap();
  _parentIndex = new WeakMap();
  _negs = new WeakMap();
  _filledNegs = new WeakMap();
  _options = new WeakMap();
  _toString = new WeakMap();
  _emptyExt = new WeakMap();
  _fillNegs = new WeakSet();
  fillNegs_fn = function() {
    if (this !== __privateGet(this, _root))
      throw new Error("should only call on root");
    if (__privateGet(this, _filledNegs))
      return this;
    this.toString();
    __privateSet(this, _filledNegs, true);
    let n;
    while (n = __privateGet(this, _negs).pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = __privateGet(p, _parent);
      while (pp) {
        for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
          for (const part of __privateGet(n, _parts)) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(__privateGet(pp, _parts)[i]);
          }
        }
        p = pp;
        pp = __privateGet(p, _parent);
      }
    }
    return this;
  };
  _parseAST = new WeakSet();
  parseAST_fn = function(str, ast, pos, opt) {
    var _a2, _b2;
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str.length) {
        const c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = __privateMethod(_a2 = _AST, _parseAST, parseAST_fn).call(_a2, str, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = __privateMethod(_b2 = _AST, _parseAST, parseAST_fn).call(_b2, str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && __privateGet(ast, _parts).length === 0) {
          __privateSet(ast, _emptyExt, true);
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    __privateSet(ast, _hasMagic, void 0);
    __privateSet(ast, _parts, [str.substring(pos - 1)]);
    return i;
  };
  _partsToRegExp = new WeakSet();
  partsToRegExp_fn = function(dot) {
    return __privateGet(this, _parts).map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
      __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  };
  _parseGlob = new WeakSet();
  parseGlob_fn = function(glob2, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob2.length; i++) {
      const c = glob2.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob2.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob2 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob2), !!hasMagic2, uflag];
  };
  __privateAdd(AST, _parseAST);
  __privateAdd(AST, _parseGlob);

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/escape.js
  var escape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
  };

  // ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/index.js
  var minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
  var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
  var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
  var starDotExtTestNocase = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
  };
  var starDotExtTestNocaseDot = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext2);
  };
  var starDotStarRE = /^\*+\.\*+$/;
  var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
  var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
  var dotStarRE = /^\.\*+$/;
  var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
  var starRE = /^\*+$/;
  var starTest = (f) => f.length !== 0 && !f.startsWith(".");
  var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
  var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
  var qmarksTestNocase = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
  };
  var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
  };
  var qmarksTestDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
  };
  var qmarksTest = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
  };
  var qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith(".");
  };
  var qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== "." && f !== "..";
  };
  var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
  var path = {
    win32: { sep: "\\" },
    posix: { sep: "/" }
  };
  var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
  minimatch.sep = sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var qmark2 = "[^/]";
  var star2 = qmark2 + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
  minimatch.filter = filter;
  var ext = (a, b = {}) => Object.assign({}, a, b);
  var defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
      Minimatch: class Minimatch extends orig.Minimatch {
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class AST extends orig.AST {
        /* c8 ignore start */
        constructor(type3, parent, options = {}) {
          super(type3, parent, ext(def, options));
        }
        /* c8 ignore stop */
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: (options) => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR
    });
  };
  minimatch.defaults = defaults;
  var braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return (0, import_brace_expansion.default)(pattern);
  };
  minimatch.braceExpand = braceExpand;
  var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
  minimatch.makeRe = makeRe;
  var match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f) => mm.match(f));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  minimatch.match = match;
  var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
  var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var Minimatch = class {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      assertValidPattern(pattern);
      options = options || {};
      this.options = options;
      this.pattern = pattern;
      this.platform = options.platform || defaultPlatform;
      this.isWindows = this.platform === "win32";
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
      this.regexp = null;
      this.negate = false;
      this.nonegate = !!options.nonegate;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.nocase = !!this.options.nocase;
      this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
      this.globSet = [];
      this.globParts = [];
      this.set = [];
      this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) {
        return true;
      }
      for (const pattern of this.set) {
        for (const part of pattern) {
          if (typeof part !== "string")
            return true;
        }
      }
      return false;
    }
    debug(..._) {
    }
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      this.globSet = [...new Set(this.braceExpand())];
      if (options.debug) {
        this.debug = (...args) => console.error(...args);
      }
      this.debug(this.pattern, this.globSet);
      const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts);
      this.debug(this.pattern, this.globParts);
      let set = this.globParts.map((s, _, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
          const isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) {
            return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
          } else if (isDrive) {
            return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
          }
        }
        return s.map((ss) => this.parse(ss));
      });
      this.debug(this.pattern, set);
      this.set = set.filter((s) => s.indexOf(false) === -1);
      if (this.isWindows) {
        for (let i = 0; i < this.set.length; i++) {
          const p = this.set[i];
          if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
            p[2] = "?";
          }
        }
      }
      this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
      if (this.options.noglobstar) {
        for (let i = 0; i < globParts.length; i++) {
          for (let j = 0; j < globParts[i].length; j++) {
            if (globParts[i][j] === "**") {
              globParts[i][j] = "*";
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        globParts = this.firstPhasePreProcess(globParts);
        globParts = this.secondPhasePreProcess(globParts);
      } else if (optimizationLevel >= 1) {
        globParts = this.levelOneOptimize(globParts);
      } else {
        globParts = this.adjascentGlobstarOptimize(globParts);
      }
      return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
      return globParts.map((parts) => {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let i = gs;
          while (parts[i + 1] === "**") {
            i++;
          }
          if (i !== gs) {
            parts.splice(gs, i - gs);
          }
        }
        return parts;
      });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
      return globParts.map((parts) => {
        parts = parts.reduce((set, part) => {
          const prev = set[set.length - 1];
          if (part === "**" && prev === "**") {
            return set;
          }
          if (part === "..") {
            if (prev && prev !== ".." && prev !== "." && prev !== "**") {
              set.pop();
              return set;
            }
          }
          set.push(part);
          return set;
        }, []);
        return parts.length === 0 ? [""] : parts;
      });
    }
    levelTwoFileOptimize(parts) {
      if (!Array.isArray(parts)) {
        parts = this.slashSplit(parts);
      }
      let didSomething = false;
      do {
        didSomething = false;
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            parts.splice(dd - 1, 2);
            dd -= 2;
          }
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
      let didSomething = false;
      do {
        didSomething = false;
        for (let parts of globParts) {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let gss = gs;
            while (parts[gss + 1] === "**") {
              gss++;
            }
            if (gss > gs) {
              parts.splice(gs + 1, gss - gs);
            }
            let next = parts[gs + 1];
            const p = parts[gs + 2];
            const p2 = parts[gs + 3];
            if (next !== "..")
              continue;
            if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
              continue;
            }
            didSomething = true;
            parts.splice(gs, 1);
            const other = parts.slice(0);
            other[gs] = "**";
            globParts.push(other);
            gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              const needDot = dd === 1 && parts[dd + 1] === "**";
              const splin = needDot ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin);
              if (parts.length === 0)
                parts.push("");
              dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
      for (let i = 0; i < globParts.length - 1; i++) {
        for (let j = i + 1; j < globParts.length; j++) {
          const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
          if (matched) {
            globParts[i] = [];
            globParts[j] = matched;
            break;
          }
        }
      }
      return globParts.filter((gs) => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
      let ai = 0;
      let bi = 0;
      let result = [];
      let which = "";
      while (ai < a.length && bi < b.length) {
        if (a[ai] === b[bi]) {
          result.push(which === "b" ? b[bi] : a[ai]);
          ai++;
          bi++;
        } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
          result.push(a[ai]);
          ai++;
        } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
          result.push(b[bi]);
          bi++;
        } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
          if (which === "b")
            return false;
          which = "a";
          result.push(a[ai]);
          ai++;
          bi++;
        } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
          if (which === "a")
            return false;
          which = "b";
          result.push(b[bi]);
          ai++;
          bi++;
        } else {
          return false;
        }
      }
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
      const options = this.options;
      if (this.isWindows) {
        const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
        const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
        const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
        const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
        const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
        const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
        if (typeof fdi === "number" && typeof pdi === "number") {
          const [fd2, pd] = [file[fdi], pattern[pdi]];
          if (fd2.toLowerCase() === pd.toLowerCase()) {
            pattern[pdi] = fd2;
            if (pdi > fdi) {
              pattern = pattern.slice(pdi);
            } else if (fdi > pdi) {
              file = file.slice(fdi);
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        file = this.levelTwoFileOptimize(file);
      }
      this.debug("matchOne", this, { file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl2 = file.length, pl = pattern.length; fi < fl2 && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false) {
          return false;
        }
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl2; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl2) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl2, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl2) {
              return true;
            }
          }
          return false;
        }
        let hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = p.test(f);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl2 && pi === pl) {
        return true;
      } else if (fi === fl2) {
        return partial;
      } else if (pi === pl) {
        return fi === fl2 - 1 && file[fi] === "";
      } else {
        throw new Error("wtf?");
      }
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      let m;
      let fastTest = null;
      if (m = pattern.match(starRE)) {
        fastTest = options.dot ? starTestDot : starTest;
      } else if (m = pattern.match(starDotExtRE)) {
        fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
      } else if (m = pattern.match(qmarksRE)) {
        fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
      } else if (m = pattern.match(starDotStarRE)) {
        fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
      } else if (m = pattern.match(dotStarRE)) {
        fastTest = dotStarTest;
      }
      const re = AST.fromGlob(pattern, this.options).toMMPattern();
      if (fastTest && typeof re === "object") {
        Reflect.defineProperty(re, "test", { value: fastTest });
      }
      return re;
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
      const flags = new Set(options.nocase ? ["i"] : []);
      let re = set.map((pattern) => {
        const pp = pattern.map((p) => {
          if (p instanceof RegExp) {
            for (const f of p.flags.split(""))
              flags.add(f);
          }
          return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
        });
        pp.forEach((p, i) => {
          const next = pp[i + 1];
          const prev = pp[i - 1];
          if (p !== GLOBSTAR || prev === GLOBSTAR) {
            return;
          }
          if (prev === void 0) {
            if (next !== void 0 && next !== GLOBSTAR) {
              pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
            } else {
              pp[i] = twoStar;
            }
          } else if (next === void 0) {
            pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
          } else if (next !== GLOBSTAR) {
            pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
            pp[i + 1] = GLOBSTAR;
          }
        });
        return pp.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$";
      if (this.negate)
        re = "^(?!" + re + ").+$";
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    slashSplit(p) {
      if (this.preserveMultipleSlashes) {
        return p.split("/");
      } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
        return ["", ...p.split(/\/+/)];
      } else {
        return p.split(/\/+/);
      }
    }
    match(f, partial = this.partial) {
      this.debug("match", f, this.pattern);
      if (this.comment) {
        return false;
      }
      if (this.empty) {
        return f === "";
      }
      if (f === "/" && partial) {
        return true;
      }
      const options = this.options;
      if (this.isWindows) {
        f = f.split("\\").join("/");
      }
      const ff = this.slashSplit(f);
      this.debug(this.pattern, "split", ff);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename = ff[ff.length - 1];
      if (!filename) {
        for (let i = ff.length - 2; !filename && i >= 0; i--) {
          filename = ff[i];
        }
      }
      for (let i = 0; i < set.length; i++) {
        const pattern = set[i];
        let file = ff;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) {
            return true;
          }
          return !this.negate;
        }
      }
      if (options.flipNegate) {
        return false;
      }
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  };
  minimatch.AST = AST;
  minimatch.Minimatch = Minimatch;
  minimatch.escape = escape;
  minimatch.unescape = unescape;

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/glob.js
  var import_node_url2 = __require("url");

  // ../../node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/esm/index.js
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var warned = /* @__PURE__ */ new Set();
  var PROCESS = typeof process === "object" && !!process ? process : {};
  var emitWarning = (msg, type3, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type3, code, fn) : console.error(`[${code}] ${type3}: ${msg}`);
  };
  var AC = globalThis.AbortController;
  var AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(_, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS();
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  var shouldWarn = (code) => !warned.has(code);
  var TYPE = Symbol("type");
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
  var ZeroArray = class extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  };
  var _constructing;
  var _Stack = class {
    heap;
    length;
    static create(max) {
      const HeapCls = getUintArray(max);
      if (!HeapCls)
        return [];
      __privateSet(_Stack, _constructing, true);
      const s = new _Stack(max, HeapCls);
      __privateSet(_Stack, _constructing, false);
      return s;
    }
    constructor(max, HeapCls) {
      if (!__privateGet(_Stack, _constructing)) {
        throw new TypeError("instantiate Stack using Stack.create(n)");
      }
      this.heap = new HeapCls(max);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  var Stack = _Stack;
  _constructing = new WeakMap();
  // private constructor
  __privateAdd(Stack, _constructing, false);
  var LRUCache = class {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
      return {
        // properties
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        // methods
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options) => c.#indexes(options),
        rindexes: (options) => c.#rindexes(options),
        isStale: (index) => c.#isStale(index)
      };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
      return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
      return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
      return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
      return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
      return this.#fetchMethod;
    }
    get memoMethod() {
      return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
      return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options) {
      const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      this.#max = max;
      this.#maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.#maxSize;
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (memoMethod !== void 0 && typeof memoMethod !== "function") {
        throw new TypeError("memoMethod must be a function if defined");
      }
      this.#memoMethod = memoMethod;
      if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.#fetchMethod = fetchMethod;
      this.#hasFetchMethod = !!fetchMethod;
      this.#keyMap = /* @__PURE__ */ new Map();
      this.#keyList = new Array(max).fill(void 0);
      this.#valList = new Array(max).fill(void 0);
      this.#next = new UintArray(max);
      this.#prev = new UintArray(max);
      this.#head = 0;
      this.#tail = 0;
      this.#free = Stack.create(max);
      this.#size = 0;
      this.#calculatedSize = 0;
      if (typeof dispose === "function") {
        this.#dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.#disposeAfter = disposeAfter;
        this.#disposed = [];
      } else {
        this.#disposeAfter = void 0;
        this.#disposed = void 0;
      }
      this.#hasDispose = !!this.#dispose;
      this.#hasDisposeAfter = !!this.#disposeAfter;
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.#initializeSizeTracking();
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max);
      const starts = new ZeroArray(this.#max);
      this.#ttls = ttls;
      this.#starts = starts;
      this.#setItemTTL = (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.#delete(this.#keyList[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      };
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.#keyMap.get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      this.#isStale = (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => {
    };
    #statusTTL = () => {
    };
    #setItemTTL = () => {
    };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0;
      this.#sizes = sizes;
      this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index];
        sizes[index] = 0;
      };
      this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      };
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size;
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize) {
            this.#evict(true);
          }
        }
        this.#calculatedSize += sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.#calculatedSize;
        }
      };
    }
    #removeItemSize = (_i) => {
    };
    #addItemSize = (_i, _s, _st) => {
    };
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail; true; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#head) {
            break;
          } else {
            i = this.#prev[i];
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head; true; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#tail) {
            break;
          } else {
            i = this.#next[i];
          }
        }
      }
    }
    #isValidIndex(index) {
      return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
      for (const i of this.#indexes()) {
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
      for (const i of this.#rindexes()) {
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
      return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = "LRUCache";
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions);
        }
      }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
      let deleted = false;
      for (const i of this.#rindexes({ allowStale: true })) {
        if (this.#isStale(i)) {
          this.#delete(this.#keyList[i], "expire");
          deleted = true;
        }
      }
      return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
      const i = this.#keyMap.get(key);
      if (i === void 0)
        return void 0;
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        return void 0;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        const ttl = this.#ttls[i];
        const start = this.#starts[i];
        if (ttl && start) {
          const remain = ttl - (perf.now() - start);
          entry.ttl = remain;
          entry.start = Date.now();
        }
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
      const arr = [];
      for (const i of this.#indexes({ allowStale: true })) {
        const key = this.#keyList[i];
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0 || key === void 0)
          continue;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          const age = perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
      if (v === void 0) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.#delete(k, "set");
        return this;
      }
      let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
      if (index === void 0) {
        index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
        this.#keyList[index] = k;
        this.#valList[index] = v;
        this.#keyMap.set(k, index);
        this.#next[this.#tail] = index;
        this.#prev[index] = this.#tail;
        this.#tail = index;
        this.#size++;
        this.#addItemSize(index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
      } else {
        this.#moveToTail(index);
        const oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: s } = oldVal;
            if (s !== void 0 && !noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(s, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([s, k, "set"]);
              }
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, "set"]);
            }
          }
          this.#removeItemSize(index);
          this.#addItemSize(index, size, status);
          this.#valList[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== void 0)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking();
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start);
        }
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head];
          this.#evict(true);
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== void 0) {
            return val;
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head;
      const k = this.#keyList[head];
      const v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "evict");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "evict"]);
        }
      }
      this.#removeItemSize(head);
      if (free) {
        this.#keyList[head] = void 0;
        this.#valList[head] = void 0;
        this.#free.push(head);
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0;
        this.#free.length = 0;
      } else {
        this.#head = this.#next[head];
      }
      this.#keyMap.delete(k);
      this.#size--;
      return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
          return false;
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index);
          }
          if (status) {
            status.has = "hit";
            this.#statusTTL(status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          this.#statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = this.#keyMap.get(k);
      if (index === void 0 || !allowStale && this.#isStale(index)) {
        return;
      }
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
      const v = index === void 0 ? void 0 : this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (this.#valList[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              this.#valList[index] = bf2.__staleWhileFetching;
            } else {
              this.#delete(k, "fetch");
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (this.#valList[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            this.#delete(k, "fetch");
          } else if (!allowStaleAborted) {
            this.#valList[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = this.#keyMap.get(k);
      } else {
        this.#valList[index] = bf;
      }
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.#keyMap.get(k);
      if (index === void 0) {
        if (status)
          status.fetch = "miss";
        const p = this.#backgroundFetch(k, index, options, context);
        return p.__returned = p;
      } else {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== void 0;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        const p = this.#backgroundFetch(k, index, options, context);
        const hasStale = p.__staleWhileFetching !== void 0;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions);
      if (v === void 0)
        throw new Error("fetch() returned undefined");
      return v;
    }
    memo(k, memoOptions = {}) {
      const memoMethod = this.#memoMethod;
      if (!memoMethod) {
        throw new Error("no memoMethod provided to constructor");
      }
      const { context, forceRefresh, ...options } = memoOptions;
      const v = this.get(k, options);
      if (!forceRefresh && v !== void 0)
        return v;
      const vv = memoMethod(k, v, {
        options,
        context
      });
      this.set(k, vv, options);
      return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        const value = this.#valList[index];
        const fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.#delete(k, "expire");
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : void 0;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== void 0) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : void 0;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    #connect(p, n) {
      this.#prev[n] = p;
      this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index];
        } else {
          this.#connect(this.#prev[index], this.#next[index]);
        }
        this.#connect(this.#tail, index);
        this.#tail = index;
      }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
      return this.#delete(k, "delete");
    }
    #delete(k, reason) {
      let deleted = false;
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          deleted = true;
          if (this.#size === 1) {
            this.#clear(reason);
          } else {
            this.#removeItemSize(index);
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason);
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason]);
              }
            }
            this.#keyMap.delete(k);
            this.#keyList[index] = void 0;
            this.#valList[index] = void 0;
            if (index === this.#tail) {
              this.#tail = this.#prev[index];
            } else if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              const pi = this.#prev[index];
              this.#next[pi] = this.#next[index];
              const ni = this.#next[index];
              this.#prev[ni] = this.#prev[index];
            }
            this.#size--;
            this.#free.push(index);
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
      return this.#clear("delete");
    }
    #clear(reason) {
      for (const index of this.#rindexes({ allowStale: true })) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.#keyList[index];
          if (this.#hasDispose) {
            this.#dispose?.(v, k, reason);
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, reason]);
          }
        }
      }
      this.#keyMap.clear();
      this.#valList.fill(void 0);
      this.#keyList.fill(void 0);
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0);
        this.#starts.fill(0);
      }
      if (this.#sizes) {
        this.#sizes.fill(0);
      }
      this.#head = 0;
      this.#tail = 0;
      this.#free.length = 0;
      this.#calculatedSize = 0;
      this.#size = 0;
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  };

  // ../../node_modules/.pnpm/path-scurry@1.11.1/node_modules/path-scurry/dist/esm/index.js
  var import_node_path = __require("path");
  var import_node_url = __require("url");
  var import_fs = __require("fs");
  var actualFS = __toESM(__require("fs"), 1);
  var import_promises = __require("fs/promises");

  // ../../node_modules/.pnpm/minipass@7.1.2/node_modules/minipass/dist/esm/index.js
  var import_node_events = __require("events");
  var import_node_stream = __toESM(__require("stream"), 1);
  var import_node_string_decoder = __require("string_decoder");
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof import_node_stream.default || isReadable(s) || isWritable(s));
  var isReadable = (s) => !!s && typeof s === "object" && s instanceof import_node_events.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
  s.pipe !== import_node_stream.default.Writable.prototype.pipe;
  var isWritable = (s) => !!s && typeof s === "object" && s instanceof import_node_events.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFER = Symbol("buffer");
  var PIPES = Symbol("pipes");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var ERROR = Symbol("error");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var ABORT = Symbol("abort");
  var ABORTED = Symbol("aborted");
  var SIGNAL = Symbol("signal");
  var DATALISTENERS = Symbol("dataListeners");
  var DISCARDED = Symbol("discarded");
  var defer = (fn) => Promise.resolve().then(fn);
  var nodefer = (fn) => fn();
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  var Pipe = class {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      this.dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) {
    }
    /* c8 ignore stop */
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  };
  var PipeProxyErrors = class extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  };
  var isObjectModeOptions = (o) => !!o.objectMode;
  var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
  var Minipass = class extends import_node_events.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
      const options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string") {
        throw new TypeError("Encoding and objectMode may not be used together");
      }
      if (isObjectModeOptions(options)) {
        this[OBJECTMODE] = true;
        this[ENCODING] = null;
      } else if (isEncodingOptions(options)) {
        this[ENCODING] = options.encoding;
        this[OBJECTMODE] = false;
      } else {
        this[OBJECTMODE] = false;
        this[ENCODING] = null;
      }
      this[ASYNC] = !!options.async;
      this[DECODER] = this[ENCODING] ? new import_node_string_decoder.StringDecoder(this[ENCODING]) : null;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      const { signal } = options;
      if (signal) {
        this[SIGNAL] = signal;
        if (signal.aborted) {
          this[ABORT]();
        } else {
          signal.addEventListener("abort", () => this[ABORT]());
        }
      }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
      return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
      return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
      throw new Error("objectMode must be set at instantiation time");
    }
    /**
     * true if this is an async stream
     */
    get ["async"]() {
      return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL]?.reason);
      this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
      return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : nodefer;
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk)) {
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        } else if (isArrayBufferLike(chunk)) {
          chunk = Buffer.from(chunk);
        } else if (typeof chunk !== "string") {
          throw new Error("Non-contiguous data written to non-objectMode stream");
        }
      }
      if (this[OBJECTMODE]) {
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (typeof chunk === "string" && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING]) {
        chunk = this[DECODER].write(chunk);
      }
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
      if (this[DESTROYED])
        return null;
      this[DISCARDED] = false;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        this[BUFFER] = [
          this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
        ];
      }
      const ret = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (this[OBJECTMODE])
        this[BUFFERSHIFT]();
      else {
        const c = chunk;
        if (n === c.length || n === null)
          this[BUFFERSHIFT]();
        else if (typeof c === "string") {
          this[BUFFER][0] = c.slice(n);
          chunk = c.slice(0, n);
          this[BUFFERLENGTH] -= n;
        } else {
          this[BUFFER][0] = c.subarray(n);
          chunk = c.subarray(0, n);
          this[BUFFERLENGTH] -= n;
        }
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = void 0;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (chunk !== void 0)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this[FLOWING] || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
      if (this[DESTROYED])
        return;
      if (!this[DATALISTENERS] && !this[PIPES].length) {
        this[DISCARDED] = true;
      }
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
      return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
      this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
      return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
      return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
      if (this[DESTROYED])
        return dest;
      this[DISCARDED] = false;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES].length === 1) {
          if (this[FLOWING] && this[DATALISTENERS] === 0) {
            this[FLOWING] = false;
          }
          this[PIPES] = [];
        } else
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
      const ret = super.on(ev, handler);
      if (ev === "data") {
        this[DISCARDED] = false;
        this[DATALISTENERS]++;
        if (!this[PIPES].length && !this[FLOWING]) {
          this[RESUME]();
        }
      } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
        super.emit("readable");
      } else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        const h = handler;
        if (this[ASYNC])
          defer(() => h.call(this, this[EMITTED_ERROR]));
        else
          h.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
      const ret = super.off(ev, handler);
      if (ev === "data") {
        this[DATALISTENERS] = this.listeners("data").length;
        if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
      const ret = super.removeAllListeners(ev);
      if (ev === "data" || ev === void 0) {
        this[DATALISTENERS] = 0;
        if (!this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
      const data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
        return false;
      } else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return false;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, ...args);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = this[DISCARDED] ? false : super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return false;
      this[EMITTED_END] = true;
      this.readable = false;
      return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          if (!this[DISCARDED])
            super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
      const buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      await p;
      return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
      if (this[OBJECTMODE]) {
        throw new Error("cannot concat in objectMode");
      }
      const buf = await this.collect();
      return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
      return new Promise((resolve7, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve7());
      });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = async () => {
        this.pause();
        stopped = true;
        return { value: void 0, done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve7;
        let reject;
        const onerr = (er) => {
          this.off("data", ondata);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.off("error", onerr);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          this.pause();
          resolve7({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.off("error", onerr);
          this.off("data", ondata);
          this.off(DESTROYED, ondestroy);
          stop();
          resolve7({ done: true, value: void 0 });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve7 = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = () => {
        this.pause();
        this.off(ERROR, stop);
        this.off(DESTROYED, stop);
        this.off("end", stop);
        stopped = true;
        return { done: true, value: void 0 };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { done: false, value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[DISCARDED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      const wc = this;
      if (typeof wc.close === "function" && !this[CLOSED])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
      return isStream;
    }
  };

  // ../../node_modules/.pnpm/path-scurry@1.11.1/node_modules/path-scurry/dist/esm/index.js
  var realpathSync = import_fs.realpathSync.native;
  var defaultFS = {
    lstatSync: import_fs.lstatSync,
    readdir: import_fs.readdir,
    readdirSync: import_fs.readdirSync,
    readlinkSync: import_fs.readlinkSync,
    realpathSync,
    promises: {
      lstat: import_promises.lstat,
      readdir: import_promises.readdir,
      readlink: import_promises.readlink,
      realpath: import_promises.realpath
    }
  };
  var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
    ...defaultFS,
    ...fsOption,
    promises: {
      ...defaultFS.promises,
      ...fsOption.promises || {}
    }
  };
  var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
  var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
  var eitherSep = /[\\\/]/;
  var UNKNOWN = 0;
  var IFIFO = 1;
  var IFCHR = 2;
  var IFDIR = 4;
  var IFBLK = 6;
  var IFREG = 8;
  var IFLNK = 10;
  var IFSOCK = 12;
  var IFMT = 15;
  var IFMT_UNKNOWN = ~IFMT;
  var READDIR_CALLED = 16;
  var LSTAT_CALLED = 32;
  var ENOTDIR = 64;
  var ENOENT = 128;
  var ENOREADLINK = 256;
  var ENOREALPATH = 512;
  var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
  var TYPEMASK = 1023;
  var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
  var normalizeCache = /* @__PURE__ */ new Map();
  var normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
      return c;
    const n = s.normalize("NFKD");
    normalizeCache.set(s, n);
    return n;
  };
  var normalizeNocaseCache = /* @__PURE__ */ new Map();
  var normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
      return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
  };
  var ResolveCache = class extends LRUCache {
    constructor() {
      super({ max: 256 });
    }
  };
  var ChildrenCache = class extends LRUCache {
    constructor(maxSize = 16 * 1024) {
      super({
        maxSize,
        // parent + children
        sizeCalculation: (a) => a.length + 1
      });
    }
  };
  var setAsCwd = Symbol("PathScurry setAsCwd");
  var PathBase = class {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    /**
     * boolean indicating that this path is the current working directory
     * of the PathScurry collection that contains it.
     */
    isCWD = false;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
      return this.#dev;
    }
    #mode;
    get mode() {
      return this.#mode;
    }
    #nlink;
    get nlink() {
      return this.#nlink;
    }
    #uid;
    get uid() {
      return this.#uid;
    }
    #gid;
    get gid() {
      return this.#gid;
    }
    #rdev;
    get rdev() {
      return this.#rdev;
    }
    #blksize;
    get blksize() {
      return this.#blksize;
    }
    #ino;
    get ino() {
      return this.#ino;
    }
    #size;
    get size() {
      return this.#size;
    }
    #blocks;
    get blocks() {
      return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
      return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
      return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
      return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
      return this.#birthtimeMs;
    }
    #atime;
    get atime() {
      return this.#atime;
    }
    #mtime;
    get mtime() {
      return this.#mtime;
    }
    #ctime;
    get ctime() {
      return this.#ctime;
    }
    #birthtime;
    get birthtime() {
      return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['parentPath'] refers to the path of the
     * directory that was passed to readdir. For root entries, it's the path
     * to the entry itself.
     */
    get parentPath() {
      return (this.parent || this).fullpath();
    }
    /**
     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
     * this property refers to the *parent* path, not the path object itself.
     */
    get path() {
      return this.parentPath;
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      this.name = name;
      this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
      this.#type = type3 & TYPEMASK;
      this.nocase = nocase;
      this.roots = roots;
      this.root = root || this;
      this.#children = children;
      this.#fullpath = opts.fullpath;
      this.#relative = opts.relative;
      this.#relativePosix = opts.relativePosix;
      this.parent = opts.parent;
      if (this.parent) {
        this.#fs = this.parent.#fs;
      } else {
        this.#fs = fsFromOption(opts.fs);
      }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
      if (this.#depth !== void 0)
        return this.#depth;
      if (!this.parent)
        return this.#depth = 0;
      return this.#depth = this.parent.depth() + 1;
    }
    /**
     * @internal
     */
    childrenCache() {
      return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path2) {
      if (!path2) {
        return this;
      }
      const rootPath = this.getRootString(path2);
      const dir = path2.substring(rootPath.length);
      const dirParts = dir.split(this.splitSep);
      const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
      return result;
    }
    #resolveParts(dirParts) {
      let p = this;
      for (const part of dirParts) {
        p = p.child(part);
      }
      return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
      const cached = this.#children.get(this);
      if (cached) {
        return cached;
      }
      const children = Object.assign([], { provisional: 0 });
      this.#children.set(this, children);
      this.#type &= ~READDIR_CALLED;
      return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
      if (pathPart === "" || pathPart === ".") {
        return this;
      }
      if (pathPart === "..") {
        return this.parent || this;
      }
      const children = this.children();
      const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
      for (const p of children) {
        if (p.#matchName === name) {
          return p;
        }
      }
      const s = this.parent ? this.sep : "";
      const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
      const pchild = this.newChild(pathPart, UNKNOWN, {
        ...opts,
        parent: this,
        fullpath
      });
      if (!this.canReaddir()) {
        pchild.#type |= ENOENT;
      }
      children.push(pchild);
      return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
      if (this.isCWD)
        return "";
      if (this.#relative !== void 0) {
        return this.#relative;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relative = this.name;
      }
      const pv = p.relative();
      return pv + (!pv || !p.parent ? "" : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
      if (this.sep === "/")
        return this.relative();
      if (this.isCWD)
        return "";
      if (this.#relativePosix !== void 0)
        return this.#relativePosix;
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relativePosix = this.fullpathPosix();
      }
      const pv = p.relativePosix();
      return pv + (!pv || !p.parent ? "" : "/") + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
      if (this.#fullpath !== void 0) {
        return this.#fullpath;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#fullpath = this.name;
      }
      const pv = p.fullpath();
      const fp = pv + (!p.parent ? "" : this.sep) + name;
      return this.#fullpath = fp;
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
      if (this.#fullpathPosix !== void 0)
        return this.#fullpathPosix;
      if (this.sep === "/")
        return this.#fullpathPosix = this.fullpath();
      if (!this.parent) {
        const p2 = this.fullpath().replace(/\\/g, "/");
        if (/^[a-z]:\//i.test(p2)) {
          return this.#fullpathPosix = `//?/${p2}`;
        } else {
          return this.#fullpathPosix = p2;
        }
      }
      const p = this.parent;
      const pfpp = p.fullpathPosix();
      const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
      return this.#fullpathPosix = fpp;
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
      return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type3) {
      return this[`is${type3}`]();
    }
    getType() {
      return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
        /* c8 ignore start */
        this.isSocket() ? "Socket" : "Unknown"
      );
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
      return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
      return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
      return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
      return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
      return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
      return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
      return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
      return this.#type & LSTAT_CALLED ? this : void 0;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
      return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
      return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
      const children = this.children();
      return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
      if (this.#linkTarget)
        return true;
      if (!this.parent)
        return false;
      const ifmt = this.#type & IFMT;
      return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
      return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
      return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
      return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return void 0;
      }
      if (!this.parent) {
        return void 0;
      }
      try {
        const read = await this.#fs.promises.readlink(this.fullpath());
        const linkTarget = (await this.parent.realpath())?.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return void 0;
      }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return void 0;
      }
      if (!this.parent) {
        return void 0;
      }
      try {
        const read = this.#fs.readlinkSync(this.fullpath());
        const linkTarget = this.parent.realpathSync()?.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return void 0;
      }
    }
    #readdirSuccess(children) {
      this.#type |= READDIR_CALLED;
      for (let p = children.provisional; p < children.length; p++) {
        const c = children[p];
        if (c)
          c.#markENOENT();
      }
    }
    #markENOENT() {
      if (this.#type & ENOENT)
        return;
      this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
      this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
      const children = this.children();
      children.provisional = 0;
      for (const p of children) {
        p.#markENOENT();
      }
    }
    #markENOREALPATH() {
      this.#type |= ENOREALPATH;
      this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
      if (this.#type & ENOTDIR)
        return;
      let t = this.#type;
      if ((t & IFMT) === IFDIR)
        t &= IFMT_UNKNOWN;
      this.#type = t | ENOTDIR;
      this.#markChildrenENOENT();
    }
    #readdirFail(code = "") {
      if (code === "ENOTDIR" || code === "EPERM") {
        this.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      } else {
        this.children().provisional = 0;
      }
    }
    #lstatFail(code = "") {
      if (code === "ENOTDIR") {
        const p = this.parent;
        p.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      }
    }
    #readlinkFail(code = "") {
      let ter = this.#type;
      ter |= ENOREADLINK;
      if (code === "ENOENT")
        ter |= ENOENT;
      if (code === "EINVAL" || code === "UNKNOWN") {
        ter &= IFMT_UNKNOWN;
      }
      this.#type = ter;
      if (code === "ENOTDIR" && this.parent) {
        this.parent.#markENOTDIR();
      }
    }
    #readdirAddChild(e, c) {
      return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
    }
    #readdirAddNewChild(e, c) {
      const type3 = entToType(e);
      const child = this.newChild(e.name, type3, { parent: this });
      const ifmt = child.#type & IFMT;
      if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
        child.#type |= ENOTDIR;
      }
      c.unshift(child);
      c.provisional++;
      return child;
    }
    #readdirMaybePromoteChild(e, c) {
      for (let p = c.provisional; p < c.length; p++) {
        const pchild = c[p];
        const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
        if (name !== pchild.#matchName) {
          continue;
        }
        return this.#readdirPromoteChild(e, pchild, p, c);
      }
    }
    #readdirPromoteChild(e, p, index, c) {
      const v = p.name;
      p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
      if (v !== e.name)
        p.name = e.name;
      if (index !== c.provisional) {
        if (index === c.length - 1)
          c.pop();
        else
          c.splice(index, 1);
        c.unshift(p);
      }
      c.provisional++;
      return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(this.#fs.lstatSync(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    #applyStat(st) {
      const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
      this.#atime = atime;
      this.#atimeMs = atimeMs;
      this.#birthtime = birthtime;
      this.#birthtimeMs = birthtimeMs;
      this.#blksize = blksize;
      this.#blocks = blocks;
      this.#ctime = ctime;
      this.#ctimeMs = ctimeMs;
      this.#dev = dev;
      this.#gid = gid;
      this.#ino = ino;
      this.#mode = mode;
      this.#mtime = mtime;
      this.#mtimeMs = mtimeMs;
      this.#nlink = nlink;
      this.#rdev = rdev;
      this.#size = size;
      this.#uid = uid;
      const ifmt = entToType(st);
      this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
      if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
        this.#type |= ENOTDIR;
      }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
      this.#readdirCBInFlight = false;
      const cbs = this.#onReaddirCB.slice();
      this.#onReaddirCB.length = 0;
      cbs.forEach((cb) => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
      if (!this.canReaddir()) {
        if (allowZalgo)
          cb(null, []);
        else
          queueMicrotask(() => cb(null, []));
        return;
      }
      const children = this.children();
      if (this.calledReaddir()) {
        const c = children.slice(0, children.provisional);
        if (allowZalgo)
          cb(null, c);
        else
          queueMicrotask(() => cb(null, c));
        return;
      }
      this.#onReaddirCB.push(cb);
      if (this.#readdirCBInFlight) {
        return;
      }
      this.#readdirCBInFlight = true;
      const fullpath = this.fullpath();
      this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
        if (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        } else {
          for (const e of entries) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        }
        this.#callOnReaddirCB(children.slice(0, children.provisional));
        return;
      });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      if (this.#asyncReaddirInFlight) {
        await this.#asyncReaddirInFlight;
      } else {
        let resolve7 = () => {
        };
        this.#asyncReaddirInFlight = new Promise((res) => resolve7 = res);
        try {
          for (const e of await this.#fs.promises.readdir(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        this.#asyncReaddirInFlight = void 0;
        resolve7();
      }
      return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      try {
        for (const e of this.#fs.readdirSync(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      return children.slice(0, children.provisional);
    }
    canReaddir() {
      if (this.#type & ENOCHILD)
        return false;
      const ifmt = IFMT & this.#type;
      if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
        return false;
      }
      return true;
    }
    shouldWalk(dirs, walkFilter) {
      return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return void 0;
      try {
        const rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_) {
        this.#markENOREALPATH();
      }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return void 0;
      try {
        const rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_) {
        this.#markENOREALPATH();
      }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
      if (oldCwd === this)
        return;
      oldCwd.isCWD = false;
      this.isCWD = true;
      const changed = /* @__PURE__ */ new Set([]);
      let rp = [];
      let p = this;
      while (p && p.parent) {
        changed.add(p);
        p.#relative = rp.join(this.sep);
        p.#relativePosix = rp.join("/");
        p = p.parent;
        rp.push("..");
      }
      p = oldCwd;
      while (p && p.parent && !changed.has(p)) {
        p.#relative = void 0;
        p.#relativePosix = void 0;
        p = p.parent;
      }
    }
  };
  var PathWin32 = class extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = "\\";
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type3, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type3 = UNKNOWN, opts = {}) {
      return new PathWin32(name, type3, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path2) {
      return import_node_path.win32.parse(path2).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
      rootPath = uncToDrive(rootPath.toUpperCase());
      if (rootPath === this.root.name) {
        return this.root;
      }
      for (const [compare, root] of Object.entries(this.roots)) {
        if (this.sameRoot(rootPath, compare)) {
          return this.roots[rootPath] = root;
        }
      }
      return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
      rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
      return rootPath === compare;
    }
  };
  var PathPosix = class extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = "/";
    /**
     * separator for generating path strings
     */
    sep = "/";
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type3, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path2) {
      return path2.startsWith("/") ? "/" : "";
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
      return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type3 = UNKNOWN, opts = {}) {
      return new PathPosix(name, type3, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
  };
  var PathScurryBase = class {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs2 = defaultFS } = {}) {
      this.#fs = fsFromOption(fs2);
      if (cwd instanceof URL || cwd.startsWith("file://")) {
        cwd = (0, import_node_url.fileURLToPath)(cwd);
      }
      const cwdPath = pathImpl.resolve(cwd);
      this.roots = /* @__PURE__ */ Object.create(null);
      this.rootPath = this.parseRootPath(cwdPath);
      this.#resolveCache = new ResolveCache();
      this.#resolvePosixCache = new ResolveCache();
      this.#children = new ChildrenCache(childrenCacheSize);
      const split = cwdPath.substring(this.rootPath.length).split(sep2);
      if (split.length === 1 && !split[0]) {
        split.pop();
      }
      if (nocase === void 0) {
        throw new TypeError("must provide nocase setting to PathScurryBase ctor");
      }
      this.nocase = nocase;
      this.root = this.newRoot(this.#fs);
      this.roots[this.rootPath] = this.root;
      let prev = this.root;
      let len = split.length - 1;
      const joinSep = pathImpl.sep;
      let abs = this.rootPath;
      let sawFirst = false;
      for (const part of split) {
        const l = len--;
        prev = prev.child(part, {
          relative: new Array(l).fill("..").join(joinSep),
          relativePosix: new Array(l).fill("..").join("/"),
          fullpath: abs += (sawFirst ? "" : joinSep) + part
        });
        sawFirst = true;
      }
      this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path2 = this.cwd) {
      if (typeof path2 === "string") {
        path2 = this.cwd.resolve(path2);
      }
      return path2.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
      return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
      let r = "";
      for (let i = paths.length - 1; i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolveCache.get(r);
      if (cached !== void 0) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpath();
      this.#resolveCache.set(r, result);
      return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
      let r = "";
      for (let i = paths.length - 1; i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolvePosixCache.get(r);
      if (cached !== void 0) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpathPosix();
      this.#resolvePosixCache.set(r, result);
      return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else {
        const p = await entry.readdir();
        return withFileTypes ? p : p.map((e) => e.name);
      }
    }
    readdirSync(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else if (withFileTypes) {
        return entry.readdirSync();
      } else {
        return entry.readdirSync().map((e) => e.name);
      }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.readlink();
      return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.readlinkSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.realpath();
      return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.realpathSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set();
      const walk = (dir, cb) => {
        dirs.add(dir);
        dir.readdirCB((er, entries) => {
          if (er) {
            return cb(er);
          }
          let len = entries.length;
          if (!len)
            return cb();
          const next = () => {
            if (--len === 0) {
              cb();
            }
          };
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            if (follow && e.isSymbolicLink()) {
              e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
            } else {
              if (e.shouldWalk(dirs, walkFilter)) {
                walk(e, next);
              } else {
                next();
              }
            }
          }
        }, true);
      };
      const start = entry;
      return new Promise((res, rej) => {
        walk(start, (er) => {
          if (er)
            return rej(er);
          res(results);
        });
      });
    }
    walkSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
      return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        options = entry;
        entry = this.cwd;
      }
      return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      if (!filter2 || filter2(entry)) {
        yield withFileTypes ? entry : entry.fullpath();
      }
      const dirs = /* @__PURE__ */ new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            yield withFileTypes ? e : e.fullpath();
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
    }
    stream(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new Minipass({ objectMode: true });
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set();
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const onReaddir = (er, entries, didRealpaths = false) => {
            if (er)
              return results.emit("error", er);
            if (follow && !didRealpaths) {
              const promises2 = [];
              for (const e of entries) {
                if (e.isSymbolicLink()) {
                  promises2.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                }
              }
              if (promises2.length) {
                Promise.all(promises2).then(() => onReaddir(null, entries, true));
                return;
              }
            }
            for (const e of entries) {
              if (e && (!filter2 || filter2(e))) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              const r = e.realpathCached() || e;
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
            if (paused && !results.flowing) {
              results.once("drain", process2);
            } else if (!sync2) {
              process2();
            }
          };
          let sync2 = true;
          dir.readdirCB(onReaddir, true);
          sync2 = false;
        }
      };
      process2();
      return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new Minipass({ objectMode: true });
      const dirs = /* @__PURE__ */ new Set();
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
        }
        if (paused && !results.flowing)
          results.once("drain", process2);
      };
      process2();
      return results;
    }
    chdir(path2 = this.cwd) {
      const oldCwd = this.cwd;
      this.cwd = typeof path2 === "string" ? this.cwd.resolve(path2) : path2;
      this.cwd[setAsCwd](oldCwd);
    }
  };
  var PathScurryWin32 = class extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = "\\";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, import_node_path.win32, "\\", { ...opts, nocase });
      this.nocase = nocase;
      for (let p = this.cwd; p; p = p.parent) {
        p.nocase = this.nocase;
      }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
      return import_node_path.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs2) {
      return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
      return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
    }
  };
  var PathScurryPosix = class extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = "/";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = false } = opts;
      super(cwd, import_node_path.posix, "/", { ...opts, nocase });
      this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
      return "/";
    }
    /**
     * @internal
     */
    newRoot(fs2) {
      return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
      return p.startsWith("/");
    }
  };
  var PathScurryDarwin = class extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, { ...opts, nocase });
    }
  };
  var Path = process.platform === "win32" ? PathWin32 : PathPosix;
  var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/pattern.js
  var isPatternList = (pl) => pl.length >= 1;
  var isGlobList = (gl) => gl.length >= 1;
  var Pattern = class {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform2) {
      if (!isPatternList(patternList)) {
        throw new TypeError("empty pattern list");
      }
      if (!isGlobList(globList)) {
        throw new TypeError("empty glob list");
      }
      if (globList.length !== patternList.length) {
        throw new TypeError("mismatched pattern list and glob list lengths");
      }
      this.length = patternList.length;
      if (index < 0 || index >= this.length) {
        throw new TypeError("index out of range");
      }
      this.#patternList = patternList;
      this.#globList = globList;
      this.#index = index;
      this.#platform = platform2;
      if (this.#index === 0) {
        if (this.isUNC()) {
          const [p0, p1, p2, p3, ...prest] = this.#patternList;
          const [g0, g1, g2, g3, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = [p0, p1, p2, p3, ""].join("/");
          const g = [g0, g1, g2, g3, ""].join("/");
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        } else if (this.isDrive() || this.isAbsolute()) {
          const [p1, ...prest] = this.#patternList;
          const [g1, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = p1 + "/";
          const g = g1 + "/";
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        }
      }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
      return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
      return typeof this.#patternList[this.#index] === "string";
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
      return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
      return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
      return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
      return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
      if (this.#rest !== void 0)
        return this.#rest;
      if (!this.hasMore())
        return this.#rest = null;
      this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
      this.#rest.#isAbsolute = this.#isAbsolute;
      this.#rest.#isUNC = this.#isUNC;
      this.#rest.#isDrive = this.#isDrive;
      return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
      const pl = this.#patternList;
      return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
      const pl = this.#patternList;
      return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
      const pl = this.#patternList;
      return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
      const p = this.#patternList[0];
      return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
      return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
      if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
        return false;
      this.#followGlobstar = false;
      return true;
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/ignore.js
  var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
  var Ignore = class {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform2 = defaultPlatform2 }) {
      this.relative = [];
      this.absolute = [];
      this.relativeChildren = [];
      this.absoluteChildren = [];
      this.platform = platform2;
      this.mmopts = {
        dot: true,
        nobrace,
        nocase,
        noext,
        noglobstar,
        optimizationLevel: 2,
        platform: platform2,
        nocomment: true,
        nonegate: true
      };
      for (const ign of ignored)
        this.add(ign);
    }
    add(ign) {
      const mm = new Minimatch(ign, this.mmopts);
      for (let i = 0; i < mm.set.length; i++) {
        const parsed = mm.set[i];
        const globParts = mm.globParts[i];
        if (!parsed || !globParts) {
          throw new Error("invalid pattern object");
        }
        while (parsed[0] === "." && globParts[0] === ".") {
          parsed.shift();
          globParts.shift();
        }
        const p = new Pattern(parsed, globParts, 0, this.platform);
        const m = new Minimatch(p.globString(), this.mmopts);
        const children = globParts[globParts.length - 1] === "**";
        const absolute = p.isAbsolute();
        if (absolute)
          this.absolute.push(m);
        else
          this.relative.push(m);
        if (children) {
          if (absolute)
            this.absoluteChildren.push(m);
          else
            this.relativeChildren.push(m);
        }
      }
    }
    ignored(p) {
      const fullpath = p.fullpath();
      const fullpaths = `${fullpath}/`;
      const relative = p.relative() || ".";
      const relatives = `${relative}/`;
      for (const m of this.relative) {
        if (m.match(relative) || m.match(relatives))
          return true;
      }
      for (const m of this.absolute) {
        if (m.match(fullpath) || m.match(fullpaths))
          return true;
      }
      return false;
    }
    childrenIgnored(p) {
      const fullpath = p.fullpath() + "/";
      const relative = (p.relative() || ".") + "/";
      for (const m of this.relativeChildren) {
        if (m.match(relative))
          return true;
      }
      for (const m of this.absoluteChildren) {
        if (m.match(fullpath))
          return true;
      }
      return false;
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/processor.js
  var HasWalkedCache = class {
    store;
    constructor(store = /* @__PURE__ */ new Map()) {
      this.store = store;
    }
    copy() {
      return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
      return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
      const fullpath = target.fullpath();
      const cached = this.store.get(fullpath);
      if (cached)
        cached.add(pattern.globString());
      else
        this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
    }
  };
  var MatchRecord = class {
    store = /* @__PURE__ */ new Map();
    add(target, absolute, ifDir) {
      const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
      const current = this.store.get(target);
      this.store.set(target, current === void 0 ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
      return [...this.store.entries()].map(([path2, n]) => [
        path2,
        !!(n & 2),
        !!(n & 1)
      ]);
    }
  };
  var SubWalks = class {
    store = /* @__PURE__ */ new Map();
    add(target, pattern) {
      if (!target.canReaddir()) {
        return;
      }
      const subs = this.store.get(target);
      if (subs) {
        if (!subs.find((p) => p.globString() === pattern.globString())) {
          subs.push(pattern);
        }
      } else
        this.store.set(target, [pattern]);
    }
    get(target) {
      const subs = this.store.get(target);
      if (!subs) {
        throw new Error("attempting to walk unknown path");
      }
      return subs;
    }
    entries() {
      return this.keys().map((k) => [k, this.store.get(k)]);
    }
    keys() {
      return [...this.store.keys()].filter((t) => t.canReaddir());
    }
  };
  var Processor = class {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
      this.opts = opts;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
      this.patterns = patterns;
      const processingSet = patterns.map((p) => [target, p]);
      for (let [t, pattern] of processingSet) {
        this.hasWalkedCache.storeWalked(t, pattern);
        const root = pattern.root();
        const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
        if (root) {
          t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
          const rest2 = pattern.rest();
          if (!rest2) {
            this.matches.add(t, true, false);
            continue;
          } else {
            pattern = rest2;
          }
        }
        if (t.isENOENT())
          continue;
        let p;
        let rest;
        let changed = false;
        while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
          const c = t.resolve(p);
          t = c;
          pattern = rest;
          changed = true;
        }
        p = pattern.pattern();
        rest = pattern.rest();
        if (changed) {
          if (this.hasWalkedCache.hasWalked(t, pattern))
            continue;
          this.hasWalkedCache.storeWalked(t, pattern);
        }
        if (typeof p === "string") {
          const ifDir = p === ".." || p === "" || p === ".";
          this.matches.add(t.resolve(p), absolute, ifDir);
          continue;
        } else if (p === GLOBSTAR) {
          if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
            this.subwalks.add(t, pattern);
          }
          const rp = rest?.pattern();
          const rrest = rest?.rest();
          if (!rest || (rp === "" || rp === ".") && !rrest) {
            this.matches.add(t, absolute, rp === "" || rp === ".");
          } else {
            if (rp === "..") {
              const tp = t.parent || t;
              if (!rrest)
                this.matches.add(tp, absolute, true);
              else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                this.subwalks.add(tp, rrest);
              }
            }
          }
        } else if (p instanceof RegExp) {
          this.subwalks.add(t, pattern);
        }
      }
      return this;
    }
    subwalkTargets() {
      return this.subwalks.keys();
    }
    child() {
      return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
      const patterns = this.subwalks.get(parent);
      const results = this.child();
      for (const e of entries) {
        for (const pattern of patterns) {
          const absolute = pattern.isAbsolute();
          const p = pattern.pattern();
          const rest = pattern.rest();
          if (p === GLOBSTAR) {
            results.testGlobstar(e, pattern, rest, absolute);
          } else if (p instanceof RegExp) {
            results.testRegExp(e, p, rest, absolute);
          } else {
            results.testString(e, p, rest, absolute);
          }
        }
      }
      return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
      if (this.dot || !e.name.startsWith(".")) {
        if (!pattern.hasMore()) {
          this.matches.add(e, absolute, false);
        }
        if (e.canReaddir()) {
          if (this.follow || !e.isSymbolicLink()) {
            this.subwalks.add(e, pattern);
          } else if (e.isSymbolicLink()) {
            if (rest && pattern.checkFollowGlobstar()) {
              this.subwalks.add(e, rest);
            } else if (pattern.markFollowGlobstar()) {
              this.subwalks.add(e, pattern);
            }
          }
        }
      }
      if (rest) {
        const rp = rest.pattern();
        if (typeof rp === "string" && // dots and empty were handled already
        rp !== ".." && rp !== "" && rp !== ".") {
          this.testString(e, rp, rest.rest(), absolute);
        } else if (rp === "..") {
          const ep = e.parent || e;
          this.subwalks.add(ep, rest);
        } else if (rp instanceof RegExp) {
          this.testRegExp(e, rp, rest.rest(), absolute);
        }
      }
    }
    testRegExp(e, p, rest, absolute) {
      if (!p.test(e.name))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
    testString(e, p, rest, absolute) {
      if (!e.isNamed(p))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/walker.js
  var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
  var GlobUtil = class {
    path;
    patterns;
    opts;
    seen = /* @__PURE__ */ new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path2, opts) {
      this.patterns = patterns;
      this.path = path2;
      this.opts = opts;
      this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
      this.includeChildMatches = opts.includeChildMatches !== false;
      if (opts.ignore || !this.includeChildMatches) {
        this.#ignore = makeIgnore(opts.ignore ?? [], opts);
        if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
          const m = "cannot ignore child matches, ignore lacks add() method.";
          throw new Error(m);
        }
      }
      this.maxDepth = opts.maxDepth || Infinity;
      if (opts.signal) {
        this.signal = opts.signal;
        this.signal.addEventListener("abort", () => {
          this.#onResume.length = 0;
        });
      }
    }
    #ignored(path2) {
      return this.seen.has(path2) || !!this.#ignore?.ignored?.(path2);
    }
    #childrenIgnored(path2) {
      return !!this.#ignore?.childrenIgnored?.(path2);
    }
    // backpressure mechanism
    pause() {
      this.paused = true;
    }
    resume() {
      if (this.signal?.aborted)
        return;
      this.paused = false;
      let fn = void 0;
      while (!this.paused && (fn = this.#onResume.shift())) {
        fn();
      }
    }
    onResume(fn) {
      if (this.signal?.aborted)
        return;
      if (!this.paused) {
        fn();
      } else {
        this.#onResume.push(fn);
      }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return void 0;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || await e.realpath();
        if (!rpc)
          return void 0;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      const s = needStat ? await e.lstat() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        const target = await s.realpath();
        if (target && (target.isUnknown() || this.opts.stat)) {
          await target.lstat();
        }
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
      return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
    }
    matchCheckSync(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return void 0;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || e.realpathSync();
        if (!rpc)
          return void 0;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      const s = needStat ? e.lstatSync() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        const target = s.realpathSync();
        if (target && (target?.isUnknown() || this.opts.stat)) {
          target.lstatSync();
        }
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
      if (this.#ignored(e))
        return;
      if (!this.includeChildMatches && this.#ignore?.add) {
        const ign = `${e.relativePosix()}/**`;
        this.#ignore.add(ign);
      }
      const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
      this.seen.add(e);
      const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
      if (this.opts.withFileTypes) {
        this.matchEmit(e);
      } else if (abs) {
        const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
        this.matchEmit(abs2 + mark);
      } else {
        const rel = this.opts.posix ? e.relativePosix() : e.relative();
        const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
        this.matchEmit(!rel ? "." + mark : pre + rel + mark);
      }
    }
    async match(e, absolute, ifDir) {
      const p = await this.matchCheck(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
      const p = this.matchCheckSync(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const childrenCached = t.readdirCached();
        if (t.calledReaddir())
          this.walkCB3(t, childrenCached, processor, next);
        else {
          t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
        }
      }
      next();
    }
    walkCB3(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2(target2, patterns, processor.child(), next);
      }
      next();
    }
    walkCBSync(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const children = t.readdirSync();
        this.walkCB3Sync(t, children, processor, next);
      }
      next();
    }
    walkCB3Sync(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2Sync(target2, patterns, processor.child(), next);
      }
      next();
    }
  };
  var GlobWalker = class extends GlobUtil {
    matches = /* @__PURE__ */ new Set();
    constructor(patterns, path2, opts) {
      super(patterns, path2, opts);
    }
    matchEmit(e) {
      this.matches.add(e);
    }
    async walk() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        await this.path.lstat();
      }
      await new Promise((res, rej) => {
        this.walkCB(this.path, this.patterns, () => {
          if (this.signal?.aborted) {
            rej(this.signal.reason);
          } else {
            res(this.matches);
          }
        });
      });
      return this.matches;
    }
    walkSync() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => {
        if (this.signal?.aborted)
          throw this.signal.reason;
      });
      return this.matches;
    }
  };
  var GlobStream = class extends GlobUtil {
    results;
    constructor(patterns, path2, opts) {
      super(patterns, path2, opts);
      this.results = new Minipass({
        signal: this.signal,
        objectMode: true
      });
      this.results.on("drain", () => this.resume());
      this.results.on("resume", () => this.resume());
    }
    matchEmit(e) {
      this.results.write(e);
      if (!this.results.flowing)
        this.pause();
    }
    stream() {
      const target = this.path;
      if (target.isUnknown()) {
        target.lstat().then(() => {
          this.walkCB(target, this.patterns, () => this.results.end());
        });
      } else {
        this.walkCB(target, this.patterns, () => this.results.end());
      }
      return this.results;
    }
    streamSync() {
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => this.results.end());
      return this.results;
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/glob.js
  var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
  var Glob = class {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
      if (!opts)
        throw new TypeError("glob options required");
      this.withFileTypes = !!opts.withFileTypes;
      this.signal = opts.signal;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.dotRelative = !!opts.dotRelative;
      this.nodir = !!opts.nodir;
      this.mark = !!opts.mark;
      if (!opts.cwd) {
        this.cwd = "";
      } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
        opts.cwd = (0, import_node_url2.fileURLToPath)(opts.cwd);
      }
      this.cwd = opts.cwd || "";
      this.root = opts.root;
      this.magicalBraces = !!opts.magicalBraces;
      this.nobrace = !!opts.nobrace;
      this.noext = !!opts.noext;
      this.realpath = !!opts.realpath;
      this.absolute = opts.absolute;
      this.includeChildMatches = opts.includeChildMatches !== false;
      this.noglobstar = !!opts.noglobstar;
      this.matchBase = !!opts.matchBase;
      this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
      this.stat = !!opts.stat;
      this.ignore = opts.ignore;
      if (this.withFileTypes && this.absolute !== void 0) {
        throw new Error("cannot set absolute and withFileTypes:true");
      }
      if (typeof pattern === "string") {
        pattern = [pattern];
      }
      this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        pattern = pattern.map((p) => p.replace(/\\/g, "/"));
      }
      if (this.matchBase) {
        if (opts.noglobstar) {
          throw new TypeError("base matching requires globstar");
        }
        pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
      }
      this.pattern = pattern;
      this.platform = opts.platform || defaultPlatform3;
      this.opts = { ...opts, platform: this.platform };
      if (opts.scurry) {
        this.scurry = opts.scurry;
        if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
          throw new Error("nocase option contradicts provided scurry option");
        }
      } else {
        const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
        this.scurry = new Scurry(this.cwd, {
          nocase: opts.nocase,
          fs: opts.fs
        });
      }
      this.nocase = this.scurry.nocase;
      const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
      const mmo = {
        // default nocase based on platform
        ...opts,
        dot: this.dot,
        matchBase: this.matchBase,
        nobrace: this.nobrace,
        nocase: this.nocase,
        nocaseMagicOnly,
        nocomment: true,
        noext: this.noext,
        nonegate: true,
        optimizationLevel: 2,
        platform: this.platform,
        windowsPathsNoEscape: this.windowsPathsNoEscape,
        debug: !!this.opts.debug
      };
      const mms = this.pattern.map((p) => new Minimatch(p, mmo));
      const [matchSet, globParts] = mms.reduce((set, m) => {
        set[0].push(...m.set);
        set[1].push(...m.globParts);
        return set;
      }, [[], []]);
      this.patterns = matchSet.map((set, i) => {
        const g = globParts[i];
        if (!g)
          throw new Error("invalid pattern object");
        return new Pattern(set, g, 0, this.platform);
      });
    }
    async walk() {
      return [
        ...await new GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walk()
      ];
    }
    walkSync() {
      return [
        ...new GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walkSync()
      ];
    }
    stream() {
      return new GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).stream();
    }
    streamSync() {
      return new GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
      return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
      return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/has-magic.js
  var hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
      pattern = [pattern];
    }
    for (const p of pattern) {
      if (new Minimatch(p, options).hasMagic())
        return true;
    }
    return false;
  };

  // ../../node_modules/.pnpm/glob@10.4.5/node_modules/glob/dist/esm/index.js
  function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
  }
  function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
  }
  function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
  }
  async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
  }
  function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
  }
  function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
  }
  var streamSync = globStreamSync;
  var stream = Object.assign(globStream, { sync: globStreamSync });
  var iterateSync = globIterateSync;
  var iterate = Object.assign(globIterate, {
    sync: globIterateSync
  });
  var sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync
  });
  var glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob,
    hasMagic,
    escape,
    unescape
  });
  glob.glob = glob;

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/mkdirp-manual.js
  var import_path = __require("path");

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/opts-arg.js
  var import_fs2 = __require("fs");
  var optsArg = (opts) => {
    if (!opts) {
      opts = { mode: 511 };
    } else if (typeof opts === "object") {
      opts = { mode: 511, ...opts };
    } else if (typeof opts === "number") {
      opts = { mode: opts };
    } else if (typeof opts === "string") {
      opts = { mode: parseInt(opts, 8) };
    } else {
      throw new TypeError("invalid options argument");
    }
    const resolved = opts;
    const optsFs = opts.fs || {};
    opts.mkdir = opts.mkdir || optsFs.mkdir || import_fs2.mkdir;
    opts.mkdirAsync = opts.mkdirAsync ? opts.mkdirAsync : async (path2, options) => {
      return new Promise((res, rej) => resolved.mkdir(path2, options, (er, made) => er ? rej(er) : res(made)));
    };
    opts.stat = opts.stat || optsFs.stat || import_fs2.stat;
    opts.statAsync = opts.statAsync ? opts.statAsync : async (path2) => new Promise((res, rej) => resolved.stat(path2, (err, stats) => err ? rej(err) : res(stats)));
    opts.statSync = opts.statSync || optsFs.statSync || import_fs2.statSync;
    opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || import_fs2.mkdirSync;
    return resolved;
  };

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/mkdirp-manual.js
  var mkdirpManualSync = (path2, options, made) => {
    const parent = (0, import_path.dirname)(path2);
    const opts = { ...optsArg(options), recursive: false };
    if (parent === path2) {
      try {
        return opts.mkdirSync(path2, opts);
      } catch (er) {
        const fer = er;
        if (fer && fer.code !== "EISDIR") {
          throw er;
        }
        return;
      }
    }
    try {
      opts.mkdirSync(path2, opts);
      return made || path2;
    } catch (er) {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManualSync(path2, opts, mkdirpManualSync(parent, opts, made));
      }
      if (fer && fer.code !== "EEXIST" && fer && fer.code !== "EROFS") {
        throw er;
      }
      try {
        if (!opts.statSync(path2).isDirectory())
          throw er;
      } catch (_) {
        throw er;
      }
    }
  };
  var mkdirpManual = Object.assign(async (path2, options, made) => {
    const opts = optsArg(options);
    opts.recursive = false;
    const parent = (0, import_path.dirname)(path2);
    if (parent === path2) {
      return opts.mkdirAsync(path2, opts).catch((er) => {
        const fer = er;
        if (fer && fer.code !== "EISDIR") {
          throw er;
        }
      });
    }
    return opts.mkdirAsync(path2, opts).then(() => made || path2, async (er) => {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path2, opts, made2));
      }
      if (fer && fer.code !== "EEXIST" && fer.code !== "EROFS") {
        throw er;
      }
      return opts.statAsync(path2).then((st) => {
        if (st.isDirectory()) {
          return made;
        } else {
          throw er;
        }
      }, () => {
        throw er;
      });
    });
  }, { sync: mkdirpManualSync });

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/mkdirp-native.js
  var import_path3 = __require("path");

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/find-made.js
  var import_path2 = __require("path");
  var findMade = async (opts, parent, path2) => {
    if (path2 === parent) {
      return;
    }
    return opts.statAsync(parent).then(
      (st) => st.isDirectory() ? path2 : void 0,
      // will fail later
      // will fail later
      (er) => {
        const fer = er;
        return fer && fer.code === "ENOENT" ? findMade(opts, (0, import_path2.dirname)(parent), parent) : void 0;
      }
    );
  };
  var findMadeSync = (opts, parent, path2) => {
    if (path2 === parent) {
      return void 0;
    }
    try {
      return opts.statSync(parent).isDirectory() ? path2 : void 0;
    } catch (er) {
      const fer = er;
      return fer && fer.code === "ENOENT" ? findMadeSync(opts, (0, import_path2.dirname)(parent), parent) : void 0;
    }
  };

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/mkdirp-native.js
  var mkdirpNativeSync = (path2, options) => {
    const opts = optsArg(options);
    opts.recursive = true;
    const parent = (0, import_path3.dirname)(path2);
    if (parent === path2) {
      return opts.mkdirSync(path2, opts);
    }
    const made = findMadeSync(opts, path2);
    try {
      opts.mkdirSync(path2, opts);
      return made;
    } catch (er) {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManualSync(path2, opts);
      } else {
        throw er;
      }
    }
  };
  var mkdirpNative = Object.assign(async (path2, options) => {
    const opts = { ...optsArg(options), recursive: true };
    const parent = (0, import_path3.dirname)(path2);
    if (parent === path2) {
      return await opts.mkdirAsync(path2, opts);
    }
    return findMade(opts, path2).then((made) => opts.mkdirAsync(path2, opts).then((m) => made || m).catch((er) => {
      const fer = er;
      if (fer && fer.code === "ENOENT") {
        return mkdirpManual(path2, opts);
      } else {
        throw er;
      }
    }));
  }, { sync: mkdirpNativeSync });

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/path-arg.js
  var import_path4 = __require("path");
  var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var pathArg = (path2) => {
    if (/\0/.test(path2)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path: path2,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path2 = (0, import_path4.resolve)(path2);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const { root } = (0, import_path4.parse)(path2);
      if (badWinChars.test(path2.substring(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path2,
          code: "EINVAL"
        });
      }
    }
    return path2;
  };

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/use-native.js
  var import_fs3 = __require("fs");
  var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  var useNativeSync = !hasNative ? () => false : (opts) => optsArg(opts).mkdirSync === import_fs3.mkdirSync;
  var useNative = Object.assign(!hasNative ? () => false : (opts) => optsArg(opts).mkdir === import_fs3.mkdir, {
    sync: useNativeSync
  });

  // ../../node_modules/.pnpm/mkdirp@3.0.1/node_modules/mkdirp/dist/mjs/index.js
  var mkdirpSync = (path2, opts) => {
    path2 = pathArg(path2);
    const resolved = optsArg(opts);
    return useNativeSync(resolved) ? mkdirpNativeSync(path2, resolved) : mkdirpManualSync(path2, resolved);
  };
  var mkdirp = Object.assign(async (path2, opts) => {
    path2 = pathArg(path2);
    const resolved = optsArg(opts);
    return useNative(resolved) ? mkdirpNative(path2, resolved) : mkdirpManual(path2, resolved);
  }, {
    mkdirpSync,
    mkdirpNative,
    mkdirpNativeSync,
    mkdirpManual,
    mkdirpManualSync,
    sync: mkdirpSync,
    native: mkdirpNative,
    nativeSync: mkdirpNativeSync,
    manual: mkdirpManual,
    manualSync: mkdirpManualSync,
    useNative,
    useNativeSync
  });

  // src/runTypegen.ts
  var import_path13 = __require("path");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/opt-arg.js
  var typeOrUndef = (val, t) => typeof val === "undefined" || typeof val === t;
  var isRimrafOptions = (o) => !!o && typeof o === "object" && typeOrUndef(o.preserveRoot, "boolean") && typeOrUndef(o.tmp, "string") && typeOrUndef(o.maxRetries, "number") && typeOrUndef(o.retryDelay, "number") && typeOrUndef(o.backoff, "number") && typeOrUndef(o.maxBackoff, "number") && (typeOrUndef(o.glob, "boolean") || o.glob && typeof o.glob === "object") && typeOrUndef(o.filter, "function");
  var assertRimrafOptions = (o) => {
    if (!isRimrafOptions(o)) {
      throw new Error("invalid rimraf options");
    }
  };
  var optArgT = (opt) => {
    assertRimrafOptions(opt);
    const { glob: glob2, ...options } = opt;
    if (!glob2) {
      return options;
    }
    const globOpt = glob2 === true ? opt.signal ? { signal: opt.signal } : {} : opt.signal ? {
      signal: opt.signal,
      ...glob2
    } : glob2;
    return {
      ...options,
      glob: {
        ...globOpt,
        // always get absolute paths from glob, to ensure
        // that we are referencing the correct thing.
        absolute: true,
        withFileTypes: false
      }
    };
  };
  var optArg = (opt = {}) => optArgT(opt);
  var optArgSync = (opt = {}) => optArgT(opt);

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/path-arg.js
  var import_path5 = __require("path");
  var import_util = __require("util");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/platform.js
  var platform_default = process.env.__TESTING_RIMRAF_PLATFORM__ || process.platform;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/path-arg.js
  var pathArg2 = (path2, opt = {}) => {
    const type3 = typeof path2;
    if (type3 !== "string") {
      const ctor = path2 && type3 === "object" && path2.constructor;
      const received = ctor && ctor.name ? `an instance of ${ctor.name}` : type3 === "object" ? (0, import_util.inspect)(path2) : `type ${type3} ${path2}`;
      const msg = `The "path" argument must be of type string. Received ${received}`;
      throw Object.assign(new TypeError(msg), {
        path: path2,
        code: "ERR_INVALID_ARG_TYPE"
      });
    }
    if (/\0/.test(path2)) {
      const msg = "path must be a string without null bytes";
      throw Object.assign(new TypeError(msg), {
        path: path2,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path2 = (0, import_path5.resolve)(path2);
    const { root } = (0, import_path5.parse)(path2);
    if (path2 === root && opt.preserveRoot !== false) {
      const msg = "refusing to remove root directory without preserveRoot:false";
      throw Object.assign(new Error(msg), {
        path: path2,
        code: "ERR_PRESERVE_ROOT"
      });
    }
    if (platform_default === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const { root: root2 } = (0, import_path5.parse)(path2);
      if (badWinChars.test(path2.substring(root2.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path2,
          code: "EINVAL"
        });
      }
    }
    return path2;
  };
  var path_arg_default = pathArg2;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/fs.js
  var import_fs4 = __toESM(__require("fs"), 1);
  var import_fs5 = __require("fs");
  var import_fs6 = __require("fs");
  var readdirSync2 = (path2) => (0, import_fs6.readdirSync)(path2, { withFileTypes: true });
  var chmod = (path2, mode) => new Promise((res, rej) => import_fs4.default.chmod(path2, mode, (er, ...d) => er ? rej(er) : res(...d)));
  var mkdir3 = (path2, options) => new Promise((res, rej) => import_fs4.default.mkdir(path2, options, (er, made) => er ? rej(er) : res(made)));
  var readdir2 = (path2) => new Promise((res, rej) => import_fs4.default.readdir(path2, { withFileTypes: true }, (er, data) => er ? rej(er) : res(data)));
  var rename = (oldPath, newPath) => new Promise((res, rej) => import_fs4.default.rename(oldPath, newPath, (er, ...d) => er ? rej(er) : res(...d)));
  var rm = (path2, options) => new Promise((res, rej) => import_fs4.default.rm(path2, options, (er, ...d) => er ? rej(er) : res(...d)));
  var rmdir = (path2) => new Promise((res, rej) => import_fs4.default.rmdir(path2, (er, ...d) => er ? rej(er) : res(...d)));
  var stat2 = (path2) => new Promise((res, rej) => import_fs4.default.stat(path2, (er, data) => er ? rej(er) : res(data)));
  var lstat2 = (path2) => new Promise((res, rej) => import_fs4.default.lstat(path2, (er, data) => er ? rej(er) : res(data)));
  var unlink = (path2) => new Promise((res, rej) => import_fs4.default.unlink(path2, (er, ...d) => er ? rej(er) : res(...d)));
  var promises = {
    chmod,
    mkdir: mkdir3,
    readdir: readdir2,
    rename,
    rm,
    rmdir,
    stat: stat2,
    lstat: lstat2,
    unlink
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-posix.js
  var import_path6 = __require("path");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/readdir-or-error.js
  var { readdir: readdir3 } = promises;
  var readdirOrError = (path2) => readdir3(path2).catch((er) => er);
  var readdirOrErrorSync = (path2) => {
    try {
      return readdirSync2(path2);
    } catch (er) {
      return er;
    }
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/ignore-enoent.js
  var ignoreENOENT = async (p) => p.catch((er) => {
    if (er.code !== "ENOENT") {
      throw er;
    }
  });
  var ignoreENOENTSync = (fn) => {
    try {
      return fn();
    } catch (er) {
      if (er?.code !== "ENOENT") {
        throw er;
      }
    }
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-posix.js
  var { lstat: lstat3, rmdir: rmdir2, unlink: unlink2 } = promises;
  var rimrafPosix = async (path2, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return await rimrafPosixDir(path2, opt, await lstat3(path2));
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafPosixSync = (path2, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return rimrafPosixDirSync(path2, opt, (0, import_fs5.lstatSync)(path2));
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafPosixDir = async (path2, opt, ent) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const entries = ent.isDirectory() ? await readdirOrError(path2) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !await opt.filter(path2, ent)) {
        return false;
      }
      await ignoreENOENT(unlink2(path2));
      return true;
    }
    const removedAll = (await Promise.all(entries.map((ent2) => rimrafPosixDir((0, import_path6.resolve)(path2, ent2.name), opt, ent2)))).reduce((a, b) => a && b, true);
    if (!removedAll) {
      return false;
    }
    if (opt.preserveRoot === false && path2 === (0, import_path6.parse)(path2).root) {
      return false;
    }
    if (opt.filter && !await opt.filter(path2, ent)) {
      return false;
    }
    await ignoreENOENT(rmdir2(path2));
    return true;
  };
  var rimrafPosixDirSync = (path2, opt, ent) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const entries = ent.isDirectory() ? readdirOrErrorSync(path2) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !opt.filter(path2, ent)) {
        return false;
      }
      ignoreENOENTSync(() => (0, import_fs5.unlinkSync)(path2));
      return true;
    }
    let removedAll = true;
    for (const ent2 of entries) {
      const p = (0, import_path6.resolve)(path2, ent2.name);
      removedAll = rimrafPosixDirSync(p, opt, ent2) && removedAll;
    }
    if (opt.preserveRoot === false && path2 === (0, import_path6.parse)(path2).root) {
      return false;
    }
    if (!removedAll) {
      return false;
    }
    if (opt.filter && !opt.filter(path2, ent)) {
      return false;
    }
    ignoreENOENTSync(() => (0, import_fs5.rmdirSync)(path2));
    return true;
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-windows.js
  var import_path9 = __require("path");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/fix-eperm.js
  var { chmod: chmod2 } = promises;
  var fixEPERM = (fn) => async (path2) => {
    try {
      return await fn(path2);
    } catch (er) {
      const fer = er;
      if (fer?.code === "ENOENT") {
        return;
      }
      if (fer?.code === "EPERM") {
        try {
          await chmod2(path2, 438);
        } catch (er2) {
          const fer2 = er2;
          if (fer2?.code === "ENOENT") {
            return;
          }
          throw er;
        }
        return await fn(path2);
      }
      throw er;
    }
  };
  var fixEPERMSync = (fn) => (path2) => {
    try {
      return fn(path2);
    } catch (er) {
      const fer = er;
      if (fer?.code === "ENOENT") {
        return;
      }
      if (fer?.code === "EPERM") {
        try {
          (0, import_fs5.chmodSync)(path2, 438);
        } catch (er2) {
          const fer2 = er2;
          if (fer2?.code === "ENOENT") {
            return;
          }
          throw er;
        }
        return fn(path2);
      }
      throw er;
    }
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/retry-busy.js
  var MAXBACKOFF = 200;
  var RATE = 1.2;
  var MAXRETRIES = 10;
  var codes = /* @__PURE__ */ new Set(["EMFILE", "ENFILE", "EBUSY"]);
  var retryBusy = (fn) => {
    const method = async (path2, opt, backoff = 1, total = 0) => {
      const mbo = opt.maxBackoff || MAXBACKOFF;
      const rate = opt.backoff || RATE;
      const max = opt.maxRetries || MAXRETRIES;
      let retries = 0;
      while (true) {
        try {
          return await fn(path2);
        } catch (er) {
          const fer = er;
          if (fer?.path === path2 && fer?.code && codes.has(fer.code)) {
            backoff = Math.ceil(backoff * rate);
            total = backoff + total;
            if (total < mbo) {
              return new Promise((res, rej) => {
                setTimeout(() => {
                  method(path2, opt, backoff, total).then(res, rej);
                }, backoff);
              });
            }
            if (retries < max) {
              retries++;
              continue;
            }
          }
          throw er;
        }
      }
    };
    return method;
  };
  var retryBusySync = (fn) => {
    const method = (path2, opt) => {
      const max = opt.maxRetries || MAXRETRIES;
      let retries = 0;
      while (true) {
        try {
          return fn(path2);
        } catch (er) {
          const fer = er;
          if (fer?.path === path2 && fer?.code && codes.has(fer.code) && retries < max) {
            retries++;
            continue;
          }
          throw er;
        }
      }
    };
    return method;
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-move-remove.js
  var import_path8 = __require("path");

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/default-tmp.js
  var import_os = __require("os");
  var import_path7 = __require("path");
  var { stat: stat3 } = promises;
  var isDirSync = (path2) => {
    try {
      return (0, import_fs5.statSync)(path2).isDirectory();
    } catch (er) {
      return false;
    }
  };
  var isDir = (path2) => stat3(path2).then((st) => st.isDirectory(), () => false);
  var win32DefaultTmp = async (path2) => {
    const { root } = (0, import_path7.parse)(path2);
    const tmp = (0, import_os.tmpdir)();
    const { root: tmpRoot } = (0, import_path7.parse)(tmp);
    if (root.toLowerCase() === tmpRoot.toLowerCase()) {
      return tmp;
    }
    const driveTmp = (0, import_path7.resolve)(root, "/temp");
    if (await isDir(driveTmp)) {
      return driveTmp;
    }
    return root;
  };
  var win32DefaultTmpSync = (path2) => {
    const { root } = (0, import_path7.parse)(path2);
    const tmp = (0, import_os.tmpdir)();
    const { root: tmpRoot } = (0, import_path7.parse)(tmp);
    if (root.toLowerCase() === tmpRoot.toLowerCase()) {
      return tmp;
    }
    const driveTmp = (0, import_path7.resolve)(root, "/temp");
    if (isDirSync(driveTmp)) {
      return driveTmp;
    }
    return root;
  };
  var posixDefaultTmp = async () => (0, import_os.tmpdir)();
  var posixDefaultTmpSync = () => (0, import_os.tmpdir)();
  var defaultTmp = platform_default === "win32" ? win32DefaultTmp : posixDefaultTmp;
  var defaultTmpSync = platform_default === "win32" ? win32DefaultTmpSync : posixDefaultTmpSync;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-move-remove.js
  var { lstat: lstat4, rename: rename2, unlink: unlink3, rmdir: rmdir3, chmod: chmod3 } = promises;
  var uniqueFilename = (path2) => `.${(0, import_path8.basename)(path2)}.${Math.random()}`;
  var unlinkFixEPERM = async (path2) => unlink3(path2).catch((er) => {
    if (er.code === "EPERM") {
      return chmod3(path2, 438).then(() => unlink3(path2), (er2) => {
        if (er2.code === "ENOENT") {
          return;
        }
        throw er;
      });
    } else if (er.code === "ENOENT") {
      return;
    }
    throw er;
  });
  var unlinkFixEPERMSync = (path2) => {
    try {
      (0, import_fs5.unlinkSync)(path2);
    } catch (er) {
      if (er?.code === "EPERM") {
        try {
          return (0, import_fs5.chmodSync)(path2, 438);
        } catch (er2) {
          if (er2?.code === "ENOENT") {
            return;
          }
          throw er;
        }
      } else if (er?.code === "ENOENT") {
        return;
      }
      throw er;
    }
  };
  var rimrafMoveRemove = async (path2, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return await rimrafMoveRemoveDir(path2, opt, await lstat4(path2));
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafMoveRemoveDir = async (path2, opt, ent) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    if (!opt.tmp) {
      return rimrafMoveRemoveDir(path2, { ...opt, tmp: await defaultTmp(path2) }, ent);
    }
    if (path2 === opt.tmp && (0, import_path8.parse)(path2).root !== path2) {
      throw new Error("cannot delete temp directory used for deletion");
    }
    const entries = ent.isDirectory() ? await readdirOrError(path2) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !await opt.filter(path2, ent)) {
        return false;
      }
      await ignoreENOENT(tmpUnlink(path2, opt.tmp, unlinkFixEPERM));
      return true;
    }
    const removedAll = (await Promise.all(entries.map((ent2) => rimrafMoveRemoveDir((0, import_path8.resolve)(path2, ent2.name), opt, ent2)))).reduce((a, b) => a && b, true);
    if (!removedAll) {
      return false;
    }
    if (opt.preserveRoot === false && path2 === (0, import_path8.parse)(path2).root) {
      return false;
    }
    if (opt.filter && !await opt.filter(path2, ent)) {
      return false;
    }
    await ignoreENOENT(tmpUnlink(path2, opt.tmp, rmdir3));
    return true;
  };
  var tmpUnlink = async (path2, tmp, rm3) => {
    const tmpFile = (0, import_path8.resolve)(tmp, uniqueFilename(path2));
    await rename2(path2, tmpFile);
    return await rm3(tmpFile);
  };
  var rimrafMoveRemoveSync = (path2, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return rimrafMoveRemoveDirSync(path2, opt, (0, import_fs5.lstatSync)(path2));
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafMoveRemoveDirSync = (path2, opt, ent) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    if (!opt.tmp) {
      return rimrafMoveRemoveDirSync(path2, { ...opt, tmp: defaultTmpSync(path2) }, ent);
    }
    const tmp = opt.tmp;
    if (path2 === opt.tmp && (0, import_path8.parse)(path2).root !== path2) {
      throw new Error("cannot delete temp directory used for deletion");
    }
    const entries = ent.isDirectory() ? readdirOrErrorSync(path2) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !opt.filter(path2, ent)) {
        return false;
      }
      ignoreENOENTSync(() => tmpUnlinkSync(path2, tmp, unlinkFixEPERMSync));
      return true;
    }
    let removedAll = true;
    for (const ent2 of entries) {
      const p = (0, import_path8.resolve)(path2, ent2.name);
      removedAll = rimrafMoveRemoveDirSync(p, opt, ent2) && removedAll;
    }
    if (!removedAll) {
      return false;
    }
    if (opt.preserveRoot === false && path2 === (0, import_path8.parse)(path2).root) {
      return false;
    }
    if (opt.filter && !opt.filter(path2, ent)) {
      return false;
    }
    ignoreENOENTSync(() => tmpUnlinkSync(path2, tmp, import_fs5.rmdirSync));
    return true;
  };
  var tmpUnlinkSync = (path2, tmp, rmSync2) => {
    const tmpFile = (0, import_path8.resolve)(tmp, uniqueFilename(path2));
    (0, import_fs5.renameSync)(path2, tmpFile);
    return rmSync2(tmpFile);
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-windows.js
  var { unlink: unlink4, rmdir: rmdir4, lstat: lstat5 } = promises;
  var rimrafWindowsFile = retryBusy(fixEPERM(unlink4));
  var rimrafWindowsFileSync = retryBusySync(fixEPERMSync(import_fs5.unlinkSync));
  var rimrafWindowsDirRetry = retryBusy(fixEPERM(rmdir4));
  var rimrafWindowsDirRetrySync = retryBusySync(fixEPERMSync(import_fs5.rmdirSync));
  var rimrafWindowsDirMoveRemoveFallback = async (path2, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const { filter: filter2, ...options } = opt;
    try {
      return await rimrafWindowsDirRetry(path2, options);
    } catch (er) {
      if (er?.code === "ENOTEMPTY") {
        return await rimrafMoveRemove(path2, options);
      }
      throw er;
    }
  };
  var rimrafWindowsDirMoveRemoveFallbackSync = (path2, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const { filter: filter2, ...options } = opt;
    try {
      return rimrafWindowsDirRetrySync(path2, options);
    } catch (er) {
      const fer = er;
      if (fer?.code === "ENOTEMPTY") {
        return rimrafMoveRemoveSync(path2, options);
      }
      throw er;
    }
  };
  var START = Symbol("start");
  var CHILD = Symbol("child");
  var FINISH = Symbol("finish");
  var rimrafWindows = async (path2, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return await rimrafWindowsDir(path2, opt, await lstat5(path2), START);
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafWindowsSync = (path2, opt) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    try {
      return rimrafWindowsDirSync(path2, opt, (0, import_fs5.lstatSync)(path2), START);
    } catch (er) {
      if (er?.code === "ENOENT")
        return true;
      throw er;
    }
  };
  var rimrafWindowsDir = async (path2, opt, ent, state = START) => {
    if (opt?.signal?.aborted) {
      throw opt.signal.reason;
    }
    const entries = ent.isDirectory() ? await readdirOrError(path2) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !await opt.filter(path2, ent)) {
        return false;
      }
      await ignoreENOENT(rimrafWindowsFile(path2, opt));
      return true;
    }
    const s = state === START ? CHILD : state;
    const removedAll = (await Promise.all(entries.map((ent2) => rimrafWindowsDir((0, import_path9.resolve)(path2, ent2.name), opt, ent2, s)))).reduce((a, b) => a && b, true);
    if (state === START) {
      return rimrafWindowsDir(path2, opt, ent, FINISH);
    } else if (state === FINISH) {
      if (opt.preserveRoot === false && path2 === (0, import_path9.parse)(path2).root) {
        return false;
      }
      if (!removedAll) {
        return false;
      }
      if (opt.filter && !await opt.filter(path2, ent)) {
        return false;
      }
      await ignoreENOENT(rimrafWindowsDirMoveRemoveFallback(path2, opt));
    }
    return true;
  };
  var rimrafWindowsDirSync = (path2, opt, ent, state = START) => {
    const entries = ent.isDirectory() ? readdirOrErrorSync(path2) : null;
    if (!Array.isArray(entries)) {
      if (entries) {
        if (entries.code === "ENOENT") {
          return true;
        }
        if (entries.code !== "ENOTDIR") {
          throw entries;
        }
      }
      if (opt.filter && !opt.filter(path2, ent)) {
        return false;
      }
      ignoreENOENTSync(() => rimrafWindowsFileSync(path2, opt));
      return true;
    }
    let removedAll = true;
    for (const ent2 of entries) {
      const s = state === START ? CHILD : state;
      const p = (0, import_path9.resolve)(path2, ent2.name);
      removedAll = rimrafWindowsDirSync(p, opt, ent2, s) && removedAll;
    }
    if (state === START) {
      return rimrafWindowsDirSync(path2, opt, ent, FINISH);
    } else if (state === FINISH) {
      if (opt.preserveRoot === false && path2 === (0, import_path9.parse)(path2).root) {
        return false;
      }
      if (!removedAll) {
        return false;
      }
      if (opt.filter && !opt.filter(path2, ent)) {
        return false;
      }
      ignoreENOENTSync(() => {
        rimrafWindowsDirMoveRemoveFallbackSync(path2, opt);
      });
    }
    return true;
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-manual.js
  var rimrafManual = platform_default === "win32" ? rimrafWindows : rimrafPosix;
  var rimrafManualSync = platform_default === "win32" ? rimrafWindowsSync : rimrafPosixSync;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/rimraf-native.js
  var { rm: rm2 } = promises;
  var rimrafNative = async (path2, opt) => {
    await rm2(path2, {
      ...opt,
      force: true,
      recursive: true
    });
    return true;
  };
  var rimrafNativeSync = (path2, opt) => {
    (0, import_fs5.rmSync)(path2, {
      ...opt,
      force: true,
      recursive: true
    });
    return true;
  };

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/use-native.js
  var version2 = process.env.__TESTING_RIMRAF_NODE_VERSION__ || process.version;
  var versArr2 = version2.replace(/^v/, "").split(".");
  var [major = 0, minor = 0] = versArr2.map((v) => parseInt(v, 10));
  var hasNative2 = major > 14 || major === 14 && minor >= 14;
  var useNative2 = !hasNative2 || platform_default === "win32" ? () => false : (opt) => !opt?.signal && !opt?.filter;
  var useNativeSync2 = !hasNative2 || platform_default === "win32" ? () => false : (opt) => !opt?.signal && !opt?.filter;

  // ../../node_modules/.pnpm/rimraf@5.0.10/node_modules/rimraf/dist/esm/index.js
  var wrap = (fn) => async (path2, opt) => {
    const options = optArg(opt);
    if (options.glob) {
      path2 = await glob(path2, options.glob);
    }
    if (Array.isArray(path2)) {
      return !!(await Promise.all(path2.map((p) => fn(path_arg_default(p, options), options)))).reduce((a, b) => a && b, true);
    } else {
      return !!await fn(path_arg_default(path2, options), options);
    }
  };
  var wrapSync = (fn) => (path2, opt) => {
    const options = optArgSync(opt);
    if (options.glob) {
      path2 = globSync(path2, options.glob);
    }
    if (Array.isArray(path2)) {
      return !!path2.map((p) => fn(path_arg_default(p, options), options)).reduce((a, b) => a && b, true);
    } else {
      return !!fn(path_arg_default(path2, options), options);
    }
  };
  var nativeSync = wrapSync(rimrafNativeSync);
  var native = Object.assign(wrap(rimrafNative), { sync: nativeSync });
  var manualSync = wrapSync(rimrafManualSync);
  var manual = Object.assign(wrap(rimrafManual), { sync: manualSync });
  var windowsSync = wrapSync(rimrafWindowsSync);
  var windows = Object.assign(wrap(rimrafWindows), { sync: windowsSync });
  var posixSync = wrapSync(rimrafPosixSync);
  var posix2 = Object.assign(wrap(rimrafPosix), { sync: posixSync });
  var moveRemoveSync = wrapSync(rimrafMoveRemoveSync);
  var moveRemove = Object.assign(wrap(rimrafMoveRemove), {
    sync: moveRemoveSync
  });
  var rimrafSync = wrapSync((path2, opt) => useNativeSync2(opt) ? rimrafNativeSync(path2, opt) : rimrafManualSync(path2, opt));
  var rimraf_ = wrap((path2, opt) => useNative2(opt) ? rimrafNative(path2, opt) : rimrafManual(path2, opt));
  var rimraf = Object.assign(rimraf_, {
    rimraf: rimraf_,
    sync: rimrafSync,
    rimrafSync,
    manual,
    manualSync,
    native,
    nativeSync,
    posix: posix2,
    posixSync,
    windows,
    windowsSync,
    moveRemove,
    moveRemoveSync
  });
  rimraf.rimraf = rimraf;

  // ../math/dist/index.mjs
  var import_bn = __toESM(require_bn(), 1);
  var DEFAULT_PRECISION = 9;
  var DEFAULT_MIN_PRECISION = 3;
  var DEFAULT_DECIMAL_UNITS = 9;
  var BN = class extends import_bn.default {
    MAX_U64 = "0xFFFFFFFFFFFFFFFF";
    constructor(value, base, endian) {
      let bnValue = value;
      let bnBase = base;
      if (BN.isBN(value)) {
        bnValue = value.toArray();
      } else if (typeof value === "string" && value.slice(0, 2) === "0x") {
        bnValue = value.substring(2);
        bnBase = base || "hex";
      }
      super(bnValue == null ? 0 : bnValue, bnBase, endian);
    }
    // ANCHOR: HELPERS
    // make sure we always include `0x` in hex strings
    toString(base, length) {
      const output = super.toString(base, length);
      if (base === 16 || base === "hex") {
        return `0x${output}`;
      }
      return output;
    }
    toHex(bytesPadding) {
      const bytes = bytesPadding || 0;
      const bytesLength = bytes * 2;
      if (this.isNeg()) {
        throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to hex.");
      }
      if (bytesPadding && this.byteLength() > bytesPadding) {
        throw new FuelError(
          ErrorCode.CONVERTING_FAILED,
          `Provided value ${this} is too large. It should fit within ${bytesPadding} bytes.`
        );
      }
      return this.toString(16, bytesLength);
    }
    toBytes(bytesPadding) {
      if (this.isNeg()) {
        throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to bytes.");
      }
      return Uint8Array.from(this.toArray(void 0, bytesPadding));
    }
    toJSON() {
      return this.toString(16);
    }
    valueOf() {
      return this.toString();
    }
    format(options) {
      const {
        units = DEFAULT_DECIMAL_UNITS,
        precision: initialPrecision = DEFAULT_PRECISION,
        minPrecision: initialMinPrecision = DEFAULT_MIN_PRECISION
      } = options || {};
      if (units === 0) {
        return this.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      const minPrecision = initialMinPrecision > initialPrecision ? initialPrecision : initialMinPrecision;
      const precision = initialPrecision > initialMinPrecision ? initialPrecision : initialMinPrecision;
      const formattedUnits = this.formatUnits(units);
      const [integerPart, fractionalPart = ""] = formattedUnits.split(".");
      const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      if (precision === 0) {
        return formattedInteger;
      }
      let formattedFractional = fractionalPart.replace(/0+$/, "");
      if (formattedFractional.length > precision) {
        if (integerPart === "0") {
          const firstNonZeroIndex = formattedFractional.search(/[1-9]/);
          if (firstNonZeroIndex >= 0 && firstNonZeroIndex < precision) {
            formattedFractional = formattedFractional.slice(0, precision);
          } else {
            formattedFractional = formattedFractional.slice(0, firstNonZeroIndex + 1);
          }
        } else {
          formattedFractional = formattedFractional.slice(0, precision);
        }
      } else {
        formattedFractional = formattedFractional.slice(0, precision);
      }
      if (formattedFractional.length < minPrecision) {
        formattedFractional = formattedFractional.padEnd(minPrecision, "0");
      }
      if (formattedFractional === "" && minPrecision === 0) {
        return formattedInteger;
      }
      return formattedFractional ? `${formattedInteger}.${formattedFractional}` : formattedInteger;
    }
    formatUnits(units = DEFAULT_DECIMAL_UNITS) {
      const valueString = this.toString();
      const valueLength = valueString.length;
      if (valueLength <= units) {
        const paddedZeros = "0".repeat(units - valueLength);
        return `0.${paddedZeros}${valueString}`;
      }
      const integerPart = valueString.slice(0, valueLength - units);
      const fractionalPart = valueString.slice(valueLength - units);
      return `${integerPart}.${fractionalPart}`;
    }
    // END ANCHOR: HELPERS
    // ANCHOR: OVERRIDES to accept better inputs
    add(v) {
      return this.caller(v, "add");
    }
    pow(v) {
      return this.caller(v, "pow");
    }
    sub(v) {
      return this.caller(v, "sub");
    }
    div(v) {
      return this.caller(v, "div");
    }
    mul(v) {
      return this.caller(v, "mul");
    }
    mod(v) {
      return this.caller(v, "mod");
    }
    divRound(v) {
      return this.caller(v, "divRound");
    }
    lt(v) {
      return this.caller(v, "lt");
    }
    lte(v) {
      return this.caller(v, "lte");
    }
    gt(v) {
      return this.caller(v, "gt");
    }
    gte(v) {
      return this.caller(v, "gte");
    }
    eq(v) {
      return this.caller(v, "eq");
    }
    cmp(v) {
      return this.caller(v, "cmp");
    }
    // END ANCHOR: OVERRIDES to accept better inputs
    // ANCHOR: OVERRIDES to output our BN type
    sqr() {
      return new BN(super.sqr().toArray());
    }
    neg() {
      return new BN(super.neg().toArray());
    }
    abs() {
      return new BN(super.abs().toArray());
    }
    toTwos(width) {
      return new BN(super.toTwos(width).toArray());
    }
    fromTwos(width) {
      return new BN(super.fromTwos(width).toArray());
    }
    // END ANCHOR: OVERRIDES to output our BN type
    // ANCHOR: OVERRIDES to avoid losing references
    caller(v, methodName) {
      const output = super[methodName](new BN(v));
      if (BN.isBN(output)) {
        return new BN(output.toArray());
      }
      if (typeof output === "boolean") {
        return output;
      }
      return output;
    }
    clone() {
      return new BN(this.toArray());
    }
    mulTo(num, out) {
      const output = new import_bn.default(this.toArray()).mulTo(num, out);
      return new BN(output.toArray());
    }
    egcd(p) {
      const { a, b, gcd } = new import_bn.default(this.toArray()).egcd(p);
      return {
        a: new BN(a.toArray()),
        b: new BN(b.toArray()),
        gcd: new BN(gcd.toArray())
      };
    }
    divmod(num, mode, positive) {
      const { div, mod } = new import_bn.default(this.toArray()).divmod(new BN(num), mode, positive);
      return {
        div: new BN(div?.toArray()),
        mod: new BN(mod?.toArray())
      };
    }
    maxU64() {
      return this.gte(this.MAX_U64) ? new BN(this.MAX_U64) : this;
    }
    max(num) {
      return this.gte(num) ? new BN(num) : this;
    }
    normalizeZeroToOne() {
      return this.isZero() ? new BN(1) : this;
    }
    // END ANCHOR: OVERRIDES to avoid losing references
  };
  var bn = (value, base, endian) => new BN(value, base, endian);
  bn.parseUnits = (value, units = DEFAULT_DECIMAL_UNITS) => {
    const valueToParse = value === "." ? "0." : value;
    const [valueUnits = "0", valueDecimals = "0"] = valueToParse.split(".");
    const length = valueDecimals.length;
    if (units === 0) {
      const valueWithoutDecimals = valueToParse.replace(",", "").split(".")[0];
      return bn(valueWithoutDecimals);
    }
    if (length > units) {
      throw new FuelError(
        ErrorCode.CONVERTING_FAILED,
        `Decimal can't have more than ${units} digits.`
      );
    }
    const decimals = Array.from({ length: units }).fill("0");
    decimals.splice(0, length, valueDecimals);
    const amount = `${valueUnits.replaceAll(",", "")}${decimals.join("")}`;
    return bn(amount);
  };

  // ../../node_modules/.pnpm/fflate@0.8.2/node_modules/fflate/esm/index.mjs
  var import_module = __require("module");
  var require2 = (0, import_module.createRequire)("/");
  var Worker;
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {
  }
  var u8 = Uint8Array;
  var u16 = Uint16Array;
  var i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
      b[i] = start += 1 << eb[i - 1];
    }
    var r = new i32(b[30]);
    for (var i = 1; i < 30; ++i) {
      for (var j = b[i]; j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }
    return { b, r };
  };
  var _a = freb(fleb, 2);
  var fl = _a.b;
  var revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0);
  var fd = _b.b;
  var revfd = _b.r;
  var rev = new u16(32768);
  for (i = 0; i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var x;
  var i;
  var hMap = function(cd, mb, r) {
    var s = cd.length;
    var i = 0;
    var l = new u16(mb);
    for (; i < s; ++i) {
      if (cd[i])
        ++l[cd[i] - 1];
    }
    var le = new u16(mb);
    for (i = 1; i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          var sv = i << 4 | cd[i];
          var r_1 = mb - cd[i];
          var v = le[cd[i] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (i = 0; i < 144; ++i)
    flt[i] = 8;
  var i;
  for (i = 144; i < 256; ++i)
    flt[i] = 9;
  var i;
  for (i = 256; i < 280; ++i)
    flt[i] = 7;
  var i;
  for (i = 280; i < 288; ++i)
    flt[i] = 8;
  var i;
  var fdt = new u8(32);
  for (i = 0; i < 32; ++i)
    fdt[i] = 5;
  var i;
  var flm = /* @__PURE__ */ hMap(flt, 9, 0);
  var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
  var shft = function(p) {
    return (p + 7) / 8 | 0;
  };
  var slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    return new u8(v.subarray(s, e));
  };
  var wbits = function(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
  };
  var wbits16 = function(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
    d[o + 2] |= v >> 16;
  };
  var hTree = function(d, mb) {
    var t = [];
    for (var i = 0; i < d.length; ++i) {
      if (d[i])
        t.push({ s: i, f: d[i] });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s)
      return { t: et, l: 0 };
    if (s == 1) {
      var v = new u8(t[0].s + 1);
      v[t[0].s] = 1;
      return { t: v, l: 1 };
    }
    t.sort(function(a, b) {
      return a.f - b.f;
    });
    t.push({ s: -1, f: 25001 });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = { s: -1, f: l.f + r.f, l, r };
    while (i1 != s - 1) {
      l = t[t[i0].f < t[i2].f ? i0++ : i2++];
      r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
      t[i1++] = { s: -1, f: l.f + r.f, l, r };
    }
    var maxSym = t2[0].s;
    for (var i = 1; i < s; ++i) {
      if (t2[i].s > maxSym)
        maxSym = t2[i].s;
    }
    var tr = new u16(maxSym + 1);
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
      var i = 0, dt = 0;
      var lft = mbt - mb, cst = 1 << lft;
      t2.sort(function(a, b) {
        return tr[b.s] - tr[a.s] || a.f - b.f;
      });
      for (; i < s; ++i) {
        var i2_1 = t2[i].s;
        if (tr[i2_1] > mb) {
          dt += cst - (1 << mbt - tr[i2_1]);
          tr[i2_1] = mb;
        } else
          break;
      }
      dt >>= lft;
      while (dt > 0) {
        var i2_2 = t2[i].s;
        if (tr[i2_2] < mb)
          dt -= 1 << mb - tr[i2_2]++ - 1;
        else
          ++i;
      }
      for (; i >= 0 && dt; --i) {
        var i2_3 = t2[i].s;
        if (tr[i2_3] == mb) {
          --tr[i2_3];
          ++dt;
        }
      }
      mbt = mb;
    }
    return { t: new u8(tr), l: mbt };
  };
  var ln = function(n, l, d) {
    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
  };
  var lc = function(c) {
    var s = c.length;
    while (s && !c[--s])
      ;
    var cl = new u16(++s);
    var cli = 0, cln = c[0], cls = 1;
    var w = function(v) {
      cl[cli++] = v;
    };
    for (var i = 1; i <= s; ++i) {
      if (c[i] == cln && i != s)
        ++cls;
      else {
        if (!cln && cls > 2) {
          for (; cls > 138; cls -= 138)
            w(32754);
          if (cls > 2) {
            w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
            cls = 0;
          }
        } else if (cls > 3) {
          w(cln), --cls;
          for (; cls > 6; cls -= 6)
            w(8304);
          if (cls > 2)
            w(cls - 3 << 5 | 8208), cls = 0;
        }
        while (cls--)
          w(cln);
        cls = 1;
        cln = c[i];
      }
    }
    return { c: cl.subarray(0, cli), n: s };
  };
  var clen = function(cf, cl) {
    var l = 0;
    for (var i = 0; i < cl.length; ++i)
      l += cf[i] * cl[i];
    return l;
  };
  var wfblk = function(out, pos, dat) {
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for (var i = 0; i < s; ++i)
      out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
  };
  var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, final);
    ++lf[256];
    var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
    var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for (var i = 0; i < lclt.length; ++i)
      ++lcfreq[lclt[i] & 31];
    for (var i = 0; i < lcdt.length; ++i)
      ++lcfreq[lcdt[i] & 31];
    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
      ;
    var flen = bl + 5 << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen)
      return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
      lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
      var llm = hMap(lct, mlcb, 0);
      wbits(out, p, nlc - 257);
      wbits(out, p + 5, ndc - 1);
      wbits(out, p + 10, nlcc - 4);
      p += 14;
      for (var i = 0; i < nlcc; ++i)
        wbits(out, p + 3 * i, lct[clim[i]]);
      p += 3 * nlcc;
      var lcts = [lclt, lcdt];
      for (var it = 0; it < 2; ++it) {
        var clct = lcts[it];
        for (var i = 0; i < clct.length; ++i) {
          var len = clct[i] & 31;
          wbits(out, p, llm[len]), p += lct[len];
          if (len > 15)
            wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
        }
      }
    } else {
      lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i = 0; i < li; ++i) {
      var sym = syms[i];
      if (sym > 255) {
        var len = sym >> 18 & 31;
        wbits16(out, p, lm[len + 257]), p += ll[len + 257];
        if (len > 7)
          wbits(out, p, sym >> 23 & 31), p += fleb[len];
        var dst = sym & 31;
        wbits16(out, p, dm[dst]), p += dl[dst];
        if (dst > 3)
          wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
      } else {
        wbits16(out, p, lm[sym]), p += ll[sym];
      }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
  };
  var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  var et = /* @__PURE__ */ new u8(0);
  var dflt = function(dat, lvl, plvl, pre, post, st) {
    var s = st.z || dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
    var w = o.subarray(pre, o.length - post);
    var lst = st.l;
    var pos = (st.r || 0) & 7;
    if (lvl) {
      if (pos)
        w[0] = st.r >> 3;
      var opt = deo[lvl - 1];
      var n = opt >> 13, c = opt & 8191;
      var msk_1 = (1 << plvl) - 1;
      var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
      var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
      var hsh = function(i2) {
        return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
      };
      var syms = new i32(25e3);
      var lf = new u16(288), df = new u16(32);
      var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
      for (; i + 2 < s; ++i) {
        var hv = hsh(i);
        var imod = i & 32767, pimod = head[hv];
        prev[imod] = pimod;
        head[hv] = imod;
        if (wi <= i) {
          var rem = s - i;
          if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
            pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
            li = lc_1 = eb = 0, bs = i;
            for (var j = 0; j < 286; ++j)
              lf[j] = 0;
            for (var j = 0; j < 30; ++j)
              df[j] = 0;
          }
          var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
          if (rem > 2 && hv == hsh(i - dif)) {
            var maxn = Math.min(n, rem) - 1;
            var maxd = Math.min(32767, i);
            var ml = Math.min(258, rem);
            while (dif <= maxd && --ch_1 && imod != pimod) {
              if (dat[i + l] == dat[i + l - dif]) {
                var nl = 0;
                for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                  ;
                if (nl > l) {
                  l = nl, d = dif;
                  if (nl > maxn)
                    break;
                  var mmd = Math.min(dif, nl - 2);
                  var md = 0;
                  for (var j = 0; j < mmd; ++j) {
                    var ti = i - dif + j & 32767;
                    var pti = prev[ti];
                    var cd = ti - pti & 32767;
                    if (cd > md)
                      md = cd, pimod = ti;
                  }
                }
              }
              imod = pimod, pimod = prev[imod];
              dif += imod - pimod & 32767;
            }
          }
          if (d) {
            syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
            var lin = revfl[l] & 31, din = revfd[d] & 31;
            eb += fleb[lin] + fdeb[din];
            ++lf[257 + lin];
            ++df[din];
            wi = i + l;
            ++lc_1;
          } else {
            syms[li++] = dat[i];
            ++lf[dat[i]];
          }
        }
      }
      for (i = Math.max(i, wi); i < s; ++i) {
        syms[li++] = dat[i];
        ++lf[dat[i]];
      }
      pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
      if (!lst) {
        st.r = pos & 7 | w[pos / 8 | 0] << 3;
        pos -= 7;
        st.h = head, st.p = prev, st.i = i, st.w = wi;
      }
    } else {
      for (var i = st.w || 0; i < s + lst; i += 65535) {
        var e = i + 65535;
        if (e >= s) {
          w[pos / 8 | 0] = lst;
          e = s;
        }
        pos = wfblk(w, pos + 1, dat.subarray(i, e));
      }
      st.i = s;
    }
    return slc(o, 0, pre + shft(pos) + post);
  };
  var crct = /* @__PURE__ */ function() {
    var t = new Int32Array(256);
    for (var i = 0; i < 256; ++i) {
      var c = i, k = 9;
      while (--k)
        c = (c & 1 && -306674912) ^ c >>> 1;
      t[i] = c;
    }
    return t;
  }();
  var crc = function() {
    var c = -1;
    return {
      p: function(d) {
        var cr = c;
        for (var i = 0; i < d.length; ++i)
          cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
        c = cr;
      },
      d: function() {
        return ~c;
      }
    };
  };
  var dopt = function(dat, opt, pre, post, st) {
    if (!st) {
      st = { l: 1 };
      if (opt.dictionary) {
        var dict = opt.dictionary.subarray(-32768);
        var newDat = new u8(dict.length + dat.length);
        newDat.set(dict);
        newDat.set(dat, dict.length);
        dat = newDat;
        st.w = dict.length;
      }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
  };
  var wbytes = function(d, b, v) {
    for (; v; ++b)
      d[b] = v, v >>>= 8;
  };
  var gzh = function(c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
    if (o.mtime != 0)
      wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
    if (fn) {
      c[3] = 8;
      for (var i = 0; i <= fn.length; ++i)
        c[i + 10] = fn.charCodeAt(i);
    }
  };
  var gzhl = function(o) {
    return 10 + (o.filename ? o.filename.length + 1 : 0);
  };
  function gzipSync(data, opts) {
    if (!opts)
      opts = {};
    var c = crc(), l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }

  // ../utils/dist/index.mjs
  var __defProp3 = Object.defineProperty;
  var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField3 = (obj, key, value) => {
    __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var arrayify = (value, name, copy = true) => {
    if (value instanceof Uint8Array) {
      if (copy) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    const nameMessage = name ? ` ${name} -` : "";
    const message = `invalid data:${nameMessage} ${value}
If you are attempting to transform a hex value, please make sure it is being passed as a string and wrapped in quotes.`;
    throw new FuelError(ErrorCode.INVALID_DATA, message);
  };
  var HexCharacters = "0123456789abcdef";
  function hexlify(data) {
    const bytes = arrayify(data);
    let result = "0x";
    for (let i = 0; i < bytes.length; i++) {
      const v = bytes[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  var normalizeString = (str) => {
    const transformations = [
      (s) => s.replace(/\s+/g, "-"),
      // spaces to -
      (s) => s.replace(/\./g, "-"),
      // dots to -
      (s) => s.replace(/_/g, "-"),
      // underscore to -
      (s) => s.replace(/-[a-z]/g, (match2) => match2.slice(-1).toUpperCase()),
      // delete '-' and capitalize the letter after them
      (s) => s.replace(/-/g, ""),
      // delete any '-' left
      (s) => s.replace(/^\d+/, ""),
      // removes leading digits
      (s) => s[0].toUpperCase() + s.slice(1)
      // capitalize first letter
    ];
    const output = transformations.reduce((s, t) => t(s), str);
    if (output === "") {
      const errMsg = `The provided string '${str}' results in an empty output after`.concat(
        ` normalization, therefore, it can't normalize string.`
      );
      throw new FuelError(ErrorCode.PARSE_FAILED, errMsg);
    }
    return output;
  };
  var TAI64_LEAP_SECONDS = 37;
  var TAI64_UNIX_OFFSET = BigInt(2 ** 62) + BigInt(TAI64_LEAP_SECONDS);
  var msToSeconds = (ms) => Math.floor(ms / 1e3);
  var secondsToMs = (seconds) => seconds * 1e3;
  var tai64ToUnixSeconds = (tai64) => Number(BigInt(tai64) - TAI64_UNIX_OFFSET);
  var unixSecondsToTai64 = (unixSeconds) => String(BigInt(unixSeconds) + TAI64_UNIX_OFFSET);
  var tai64ToUnixMilliseconds = (tai64) => secondsToMs(tai64ToUnixSeconds(tai64));
  var _DateTime = class extends Date {
    /**
     * Generates a new DateTime instance from a Tai64 timestamp.
     *
     * @param tai64 - Tai64 timestamp
     * @returns a new DateTime instance
     */
    static fromTai64(tai64) {
      return new _DateTime(tai64ToUnixMilliseconds(tai64));
    }
    /**
     * @param unixMilliseconds - unix milliseconds timestamp
     * @returns a new DateTime instance
     */
    static fromUnixMilliseconds(unixMilliseconds) {
      return new _DateTime(unixMilliseconds);
    }
    /**
     * @param unixSeconds - unix seconds timestamp
     * @returns a new DateTime instance
     */
    static fromUnixSeconds(unixSeconds) {
      return new _DateTime(secondsToMs(unixSeconds));
    }
    /**
     * Hide the constructor to prevent direct instantiation.
     */
    constructor(date) {
      super(date);
    }
    /**
     * Returns the Tai64 timestamp.
     *
     * @returns the Tai64 timestamp
     */
    toTai64() {
      return unixSecondsToTai64(this.toUnixSeconds());
    }
    /**
     * @returns the unix milliseconds timestamp
     */
    toUnixMilliseconds() {
      return this.getTime();
    }
    /**
     * @returns the unix seconds timestamp
     */
    toUnixSeconds() {
      return msToSeconds(this.getTime());
    }
  };
  var DateTime = _DateTime;
  __publicField3(DateTime, "TAI64_NULL", "");
  var BN_0 = bn(0);
  var BN_58 = bn(58);
  var compressBytecode = (bytecodeAsBinary) => {
    if (!bytecodeAsBinary) {
      return "";
    }
    const bytecodeCompressBytes = arrayify(bytecodeAsBinary);
    const bytecodeCompressGzipped = gzipSync(bytecodeCompressBytes, { mtime: 0 });
    const bytecodeCompressBinary = String.fromCharCode.apply(
      null,
      new Uint8Array(bytecodeCompressGzipped)
    );
    const bytecodeCompressEncoded = btoa(bytecodeCompressBinary);
    return bytecodeCompressEncoded;
  };

  // src/abi/types/AType.ts
  var AType = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };

  // src/abi/types/EmptyType.ts
  var _EmptyType = class extends AType {
    name = "empty";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: "undefined",
        outputLabel: "void"
      };
    }
    static isSuitableFor(params) {
      return _EmptyType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var EmptyType = _EmptyType;
  __publicField(EmptyType, "swayType", "()");
  __publicField(EmptyType, "MATCH_REGEX", /^\(\)$/m);

  // src/abi/types/OptionType.ts
  var _OptionType = class extends AType {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType = _OptionType;
  __publicField(OptionType, "swayType", "enum Option");
  __publicField(OptionType, "MATCH_REGEX", /^enum (std::option::)?Option$/m);

  // src/utils/findType.ts
  function findType(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }

  // src/utils/getFunctionInputs.ts
  var getFunctionInputs = (params) => {
    const { types: types2, inputs } = params;
    let isMandatory = false;
    return inputs.reduceRight((result, input) => {
      const type3 = findType({ types: types2, typeId: input.type });
      const isTypeMandatory = !EmptyType.isSuitableFor({ type: type3.rawAbiType.type }) && !OptionType.isSuitableFor({ type: type3.rawAbiType.type });
      isMandatory = isMandatory || isTypeMandatory;
      return [{ ...input, isOptional: !isMandatory }, ...result];
    }, []);
  };

  // src/utils/parseTypeArguments.ts
  function parseTypeArguments(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      const currentTypeId = typeArgument.type;
      const currentType = findType({ types: types2, typeId: currentTypeId });
      const currentLabel = currentType.attributes[attributeKey];
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output = buffer.join(", ");
    if (parentLabel) {
      output = `${parentLabel}<${output}>`;
    }
    return output;
  }

  // src/utils/getTypeDeclaration.ts
  function resolveInputLabel(types2, typeId, typeArguments) {
    const type3 = findType({ types: types2, typeId });
    let typeDecl;
    if (typeArguments?.length) {
      typeDecl = parseTypeArguments({
        types: types2,
        target: "input" /* INPUT */,
        parentTypeId: typeId,
        typeArguments
      });
    } else {
      typeDecl = type3.attributes.inputLabel;
    }
    return typeDecl;
  }

  // src/abi/functions/Function.ts
  var Function2 = class {
    name;
    types;
    rawAbiFunction;
    attributes;
    constructor(params) {
      this.rawAbiFunction = params.rawAbiFunction;
      this.types = params.types;
      this.name = params.rawAbiFunction.name;
      this.attributes = {
        inputs: this.bundleInputTypes(),
        output: this.bundleOutputTypes(),
        prefixedInputs: this.bundleInputTypes(true)
      };
    }
    bundleInputTypes(shouldPrefixParams = false) {
      const { types: types2 } = this;
      const inputs = getFunctionInputs({ types: types2, inputs: this.rawAbiFunction.inputs }).map(
        ({ isOptional, ...input }) => {
          const { name, type: typeId, typeArguments } = input;
          const typeDecl = resolveInputLabel(types2, typeId, typeArguments);
          if (shouldPrefixParams) {
            const optionalSuffix = isOptional ? "?" : "";
            return `${name}${optionalSuffix}: ${typeDecl}`;
          }
          return typeDecl;
        }
      );
      return inputs.join(", ");
    }
    bundleOutputTypes() {
      return parseTypeArguments({
        types: this.types,
        target: "output" /* OUTPUT */,
        typeArguments: [this.rawAbiFunction.output]
      });
    }
    getDeclaration() {
      const { name } = this;
      const { prefixedInputs, output } = this.attributes;
      const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output}>`;
      return decl;
    }
  };

  // src/utils/makeFunction.ts
  function makeFunction(params) {
    const { types: types2, rawAbiFunction } = params;
    return new Function2({ types: types2, rawAbiFunction });
  }

  // src/utils/parseFunctions.ts
  function parseFunctions(params) {
    const { types: types2, rawAbiFunctions } = params;
    const functions = rawAbiFunctions.map(
      (rawAbiFunction) => makeFunction({ types: types2, rawAbiFunction })
    );
    return functions;
  }

  // src/abi/types/ArrayType.ts
  var _ArrayType = class extends AType {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input" /* INPUT */
          });
          const outputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output" /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType = _ArrayType;
  // Note: the array length expressed in '; 2]' could be any length
  __publicField(ArrayType, "swayType", "[_; 2]");
  __publicField(ArrayType, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);

  // src/abi/types/StrType.ts
  var _StrType = class extends AType {
    name = "str";
    static isSuitableFor(params) {
      return _StrType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType = _StrType;
  // Note: the str length expressed in '[3]' could be any length
  __publicField(StrType, "swayType", "str[3]");
  __publicField(StrType, "MATCH_REGEX", /^str\[(.+)\]$/m);

  // src/abi/types/B256Type.ts
  var _B256Type = class extends StrType {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type = _B256Type;
  __publicField(B256Type, "swayType", "b256");
  __publicField(B256Type, "MATCH_REGEX", /^b256$/m);

  // src/abi/types/B512Type.ts
  var _B512Type = class extends B256Type {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type = _B512Type;
  __publicField(B512Type, "swayType", "struct B512");
  __publicField(B512Type, "MATCH_REGEX", /^struct (std::b512::)?B512$/m);

  // src/abi/types/BoolType.ts
  var _BoolType = class extends AType {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType = _BoolType;
  __publicField(BoolType, "swayType", "bool");
  __publicField(BoolType, "MATCH_REGEX", /^bool$/m);

  // src/abi/types/BytesType.ts
  var _BytesType = class extends ArrayType {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType = _BytesType;
  __publicField(BytesType, "swayType", "struct Bytes");
  __publicField(BytesType, "MATCH_REGEX", /^struct (std::bytes::)?Bytes/m);

  // src/utils/extractStructName.ts
  function extractStructName(params) {
    const { rawAbiType, regex } = params;
    const matches = rawAbiType.type.match(regex);
    const match2 = matches?.[2] ?? matches?.[1];
    if (!match2) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match2;
  }

  // src/abi/types/ResultType.ts
  var _ResultType = class extends AType {
    name = "result";
    static isSuitableFor(params) {
      return _ResultType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Result`,
        outputLabel: `Result`
      };
      return this.attributes;
    }
  };
  var ResultType = _ResultType;
  __publicField(ResultType, "swayType", "enum Result");
  __publicField(ResultType, "MATCH_REGEX", /^enum (std::result::)?Result$/m);

  // src/abi/types/EnumType.ts
  var _EnumType = class extends AType {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType.IGNORE_REGEXES.some((r) => r.test(params.type));
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _EnumType.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash, row) => ({
          ...hash,
          [row.rawAbiType.typeId]: row.rawAbiType.type
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => typeHash[type3] === EmptyType.swayType)) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const type3 = findType({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return contents.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var EnumType = _EnumType;
  __publicField(EnumType, "swayType", "enum MyEnumName");
  __publicField(EnumType, "MATCH_REGEX", /^enum (.+::)?(.+)$/m);
  __publicField(EnumType, "IGNORE_REGEXES", [OptionType.MATCH_REGEX, ResultType.MATCH_REGEX]);

  // src/abi/types/EvmAddressType.ts
  var _EvmAddressType = class extends AType {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType = _EvmAddressType;
  __publicField(EvmAddressType, "swayType", "struct EvmAddress");
  __publicField(EvmAddressType, "MATCH_REGEX", /^struct (std::vm::evm::evm_address::)?EvmAddress$/m);

  // src/abi/types/GenericType.ts
  var _GenericType = class extends AType {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _GenericType.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType = _GenericType;
  __publicField(GenericType, "swayType", "generic T");
  __publicField(GenericType, "MATCH_REGEX", /^generic ([^\s]+)$/m);

  // src/abi/types/U8Type.ts
  var _U8Type = class extends AType {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type = _U8Type;
  __publicField(U8Type, "swayType", "u8");
  __publicField(U8Type, "MATCH_REGEX", /^u8$/m);

  // src/abi/types/U64Type.ts
  var _U64Type = class extends U8Type {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type = _U64Type;
  __publicField(U64Type, "swayType", "u64");
  __publicField(U64Type, "MATCH_REGEX", /^u64$/m);

  // src/abi/types/RawUntypedPtr.ts
  var _RawUntypedPtr = class extends U64Type {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr = _RawUntypedPtr;
  __publicField(RawUntypedPtr, "swayType", "raw untyped ptr");
  __publicField(RawUntypedPtr, "MATCH_REGEX", /^raw untyped ptr$/m);

  // src/abi/types/RawUntypedSlice.ts
  var _RawUntypedSlice = class extends ArrayType {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice = _RawUntypedSlice;
  __publicField(RawUntypedSlice, "swayType", "raw untyped slice");
  __publicField(RawUntypedSlice, "MATCH_REGEX", /^raw untyped slice$/m);

  // src/abi/types/StdStringType.ts
  var _StdStringType = class extends AType {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType = _StdStringType;
  __publicField(StdStringType, "swayType", "struct String");
  __publicField(StdStringType, "MATCH_REGEX", /^struct (std::string::)?String/m);

  // src/abi/types/StrSliceType.ts
  var _StrSliceType = class extends AType {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StrSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StrSliceType = _StrSliceType;
  __publicField(StrSliceType, "swayType", "str");
  __publicField(StrSliceType, "MATCH_REGEX", /^str$/m);

  // src/abi/types/StructType.ts
  var _StructType = class extends AType {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _StructType.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType = _StructType;
  __publicField(StructType, "swayType", "struct MyStruct");
  __publicField(StructType, "MATCH_REGEX", /^struct (.+::)?(.+)$/m);
  __publicField(StructType, "IGNORE_REGEX", /^struct (std::.*)?(Vec|RawVec|EvmAddress|Bytes|String|RawBytes)$/m);

  // src/abi/types/TupleType.ts
  var _TupleType = class extends AType {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input" /* INPUT */
          });
          const outputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output" /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType = _TupleType;
  // Note: a tuple can have more/less than 3x items (like the one bellow)
  __publicField(TupleType, "swayType", "(_, _, _)");
  __publicField(TupleType, "MATCH_REGEX", /^\([_,\s]+\)$/m);

  // src/abi/types/U16Type.ts
  var _U16Type = class extends U8Type {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type = _U16Type;
  __publicField(U16Type, "swayType", "u16");
  __publicField(U16Type, "MATCH_REGEX", /^u16$/m);

  // src/abi/types/U256Type.ts
  var _U256Type = class extends U64Type {
    name = "u256";
    static isSuitableFor(params) {
      return _U256Type.MATCH_REGEX.test(params.type);
    }
  };
  var U256Type = _U256Type;
  __publicField(U256Type, "swayType", "u256");
  __publicField(U256Type, "MATCH_REGEX", /^u256$/m);

  // src/abi/types/U32Type.ts
  var _U32Type = class extends U8Type {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type = _U32Type;
  __publicField(U32Type, "swayType", "u32");
  __publicField(U32Type, "MATCH_REGEX", /^u32$/m);

  // src/abi/types/VectorType.ts
  var _VectorType = class extends ArrayType {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType = _VectorType;
  __publicField(VectorType, "swayType", "struct Vec");
  __publicField(VectorType, "MATCH_REGEX", /^struct (std::vec::)?Vec/m);
  __publicField(VectorType, "IGNORE_REGEX", /^struct (std::vec::)?RawVec$/m);

  // src/utils/supportedTypes.ts
  var supportedTypes = [
    EmptyType,
    ArrayType,
    B256Type,
    B512Type,
    BoolType,
    BytesType,
    EnumType,
    GenericType,
    OptionType,
    RawUntypedPtr,
    RawUntypedSlice,
    StdStringType,
    StrType,
    StrSliceType,
    StructType,
    TupleType,
    U16Type,
    U32Type,
    U64Type,
    U256Type,
    U8Type,
    VectorType,
    EvmAddressType,
    ResultType
  ];

  // src/utils/makeType.ts
  function makeType(params) {
    const { rawAbiType } = params;
    const { type: type3 } = rawAbiType;
    const TypeClass = supportedTypes.find((tc) => tc.isSuitableFor({ type: type3 }));
    if (!TypeClass) {
      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Type not supported: ${type3}`);
    }
    return new TypeClass(params);
  }

  // src/utils/shouldSkipAbiType.ts
  function shouldSkipAbiType(params) {
    const ignoreList = [
      "struct RawVec",
      "struct std::vec::RawVec",
      "struct RawBytes",
      "struct std::bytes::RawBytes"
    ];
    const shouldSkip = ignoreList.indexOf(params.type) >= 0;
    return shouldSkip;
  }

  // src/utils/parseTypes.ts
  function parseTypes(params) {
    const types2 = [];
    params.rawAbiTypes.forEach((rawAbiType) => {
      const { type: type3 } = rawAbiType;
      const skip = shouldSkipAbiType({ type: type3 });
      if (!skip) {
        const parsedType = makeType({ rawAbiType });
        types2.push(parsedType);
      }
    });
    types2.forEach((type3) => {
      type3.parseComponentsAttributes({ types: types2 });
    });
    return types2;
  }

  // src/utils/transpile-abi.ts
  var findTypeByConcreteId = (types2, id) => types2.find((x) => x.concreteTypeId === id);
  var findConcreteTypeById = (abi, id) => abi.concreteTypes.find((x) => x.concreteTypeId === id);
  function finsertTypeIdByConcreteTypeId(abi, types2, id) {
    const concreteType = findConcreteTypeById(abi, id);
    if (concreteType.metadataTypeId !== void 0) {
      return concreteType.metadataTypeId;
    }
    const type3 = findTypeByConcreteId(types2, id);
    if (type3) {
      return type3.typeId;
    }
    types2.push({
      typeId: types2.length,
      type: concreteType.type,
      components: parseComponents(concreteType.components),
      concreteTypeId: id,
      typeParameters: concreteType.typeParameters ?? null,
      originalConcreteTypeId: concreteType?.concreteTypeId
    });
    return types2.length - 1;
  }
  function parseFunctionTypeArguments(abi, types2, concreteType) {
    return concreteType.typeArguments?.map((cTypeId) => {
      const self = findConcreteTypeById(abi, cTypeId);
      const type3 = !isNaN(cTypeId) ? cTypeId : finsertTypeIdByConcreteTypeId(abi, types2, cTypeId);
      return {
        name: "",
        type: type3,
        // originalTypeId: cTypeId,
        typeArguments: parseFunctionTypeArguments(abi, types2, self)
      };
    }) ?? null;
  }
  function parseConcreteType(abi, types2, concreteTypeId, name) {
    const type3 = finsertTypeIdByConcreteTypeId(abi, types2, concreteTypeId);
    const concrete = findConcreteTypeById(abi, concreteTypeId);
    return {
      name: name ?? "",
      type: type3,
      // concreteTypeId,
      typeArguments: parseFunctionTypeArguments(abi, types2, concrete)
    };
  }
  function parseComponents(abi, types2, components) {
    return components?.map((component) => {
      const { typeId, name, typeArguments } = component;
      const type3 = !isNaN(typeId) ? typeId : finsertTypeIdByConcreteTypeId(abi, types2, typeId);
      return {
        name,
        type: type3,
        // originalTypeId: typeId,
        typeArguments: parseComponents(abi, types2, typeArguments)
      };
    }) ?? null;
  }
  function transpileAbi(abi) {
    if (!abi.specVersion) {
      return abi;
    }
    const types2 = [];
    abi.metadataTypes.forEach((m) => {
      const t = {
        typeId: m.metadataTypeId,
        type: m.type,
        components: m.components ?? (m.type === "()" ? [] : null),
        typeParameters: m.typeParameters ?? null
      };
      types2.push(t);
    });
    types2.forEach((t) => {
      t.components = parseComponents(abi, types2, t.components);
    });
    const functions = abi.functions.map((fn) => {
      const inputs = fn.inputs.map(
        ({ concreteTypeId, name }) => parseConcreteType(abi, types2, concreteTypeId, name)
      );
      const output = parseConcreteType(abi, types2, fn.output, "");
      return { ...fn, inputs, output };
    });
    const configurables = abi.configurables.map((conf) => ({
      name: conf.name,
      configurableType: parseConcreteType(abi, types2, conf.concreteTypeId),
      offset: conf.offset
    }));
    const loggedTypes = abi.loggedTypes.map((log) => ({
      logId: log.logId,
      loggedType: parseConcreteType(abi, types2, log.concreteTypeId)
    }));
    const transpiled = {
      encoding: abi.encodingVersion,
      types: types2,
      functions,
      loggedTypes,
      messagesTypes: abi.messagesTypes,
      configurables
    };
    return transpiled;
  }

  // src/abi/configurable/Configurable.ts
  var Configurable = class {
    name;
    inputLabel;
    constructor(params) {
      const {
        types: types2,
        rawAbiConfigurable: {
          name,
          configurableType: { type: type3, typeArguments }
        }
      } = params;
      this.name = name;
      this.inputLabel = resolveInputLabel(types2, type3, typeArguments);
    }
  };

  // src/abi/Abi.ts
  var Abi = class {
    capitalizedName;
    camelizedName;
    programType;
    filepath;
    outputDir;
    commonTypesInUse = [];
    rawContents;
    hexlifiedBinContents;
    storageSlotsContents;
    types;
    functions;
    configurables;
    constructor(params) {
      const {
        filepath,
        outputDir,
        rawContents,
        hexlifiedBinContents,
        programType,
        storageSlotsContents
      } = params;
      const abiNameRegex = /([^/]+)-abi\.json$/m;
      const abiName = filepath.match(abiNameRegex);
      const couldNotParseName = !abiName || abiName.length === 0;
      if (couldNotParseName) {
        throw new FuelError(
          ErrorCode.PARSE_FAILED,
          `Could not parse name from ABI file: ${filepath}.`
        );
      }
      this.programType = programType;
      this.capitalizedName = `${normalizeString(abiName[1])}`;
      this.camelizedName = this.capitalizedName.replace(/^./m, (x) => x.toLowerCase());
      this.filepath = filepath;
      this.rawContents = rawContents;
      this.hexlifiedBinContents = hexlifiedBinContents;
      this.storageSlotsContents = storageSlotsContents;
      this.outputDir = outputDir;
      const { types: types2, functions, configurables } = this.parse();
      this.types = types2;
      this.functions = functions;
      this.configurables = configurables;
      this.computeCommonTypesInUse();
    }
    parse() {
      const transpiled = transpileAbi(this.rawContents);
      const {
        types: rawAbiTypes,
        functions: rawAbiFunctions,
        configurables: rawAbiConfigurables
      } = transpiled;
      const types2 = parseTypes({ rawAbiTypes });
      const functions = parseFunctions({ rawAbiFunctions, types: types2 });
      const configurables = rawAbiConfigurables.map(
        (rawAbiConfigurable) => new Configurable({ types: types2, rawAbiConfigurable })
      );
      return {
        types: types2,
        functions,
        configurables
      };
    }
    computeCommonTypesInUse() {
      const customTypesTable = {
        option: "Option",
        enum: "Enum",
        vector: "Vec",
        result: "Result"
      };
      this.commonTypesInUse = [];
      Object.keys(customTypesTable).forEach((typeName) => {
        const isInUse = !!this.types.find((t) => t.name === typeName);
        if (isInUse) {
          const commonTypeLabel = customTypesTable[typeName];
          this.commonTypesInUse.push(commonTypeLabel);
        }
      });
    }
  };

  // src/types/enums/ProgramTypeEnum.ts
  var ProgramTypeEnum = /* @__PURE__ */ ((ProgramTypeEnum2) => {
    ProgramTypeEnum2["CONTRACT"] = "contract";
    ProgramTypeEnum2["SCRIPT"] = "script";
    ProgramTypeEnum2["PREDICATE"] = "predicate";
    return ProgramTypeEnum2;
  })(ProgramTypeEnum || {});

  // src/utils/assembleContracts.ts
  var import_path10 = __require("path");

  // src/templates/renderHbsTemplate.ts
  var import_handlebars = __toESM(require_lib());

  // src/templates/common/_header.hbs
  var header_default = "/* Autogenerated file. Do not edit manually. */\n\n/* eslint-disable max-classes-per-file */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/consistent-type-imports */\n\n\n/*\n  Fuels version: {{FUELS}}\n{{#if FORC}}\n  Forc version: {{FORC}}\n{{/if}}\n{{#if FUEL_CORE}}\n  Fuel-Core version: {{FUEL_CORE}}\n{{/if}}\n*/\n";

  // src/templates/renderHbsTemplate.ts
  function renderHbsTemplate(params) {
    const { data, template, versions: versions2 } = params;
    const options = {
      strict: true,
      noEscape: true
    };
    const renderTemplate = import_handlebars.default.compile(template, options);
    const renderHeaderTemplate = import_handlebars.default.compile(header_default, options);
    const text = renderTemplate({
      ...data,
      header: renderHeaderTemplate(versions2)
    });
    return text.replace(/[\n]{3,}/gm, "\n\n");
  }

  // src/templates/common/common.hbs
  var common_default = "{{header}}\n\n/**\n * Mimics Sway Enum.\n * Requires one and only one Key-Value pair and raises error if more are provided.\n */\nexport type Enum<T> = {\n  [K in keyof T]: Pick<T, K> & { [P in Exclude<keyof T, K>]?: never };\n}[keyof T];\n\n/**\n * Mimics Sway Option and Vectors.\n * Vectors are treated like arrays in Typescript.\n */\nexport type Option<T> = T | undefined;\n\nexport type Vec<T> = T[];\n\n/**\n * Mimics Sway Result enum type.\n * Ok represents the success case, while Err represents the error case.\n */\nexport type Result<T, E> = Enum<{Ok: T, Err: E}>;\n";

  // src/templates/common/common.ts
  function renderCommonTemplate(params) {
    const { versions: versions2 } = params;
    const text = renderHbsTemplate({ template: common_default, versions: versions2 });
    return text;
  }

  // src/templates/common/index.hbs
  var common_default2 = "{{header}}\n\n{{#each members}}\nexport { {{this}} } from './{{this}}';\n{{/each}}\n";

  // src/templates/common/index.ts
  function renderIndexTemplate(params) {
    const { files, versions: versions2 } = params;
    const members = files.map((f) => f.path.match(/([^/]+)\.ts$/m)?.[1]);
    const text = renderHbsTemplate({
      template: common_default2,
      versions: versions2,
      data: {
        members
      }
    });
    return text;
  }

  // src/templates/contract/factory.hbs
  var factory_default = '{{header}}\n\nimport { ContractFactory, decompressBytecode } from "fuels";\nimport type { Provider, Account, DeployContractOptions } from "fuels";\n\nimport { {{capitalizedName}} } from "./{{capitalizedName}}";\n\nconst bytecode = decompressBytecode("{{compressedBytecode}}");\n\nexport class {{capitalizedName}}Factory extends ContractFactory<{{capitalizedName}}> {\n\n  static readonly bytecode = bytecode;\n\n  constructor(accountOrProvider: Account | Provider) {\n    super(\n      bytecode,\n      {{capitalizedName}}.abi,\n      accountOrProvider,\n      {{capitalizedName}}.storageSlots\n    );\n  }\n\n  static deploy (\n    wallet: Account,\n    options: DeployContractOptions = {}\n  ) {\n    const factory = new {{capitalizedName}}Factory(wallet);\n    return factory.deploy(options);\n  }\n}\n';

  // src/templates/contract/factory.ts
  function renderFactoryTemplate(params) {
    const { versions: versions2, abi } = params;
    const {
      camelizedName,
      capitalizedName,
      rawContents,
      storageSlotsContents,
      hexlifiedBinContents: hexlifiedBinString
    } = abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate({
      template: factory_default,
      versions: versions2,
      data: {
        camelizedName,
        capitalizedName,
        abiJsonString,
        storageSlotsJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString)
      }
    });
    return text;
  }

  // src/templates/utils/formatEnums.ts
  function formatEnums(params) {
    const { types: types2 } = params;
    const enums = types2.filter((t) => t.name === "enum").map((t) => {
      const et2 = t;
      const structName = et2.getStructName();
      const inputValues = et2.getStructContents({ types: types2, target: "input" /* INPUT */ });
      const outputValues = et2.getStructContents({ types: types2, target: "output" /* OUTPUT */ });
      const inputNativeValues = et2.getNativeEnum({ types: types2 });
      const outputNativeValues = et2.getNativeEnum({ types: types2 });
      const typeAnnotations = et2.getStructDeclaration({ types: types2 });
      return {
        structName,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues,
        // reduces duplication
        inputNativeValues,
        outputNativeValues,
        typeAnnotations
      };
    }).sort((a, b) => a.structName < b.structName ? -1 : 1);
    return { enums };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_isPlaceholder.js
  function _isPlaceholder(a) {
    return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_curry1.js
  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_curry2.js
  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function(_b2) {
            return fn(a, _b2);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a2) {
            return fn(_a2, b);
          }) : _isPlaceholder(b) ? _curry1(function(_b2) {
            return fn(a, _b2);
          }) : fn(a, b);
      }
    };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_isArray.js
  var isArray_default = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
  };

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_isTransformer.js
  function _isTransformer(obj) {
    return obj != null && typeof obj["@@transducer/step"] === "function";
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_dispatchable.js
  function _dispatchable(methodNames, transducerCreator, fn) {
    return function() {
      if (arguments.length === 0) {
        return fn();
      }
      var obj = arguments[arguments.length - 1];
      if (!isArray_default(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === "function") {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_xfBase.js
  var xfBase_default = {
    init: function() {
      return this.xf["@@transducer/init"]();
    },
    result: function(result) {
      return this.xf["@@transducer/result"](result);
    }
  };

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_arrayFromIterator.js
  function _arrayFromIterator(iter) {
    var list = [];
    var next;
    while (!(next = iter.next()).done) {
      list.push(next.value);
    }
    return list;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_includesWith.js
  function _includesWith(pred, x, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_functionName.js
  function _functionName(f) {
    var match2 = String(f).match(/^function (\w*)/);
    return match2 == null ? "" : match2[1];
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_has.js
  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_objectIs.js
  function _objectIs(a, b) {
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    } else {
      return a !== a && b !== b;
    }
  }
  var objectIs_default = typeof Object.is === "function" ? Object.is : _objectIs;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_isArguments.js
  var toString = Object.prototype.toString;
  var _isArguments = /* @__PURE__ */ function() {
    return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
      return toString.call(x) === "[object Arguments]";
    } : function _isArguments2(x) {
      return _has("callee", x);
    };
  }();
  var isArguments_default = _isArguments;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/keys.js
  var hasEnumBug = !/* @__PURE__ */ {
    toString: null
  }.propertyIsEnumerable("toString");
  var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
  var hasArgsEnumBug = /* @__PURE__ */ function() {
    "use strict";
    return arguments.propertyIsEnumerable("length");
  }();
  var contains = function contains2(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };
  var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : /* @__PURE__ */ _curry1(function keys3(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== "length")) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });
  var keys_default = keys;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/type.js
  var type = /* @__PURE__ */ _curry1(function type2(val) {
    return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
  });
  var type_default = type;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_equals.js
  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);
    var b = _arrayFromIterator(bIterator);
    function eq(_a2, _b2) {
      return _equals(_a2, _b2, stackA.slice(), stackB.slice());
    }
    return !_includesWith(function(b2, aItem) {
      return !_includesWith(eq, aItem, b2);
    }, b, a);
  }
  function _equals(a, b, stackA, stackB) {
    if (objectIs_default(a, b)) {
      return true;
    }
    var typeA = type_default(a);
    if (typeA !== type_default(b)) {
      return false;
    }
    if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
      return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
    }
    if (typeof a.equals === "function" || typeof b.equals === "function") {
      return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
    }
    switch (typeA) {
      case "Arguments":
      case "Array":
      case "Object":
        if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
          return a === b;
        }
        break;
      case "Boolean":
      case "Number":
      case "String":
        if (!(typeof a === typeof b && objectIs_default(a.valueOf(), b.valueOf()))) {
          return false;
        }
        break;
      case "Date":
        if (!objectIs_default(a.valueOf(), b.valueOf())) {
          return false;
        }
        break;
      case "Error":
        return a.name === b.name && a.message === b.message;
      case "RegExp":
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }
        break;
    }
    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }
    switch (typeA) {
      case "Map":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
      case "Set":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
      case "Arguments":
      case "Array":
      case "Object":
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "Error":
      case "RegExp":
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "ArrayBuffer":
        break;
      default:
        return false;
    }
    var keysA = keys_default(a);
    if (keysA.length !== keys_default(b).length) {
      return false;
    }
    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }
      idx -= 1;
    }
    return true;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/equals.js
  var equals = /* @__PURE__ */ _curry2(function equals2(a, b) {
    return _equals(a, b, [], []);
  });
  var equals_default = equals;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_indexOf.js
  function _indexOf(list, a, idx) {
    var inf, item;
    if (typeof list.indexOf === "function") {
      switch (typeof a) {
        case "number":
          if (a === 0) {
            inf = 1 / a;
            while (idx < list.length) {
              item = list[idx];
              if (item === 0 && 1 / item === inf) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          } else if (a !== a) {
            while (idx < list.length) {
              item = list[idx];
              if (typeof item === "number" && item !== item) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          }
          return list.indexOf(a, idx);
        case "string":
        case "boolean":
        case "function":
        case "undefined":
          return list.indexOf(a, idx);
        case "object":
          if (a === null) {
            return list.indexOf(a, idx);
          }
      }
    }
    while (idx < list.length) {
      if (equals_default(list[idx], a)) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_includes.js
  function _includes(a, list) {
    return _indexOf(list, a, 0) >= 0;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_identity.js
  function _identity(x) {
    return x;
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/identity.js
  var identity = /* @__PURE__ */ _curry1(_identity);
  var identity_default = identity;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_Set.js
  var _Set = /* @__PURE__ */ function() {
    function _Set2() {
      this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
      this._items = {};
    }
    _Set2.prototype.add = function(item) {
      return !hasOrAdd(item, true, this);
    };
    _Set2.prototype.has = function(item) {
      return hasOrAdd(item, false, this);
    };
    return _Set2;
  }();
  function hasOrAdd(item, shouldAdd, set) {
    var type3 = typeof item;
    var prevSize, newSize;
    switch (type3) {
      case "string":
      case "number":
        if (item === 0 && 1 / item === -Infinity) {
          if (set._items["-0"]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items["-0"] = true;
            }
            return false;
          }
        }
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type3 in set._items)) {
            if (shouldAdd) {
              set._items[type3] = {};
              set._items[type3][item] = true;
            }
            return false;
          } else if (item in set._items[type3]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type3][item] = true;
            }
            return false;
          }
        }
      case "boolean":
        if (type3 in set._items) {
          var bIdx = item ? 1 : 0;
          if (set._items[type3][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type3][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set._items[type3] = item ? [false, true] : [true, false];
          }
          return false;
        }
      case "function":
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type3 in set._items)) {
            if (shouldAdd) {
              set._items[type3] = [item];
            }
            return false;
          }
          if (!_includes(item, set._items[type3])) {
            if (shouldAdd) {
              set._items[type3].push(item);
            }
            return false;
          }
          return true;
        }
      case "undefined":
        if (set._items[type3]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type3] = true;
          }
          return false;
        }
      case "object":
        if (item === null) {
          if (!set._items["null"]) {
            if (shouldAdd) {
              set._items["null"] = true;
            }
            return false;
          }
          return true;
        }
      default:
        type3 = Object.prototype.toString.call(item);
        if (!(type3 in set._items)) {
          if (shouldAdd) {
            set._items[type3] = [item];
          }
          return false;
        }
        if (!_includes(item, set._items[type3])) {
          if (shouldAdd) {
            set._items[type3].push(item);
          }
          return false;
        }
        return true;
    }
  }
  var Set_default = _Set;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/internal/_xuniqBy.js
  var XUniqBy = /* @__PURE__ */ function() {
    function XUniqBy2(f, xf) {
      this.xf = xf;
      this.f = f;
      this.set = new Set_default();
    }
    XUniqBy2.prototype["@@transducer/init"] = xfBase_default.init;
    XUniqBy2.prototype["@@transducer/result"] = xfBase_default.result;
    XUniqBy2.prototype["@@transducer/step"] = function(result, input) {
      return this.set.add(this.f(input)) ? this.xf["@@transducer/step"](result, input) : result;
    };
    return XUniqBy2;
  }();
  function _xuniqBy(f) {
    return function(xf) {
      return new XUniqBy(f, xf);
    };
  }

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/uniqBy.js
  var uniqBy = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xuniqBy, function(fn, list) {
    var set = new Set_default();
    var result = [];
    var idx = 0;
    var appliedItem, item;
    while (idx < list.length) {
      item = list[idx];
      appliedItem = fn(item);
      if (set.add(appliedItem)) {
        result.push(item);
      }
      idx += 1;
    }
    return result;
  }));
  var uniqBy_default = uniqBy;

  // ../../node_modules/.pnpm/ramda@0.30.1/node_modules/ramda/es/uniq.js
  var uniq = /* @__PURE__ */ uniqBy_default(identity_default);
  var uniq_default = uniq;

  // src/templates/utils/formatImports.ts
  var caseInsensitiveSort = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
  function formatImports(params) {
    const { types: types2, baseMembers = [] } = params;
    const members = types2.flatMap((t) => t.requiredFuelsMembersImports);
    const imports = uniq_default(baseMembers.concat(members).sort(caseInsensitiveSort));
    return {
      imports: imports.length ? imports : void 0
    };
  }

  // src/templates/utils/formatStructs.ts
  function formatStructs(params) {
    const { types: types2 } = params;
    const structs = types2.filter((t) => t.name === "struct").map((t) => {
      const st = t;
      const structName = st.getStructName();
      const inputValues = st.getStructContents({ types: types2, target: "input" /* INPUT */ });
      const outputValues = st.getStructContents({ types: types2, target: "output" /* OUTPUT */ });
      const typeAnnotations = st.getStructDeclaration({ types: types2 });
      return {
        structName,
        typeAnnotations,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues
        // reduces duplication
      };
    }).sort((a, b) => a.structName < b.structName ? -1 : 1);
    return { structs };
  }

  // src/templates/contract/main.hbs
  var main_default = `{{header}}

import { Contract, Interface } from "fuels";
{{#if imports}}
import type {
  Provider,
  Account,
  StorageSlot,
  Address,
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
{{#each configurables}}
  {{name}}: {{inputLabel}};
{{/each}}
}>;
{{/if}}

const abi = {{abiJsonString}};

const storageSlots: StorageSlot[] = {{storageSlotsJsonString}};

export class {{capitalizedName}}Interface extends Interface {
  constructor() {
    super(abi);
  }

  declare functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };
}

export class {{capitalizedName}} extends Contract {
  static readonly abi = abi;
  static readonly storageSlots = storageSlots;

  declare interface: {{capitalizedName}}Interface;
  declare functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };

  constructor(
    id: string | Address,
    accountOrProvider: Account | Provider,
  ) {
    super(id, abi, accountOrProvider);
  }
}
`;

  // src/templates/contract/main.ts
  function renderMainTemplate(params) {
    const { versions: versions2, abi } = params;
    const { camelizedName, capitalizedName, types: types2, functions, commonTypesInUse, configurables } = abi;
    const functionsTypedefs = functions.map((f) => f.getDeclaration());
    const functionsFragments = functions.map((f) => f.name);
    const encoders = functions.map((f) => ({
      functionName: f.name,
      input: f.attributes.inputs
    }));
    const decoders = functions.map((f) => ({
      functionName: f.name
    }));
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: ["FunctionFragment", "InvokeFunction"]
    });
    const { rawContents, storageSlotsContents } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate({
      template: main_default,
      versions: versions2,
      data: {
        camelizedName,
        capitalizedName,
        commonTypesInUse: commonTypesInUse.join(", "),
        functionsTypedefs,
        functionsFragments,
        encoders,
        decoders,
        structs,
        enums,
        imports,
        abiJsonString,
        storageSlotsJsonString,
        configurables
      }
    });
    return text;
  }

  // src/utils/assembleContracts.ts
  function assembleContracts(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { capitalizedName } = abi;
      const mainFilepath = `${outputDir}/${capitalizedName}.ts`;
      const factoryFilepath = `${outputDir}/${capitalizedName}Factory.ts`;
      const main = {
        path: mainFilepath,
        contents: renderMainTemplate({ abi, versions: versions2 })
      };
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate({ abi, versions: versions2 })
      };
      files.push(main);
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path10.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }

  // src/utils/assemblePredicates.ts
  var import_path11 = __require("path");

  // src/templates/predicate/main.hbs
  var main_default2 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
  {{#each configurables}}
    {{name}}: {{inputLabel}};
  {{/each}}
}>;
{{else}}
export type {{capitalizedName}}Configurables = undefined;
{{/if}}

export type {{capitalizedName}}Inputs = [{{inputs}}];

export type {{capitalizedName}}Parameters = Omit<
  PredicateParams<{{capitalizedName}}Inputs, {{capitalizedName}}Configurables>,
  'abi' | 'bytecode'
>;

const abi = {{abiJsonString}};

const bytecode = decompressBytecode('{{compressedBytecode}}');

export class {{capitalizedName}} extends Predicate<
  {{capitalizedName}}Inputs,
  {{capitalizedName}}Configurables
> {
  static readonly abi = abi;
  static readonly bytecode = bytecode;

  constructor(params: {{capitalizedName}}Parameters) {
    super({ abi, bytecode, ...params });
  }
}
`;

  // src/templates/predicate/main.ts
  function renderMainTemplate2(params) {
    const { abi, versions: versions2 } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      capitalizedName,
      hexlifiedBinContents: hexlifiedBinString,
      commonTypesInUse
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f) => f.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: ["Predicate", "Provider", "InputValue", "PredicateParams", "decompressBytecode"]
    });
    const { prefixedInputs: inputs, output } = func.attributes;
    const text = renderHbsTemplate({
      template: main_default2,
      versions: versions2,
      data: {
        inputs,
        output,
        structs,
        enums,
        abiJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString),
        capitalizedName,
        imports,
        configurables,
        commonTypesInUse: commonTypesInUse.join(", ")
      }
    });
    return text;
  }

  // src/utils/assemblePredicates.ts
  function assemblePredicates(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { capitalizedName: name } = abi;
      const factoryFilepath = `${outputDir}/${name}.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderMainTemplate2({ abi, versions: versions2 })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path11.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }

  // src/utils/assembleScripts.ts
  var import_path12 = __require("path");

  // src/templates/script/main.hbs
  var main_default3 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input{{typeAnnotations}} = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
  {{else}}
export type {{structName}}Output{{typeAnnotations}} = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

export type {{capitalizedName}}Inputs = [{{inputs}}];
export type {{capitalizedName}}Output = {{output}};

{{#if configurables}}
export type {{capitalizedName}}Configurables = Partial<{
{{#each configurables}}
  {{name}}: {{inputLabel}};
{{/each}}
}>;
{{/if}}

const abi = {{abiJsonString}};

const bytecode = decompressBytecode('{{compressedBytecode}}');

export class {{capitalizedName}} extends Script<{{capitalizedName}}Inputs, {{capitalizedName}}Output> {

  static readonly abi = abi;
  static readonly bytecode = bytecode;

  constructor(wallet: Account) {
    super(bytecode, abi, wallet);
  }
}
`;

  // src/templates/script/main.ts
  function renderMainTemplate3(params) {
    const { abi, versions: versions2 } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      capitalizedName,
      hexlifiedBinContents: hexlifiedBinString,
      commonTypesInUse
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f) => f.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: ["Script", "Account", "decompressBytecode"]
    });
    const { prefixedInputs: inputs, output } = func.attributes;
    const text = renderHbsTemplate({
      template: main_default3,
      versions: versions2,
      data: {
        inputs,
        output,
        structs,
        enums,
        abiJsonString,
        compressedBytecode: compressBytecode(hexlifiedBinString),
        capitalizedName,
        imports,
        configurables,
        commonTypesInUse: commonTypesInUse.join(", ")
      }
    });
    return text;
  }

  // src/utils/assembleScripts.ts
  function assembleScripts(params) {
    const { abis, outputDir, versions: versions2 } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { capitalizedName } = abi;
      const factoryFilepath = `${outputDir}/${capitalizedName}.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderMainTemplate3({ abi, versions: versions2 })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ files, versions: versions2 })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path12.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate({ versions: versions2 })
      };
      files.push(file);
    }
    return files;
  }

  // src/utils/validateBinFile.ts
  var upperFirst = (s) => s[0].toUpperCase() + s.slice(1);
  function validateBinFile(params) {
    const { abiFilepath, binFilepath, binExists, programType } = params;
    const isScript = programType === "script" /* SCRIPT */;
    if (!binExists && isScript) {
      throw new FuelError(
        ErrorCode.BIN_FILE_NOT_FOUND,
        [
          `Could not find BIN file for counterpart ${upperFirst(programType)} ABI.`,
          `  - ABI: ${abiFilepath}`,
          `  - BIN: ${binFilepath}`,
          programType
        ].join("\n")
      );
    }
  }

  // src/AbiTypeGen.ts
  var AbiTypeGen = class {
    abis;
    abiFiles;
    binFiles;
    storageSlotsFiles;
    outputDir;
    files;
    versions;
    constructor(params) {
      const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles, versions: versions2 } = params;
      this.outputDir = outputDir;
      this.abiFiles = abiFiles;
      this.binFiles = binFiles;
      this.storageSlotsFiles = storageSlotsFiles;
      this.versions = versions2;
      this.abis = this.abiFiles.map((abiFile) => {
        const binFilepath = abiFile.path.replace("-abi.json", ".bin");
        const relatedBinFile = this.binFiles.find(({ path: path2 }) => path2 === binFilepath);
        const storageSlotFilepath = abiFile.path.replace("-abi.json", "-storage_slots.json");
        const relatedStorageSlotsFile = this.storageSlotsFiles.find(
          ({ path: path2 }) => path2 === storageSlotFilepath
        );
        if (!relatedBinFile) {
          validateBinFile({
            abiFilepath: abiFile.path,
            binExists: !!relatedBinFile,
            binFilepath,
            programType
          });
        }
        const abi = new Abi({
          filepath: abiFile.path,
          rawContents: JSON.parse(abiFile.contents),
          hexlifiedBinContents: relatedBinFile?.contents,
          storageSlotsContents: relatedStorageSlotsFile?.contents,
          outputDir,
          programType
        });
        return abi;
      });
      this.files = this.getAssembledFiles({ programType });
    }
    getAssembledFiles(params) {
      const { abis, outputDir, versions: versions2 } = this;
      const { programType } = params;
      switch (programType) {
        case "contract" /* CONTRACT */:
          return assembleContracts({ abis, outputDir, versions: versions2 });
        case "script" /* SCRIPT */:
          return assembleScripts({ abis, outputDir, versions: versions2 });
        case "predicate" /* PREDICATE */:
          return assemblePredicates({ abis, outputDir, versions: versions2 });
        default:
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(
              ProgramTypeEnum
            )}`
          );
      }
    }
  };

  // src/utils/collectBinFilePaths.ts
  var import_fs14 = __require("fs");
  var collectBinFilepaths = (params) => {
    const { filepaths, programType } = params;
    const binFiles = filepaths.map((abiFilepath) => {
      const binFilepath = abiFilepath.replace("-abi.json", ".bin");
      const binExists = (0, import_fs14.existsSync)(binFilepath);
      validateBinFile({ abiFilepath, binFilepath, binExists, programType });
      const bin = {
        path: binFilepath,
        contents: hexlify((0, import_fs14.readFileSync)(binFilepath))
      };
      return bin;
    });
    return binFiles;
  };

  // src/utils/collectStorageSlotsFilePaths.ts
  var import_fs15 = __require("fs");
  var collectStorageSlotsFilepaths = (params) => {
    const { filepaths, programType } = params;
    const storageSlotsFiles = [];
    if (programType !== "contract" /* CONTRACT */) {
      return storageSlotsFiles;
    }
    filepaths.forEach((abiFilepath) => {
      const storageSlotsFilepath = abiFilepath.replace("-abi.json", "-storage_slots.json");
      const storageSlotsExists = (0, import_fs15.existsSync)(storageSlotsFilepath);
      if (storageSlotsExists) {
        const storageSlots = {
          path: storageSlotsFilepath,
          contents: (0, import_fs15.readFileSync)(storageSlotsFilepath, "utf-8")
        };
        storageSlotsFiles.push(storageSlots);
      }
    });
    return storageSlotsFiles;
  };

  // src/runTypegen.ts
  function runTypegen(params) {
    const { cwd, inputs, output, silent, programType, filepaths: inputFilepaths } = params;
    const versions2 = { FUELS: versions.FUELS, ...params.versions };
    const cwdBasename = (0, import_path13.basename)(cwd);
    function log(...args) {
      if (!silent) {
        console.log(args.join(" "));
      }
    }
    let filepaths = [];
    if (!inputFilepaths?.length && inputs?.length) {
      filepaths = inputs.flatMap((i) => globSync(i, { cwd }));
    } else if (inputFilepaths?.length) {
      filepaths = inputFilepaths;
    } else {
      throw new FuelError(
        ErrorCode.MISSING_REQUIRED_PARAMETER,
        `At least one parameter should be supplied: 'input' or 'filepaths'.`
      );
    }
    const abiFiles = filepaths.map((filepath) => {
      const contents = (0, import_fs16.readFileSync)(filepath, "utf-8");
      const abi = {
        path: filepath,
        contents
      };
      return abi;
    });
    if (!abiFiles.length) {
      throw new FuelError(ErrorCode.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);
    }
    const binFiles = collectBinFilepaths({ filepaths, programType });
    const storageSlotsFiles = collectStorageSlotsFilepaths({ filepaths, programType });
    const abiTypeGen = new AbiTypeGen({
      outputDir: output,
      abiFiles,
      binFiles,
      storageSlotsFiles,
      programType,
      versions: versions2
    });
    log("Generating files..\n");
    mkdirp.sync(`${output}`);
    abiTypeGen.files.forEach((file) => {
      rimrafSync(file.path);
      (0, import_fs16.writeFileSync)(file.path, file.contents);
      const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, "m");
      log(` - ${file.path.replace(trimPathRegex, "")}`);
    });
    log("\nDone.\u26A1");
  }
})();
//# sourceMappingURL=runTypegen.global.js.map