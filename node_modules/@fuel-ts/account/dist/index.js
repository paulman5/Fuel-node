"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AbstractAccount: () => AbstractAccount,
  AbstractScriptRequest: () => AbstractScriptRequest,
  Account: () => Account,
  AddressType: () => AddressType,
  BLOCKS_PAGE_SIZE_LIMIT: () => BLOCKS_PAGE_SIZE_LIMIT,
  BaseTransactionRequest: () => BaseTransactionRequest,
  BaseWalletUnlocked: () => BaseWalletUnlocked,
  BlobTransactionRequest: () => BlobTransactionRequest,
  CHAIN_IDS: () => CHAIN_IDS,
  ChainName: () => ChainName,
  ChangeOutputCollisionError: () => ChangeOutputCollisionError,
  CreateTransactionRequest: () => CreateTransactionRequest,
  DEFAULT_RESOURCE_CACHE_TTL: () => DEFAULT_RESOURCE_CACHE_TTL,
  Fuel: () => Fuel,
  FuelConnector: () => FuelConnector,
  FuelConnectorEventType: () => FuelConnectorEventType,
  FuelConnectorEventTypes: () => FuelConnectorEventTypes,
  FuelConnectorMethods: () => FuelConnectorMethods,
  GAS_USED_MODIFIER: () => GAS_USED_MODIFIER,
  HDWallet: () => hdwallet_default,
  Language: () => Language,
  LocalStorage: () => LocalStorage,
  MNEMONIC_SIZES: () => MNEMONIC_SIZES,
  MemoryStorage: () => MemoryStorage,
  Mnemonic: () => mnemonic_default,
  MnemonicVault: () => MnemonicVault,
  NoWitnessAtIndexError: () => NoWitnessAtIndexError,
  NoWitnessByOwnerError: () => NoWitnessByOwnerError,
  OperationName: () => OperationName,
  Predicate: () => Predicate,
  PrivateKeyVault: () => PrivateKeyVault,
  Provider: () => Provider,
  RESOURCES_PAGE_SIZE_LIMIT: () => RESOURCES_PAGE_SIZE_LIMIT,
  ScriptTransactionRequest: () => ScriptTransactionRequest,
  Signer: () => Signer,
  StorageAbstract: () => StorageAbstract,
  TRANSACTIONS_PAGE_SIZE_LIMIT: () => TRANSACTIONS_PAGE_SIZE_LIMIT,
  TransactionResponse: () => TransactionResponse,
  TransactionStatus: () => TransactionStatus,
  TransactionType: () => import_transactions7.TransactionType,
  TransactionTypeName: () => TransactionTypeName,
  UpgradeTransactionRequest: () => UpgradeTransactionRequest,
  UploadTransactionRequest: () => UploadTransactionRequest,
  Vault: () => Vault,
  Wallet: () => Wallet,
  WalletLocked: () => WalletLocked,
  WalletManager: () => WalletManager,
  WalletUnlocked: () => WalletUnlocked,
  addAmountToCoinQuantities: () => addAmountToCoinQuantities,
  addOperation: () => addOperation,
  aggregateInputsAmountsByAssetAndOwner: () => aggregateInputsAmountsByAssetAndOwner,
  assemblePanicError: () => assemblePanicError,
  assembleReceiptByType: () => assembleReceiptByType,
  assembleRevertError: () => assembleRevertError,
  assembleTransactionSummary: () => assembleTransactionSummary,
  assets: () => assets,
  buildBlockExplorerUrl: () => buildBlockExplorerUrl,
  cacheFor: () => cacheFor,
  cacheRequestInputsResources: () => cacheRequestInputsResources,
  cacheRequestInputsResourcesFromOwner: () => cacheRequestInputsResourcesFromOwner,
  calculateGasFee: () => calculateGasFee,
  calculateMetadataGasForTxBlob: () => calculateMetadataGasForTxBlob,
  calculateMetadataGasForTxCreate: () => calculateMetadataGasForTxCreate,
  calculateMetadataGasForTxScript: () => calculateMetadataGasForTxScript,
  calculateMetadataGasForTxUpgrade: () => calculateMetadataGasForTxUpgrade,
  calculateMetadataGasForTxUpload: () => calculateMetadataGasForTxUpload,
  calculateMinGasForTxUpload: () => calculateMinGasForTxUpload,
  calculateTXFeeForSummary: () => calculateTXFeeForSummary,
  coinQuantityfy: () => coinQuantityfy,
  deferPromise: () => deferPromise,
  deployScriptOrPredicate: () => deployScriptOrPredicate,
  dispatchFuelConnectorEvent: () => dispatchFuelConnectorEvent,
  english: () => english,
  extractBurnedAssetsFromReceipts: () => extractBurnedAssetsFromReceipts,
  extractMintedAssetsFromReceipts: () => extractMintedAssetsFromReceipts,
  extractTxError: () => extractTxError,
  fuelAssetsBaseUrl: () => fuelAssetsBaseUrl,
  gasUsedByInputs: () => gasUsedByInputs,
  getAssetAmountInRequestInputs: () => getAssetAmountInRequestInputs,
  getAssetEth: () => getAssetEth,
  getAssetFuel: () => getAssetFuel,
  getAssetNetwork: () => getAssetNetwork,
  getAssetWithNetwork: () => getAssetWithNetwork,
  getBurnableAssetCount: () => getBurnableAssetCount,
  getContractCallOperations: () => getContractCallOperations,
  getContractCreatedOperations: () => getContractCreatedOperations,
  getDecodedLogs: () => getDecodedLogs,
  getDefaultChainId: () => getDefaultChainId,
  getGasUsedFromReceipts: () => getGasUsedFromReceipts,
  getInputAccountAddress: () => getInputAccountAddress,
  getInputContractFromIndex: () => getInputContractFromIndex,
  getInputFromAssetId: () => getInputFromAssetId,
  getInputsByType: () => getInputsByType,
  getInputsByTypes: () => getInputsByTypes,
  getInputsCoin: () => getInputsCoin,
  getInputsCoinAndMessage: () => getInputsCoinAndMessage,
  getInputsContract: () => getInputsContract,
  getInputsMessage: () => getInputsMessage,
  getMaxGas: () => getMaxGas,
  getMinGas: () => getMinGas,
  getOperations: () => getOperations,
  getOutputsByType: () => getOutputsByType,
  getOutputsChange: () => getOutputsChange,
  getOutputsCoin: () => getOutputsCoin,
  getOutputsContract: () => getOutputsContract,
  getOutputsContractCreated: () => getOutputsContractCreated,
  getOutputsVariable: () => getOutputsVariable,
  getPayProducerOperations: () => getPayProducerOperations,
  getPredicateRoot: () => getPredicateRoot,
  getReceiptsByType: () => getReceiptsByType,
  getReceiptsCall: () => getReceiptsCall,
  getReceiptsMessageOut: () => getReceiptsMessageOut,
  getReceiptsTransferOut: () => getReceiptsTransferOut,
  getReceiptsWithMissingData: () => getReceiptsWithMissingData,
  getRequestInputResourceOwner: () => getRequestInputResourceOwner,
  getTotalFeeFromStatus: () => getTotalFeeFromStatus,
  getTransactionStatusName: () => getTransactionStatusName,
  getTransactionSummary: () => getTransactionSummary,
  getTransactionSummaryFromRequest: () => getTransactionSummaryFromRequest,
  getTransactionTypeName: () => getTransactionTypeName,
  getTransactionsSummaries: () => getTransactionsSummaries,
  getTransferOperations: () => getTransferOperations,
  getWithdrawFromFuelOperations: () => getWithdrawFromFuelOperations,
  hasSameAssetId: () => hasSameAssetId,
  inputify: () => inputify,
  isCoin: () => isCoin,
  isInputCoin: () => isInputCoin,
  isMessage: () => isMessage,
  isMessageCoin: () => isMessageCoin,
  isRawCoin: () => isRawCoin,
  isRawMessage: () => isRawMessage,
  isRequestInputCoin: () => isRequestInputCoin,
  isRequestInputCoinOrMessage: () => isRequestInputCoinOrMessage,
  isRequestInputMessage: () => isRequestInputMessage,
  isRequestInputMessageWithoutData: () => isRequestInputMessageWithoutData,
  isRequestInputResource: () => isRequestInputResource,
  isRequestInputResourceFromOwner: () => isRequestInputResourceFromOwner,
  isTransactionTypeBlob: () => isTransactionTypeBlob,
  isTransactionTypeCreate: () => isTransactionTypeCreate,
  isTransactionTypeScript: () => isTransactionTypeScript,
  isTransactionTypeUpgrade: () => isTransactionTypeUpgrade,
  isTransactionTypeUpload: () => isTransactionTypeUpload,
  isType: () => isType,
  isTypeBlob: () => isTypeBlob,
  isTypeCreate: () => isTypeCreate,
  isTypeMint: () => isTypeMint,
  isTypeScript: () => isTypeScript,
  isTypeUpgrade: () => isTypeUpgrade,
  isTypeUpload: () => isTypeUpload,
  normalizeJSON: () => normalizeJSON,
  outputify: () => outputify,
  processGqlReceipt: () => processGqlReceipt,
  processGraphqlStatus: () => processGraphqlStatus,
  rawAssets: () => rawAssets,
  resolveGasDependentCosts: () => resolveGasDependentCosts,
  resolveIconPaths: () => resolveIconPaths,
  returnZeroScript: () => returnZeroScript,
  transactionRequestify: () => transactionRequestify,
  urlJoin: () => urlJoin,
  validateTransactionForAssetBurn: () => validateTransactionForAssetBurn,
  withTimeout: () => withTimeout,
  withdrawScript: () => withdrawScript
});
module.exports = __toCommonJS(src_exports);

// src/account.ts
var import_abi_coder7 = require("@fuel-ts/abi-coder");
var import_address5 = require("@fuel-ts/address");
var import_crypto2 = require("@fuel-ts/crypto");
var import_errors21 = require("@fuel-ts/errors");
var import_math20 = require("@fuel-ts/math");
var import_transactions24 = require("@fuel-ts/transactions");
var import_utils34 = require("@fuel-ts/utils");
var import_ramda9 = require("ramda");

// src/providers/coin-quantity.ts
var import_math = require("@fuel-ts/math");
var import_utils = require("@fuel-ts/utils");
var coinQuantityfy = (coinQuantityLike) => {
  let assetId;
  let amount;
  let max;
  if (Array.isArray(coinQuantityLike)) {
    amount = coinQuantityLike[0];
    assetId = coinQuantityLike[1];
    max = coinQuantityLike[2] ?? void 0;
  } else {
    amount = coinQuantityLike.amount;
    assetId = coinQuantityLike.assetId;
    max = coinQuantityLike.max ?? void 0;
  }
  const bnAmount = (0, import_math.bn)(amount);
  return {
    assetId: (0, import_utils.hexlify)(assetId),
    amount: bnAmount.lt(1) ? (0, import_math.bn)(1) : bnAmount,
    max: max ? (0, import_math.bn)(max) : void 0
  };
};
var addAmountToCoinQuantities = (params) => {
  const { amount, assetId } = params;
  const coinQuantities = [...params.coinQuantities];
  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
  if (assetIdx !== -1) {
    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
  } else {
    coinQuantities.push({ assetId, amount });
  }
  return coinQuantities;
};

// src/providers/provider.ts
var import_address3 = require("@fuel-ts/address");
var import_errors19 = require("@fuel-ts/errors");
var import_math18 = require("@fuel-ts/math");
var import_transactions22 = require("@fuel-ts/transactions");
var import_utils28 = require("@fuel-ts/utils");
var import_versions = require("@fuel-ts/versions");
var import_utils29 = require("@noble/curves/abstract/utils");
var import_graphql_request = require("graphql-request");
var import_graphql_tag2 = __toESM(require("graphql-tag"));
var import_ramda8 = require("ramda");

// src/providers/__generated__/operations.ts
var import_graphql_tag = __toESM(require("graphql-tag"));
var SubmittedStatusFragmentDoc = import_graphql_tag.default`
    fragment SubmittedStatusFragment on SubmittedStatus {
  type: __typename
  time
}
    `;
var ReceiptFragmentDoc = import_graphql_tag.default`
    fragment receiptFragment on Receipt {
  id
  pc
  is
  to
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
var SuccessStatusFragmentDoc = import_graphql_tag.default`
    fragment SuccessStatusFragment on SuccessStatus {
  type: __typename
  time
  programState {
    returnType
    data
  }
  receipts {
    ...receiptFragment
  }
  totalGas
  totalFee
}
    ${ReceiptFragmentDoc}`;
var SuccessStatusWithBlockIdFragmentDoc = import_graphql_tag.default`
    fragment SuccessStatusWithBlockIdFragment on SuccessStatus {
  ...SuccessStatusFragment
  block {
    id
  }
}
    ${SuccessStatusFragmentDoc}`;
var MalleableTransactionFieldsFragmentDoc = import_graphql_tag.default`
    fragment malleableTransactionFieldsFragment on Transaction {
  receiptsRoot
  inputs {
    type: __typename
    ... on InputCoin {
      txPointer
    }
    ... on InputContract {
      txPointer
    }
  }
  outputs {
    type: __typename
    ... on CoinOutput {
      to
      amount
      assetId
    }
    ... on ContractOutput {
      inputIndex
      balanceRoot
      stateRoot
    }
    ... on ChangeOutput {
      to
      amount
      assetId
    }
    ... on VariableOutput {
      to
      amount
      assetId
    }
    ... on ContractCreated {
      contract
      stateRoot
    }
  }
}
    `;
var FailureStatusFragmentDoc = import_graphql_tag.default`
    fragment FailureStatusFragment on FailureStatus {
  type: __typename
  totalGas
  totalFee
  time
  reason
  receipts {
    ...receiptFragment
  }
}
    ${ReceiptFragmentDoc}`;
var FailureStatusWithBlockIdFragmentDoc = import_graphql_tag.default`
    fragment FailureStatusWithBlockIdFragment on FailureStatus {
  ...FailureStatusFragment
  block {
    id
  }
}
    ${FailureStatusFragmentDoc}`;
var SqueezedOutStatusFragmentDoc = import_graphql_tag.default`
    fragment SqueezedOutStatusFragment on SqueezedOutStatus {
  type: __typename
  reason
}
    `;
var TransactionStatusSubscriptionFragmentDoc = import_graphql_tag.default`
    fragment transactionStatusSubscriptionFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on FailureStatus {
    ...FailureStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusWithBlockIdFragmentDoc}
${MalleableTransactionFieldsFragmentDoc}
${FailureStatusWithBlockIdFragmentDoc}
${SqueezedOutStatusFragmentDoc}`;
var TransactionStatusFragmentDoc = import_graphql_tag.default`
    fragment transactionStatusFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusFragment
  }
  ... on FailureStatus {
    ...FailureStatusFragment
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusFragmentDoc}
${FailureStatusFragmentDoc}
${SqueezedOutStatusFragmentDoc}`;
var TransactionFragmentDoc = import_graphql_tag.default`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  status {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentDoc}`;
var TransactionRawPayloadFragmentDoc = import_graphql_tag.default`
    fragment transactionRawPayloadFragment on Transaction {
  id
  rawPayload
}
    `;
var InputEstimatePredicatesFragmentDoc = import_graphql_tag.default`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
var TransactionEstimatePredicatesFragmentDoc = import_graphql_tag.default`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentDoc}`;
var DryRunFailureStatusFragmentDoc = import_graphql_tag.default`
    fragment dryRunFailureStatusFragment on DryRunFailureStatus {
  type: __typename
  totalGas
  totalFee
  reason
  programState {
    returnType
    data
  }
}
    `;
var DryRunSuccessStatusFragmentDoc = import_graphql_tag.default`
    fragment dryRunSuccessStatusFragment on DryRunSuccessStatus {
  type: __typename
  totalGas
  totalFee
  programState {
    returnType
    data
  }
}
    `;
var DryRunTransactionStatusFragmentDoc = import_graphql_tag.default`
    fragment dryRunTransactionStatusFragment on DryRunTransactionStatus {
  ... on DryRunFailureStatus {
    ...dryRunFailureStatusFragment
  }
  ... on DryRunSuccessStatus {
    ...dryRunSuccessStatusFragment
  }
}
    ${DryRunFailureStatusFragmentDoc}
${DryRunSuccessStatusFragmentDoc}`;
var DryRunTransactionExecutionStatusFragmentDoc = import_graphql_tag.default`
    fragment dryRunTransactionExecutionStatusFragment on DryRunTransactionExecutionStatus {
  id
  status {
    ...dryRunTransactionStatusFragment
  }
  receipts {
    ...receiptFragment
  }
}
    ${DryRunTransactionStatusFragmentDoc}
${ReceiptFragmentDoc}`;
var BlockFragmentDoc = import_graphql_tag.default`
    fragment blockFragment on Block {
  id
  height
  header {
    time
    daHeight
    stateTransitionBytecodeVersion
    transactionsCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    prevRoot
    applicationHash
  }
  transactions {
    id
  }
}
    `;
var CoinFragmentDoc = import_graphql_tag.default`
    fragment coinFragment on Coin {
  type: __typename
  utxoId
  amount
  assetId
  blockCreated
  txCreatedIdx
}
    `;
var MessageCoinFragmentDoc = import_graphql_tag.default`
    fragment messageCoinFragment on MessageCoin {
  type: __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
var MessageFragmentDoc = import_graphql_tag.default`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  daHeight
}
    `;
var GetMessageFragmentDoc = import_graphql_tag.default`
    fragment getMessageFragment on Message {
  ...messageFragment
  nonce
}
    ${MessageFragmentDoc}`;
var MessageProofFragmentDoc = import_graphql_tag.default`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  commitBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  sender
  recipient
  amount
  data
}
    `;
var TxParametersFragmentDoc = import_graphql_tag.default`
    fragment TxParametersFragment on TxParameters {
  version
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
  maxBytecodeSubsections
}
    `;
var PredicateParametersFragmentDoc = import_graphql_tag.default`
    fragment PredicateParametersFragment on PredicateParameters {
  version
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
var ScriptParametersFragmentDoc = import_graphql_tag.default`
    fragment ScriptParametersFragment on ScriptParameters {
  version
  maxScriptLength
  maxScriptDataLength
}
    `;
var ContractParametersFragmentDoc = import_graphql_tag.default`
    fragment ContractParametersFragment on ContractParameters {
  version
  contractMaxSize
  maxStorageSlots
}
    `;
var FeeParametersFragmentDoc = import_graphql_tag.default`
    fragment FeeParametersFragment on FeeParameters {
  version
  gasPriceFactor
  gasPerByte
}
    `;
var DependentCostFragmentDoc = import_graphql_tag.default`
    fragment DependentCostFragment on DependentCost {
  ... on LightOperation {
    type: __typename
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    type: __typename
    base
    gasPerUnit
  }
}
    `;
var GasCostsFragmentDoc = import_graphql_tag.default`
    fragment GasCostsFragment on GasCosts {
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  ecr1
  newStoragePerByte
}
    ${DependentCostFragmentDoc}`;
var ConsensusParametersFragmentDoc = import_graphql_tag.default`
    fragment consensusParametersFragment on ConsensusParameters {
  version
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentDoc}
${PredicateParametersFragmentDoc}
${ScriptParametersFragmentDoc}
${ContractParametersFragmentDoc}
${FeeParametersFragmentDoc}
${GasCostsFragmentDoc}`;
var ChainInfoFragmentDoc = import_graphql_tag.default`
    fragment chainInfoFragment on ChainInfo {
  name
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${ConsensusParametersFragmentDoc}`;
var ContractBalanceFragmentDoc = import_graphql_tag.default`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
var PageInfoFragmentDoc = import_graphql_tag.default`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
var NodeInfoFragmentDoc = import_graphql_tag.default`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  maxTx
  maxDepth
  nodeVersion
}
    `;
var RelayedTransactionStatusFragmentDoc = import_graphql_tag.default`
    fragment relayedTransactionStatusFragment on RelayedTransactionStatus {
  ... on RelayedTransactionFailed {
    blockHeight
    failure
  }
}
    `;
var GetVersionDocument = import_graphql_tag.default`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
var GetNodeInfoDocument = import_graphql_tag.default`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentDoc}`;
var GetChainDocument = import_graphql_tag.default`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentDoc}`;
var GetChainAndNodeInfoDocument = import_graphql_tag.default`
    query getChainAndNodeInfo {
  chain {
    ...chainInfoFragment
  }
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${ChainInfoFragmentDoc}
${NodeInfoFragmentDoc}`;
var GetTransactionDocument = import_graphql_tag.default`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentDoc}`;
var GetTransactionWithReceiptsDocument = import_graphql_tag.default`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    id
    rawPayload
    status {
      ... on SubmittedStatus {
        ...SubmittedStatusFragment
      }
      ... on SuccessStatus {
        ...SuccessStatusWithBlockIdFragment
      }
      ... on FailureStatus {
        ...FailureStatusWithBlockIdFragment
      }
      ... on SqueezedOutStatus {
        ...SqueezedOutStatusFragment
      }
    }
  }
}
    ${SubmittedStatusFragmentDoc}
${SuccessStatusWithBlockIdFragmentDoc}
${FailureStatusWithBlockIdFragmentDoc}
${SqueezedOutStatusFragmentDoc}`;
var GetTransactionsDocument = import_graphql_tag.default`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        rawPayload
      }
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${PageInfoFragmentDoc}`;
var GetTransactionsByOwnerDocument = import_graphql_tag.default`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${TransactionFragmentDoc}`;
var EstimatePredicatesDocument = import_graphql_tag.default`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentDoc}`;
var GetLatestBlockDocument = import_graphql_tag.default`
    query getLatestBlock {
  chain {
    latestBlock {
      ...blockFragment
    }
  }
}
    ${BlockFragmentDoc}`;
var GetLatestBlockHeightDocument = import_graphql_tag.default`
    query getLatestBlockHeight {
  chain {
    latestBlock {
      height
    }
  }
}
    `;
var GetBlockDocument = import_graphql_tag.default`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentDoc}`;
var GetBlockWithTransactionsDocument = import_graphql_tag.default`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionRawPayloadFragment
    }
  }
}
    ${BlockFragmentDoc}
${TransactionRawPayloadFragmentDoc}`;
var GetBlocksDocument = import_graphql_tag.default`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${BlockFragmentDoc}`;
var GetCoinDocument = import_graphql_tag.default`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
    owner
  }
}
    ${CoinFragmentDoc}`;
var GetCoinsDocument = import_graphql_tag.default`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${CoinFragmentDoc}`;
var GetCoinsToSpendDocument = import_graphql_tag.default`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentDoc}
${MessageCoinFragmentDoc}`;
var GetContractDocument = import_graphql_tag.default`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
var GetContractBalanceDocument = import_graphql_tag.default`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentDoc}`;
var GetBalanceDocument = import_graphql_tag.default`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amount
  }
}
    `;
var GetLatestGasPriceDocument = import_graphql_tag.default`
    query getLatestGasPrice {
  latestGasPrice {
    gasPrice
  }
}
    `;
var EstimateGasPriceDocument = import_graphql_tag.default`
    query estimateGasPrice($blockHorizon: U32!) {
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    `;
var GetBalancesDocument = import_graphql_tag.default`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        assetId
        amount
      }
    }
  }
}
    ${PageInfoFragmentDoc}`;
var GetMessagesDocument = import_graphql_tag.default`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...getMessageFragment
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${GetMessageFragmentDoc}`;
var GetMessageProofDocument = import_graphql_tag.default`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentDoc}`;
var GetMessageStatusDocument = import_graphql_tag.default`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
var GetRelayedTransactionStatusDocument = import_graphql_tag.default`
    query getRelayedTransactionStatus($relayedTransactionId: RelayedTransactionId!) {
  relayedTransactionStatus(id: $relayedTransactionId) {
    ...relayedTransactionStatusFragment
  }
}
    ${RelayedTransactionStatusFragmentDoc}`;
var DryRunDocument = import_graphql_tag.default`
    mutation dryRun($encodedTransactions: [HexString!]!, $utxoValidation: Boolean, $gasPrice: U64) {
  dryRun(
    txs: $encodedTransactions
    utxoValidation: $utxoValidation
    gasPrice: $gasPrice
  ) {
    ...dryRunTransactionExecutionStatusFragment
  }
}
    ${DryRunTransactionExecutionStatusFragmentDoc}`;
var SubmitDocument = import_graphql_tag.default`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
var ProduceBlocksDocument = import_graphql_tag.default`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
var GetMessageByNonceDocument = import_graphql_tag.default`
    query getMessageByNonce($nonce: Nonce!) {
  message(nonce: $nonce) {
    ...messageFragment
  }
}
    ${MessageFragmentDoc}`;
var IsUserAccountDocument = import_graphql_tag.default`
    query isUserAccount($blobId: BlobId!, $contractId: ContractId!, $transactionId: TransactionId!) {
  blob(id: $blobId) {
    id
  }
  contract(id: $contractId) {
    id
  }
  transaction(id: $transactionId) {
    id
  }
}
    `;
var GetConsensusParametersVersionDocument = import_graphql_tag.default`
    query getConsensusParametersVersion {
  chain {
    latestBlock {
      header {
        consensusParametersVersion
      }
    }
  }
}
    `;
var SubmitAndAwaitStatusDocument = import_graphql_tag.default`
    subscription submitAndAwaitStatus($encodedTransaction: HexString!) {
  submitAndAwaitStatus(tx: $encodedTransaction) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc}`;
var StatusChangeDocument = import_graphql_tag.default`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${TransactionStatusSubscriptionFragmentDoc}`;
function getSdk(requester) {
  return {
    getVersion(variables, options) {
      return requester(GetVersionDocument, variables, options);
    },
    getNodeInfo(variables, options) {
      return requester(GetNodeInfoDocument, variables, options);
    },
    getChain(variables, options) {
      return requester(GetChainDocument, variables, options);
    },
    getChainAndNodeInfo(variables, options) {
      return requester(GetChainAndNodeInfoDocument, variables, options);
    },
    getTransaction(variables, options) {
      return requester(GetTransactionDocument, variables, options);
    },
    getTransactionWithReceipts(variables, options) {
      return requester(GetTransactionWithReceiptsDocument, variables, options);
    },
    getTransactions(variables, options) {
      return requester(GetTransactionsDocument, variables, options);
    },
    getTransactionsByOwner(variables, options) {
      return requester(GetTransactionsByOwnerDocument, variables, options);
    },
    estimatePredicates(variables, options) {
      return requester(EstimatePredicatesDocument, variables, options);
    },
    getLatestBlock(variables, options) {
      return requester(GetLatestBlockDocument, variables, options);
    },
    getLatestBlockHeight(variables, options) {
      return requester(GetLatestBlockHeightDocument, variables, options);
    },
    getBlock(variables, options) {
      return requester(GetBlockDocument, variables, options);
    },
    getBlockWithTransactions(variables, options) {
      return requester(GetBlockWithTransactionsDocument, variables, options);
    },
    getBlocks(variables, options) {
      return requester(GetBlocksDocument, variables, options);
    },
    getCoin(variables, options) {
      return requester(GetCoinDocument, variables, options);
    },
    getCoins(variables, options) {
      return requester(GetCoinsDocument, variables, options);
    },
    getCoinsToSpend(variables, options) {
      return requester(GetCoinsToSpendDocument, variables, options);
    },
    getContract(variables, options) {
      return requester(GetContractDocument, variables, options);
    },
    getContractBalance(variables, options) {
      return requester(GetContractBalanceDocument, variables, options);
    },
    getBalance(variables, options) {
      return requester(GetBalanceDocument, variables, options);
    },
    getLatestGasPrice(variables, options) {
      return requester(GetLatestGasPriceDocument, variables, options);
    },
    estimateGasPrice(variables, options) {
      return requester(EstimateGasPriceDocument, variables, options);
    },
    getBalances(variables, options) {
      return requester(GetBalancesDocument, variables, options);
    },
    getMessages(variables, options) {
      return requester(GetMessagesDocument, variables, options);
    },
    getMessageProof(variables, options) {
      return requester(GetMessageProofDocument, variables, options);
    },
    getMessageStatus(variables, options) {
      return requester(GetMessageStatusDocument, variables, options);
    },
    getRelayedTransactionStatus(variables, options) {
      return requester(GetRelayedTransactionStatusDocument, variables, options);
    },
    dryRun(variables, options) {
      return requester(DryRunDocument, variables, options);
    },
    submit(variables, options) {
      return requester(SubmitDocument, variables, options);
    },
    produceBlocks(variables, options) {
      return requester(ProduceBlocksDocument, variables, options);
    },
    getMessageByNonce(variables, options) {
      return requester(GetMessageByNonceDocument, variables, options);
    },
    isUserAccount(variables, options) {
      return requester(IsUserAccountDocument, variables, options);
    },
    getConsensusParametersVersion(variables, options) {
      return requester(GetConsensusParametersVersionDocument, variables, options);
    },
    submitAndAwaitStatus(variables, options) {
      return requester(SubmitAndAwaitStatusDocument, variables, options);
    },
    statusChange(variables, options) {
      return requester(StatusChangeDocument, variables, options);
    }
  };
}

// src/providers/fuel-graphql-subscriber.ts
var import_errors = require("@fuel-ts/errors");
var import_graphql = require("graphql");
var _FuelGraphqlSubscriber = class {
  constructor(stream) {
    this.stream = stream;
  }
  static async create(options) {
    const { url, query, variables, fetchFn } = options;
    const response = await fetchFn(`${url}-sub`, {
      method: "POST",
      body: JSON.stringify({
        query: (0, import_graphql.print)(query),
        variables
      }),
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }
    });
    const [errorReader, resultReader] = response.body.tee().map((stream) => stream.getReader());
    await new _FuelGraphqlSubscriber(errorReader).next();
    return new _FuelGraphqlSubscriber(resultReader);
  }
  events = [];
  parsingLeftover = "";
  async next() {
    while (true) {
      if (this.events.length > 0) {
        const { data, errors } = this.events.shift();
        if (Array.isArray(errors)) {
          throw new import_errors.FuelError(
            import_errors.FuelError.CODES.INVALID_REQUEST,
            errors.map((err) => err.message).join("\n\n")
          );
        }
        return { value: data, done: false };
      }
      const { value, done } = await this.stream.read();
      if (done) {
        return { value, done };
      }
      const decoded = _FuelGraphqlSubscriber.textDecoder.decode(value).replace(":keep-alive-text\n\n", "");
      if (decoded === "") {
        continue;
      }
      const text = `${this.parsingLeftover}${decoded}`;
      const regex = /data:.*\n\n/g;
      const matches = [...text.matchAll(regex)].flatMap((match) => match);
      matches.forEach((match) => {
        try {
          this.events.push(JSON.parse(match.replace(/^data:/, "")));
        } catch (e) {
          throw new import_errors.FuelError(
            import_errors.ErrorCode.STREAM_PARSING_ERROR,
            `Error while parsing stream data response: ${text}`
          );
        }
      });
      this.parsingLeftover = text.replace(matches.join(), "");
    }
  }
  /**
   * Gets called when `break` is called in a `for-await-of` loop.
   */
  return() {
    return Promise.resolve({ done: true, value: void 0 });
  }
  [Symbol.asyncIterator]() {
    return this;
  }
};
var FuelGraphqlSubscriber = _FuelGraphqlSubscriber;
__publicField(FuelGraphqlSubscriber, "textDecoder", new TextDecoder());

// src/providers/resource-cache.ts
var import_errors2 = require("@fuel-ts/errors");
var import_utils2 = require("@fuel-ts/utils");
var cache = /* @__PURE__ */ new Map();
var ResourceCache = class {
  ttl;
  constructor(ttl) {
    this.ttl = ttl;
    if (typeof ttl !== "number" || this.ttl <= 0) {
      throw new import_errors2.FuelError(
        import_errors2.ErrorCode.INVALID_TTL,
        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
      );
    }
  }
  // Add resources to the cache
  set(transactionId, resources) {
    const currentTime = Date.now();
    const existingResources = cache.get(transactionId) || {
      utxos: /* @__PURE__ */ new Set(),
      messages: /* @__PURE__ */ new Set(),
      timestamp: currentTime
    };
    resources.utxos.forEach((utxo) => existingResources.utxos.add((0, import_utils2.hexlify)(utxo)));
    resources.messages.forEach((message) => existingResources.messages.add((0, import_utils2.hexlify)(message)));
    cache.set(transactionId, existingResources);
  }
  // Remove resources from the cache for a given transaction ID
  unset(transactionId) {
    cache.delete(transactionId);
  }
  // Get all cached resources and remove expired ones
  getActiveData() {
    const allResources = { utxos: [], messages: [] };
    const currentTime = Date.now();
    cache.forEach((resource, transactionId) => {
      if (currentTime - resource.timestamp < this.ttl) {
        allResources.utxos.push(...resource.utxos);
        allResources.messages.push(...resource.messages);
      } else {
        cache.delete(transactionId);
      }
    });
    return allResources;
  }
  // Check if a UTXO ID or message nonce is already cached and not expired
  isCached(key) {
    const currentTime = Date.now();
    for (const [transactionId, resourceData] of cache.entries()) {
      if (currentTime - resourceData.timestamp > this.ttl) {
        cache.delete(transactionId);
      } else if (resourceData.utxos.has(key) || resourceData.messages.has(key)) {
        return true;
      }
    }
    return false;
  }
  clear() {
    cache.clear();
  }
};

// src/providers/transaction-request/input.ts
var import_abi_coder = require("@fuel-ts/abi-coder");
var import_configs = require("@fuel-ts/address/configs");
var import_errors3 = require("@fuel-ts/errors");
var import_math2 = require("@fuel-ts/math");
var import_transactions = require("@fuel-ts/transactions");
var import_utils3 = require("@fuel-ts/utils");
var inputify = (value) => {
  const { type } = value;
  switch (value.type) {
    case import_transactions.InputType.Coin: {
      const predicate = (0, import_utils3.arrayify)(value.predicate ?? "0x");
      const predicateData = (0, import_utils3.arrayify)(value.predicateData ?? "0x");
      return {
        type: import_transactions.InputType.Coin,
        txID: (0, import_utils3.hexlify)((0, import_utils3.arrayify)(value.id).slice(0, import_abi_coder.BYTES_32)),
        outputIndex: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.id).slice(import_abi_coder.BYTES_32, import_abi_coder.UTXO_ID_LEN)),
        owner: (0, import_utils3.hexlify)(value.owner),
        amount: (0, import_math2.bn)(value.amount),
        assetId: (0, import_utils3.hexlify)(value.assetId),
        txPointer: {
          blockHeight: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.txPointer).slice(0, 8)),
          txIndex: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.txPointer).slice(8, 16))
        },
        witnessIndex: value.witnessIndex,
        predicateGasUsed: (0, import_math2.bn)(value.predicateGasUsed),
        predicateLength: (0, import_math2.bn)(predicate.length),
        predicateDataLength: (0, import_math2.bn)(predicateData.length),
        predicate: (0, import_utils3.hexlify)(predicate),
        predicateData: (0, import_utils3.hexlify)(predicateData)
      };
    }
    case import_transactions.InputType.Contract: {
      return {
        type: import_transactions.InputType.Contract,
        txID: import_configs.ZeroBytes32,
        outputIndex: 0,
        balanceRoot: import_configs.ZeroBytes32,
        stateRoot: import_configs.ZeroBytes32,
        txPointer: {
          blockHeight: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.txPointer).slice(0, 8)),
          txIndex: (0, import_math2.toNumber)((0, import_utils3.arrayify)(value.txPointer).slice(8, 16))
        },
        contractID: (0, import_utils3.hexlify)(value.contractId)
      };
    }
    case import_transactions.InputType.Message: {
      const predicate = (0, import_utils3.arrayify)(value.predicate ?? "0x");
      const predicateData = (0, import_utils3.arrayify)(value.predicateData ?? "0x");
      const data = (0, import_utils3.arrayify)(value.data ?? "0x");
      return {
        type: import_transactions.InputType.Message,
        sender: (0, import_utils3.hexlify)(value.sender),
        recipient: (0, import_utils3.hexlify)(value.recipient),
        amount: (0, import_math2.bn)(value.amount),
        nonce: (0, import_utils3.hexlify)(value.nonce),
        witnessIndex: value.witnessIndex,
        predicateGasUsed: (0, import_math2.bn)(value.predicateGasUsed),
        predicateLength: (0, import_math2.bn)(predicate.length),
        predicateDataLength: (0, import_math2.bn)(predicateData.length),
        predicate: (0, import_utils3.hexlify)(predicate),
        predicateData: (0, import_utils3.hexlify)(predicateData),
        data: (0, import_utils3.hexlify)(data),
        dataLength: data.length
      };
    }
    default: {
      throw new import_errors3.FuelError(
        import_errors3.ErrorCode.INVALID_TRANSACTION_INPUT,
        `Invalid transaction input type: ${type}.`
      );
    }
  }
};

// src/providers/transaction-request/output.ts
var import_configs2 = require("@fuel-ts/address/configs");
var import_errors4 = require("@fuel-ts/errors");
var import_math3 = require("@fuel-ts/math");
var import_transactions2 = require("@fuel-ts/transactions");
var import_utils4 = require("@fuel-ts/utils");
var outputify = (value) => {
  const { type } = value;
  switch (type) {
    case import_transactions2.OutputType.Coin: {
      return {
        type: import_transactions2.OutputType.Coin,
        to: (0, import_utils4.hexlify)(value.to),
        amount: (0, import_math3.bn)(value.amount),
        assetId: (0, import_utils4.hexlify)(value.assetId)
      };
    }
    case import_transactions2.OutputType.Contract: {
      return {
        type: import_transactions2.OutputType.Contract,
        inputIndex: value.inputIndex,
        balanceRoot: import_configs2.ZeroBytes32,
        stateRoot: import_configs2.ZeroBytes32
      };
    }
    case import_transactions2.OutputType.Change: {
      return {
        type: import_transactions2.OutputType.Change,
        to: (0, import_utils4.hexlify)(value.to),
        amount: (0, import_math3.bn)(0),
        assetId: (0, import_utils4.hexlify)(value.assetId)
      };
    }
    case import_transactions2.OutputType.Variable: {
      return {
        type: import_transactions2.OutputType.Variable,
        to: import_configs2.ZeroBytes32,
        amount: (0, import_math3.bn)(0),
        assetId: import_configs2.ZeroBytes32
      };
    }
    case import_transactions2.OutputType.ContractCreated: {
      return {
        type: import_transactions2.OutputType.ContractCreated,
        contractId: (0, import_utils4.hexlify)(value.contractId),
        stateRoot: (0, import_utils4.hexlify)(value.stateRoot)
      };
    }
    default: {
      throw new import_errors4.FuelError(
        import_errors4.ErrorCode.INVALID_TRANSACTION_INPUT,
        `Invalid transaction output type: ${type}.`
      );
    }
  }
};

// src/providers/transaction-request/transaction-request.ts
var import_abi_coder2 = require("@fuel-ts/abi-coder");
var import_address = require("@fuel-ts/address");
var import_configs6 = require("@fuel-ts/address/configs");
var import_crypto = require("@fuel-ts/crypto");
var import_errors9 = require("@fuel-ts/errors");
var import_math8 = require("@fuel-ts/math");
var import_transactions7 = require("@fuel-ts/transactions");
var import_utils9 = require("@fuel-ts/utils");

// src/providers/message.ts
var isMessageCoin = (message) => !("data" in message);

// src/providers/resource.ts
var isRawCoin = (resource) => "utxoId" in resource;
var isRawMessage = (resource) => "recipient" in resource;
var isCoin = (resource) => "id" in resource;
var isMessage = (resource) => "recipient" in resource;

// src/providers/utils/receipts.ts
var import_configs3 = require("@fuel-ts/address/configs");
var import_errors5 = require("@fuel-ts/errors");
var import_math4 = require("@fuel-ts/math");
var import_transactions3 = require("@fuel-ts/transactions");
var import_configs4 = require("@fuel-ts/transactions/configs");
var import_utils5 = require("@fuel-ts/utils");
var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === import_transactions3.ReceiptType.Revert && receipt.val.toString("hex") === import_configs4.FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
var doesReceiptHaveMissingContractId = (receipt) => receipt.type === import_transactions3.ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
var getReceiptsWithMissingData = (receipts) => receipts.reduce(
  (memo, receipt) => {
    if (doesReceiptHaveMissingOutputVariables(receipt)) {
      memo.missingOutputVariables.push(receipt);
    }
    if (doesReceiptHaveMissingContractId(receipt)) {
      memo.missingOutputContractIds.push(receipt);
    }
    return memo;
  },
  {
    missingOutputVariables: [],
    missingOutputContractIds: []
  }
);
var hexOrZero = (hex) => hex || import_configs3.ZeroBytes32;
function assembleReceiptByType(receipt) {
  const { receiptType } = receipt;
  switch (receiptType) {
    case "CALL" /* Call */: {
      const id = hexOrZero(receipt.id || receipt.contractId);
      const callReceipt = {
        type: import_transactions3.ReceiptType.Call,
        id,
        to: hexOrZero(receipt?.to),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        gas: (0, import_math4.bn)(receipt.gas),
        param1: (0, import_math4.bn)(receipt.param1),
        param2: (0, import_math4.bn)(receipt.param2),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return callReceipt;
    }
    case "RETURN" /* Return */: {
      const returnReceipt = {
        type: import_transactions3.ReceiptType.Return,
        id: hexOrZero(receipt.id || receipt.contractId),
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return returnReceipt;
    }
    case "RETURN_DATA" /* ReturnData */: {
      const returnDataReceipt = {
        type: import_transactions3.ReceiptType.ReturnData,
        id: hexOrZero(receipt.id || receipt.contractId),
        ptr: (0, import_math4.bn)(receipt.ptr),
        len: (0, import_math4.bn)(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: (0, import_math4.bn)(receipt.pc),
        data: hexOrZero(receipt.data),
        is: (0, import_math4.bn)(receipt.is)
      };
      return returnDataReceipt;
    }
    case "PANIC" /* Panic */: {
      const panicReceipt = {
        type: import_transactions3.ReceiptType.Panic,
        id: hexOrZero(receipt.id),
        reason: (0, import_math4.bn)(receipt.reason),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is),
        contractId: hexOrZero(receipt.contractId)
      };
      return panicReceipt;
    }
    case "REVERT" /* Revert */: {
      const revertReceipt = {
        type: import_transactions3.ReceiptType.Revert,
        id: hexOrZero(receipt.id || receipt.contractId),
        val: (0, import_math4.bn)(receipt.ra),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return revertReceipt;
    }
    case "LOG" /* Log */: {
      const ra = (0, import_math4.bn)(receipt.ra);
      const rb = (0, import_math4.bn)(receipt.rb);
      const rc = (0, import_math4.bn)(receipt.rc);
      const rd = (0, import_math4.bn)(receipt.rd);
      const logReceipt = {
        type: import_transactions3.ReceiptType.Log,
        id: hexOrZero(receipt.id || receipt.contractId),
        ra,
        rb,
        rc,
        rd,
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return logReceipt;
    }
    case "LOG_DATA" /* LogData */: {
      const ra = (0, import_math4.bn)(receipt.ra);
      const rb = (0, import_math4.bn)(receipt.rb);
      const logDataReceipt = {
        type: import_transactions3.ReceiptType.LogData,
        id: hexOrZero(receipt.id || receipt.contractId),
        ra,
        rb,
        ptr: (0, import_math4.bn)(receipt.ptr),
        len: (0, import_math4.bn)(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: (0, import_math4.bn)(receipt.pc),
        data: hexOrZero(receipt.data),
        is: (0, import_math4.bn)(receipt.is)
      };
      return logDataReceipt;
    }
    case "TRANSFER" /* Transfer */: {
      const id = hexOrZero(receipt.id || receipt.contractId);
      const transferReceipt = {
        type: import_transactions3.ReceiptType.Transfer,
        id,
        to: hexOrZero(receipt.toAddress || receipt?.to),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return transferReceipt;
    }
    case "TRANSFER_OUT" /* TransferOut */: {
      const id = hexOrZero(receipt.id || receipt.contractId);
      const transferOutReceipt = {
        type: import_transactions3.ReceiptType.TransferOut,
        id,
        to: hexOrZero(receipt.toAddress || receipt.to),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return transferOutReceipt;
    }
    case "SCRIPT_RESULT" /* ScriptResult */: {
      const scriptResultReceipt = {
        type: import_transactions3.ReceiptType.ScriptResult,
        result: (0, import_math4.bn)(receipt.result),
        gasUsed: (0, import_math4.bn)(receipt.gasUsed)
      };
      return scriptResultReceipt;
    }
    case "MESSAGE_OUT" /* MessageOut */: {
      const sender = hexOrZero(receipt.sender);
      const recipient = hexOrZero(receipt.recipient);
      const nonce = hexOrZero(receipt.nonce);
      const amount = (0, import_math4.bn)(receipt.amount);
      const data = receipt.data ? (0, import_utils5.arrayify)(receipt.data) : Uint8Array.from([]);
      const digest = hexOrZero(receipt.digest);
      const len = (0, import_math4.bn)(receipt.len).toNumber();
      const messageId = import_transactions3.InputMessageCoder.getMessageId({
        sender,
        recipient,
        nonce,
        amount,
        data: (0, import_utils5.hexlify)(data)
      });
      const receiptMessageOut = {
        type: import_transactions3.ReceiptType.MessageOut,
        sender,
        recipient,
        amount,
        nonce,
        len,
        data,
        digest,
        messageId
      };
      return receiptMessageOut;
    }
    case "MINT" /* Mint */: {
      const contractId = hexOrZero(receipt.id || receipt.contractId);
      const subId = hexOrZero(receipt.subId);
      const assetId = (0, import_transactions3.getMintedAssetId)(contractId, subId);
      const mintReceipt = {
        type: import_transactions3.ReceiptType.Mint,
        subId,
        contractId,
        assetId,
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return mintReceipt;
    }
    case "BURN" /* Burn */: {
      const contractId = hexOrZero(receipt.id || receipt.contractId);
      const subId = hexOrZero(receipt.subId);
      const assetId = (0, import_transactions3.getMintedAssetId)(contractId, subId);
      const burnReceipt = {
        type: import_transactions3.ReceiptType.Burn,
        subId,
        contractId,
        assetId,
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return burnReceipt;
    }
    default:
      throw new import_errors5.FuelError(import_errors5.ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
  }
}

// src/providers/utils/block-explorer.ts
var import_errors6 = require("@fuel-ts/errors");
var DEFAULT_BLOCK_EXPLORER_URL = "https://app.fuel.network";
var getPathFromInput = (key, value) => {
  const pathMap = {
    address: `address`,
    txId: `transaction`,
    blockNumber: `block`
  };
  const path = pathMap[key] || key;
  return `${path}/${value}`;
};
var buildBlockExplorerUrl = (options = {}) => {
  const { blockExplorerUrl, path, providerUrl, address, txId, blockNumber } = options;
  const explorerUrl = blockExplorerUrl || DEFAULT_BLOCK_EXPLORER_URL;
  const customInputParams = [
    {
      key: "address",
      value: address
    },
    {
      key: "txId",
      value: txId
    },
    {
      key: "blockNumber",
      value: blockNumber
    }
  ];
  const definedValues = customInputParams.filter((param) => !!param.value).map(({ key, value }) => ({
    key,
    value
  }));
  const hasAnyDefinedValues = definedValues.length > 0;
  if (definedValues.length > 1) {
    throw new import_errors6.FuelError(
      import_errors6.ErrorCode.ERROR_BUILDING_BLOCK_EXPLORER_URL,
      `Only one of the following can be passed in to buildBlockExplorerUrl: ${customInputParams.map((param) => param.key).join(", ")}.`
    );
  }
  if (path && definedValues.length > 0) {
    const inputKeys = customInputParams.map(({ key }) => key).join(", ");
    throw new import_errors6.FuelError(
      import_errors6.ErrorCode.ERROR_BUILDING_BLOCK_EXPLORER_URL,
      `You cannot pass in a path to 'buildBlockExplorerUrl' along with any of the following: ${inputKeys}.`
    );
  }
  const pathGeneratedFromInputParams = hasAnyDefinedValues ? getPathFromInput(
    definedValues[0].key,
    definedValues[0].value
  ) : "";
  const trimSlashes = /^\/|\/$/gm;
  const cleanPath = path ? path.replace(trimSlashes, "") : pathGeneratedFromInputParams;
  const cleanBlockExplorerUrl = explorerUrl.replace(trimSlashes, "");
  const cleanProviderUrl = providerUrl?.replace(trimSlashes, "");
  const encodedProviderUrl = cleanProviderUrl ? encodeURIComponent(cleanProviderUrl) : void 0;
  const protocol = cleanBlockExplorerUrl.match(/^https?:\/\//) ? "" : "https://";
  const providerUrlProtocol = cleanProviderUrl?.match(/^https?:\/\//) ? "" : "https://";
  const url = `${protocol}${cleanBlockExplorerUrl}/${cleanPath}${encodedProviderUrl ? `?providerUrl=${providerUrlProtocol}${encodedProviderUrl}` : ""}`;
  return url;
};

// src/providers/utils/gas.ts
var import_math5 = require("@fuel-ts/math");
var import_transactions4 = require("@fuel-ts/transactions");
var import_utils6 = require("@fuel-ts/utils");
var getGasUsedFromReceipts = (receipts) => {
  const scriptResult = receipts.filter(
    (receipt) => receipt.type === import_transactions4.ReceiptType.ScriptResult
  );
  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), (0, import_math5.bn)(0));
  return gasUsed;
};
function resolveGasDependentCosts(byteSize, gasDependentCost) {
  const base = (0, import_math5.bn)(gasDependentCost.base);
  let dependentValue = (0, import_math5.bn)(0);
  if ("unitsPerGas" in gasDependentCost) {
    dependentValue = (0, import_math5.bn)(byteSize).div((0, import_math5.bn)(gasDependentCost.unitsPerGas));
  } else {
    dependentValue = (0, import_math5.bn)(byteSize).mul((0, import_math5.bn)(gasDependentCost.gasPerUnit));
  }
  return base.add(dependentValue);
}
function gasUsedByInputs(inputs, txBytesSize, gasCosts) {
  const witnessCache = [];
  const chargeableInputs = inputs.filter((input) => {
    const isCoinOrMessage = "owner" in input || "sender" in input;
    if (isCoinOrMessage) {
      if ("predicate" in input && input.predicate && input.predicate !== "0x") {
        return true;
      }
      if (!witnessCache.includes(input.witnessIndex)) {
        witnessCache.push(input.witnessIndex);
        return true;
      }
    }
    return false;
  });
  const vmInitializationCost = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const totalGas = chargeableInputs.reduce((total, input) => {
    if ("predicate" in input && input.predicate && input.predicate !== "0x") {
      return total.add(
        vmInitializationCost.add(resolveGasDependentCosts((0, import_utils6.arrayify)(input.predicate).length, gasCosts.contractRoot)).add((0, import_math5.bn)(input.predicateGasUsed))
      );
    }
    return total.add(gasCosts.ecr1);
  }, (0, import_math5.bn)(0));
  return totalGas;
}
function getMinGas(params) {
  const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
  const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const bytesGas = (0, import_math5.bn)(txBytesSize).mul(gasPerByte);
  const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);
  const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
  return minGas;
}
function getMaxGas(params) {
  const {
    gasPerByte,
    witnessesLength,
    witnessLimit,
    minGas,
    gasLimit = (0, import_math5.bn)(0),
    maxGasPerTx
  } = params;
  let remainingAllowedWitnessGas = (0, import_math5.bn)(0);
  if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
    remainingAllowedWitnessGas = (0, import_math5.bn)(witnessLimit).sub(witnessesLength).mul(gasPerByte);
  }
  const maxGas = remainingAllowedWitnessGas.add(minGas).add(gasLimit);
  return maxGas.gte(maxGasPerTx) ? maxGasPerTx : maxGas;
}
function calculateMetadataGasForTxCreate({
  gasCosts,
  stateRootSize,
  txBytesSize,
  contractBytesSize
}) {
  const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);
  const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);
  const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const contractIdInputSize = (0, import_math5.bn)(4 + 32 + 32 + 32);
  const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);
  const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
  return metadataGas.maxU64();
}
function calculateMetadataGasForTxScript({
  gasCosts,
  txBytesSize
}) {
  return resolveGasDependentCosts(txBytesSize, gasCosts.s256);
}
function calculateMetadataGasForTxBlob({
  gasCosts,
  txBytesSize,
  witnessBytesSize
}) {
  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const blobLen = resolveGasDependentCosts(witnessBytesSize, gasCosts.s256);
  return txId.add(blobLen);
}
function calculateMetadataGasForTxUpgrade({
  gasCosts,
  txBytesSize,
  consensusSize
}) {
  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  if (consensusSize) {
    const consensusLen = resolveGasDependentCosts(consensusSize, gasCosts.s256);
    txId.add(consensusLen);
  }
  return txId;
}
function calculateMetadataGasForTxUpload({
  gasCosts,
  txBytesSize,
  subsectionSize,
  subsectionsSize
}) {
  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const subsectionLen = resolveGasDependentCosts(subsectionSize, gasCosts.s256);
  txId.add(subsectionLen);
  const subsectionsLen = resolveGasDependentCosts(subsectionsSize, gasCosts.stateRoot);
  txId.add(subsectionsLen);
  return txId;
}
function calculateMinGasForTxUpload({
  gasCosts,
  baseMinGas,
  subsectionSize
}) {
  const additionalStoragePerByte = (0, import_math5.bn)(gasCosts.newStoragePerByte).mul(subsectionSize);
  return (0, import_math5.bn)(baseMinGas).add(additionalStoragePerByte);
}
var calculateGasFee = (params) => {
  const { gas, gasPrice, priceFactor, tip } = params;
  return gas.mul(gasPrice).div(priceFactor).add((0, import_math5.bn)(tip));
};

// src/providers/utils/json.ts
var import_utils7 = require("@fuel-ts/utils");
var import_ramda = require("ramda");
function normalize(object) {
  Object.keys(object).forEach((key) => {
    switch (object[key]?.constructor.name) {
      case "Uint8Array":
        object[key] = (0, import_utils7.hexlify)(object[key]);
        break;
      case "Array":
        object[key] = normalize(object[key]);
        break;
      case "BN":
        object[key] = object[key].toHex();
        break;
      case "Address":
        object[key] = object[key].toB256();
        break;
      case "Object":
        object[key] = normalize(object[key]);
        break;
      default:
        break;
    }
  });
  return object;
}
function normalizeJSON(root) {
  return normalize((0, import_ramda.clone)(root));
}

// src/providers/utils/extract-tx-error.ts
var import_errors7 = require("@fuel-ts/errors");
var import_math6 = require("@fuel-ts/math");
var import_transactions5 = require("@fuel-ts/transactions");
var import_configs5 = require("@fuel-ts/transactions/configs");
var assemblePanicError = (statusReason, metadata) => {
  let errorMessage = `The transaction reverted with reason: "${statusReason}".`;
  if (import_configs5.PANIC_REASONS.includes(statusReason)) {
    errorMessage = `${errorMessage}

You can read more about this error at:

${import_configs5.PANIC_DOC_URL}#variant.${statusReason}`;
  }
  return new import_errors7.FuelError(import_errors7.ErrorCode.SCRIPT_REVERTED, errorMessage, {
    ...metadata,
    reason: statusReason
  });
};
var stringify = (obj) => JSON.stringify(obj, null, 2);
var assembleRevertError = (receipts, logs, metadata) => {
  let errorMessage = "The transaction reverted with an unknown reason.";
  const revertReceipt = receipts.find(({ type }) => type === import_transactions5.ReceiptType.Revert);
  let reason = "";
  if (revertReceipt) {
    const reasonHex = (0, import_math6.bn)(revertReceipt.val).toHex();
    const lastLog = logs[logs.length - 1];
    const lastButOneLog = logs[logs.length - 2];
    switch (reasonHex) {
      case import_configs5.FAILED_REQUIRE_SIGNAL: {
        reason = "require";
        errorMessage = `The transaction reverted because a "require" statement has thrown ${logs.length ? stringify(lastLog) : "an error."}.`;
        break;
      }
      case import_configs5.FAILED_ASSERT_EQ_SIGNAL: {
        const sufix = logs.length >= 2 ? ` comparing ${stringify(lastLog)} and ${stringify(lastButOneLog)}.` : ".";
        reason = "assert_eq";
        errorMessage = `The transaction reverted because of an "assert_eq" statement${sufix}`;
        break;
      }
      case import_configs5.FAILED_ASSERT_NE_SIGNAL: {
        const sufix = logs.length >= 2 ? ` comparing ${stringify(lastButOneLog)} and ${stringify(lastLog)}.` : ".";
        reason = "assert_ne";
        errorMessage = `The transaction reverted because of an "assert_ne" statement${sufix}`;
        break;
      }
      case import_configs5.FAILED_ASSERT_SIGNAL:
        reason = "assert";
        errorMessage = `The transaction reverted because an "assert" statement failed to evaluate to true.`;
        break;
      case import_configs5.FAILED_TRANSFER_TO_ADDRESS_SIGNAL:
        reason = "MissingOutputChange";
        errorMessage = `The transaction reverted because it's missing an "OutputChange".`;
        break;
      default:
        throw new import_errors7.FuelError(
          import_errors7.ErrorCode.UNKNOWN,
          `The transaction reverted with an unknown reason: ${revertReceipt.val}`,
          {
            ...metadata,
            reason: "unknown"
          }
        );
    }
  }
  return new import_errors7.FuelError(import_errors7.ErrorCode.SCRIPT_REVERTED, errorMessage, {
    ...metadata,
    reason
  });
};
var extractTxError = (params) => {
  const { receipts, statusReason, logs } = params;
  const isPanic = receipts.some(({ type }) => type === import_transactions5.ReceiptType.Panic);
  const isRevert = receipts.some(({ type }) => type === import_transactions5.ReceiptType.Revert);
  const metadata = {
    logs,
    receipts,
    panic: isPanic,
    revert: isRevert,
    reason: ""
  };
  if (isPanic) {
    return assemblePanicError(statusReason, metadata);
  }
  return assembleRevertError(receipts, logs, metadata);
};

// src/providers/transaction-request/errors.ts
var ChangeOutputCollisionError = class extends Error {
  name = "ChangeOutputCollisionError";
  message = 'A ChangeOutput with the same "assetId" already exists for a different "to" address';
};
var NoWitnessAtIndexError = class extends Error {
  constructor(index) {
    super();
    this.index = index;
    this.message = `Witness at index "${index}" was not found`;
  }
  name = "NoWitnessAtIndexError";
};
var NoWitnessByOwnerError = class extends Error {
  constructor(owner) {
    super();
    this.owner = owner;
    this.message = `A witness for the given owner "${owner}" was not found`;
  }
  name = "NoWitnessByOwnerError";
};

// src/providers/transaction-request/helpers.ts
var import_errors8 = require("@fuel-ts/errors");
var import_math7 = require("@fuel-ts/math");
var import_transactions6 = require("@fuel-ts/transactions");
var isRequestInputCoin = (input) => input.type === import_transactions6.InputType.Coin;
var isRequestInputMessage = (input) => input.type === import_transactions6.InputType.Message;
var isRequestInputMessageWithoutData = (input) => input.type === import_transactions6.InputType.Message && (0, import_math7.bn)(input.data).isZero();
var isRequestInputCoinOrMessage = (input) => isRequestInputCoin(input) || isRequestInputMessage(input);
var isRequestInputResource = (input) => isRequestInputCoin(input) || isRequestInputMessageWithoutData(input);
var getRequestInputResourceOwner = (input) => isRequestInputCoin(input) ? input.owner : input.recipient;
var isRequestInputResourceFromOwner = (input, owner) => getRequestInputResourceOwner(input) === owner.toB256();
var getAssetAmountInRequestInputs = (inputs, assetId, baseAsset) => inputs.filter(isRequestInputResource).reduce((acc, input) => {
  if (isRequestInputCoin(input) && input.assetId === assetId) {
    return acc.add(input.amount);
  }
  if (isRequestInputMessage(input) && assetId === baseAsset) {
    return acc.add(input.amount);
  }
  return acc;
}, (0, import_math7.bn)(0));
var cacheRequestInputsResources = (inputs) => inputs.filter(isRequestInputResource).reduce(
  (cache2, input) => {
    if (isRequestInputCoin(input)) {
      cache2.utxos.push(input.id);
    } else {
      cache2.messages.push(input.nonce);
    }
    return cache2;
  },
  {
    utxos: [],
    messages: []
  }
);
var cacheRequestInputsResourcesFromOwner = (inputs, owner) => inputs.reduce(
  (acc, input) => {
    if (isRequestInputCoin(input) && input.owner === owner.toB256()) {
      acc.utxos.push(input.id);
    } else if (isRequestInputMessage(input) && input.recipient === owner.toB256()) {
      acc.messages.push(input.nonce);
    }
    return acc;
  },
  {
    utxos: [],
    messages: []
  }
);
var getBurnableAssetCount = (baseAssetId, transactionRequest) => {
  const { inputs, outputs } = transactionRequest;
  const coinInputs = new Set(inputs.filter(isRequestInputCoin).map((input) => input.assetId));
  if (inputs.some((i) => isRequestInputMessage(i) && (0, import_math7.bn)(i.amount).gt(0))) {
    coinInputs.add(baseAssetId);
  }
  const changeOutputs = new Set(
    outputs.filter((output) => output.type === import_transactions6.OutputType.Change).map((output) => output.assetId)
  );
  const difference = new Set([...coinInputs].filter((x) => !changeOutputs.has(x)));
  return difference.size;
};
var validateTransactionForAssetBurn = (baseAssetId, transactionRequest, enableAssetBurn = false) => {
  if (enableAssetBurn === true) {
    return;
  }
  if (getBurnableAssetCount(baseAssetId, transactionRequest) <= 0) {
    return;
  }
  const message = [
    "Asset burn detected.",
    "Add the relevant change outputs to the transaction to avoid burning assets.",
    "Or enable asset burn, upon sending the transaction."
  ].join("\n");
  throw new import_errors8.FuelError(import_errors8.ErrorCode.ASSET_BURN_DETECTED, message);
};

// src/providers/transaction-request/witness.ts
var import_utils8 = require("@fuel-ts/utils");
var witnessify = (value) => {
  const data = (0, import_utils8.arrayify)(value);
  return {
    data: (0, import_utils8.hexlify)(data),
    dataLength: data.length
  };
};

// src/providers/transaction-request/transaction-request.ts
var BaseTransactionRequest = class {
  /** Gas price for transaction */
  tip;
  /** Block until which tx cannot be included */
  maturity;
  /** The maximum fee payable by this transaction using BASE_ASSET. */
  maxFee;
  /** The maximum amount of witness data allowed for the transaction */
  witnessLimit;
  /** List of inputs */
  inputs = [];
  /** List of outputs */
  outputs = [];
  /** List of witnesses */
  witnesses = [];
  /**
   * Constructor for initializing a base transaction request.
   *
   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
   */
  constructor({
    tip,
    maturity,
    maxFee,
    witnessLimit,
    inputs,
    outputs,
    witnesses
  } = {}) {
    this.tip = tip ? (0, import_math8.bn)(tip) : void 0;
    this.maturity = maturity && maturity > 0 ? maturity : void 0;
    this.witnessLimit = (0, import_utils9.isDefined)(witnessLimit) ? (0, import_math8.bn)(witnessLimit) : void 0;
    this.maxFee = (0, import_math8.bn)(maxFee);
    this.inputs = inputs ?? [];
    this.outputs = outputs ?? [];
    this.witnesses = witnesses ?? [];
  }
  static getPolicyMeta(req) {
    let policyTypes = 0;
    const policies = [];
    const { tip, witnessLimit, maturity } = req;
    if ((0, import_math8.bn)(tip).gt(0)) {
      policyTypes += import_transactions7.PolicyType.Tip;
      policies.push({ data: (0, import_math8.bn)(tip), type: import_transactions7.PolicyType.Tip });
    }
    if ((0, import_utils9.isDefined)(witnessLimit) && (0, import_math8.bn)(witnessLimit).gte(0)) {
      policyTypes += import_transactions7.PolicyType.WitnessLimit;
      policies.push({ data: (0, import_math8.bn)(witnessLimit), type: import_transactions7.PolicyType.WitnessLimit });
    }
    if (maturity && maturity > 0) {
      policyTypes += import_transactions7.PolicyType.Maturity;
      policies.push({ data: maturity, type: import_transactions7.PolicyType.Maturity });
    }
    policyTypes += import_transactions7.PolicyType.MaxFee;
    policies.push({ data: req.maxFee, type: import_transactions7.PolicyType.MaxFee });
    return {
      policyTypes,
      policies
    };
  }
  /**
   * Method to obtain the base transaction details.
   *
   * @returns The base transaction details.
   */
  getBaseTransaction() {
    const inputs = this.inputs?.map(inputify) ?? [];
    const outputs = this.outputs?.map(outputify) ?? [];
    const witnesses = this.witnesses?.map(witnessify) ?? [];
    const { policyTypes, policies } = BaseTransactionRequest.getPolicyMeta(this);
    return {
      policyTypes,
      inputs,
      outputs,
      policies,
      witnesses,
      inputsCount: inputs.length,
      outputsCount: outputs.length,
      witnessesCount: witnesses.length
    };
  }
  /**
   * Converts the transaction request to a byte array.
   *
   * @returns The transaction bytes.
   */
  toTransactionBytes() {
    return new import_transactions7.TransactionCoder().encode(this.toTransaction());
  }
  /**
   * @hidden
   *
   * Pushes an input to the list without any side effects and returns the index
   */
  pushInput(input) {
    this.inputs.push(input);
    return this.inputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes an output to the list without any side effects and returns the index
   */
  pushOutput(output) {
    this.outputs.push(output);
    return this.outputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes a witness to the list and returns the index
   *
   * @param signature - The signature to add to the witness.
   * @returns The index of the created witness.
   */
  addWitness(signature) {
    this.witnesses.push(signature);
    return this.witnesses.length - 1;
  }
  /**
   * @hidden
   *
   * Creates an empty witness without any side effects and returns the index
   *
   * @returns The index of the created witness.
   */
  addEmptyWitness() {
    this.addWitness((0, import_utils9.concat)([import_configs6.ZeroBytes32, import_configs6.ZeroBytes32]));
    return this.witnesses.length - 1;
  }
  /**
   * Updates the witness for a given owner and signature.
   *
   * @param address - The address to get the coin input witness index for.
   * @param signature - The signature to update the witness with.
   */
  updateWitnessByOwner(address, signature) {
    const ownerAddress = import_address.Address.fromAddressOrString(address);
    const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
    if (typeof witnessIndex === "number") {
      this.updateWitness(witnessIndex, signature);
    }
  }
  /**
   * Updates an existing witness without any side effects.
   *
   * @param index - The index of the witness to update.
   * @param witness - The new witness.
   * @throws If the witness does not exist.
   */
  updateWitness(index, witness) {
    if (!this.witnesses[index]) {
      throw new NoWitnessAtIndexError(index);
    }
    this.witnesses[index] = witness;
  }
  /**
   * Helper function to add an external signature to the transaction.
   *
   * @param account - The account/s to sign to the transaction.
   * @returns The transaction with the signature witness added.
   */
  async addAccountWitnesses(account) {
    const accounts = Array.isArray(account) ? account : [account];
    await Promise.all(
      accounts.map(async (acc) => {
        this.addWitness(await acc.signTransaction(this));
      })
    );
    return this;
  }
  /**
   * Gets the coin inputs for a transaction.
   *
   * @returns The coin inputs.
   */
  getCoinInputs() {
    return this.inputs.filter(
      (input) => input.type === import_transactions7.InputType.Coin
    );
  }
  /**
   * Gets the coin outputs for a transaction.
   *
   * @returns The coin outputs.
   */
  getCoinOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions7.OutputType.Coin
    );
  }
  /**
   * Gets the change outputs for a transaction.
   *
   * @returns The change outputs.
   */
  getChangeOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions7.OutputType.Change
    );
  }
  /**
   * @hidden
   *
   * Returns the witnessIndex of the found CoinInput.
   */
  getCoinInputWitnessIndexByOwner(owner) {
    const ownerAddress = (0, import_address.addressify)(owner);
    const found = this.inputs.find((input) => {
      switch (input.type) {
        case import_transactions7.InputType.Coin:
          return (0, import_utils9.hexlify)(input.owner) === ownerAddress.toB256();
        case import_transactions7.InputType.Message:
          return (0, import_utils9.hexlify)(input.recipient) === ownerAddress.toB256();
        default:
          return false;
      }
    });
    return found?.witnessIndex;
  }
  /**
   * Adds a single coin input to the transaction and a change output for the related
   * assetId, if one it was not added yet.
   *
   * @param coin - Coin resource.
   */
  addCoinInput(coin) {
    const { assetId, owner, amount, id, predicate, predicateData } = coin;
    let witnessIndex;
    if (coin.predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.addEmptyWitness();
      }
    }
    const input = {
      id,
      type: import_transactions7.InputType.Coin,
      owner: owner.toB256(),
      amount,
      assetId,
      txPointer: "0x00000000000000000000000000000000",
      witnessIndex,
      predicate,
      predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(owner, assetId);
  }
  /**
   * Adds a single message input to the transaction and a change output for the
   * asset against the message
   *
   * @param message - Message resource.
   */
  addMessageInput(message) {
    const { recipient, sender, amount, predicate, nonce, predicateData } = message;
    let witnessIndex;
    if (message.predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.addEmptyWitness();
      }
    }
    const input = {
      nonce,
      type: import_transactions7.InputType.Message,
      sender: sender.toB256(),
      recipient: recipient.toB256(),
      data: isMessageCoin(message) ? "0x" : message.data,
      amount,
      witnessIndex,
      predicate,
      predicateData
    };
    this.pushInput(input);
    if (isMessageCoin(message)) {
      this.addChangeOutput(recipient, message.assetId);
    }
  }
  /**
   * Adds a single resource to the transaction by adding a coin/message input and a
   * change output for the related assetId, if one it was not added yet.
   *
   * @param resource - The resource to add.
   * @returns This transaction.
   */
  addResource(resource) {
    if (isCoin(resource)) {
      this.addCoinInput(resource);
    } else {
      this.addMessageInput(resource);
    }
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addResources(resources) {
    resources.forEach((resource) => this.addResource(resource));
    return this;
  }
  /**
   * Adds a coin output to the transaction.
   *
   * @param to - Address of the owner.
   * @param amount - Amount of coin.
   * @param assetId - Asset ID of coin.
   */
  addCoinOutput(to, amount, assetId) {
    this.pushOutput({
      type: import_transactions7.OutputType.Coin,
      to: (0, import_address.addressify)(to).toB256(),
      amount,
      assetId
    });
    return this;
  }
  /**
   * Adds multiple coin outputs to the transaction.
   *
   * @param to - Address of the destination.
   * @param quantities - Quantities of coins.
   */
  addCoinOutputs(to, quantities) {
    quantities.map(coinQuantityfy).forEach((quantity) => {
      this.pushOutput({
        type: import_transactions7.OutputType.Coin,
        to: (0, import_address.addressify)(to).toB256(),
        amount: quantity.amount,
        assetId: quantity.assetId
      });
    });
    return this;
  }
  /**
   * Adds a change output to the transaction.
   *
   * @param to - Address of the owner.
   * @param assetId - Asset ID of coin.
   */
  addChangeOutput(to, assetId) {
    const changeOutput = this.getChangeOutputs().find(
      (output) => (0, import_utils9.hexlify)(output.assetId) === assetId
    );
    if (!changeOutput) {
      this.pushOutput({
        type: import_transactions7.OutputType.Change,
        to: (0, import_address.addressify)(to).toB256(),
        assetId
      });
    }
  }
  /**
   * @hidden
   */
  byteSize() {
    return this.toTransactionBytes().length;
  }
  /**
   * @hidden
   */
  metadataGas(_gasCosts) {
    throw new import_errors9.FuelError(import_errors9.FuelError.CODES.NOT_IMPLEMENTED, "Not implemented");
  }
  /**
   * @hidden
   */
  calculateMinGas(chainInfo) {
    const { consensusParameters } = chainInfo;
    const {
      gasCosts,
      feeParameters: { gasPerByte }
    } = consensusParameters;
    return getMinGas({
      gasPerByte,
      gasCosts,
      inputs: this.inputs,
      txBytesSize: this.byteSize(),
      metadataGas: this.metadataGas(gasCosts)
    });
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const {
      feeParameters: { gasPerByte },
      txParameters: { maxGasPerTx }
    } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      maxGasPerTx
    });
  }
  /**
   * Funds the transaction with fake UTXOs for each assetId and amount in the
   * quantities array.
   *
   * @param quantities - CoinQuantity Array.
   * @param baseAssetId - The base asset to fund the transaction.
   * @deprecated - This method is deprecated and will be removed in future versions.
   * Please use `Account.generateFakeResources` along with `this.addResources` instead.
   */
  fundWithFakeUtxos(quantities, baseAssetId, resourcesOwner) {
    const findAssetInput = (assetId) => this.inputs.find((input) => {
      if ("assetId" in input) {
        return input.assetId === assetId;
      }
      return false;
    });
    const updateAssetInput = (assetId, quantity) => {
      const assetInput = findAssetInput(assetId);
      let usedQuantity = quantity;
      if (assetId === baseAssetId) {
        usedQuantity = (0, import_math8.bn)("1000000000000000000");
      }
      if (assetInput && "assetId" in assetInput) {
        assetInput.id = (0, import_utils9.hexlify)((0, import_crypto.randomBytes)(import_abi_coder2.UTXO_ID_LEN));
        assetInput.amount = usedQuantity;
      } else {
        this.addResources([
          {
            id: (0, import_utils9.hexlify)((0, import_crypto.randomBytes)(import_abi_coder2.UTXO_ID_LEN)),
            amount: usedQuantity,
            assetId,
            owner: resourcesOwner || import_address.Address.fromRandom(),
            blockCreated: (0, import_math8.bn)(1),
            txCreatedIdx: (0, import_math8.bn)(1)
          }
        ]);
      }
    };
    updateAssetInput(baseAssetId, (0, import_math8.bn)(1e11));
    quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
    return this;
  }
  /**
   * Retrieves an array of CoinQuantity for each coin output present in the transaction.
   * a transaction.
   *
   * @returns  CoinQuantity array.
   */
  getCoinOutputsQuantities() {
    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
      amount: (0, import_math8.bn)(amount),
      assetId: assetId.toString()
    }));
    return coinsQuantities;
  }
  /**
   * Return the minimum amount in native coins required to create
   * a transaction.
   *
   * @returns The transaction as a JSON object.
   */
  toJSON() {
    return normalizeJSON(this);
  }
  removeWitness(index) {
    this.witnesses.splice(index, 1);
    this.adjustWitnessIndexes(index);
  }
  adjustWitnessIndexes(removedIndex) {
    this.inputs.filter(isRequestInputResource).forEach((input) => {
      if (input.witnessIndex > removedIndex) {
        input.witnessIndex -= 1;
      }
    });
  }
  updatePredicateGasUsed(inputs) {
    const inputsToExtractGasUsed = inputs.filter(isRequestInputCoinOrMessage);
    this.inputs.filter(isRequestInputResource).forEach((i) => {
      const owner = getRequestInputResourceOwner(i);
      const correspondingInput = inputsToExtractGasUsed.find(
        (x) => isRequestInputResourceFromOwner(x, import_address.Address.fromString(String(owner)))
      );
      if (correspondingInput && "predicateGasUsed" in correspondingInput && (0, import_math8.bn)(correspondingInput.predicateGasUsed).gt(0)) {
        i.predicateGasUsed = correspondingInput.predicateGasUsed;
      }
    });
  }
  byteLength() {
    return this.toTransactionBytes().byteLength;
  }
};

// src/providers/transaction-request/blob-transaction-request.ts
var import_ramda3 = require("ramda");

// src/providers/transaction-request/hash-transaction.ts
var import_configs7 = require("@fuel-ts/address/configs");
var import_hasher = require("@fuel-ts/hasher");
var import_math9 = require("@fuel-ts/math");
var import_transactions8 = require("@fuel-ts/transactions");
var import_utils11 = require("@fuel-ts/utils");
var import_ramda2 = require("ramda");
function hashTransaction(transactionRequest, chainId) {
  const transaction = transactionRequest.toTransaction();
  if (transaction.type === import_transactions8.TransactionType.Script) {
    transaction.receiptsRoot = import_configs7.ZeroBytes32;
  }
  transaction.inputs = transaction.inputs.map((input) => {
    const inputClone = (0, import_ramda2.clone)(input);
    switch (inputClone.type) {
      case import_transactions8.InputType.Coin: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.predicateGasUsed = (0, import_math9.bn)(0);
        return inputClone;
      }
      case import_transactions8.InputType.Message: {
        inputClone.predicateGasUsed = (0, import_math9.bn)(0);
        return inputClone;
      }
      case import_transactions8.InputType.Contract: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.txID = import_configs7.ZeroBytes32;
        inputClone.outputIndex = 0;
        inputClone.balanceRoot = import_configs7.ZeroBytes32;
        inputClone.stateRoot = import_configs7.ZeroBytes32;
        return inputClone;
      }
      default:
        return inputClone;
    }
  });
  transaction.outputs = transaction.outputs.map((output) => {
    const outputClone = (0, import_ramda2.clone)(output);
    switch (outputClone.type) {
      case import_transactions8.OutputType.Contract: {
        outputClone.balanceRoot = import_configs7.ZeroBytes32;
        outputClone.stateRoot = import_configs7.ZeroBytes32;
        return outputClone;
      }
      case import_transactions8.OutputType.Change: {
        outputClone.amount = (0, import_math9.bn)(0);
        return outputClone;
      }
      case import_transactions8.OutputType.Variable: {
        outputClone.to = import_configs7.ZeroBytes32;
        outputClone.amount = (0, import_math9.bn)(0);
        outputClone.assetId = import_configs7.ZeroBytes32;
        return outputClone;
      }
      default:
        return outputClone;
    }
  });
  transaction.witnessesCount = 0;
  transaction.witnesses = [];
  const chainIdBytes = (0, import_hasher.uint64ToBytesBE)(chainId);
  const concatenatedData = (0, import_utils11.concat)([chainIdBytes, new import_transactions8.TransactionCoder().encode(transaction)]);
  return (0, import_hasher.sha256)(concatenatedData);
}

// src/providers/transaction-request/blob-transaction-request.ts
var BlobTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    return new this((0, import_ramda3.clone)(obj));
  }
  /** Type of the transaction */
  type = import_transactions7.TransactionType.Blob;
  /** Blob ID */
  blobId;
  /** Witness index of the bytecode to create */
  witnessIndex;
  /**
   * Creates an instance `BlobTransactionRequest`.
   *
   * @param blobTransactionRequestLike - The initial values for the instance
   */
  constructor({ witnessIndex, blobId, ...rest }) {
    super(rest);
    this.blobId = blobId;
    this.witnessIndex = witnessIndex ?? 0;
  }
  /**
   * Converts the transaction request to a `TransactionBlob`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const { witnessIndex, blobId } = this;
    return {
      type: import_transactions7.TransactionType.Blob,
      ...baseTransaction,
      blobId,
      witnessIndex
    };
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Calculates the metadata gas cost for a blob transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   * @returns metadata gas cost for the blob transaction.
   */
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxBlob({
      gasCosts,
      txBytesSize: this.byteSize(),
      witnessBytesSize: this.witnesses[this.witnessIndex].length
    });
  }
};

// src/providers/transaction-request/create-transaction-request.ts
var import_configs8 = require("@fuel-ts/address/configs");
var import_math10 = require("@fuel-ts/math");
var import_transactions9 = require("@fuel-ts/transactions");
var import_utils14 = require("@fuel-ts/utils");
var import_ramda4 = require("ramda");

// src/providers/transaction-request/storage-slot.ts
var import_utils13 = require("@fuel-ts/utils");
var getStorageValue = (value) => {
  const v = new Uint8Array(32);
  v.set((0, import_utils13.arrayify)(value));
  return v;
};
var storageSlotify = (storageSlot) => {
  let key;
  let value;
  if (Array.isArray(storageSlot)) {
    key = storageSlot[0];
    value = storageSlot[1];
  } else {
    key = storageSlot.key;
    value = storageSlot.value;
  }
  return {
    key: (0, import_utils13.hexlify)(key),
    value: (0, import_utils13.hexlify)(getStorageValue(value))
  };
};

// src/providers/transaction-request/create-transaction-request.ts
var CreateTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    return new this((0, import_ramda4.clone)(obj));
  }
  /** Type of the transaction */
  type = import_transactions9.TransactionType.Create;
  /** Witness index of contract bytecode to create */
  bytecodeWitnessIndex;
  /** Salt */
  salt;
  /** List of storage slots to initialize */
  storageSlots;
  /**
   * Creates an instance `CreateTransactionRequest`.
   *
   * @param createTransactionRequestLike - The initial values for the instance
   */
  constructor({ bytecodeWitnessIndex, salt, storageSlots, ...rest }) {
    super(rest);
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.salt = (0, import_utils14.hexlify)(salt ?? import_configs8.ZeroBytes32);
    this.storageSlots = [...storageSlots ?? []];
  }
  /**
   * Converts the transaction request to a `TransactionCreate`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];
    return {
      type: import_transactions9.TransactionType.Create,
      ...baseTransaction,
      bytecodeWitnessIndex,
      storageSlotsCount: (0, import_math10.bn)(storageSlots.length),
      salt: this.salt ? (0, import_utils14.hexlify)(this.salt) : import_configs8.ZeroBytes32,
      storageSlots
    };
  }
  /**
   * Get contract created outputs for the transaction.
   *
   * @returns An array of contract created transaction request outputs.
   */
  getContractCreatedOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions9.OutputType.ContractCreated
    );
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Adds a contract created output to the transaction request.
   *
   * @param contractId - The contract ID.
   * @param stateRoot - The state root.
   */
  addContractCreatedOutput(contractId, stateRoot) {
    this.pushOutput({
      type: import_transactions9.OutputType.ContractCreated,
      contractId,
      stateRoot
    });
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxCreate({
      contractBytesSize: (0, import_math10.bn)((0, import_utils14.arrayify)(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
      gasCosts,
      stateRootSize: this.storageSlots.length,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/script-transaction-request.ts
var import_abi_coder3 = require("@fuel-ts/abi-coder");
var import_address2 = require("@fuel-ts/address");
var import_configs9 = require("@fuel-ts/address/configs");
var import_math11 = require("@fuel-ts/math");
var import_transactions10 = require("@fuel-ts/transactions");
var import_utils16 = require("@fuel-ts/utils");
var import_ramda5 = require("ramda");

// src/providers/transaction-request/scripts.ts
var import_utils15 = require("@fuel-ts/utils");
var returnZeroScript = {
  /*
      Opcode::RET(REG_ZERO)
      Opcode::NOOP
    */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: (0, import_utils15.arrayify)("0x24000000"),
  encodeScriptData: () => new Uint8Array(0)
};
var withdrawScript = {
  /*
          The following code loads some basic values into registers and calls SMO to create an output message
          5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
          5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
          4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
          24000000	- RET                [return 0]
          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
          00000000 00000000 [amount value]
      */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: (0, import_utils15.arrayify)("0x5040C0105D44C0064C40001124000000"),
  encodeScriptData: () => new Uint8Array(0)
};

// src/providers/transaction-request/script-transaction-request.ts
var ScriptTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    return new this((0, import_ramda5.clone)(obj));
  }
  /** Type of the transaction */
  type = import_transactions10.TransactionType.Script;
  /** Gas limit for transaction */
  gasLimit;
  /** Script to execute */
  script;
  /** Script input data (parameters) */
  scriptData;
  abis;
  /**
   * Constructor for `ScriptTransactionRequest`.
   *
   * @param scriptTransactionRequestLike - The initial values for the instance.
   */
  constructor({ script, scriptData, gasLimit, ...rest } = {}) {
    super(rest);
    this.gasLimit = (0, import_math11.bn)(gasLimit);
    this.script = (0, import_utils16.arrayify)(script ?? returnZeroScript.bytes);
    this.scriptData = (0, import_utils16.arrayify)(scriptData ?? returnZeroScript.encodeScriptData());
    this.abis = rest.abis;
  }
  /**
   * Helper function to estimate and fund the transaction request with a specified account.
   *
   * @param account - The account to fund the transaction.
   * @param params - The parameters for the transaction cost.
   * @returns The current instance of the `ScriptTransactionRequest` funded.
   */
  async estimateAndFund(account, { signatureCallback, quantities = [] } = {}) {
    const txCost = await account.getTransactionCost(this, { signatureCallback, quantities });
    this.maxFee = txCost.maxFee;
    this.gasLimit = txCost.gasUsed;
    await account.fund(this, txCost);
    return this;
  }
  /**
   * Converts the transaction request to a `TransactionScript`.
   *
   * @returns The transaction script object.
   */
  toTransaction() {
    const script = (0, import_utils16.arrayify)(this.script ?? "0x");
    const scriptData = (0, import_utils16.arrayify)(this.scriptData ?? "0x");
    return {
      type: import_transactions10.TransactionType.Script,
      scriptGasLimit: this.gasLimit,
      ...super.getBaseTransaction(),
      scriptLength: (0, import_math11.bn)(script.length),
      scriptDataLength: (0, import_math11.bn)(scriptData.length),
      receiptsRoot: import_configs9.ZeroBytes32,
      script: (0, import_utils16.hexlify)(script),
      scriptData: (0, import_utils16.hexlify)(scriptData)
    };
  }
  /**
   * Get contract inputs for the transaction.
   *
   * @returns An array of contract transaction request inputs.
   */
  getContractInputs() {
    return this.inputs.filter(
      (input) => input.type === import_transactions10.InputType.Contract
    );
  }
  /**
   * Get contract outputs for the transaction.
   *
   * @returns An array of contract transaction request outputs.
   */
  getContractOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions10.OutputType.Contract
    );
  }
  /**
   * Get variable outputs for the transaction.
   *
   * @returns An array of variable transaction request outputs.
   */
  getVariableOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions10.OutputType.Variable
    );
  }
  /**
   * Set the script and its data.
   *
   * @param script - The abstract script request.
   * @param data - The script data.
   */
  setScript(script, data) {
    this.scriptData = script.encodeScriptData(data);
    this.script = script.bytes;
  }
  /**
   * Adds variable outputs to the transaction request.
   *
   * @param numberOfVariables - The number of variables to add.
   * @returns The new length of the outputs array.
   */
  addVariableOutputs(numberOfVariables = 1) {
    let outputsNumber = numberOfVariables;
    while (outputsNumber) {
      this.pushOutput({
        type: import_transactions10.OutputType.Variable
      });
      outputsNumber -= 1;
    }
    return this.outputs.length - 1;
  }
  /**
   * Calculates the maximum gas for the transaction.
   *
   * @param chainInfo - The chain information.
   * @param minGas - The minimum gas.
   * @returns the maximum gas.
   */
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const {
      feeParameters: { gasPerByte },
      txParameters: { maxGasPerTx }
    } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      gasLimit: this.gasLimit,
      maxGasPerTx
    });
  }
  /**
   * Adds a contract input and output to the transaction request.
   *
   * @param contract - The contract ID.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  addContractInputAndOutput(contract) {
    const contractAddress = (0, import_address2.addressify)(contract);
    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
      return this;
    }
    const inputIndex = super.pushInput({
      type: import_transactions10.InputType.Contract,
      contractId: contractAddress.toB256(),
      txPointer: "0x00000000000000000000000000000000"
    });
    this.pushOutput({
      type: import_transactions10.OutputType.Contract,
      inputIndex
    });
    return this;
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Sets the data for the transaction request.
   *
   * @param abi - Script JSON ABI.
   * @param args - The input arguments.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  setData(abi, args) {
    const abiInterface = new import_abi_coder3.Interface(abi);
    this.scriptData = abiInterface.functions.main.encodeArguments(args);
    return this;
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/upgrade-transaction-request.ts
var import_errors11 = require("@fuel-ts/errors");
var import_hasher2 = require("@fuel-ts/hasher");
var import_transactions11 = require("@fuel-ts/transactions");
var import_utils17 = require("@fuel-ts/utils");
var import_ramda6 = require("ramda");
var UpgradeTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof UpgradeTransactionRequest) {
      return obj;
    }
    return new this((0, import_ramda6.clone)(obj));
  }
  /** The type of transaction */
  type = import_transactions11.TransactionType.Upgrade;
  /** The upgrade purpose */
  upgradePurpose;
  /** Witness index of consensus */
  bytecodeWitnessIndex;
  /**
   * Creates an instance `UpgradeTransactionRequest`.
   *
   * @param upgradeTransactionRequestLike - The initial values for the instance
   */
  constructor({
    upgradePurpose,
    bytecodeWitnessIndex,
    ...rest
  } = {}) {
    super(rest);
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.upgradePurpose = upgradePurpose ?? {
      type: import_transactions11.UpgradePurposeTypeEnum.ConsensusParameters,
      checksum: "0x"
    };
  }
  /**
   * Adds a consensus parameters upgrade purpose.
   *
   * @param consensus - The consensus bytecode.
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addConsensusParametersUpgradePurpose(consensus) {
    this.bytecodeWitnessIndex = this.addWitness(consensus);
    this.upgradePurpose = {
      type: import_transactions11.UpgradePurposeTypeEnum.ConsensusParameters,
      checksum: (0, import_hasher2.hash)(consensus)
    };
    return this;
  }
  /**
   * Adds a state transition upgrade purpose.
   *
   * @param bytecodeRoot - The Merkle root of the state transition.
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addStateTransitionUpgradePurpose(bytecodeRoot) {
    this.upgradePurpose = {
      type: import_transactions11.UpgradePurposeTypeEnum.StateTransition,
      data: (0, import_utils17.hexlify)(bytecodeRoot)
    };
    return this;
  }
  /**
   * Adds an upgrade purpose.
   *
   * @param type - The upgrade purpose type.
   * @param data - The bytecode or merkle root of upgrade purpose
   *
   * @returns - The current instance of `UpgradeTransactionRequest`.
   */
  addUpgradePurpose(type, data) {
    if (type === import_transactions11.UpgradePurposeTypeEnum.ConsensusParameters) {
      this.addConsensusParametersUpgradePurpose(data);
    }
    if (type === import_transactions11.UpgradePurposeTypeEnum.StateTransition) {
      this.addStateTransitionUpgradePurpose(data);
    }
    return this;
  }
  /**
   * Converts the transaction request to a `TransactionUpgrade`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    let upgradePurpose;
    if (this.upgradePurpose.type === import_transactions11.UpgradePurposeTypeEnum.ConsensusParameters) {
      upgradePurpose = {
        type: import_transactions11.UpgradePurposeTypeEnum.ConsensusParameters,
        data: {
          witnessIndex: this.bytecodeWitnessIndex,
          checksum: this.upgradePurpose.checksum
        }
      };
    } else if (this.upgradePurpose.type === import_transactions11.UpgradePurposeTypeEnum.StateTransition) {
      upgradePurpose = {
        type: import_transactions11.UpgradePurposeTypeEnum.StateTransition,
        data: {
          bytecodeRoot: (0, import_utils17.hexlify)(this.upgradePurpose.data)
        }
      };
    } else {
      throw new import_errors11.FuelError(import_errors11.FuelError.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
    }
    return {
      type: import_transactions11.TransactionType.Upgrade,
      ...super.getBaseTransaction(),
      upgradePurpose
    };
  }
  /**
   * Gets the Transaction ID by hashing the transaction
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Calculates the metadata gas cost for an upgrade transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   *
   * @returns metadata gas cost for the upgrade transaction.
   */
  metadataGas(gasCosts) {
    const txBytesSize = this.byteSize();
    if (this.upgradePurpose.type === import_transactions11.UpgradePurposeTypeEnum.ConsensusParameters) {
      const witnessIndex = this.bytecodeWitnessIndex;
      const consensusSize = this.witnesses[witnessIndex].length;
      return calculateMetadataGasForTxUpgrade({
        gasCosts,
        txBytesSize,
        consensusSize
      });
    }
    if (this.upgradePurpose.type === import_transactions11.UpgradePurposeTypeEnum.StateTransition) {
      return calculateMetadataGasForTxUpgrade({
        gasCosts,
        txBytesSize
      });
    }
    throw new import_errors11.FuelError(import_errors11.FuelError.CODES.NOT_IMPLEMENTED, "Invalid upgrade purpose");
  }
};

// src/providers/transaction-request/upload-transaction-request.ts
var import_configs10 = require("@fuel-ts/address/configs");
var import_transactions12 = require("@fuel-ts/transactions");
var import_utils19 = require("@fuel-ts/utils");
var import_ramda7 = require("ramda");
var UploadTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof UploadTransactionRequest) {
      return obj;
    }
    return new this((0, import_ramda7.clone)(obj));
  }
  /** Type of the transaction */
  type = import_transactions12.TransactionType.Upload;
  /** The witness index of the subsection of the bytecode. */
  witnessIndex;
  /** The subsection data. */
  subsection;
  /**
   * Creates an instance `UploadTransactionRequest`.
   *
   * @param uploadTransactionRequestLike - The initial values for the instance
   */
  constructor({ witnessIndex, subsection, ...rest } = {}) {
    super(rest);
    this.witnessIndex = witnessIndex ?? 0;
    this.subsection = subsection ?? {
      proofSet: [],
      root: import_configs10.ZeroBytes32,
      subsectionIndex: 0,
      subsectionsNumber: 0
    };
  }
  /**
   * Adds the subsection.
   *
   * @param subsection - The subsection data.
   */
  addSubsection(subsection) {
    const { subsection: subsectionBytecode, ...rest } = subsection;
    this.subsection = rest;
    this.witnessIndex = this.addWitness(subsectionBytecode);
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Converts the transaction request to a `TransactionUpload`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const { subsectionIndex, subsectionsNumber, root, proofSet } = this.subsection;
    return {
      type: import_transactions12.TransactionType.Upload,
      ...baseTransaction,
      subsectionIndex,
      subsectionsNumber,
      root: (0, import_utils19.hexlify)(root),
      proofSet: proofSet.map(import_utils19.hexlify),
      witnessIndex: this.witnessIndex,
      proofSetCount: proofSet.length
    };
  }
  /**
   * Calculates the metadata gas cost for an upload transaction.
   *
   * @param gasCosts - gas costs passed from the chain.
   *
   * @returns metadata gas cost for the upload transaction.
   */
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxUpload({
      gasCosts,
      txBytesSize: this.byteSize(),
      subsectionSize: (0, import_utils19.arrayify)(this.witnesses[this.witnessIndex]).length,
      subsectionsSize: this.subsection.subsectionsNumber
    });
  }
  /**
   * Calculates the minimum gas for an upload transaction.
   *
   * @param chainInfo - The chain information.
   *
   * @returns the minimum gas for the upload transaction
   */
  calculateMinGas(chainInfo) {
    const minGas = super.calculateMinGas(chainInfo);
    const { gasCosts } = chainInfo.consensusParameters;
    const bytecode = this.witnesses[this.witnessIndex] ?? import_configs10.ZeroBytes32;
    return calculateMinGasForTxUpload({
      gasCosts,
      baseMinGas: minGas.toNumber(),
      subsectionSize: (0, import_utils19.arrayify)(bytecode).length
    });
  }
};

// src/providers/transaction-request/types.ts
var AbstractScriptRequest = class {
};

// src/providers/transaction-request/utils.ts
var import_errors12 = require("@fuel-ts/errors");
var import_transactions13 = require("@fuel-ts/transactions");
var transactionRequestify = (obj) => {
  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest || obj instanceof BlobTransactionRequest || obj instanceof UpgradeTransactionRequest || obj instanceof UploadTransactionRequest) {
    return obj;
  }
  const { type } = obj;
  switch (obj.type) {
    case import_transactions13.TransactionType.Script: {
      return ScriptTransactionRequest.from(obj);
    }
    case import_transactions13.TransactionType.Create: {
      return CreateTransactionRequest.from(obj);
    }
    case import_transactions13.TransactionType.Blob: {
      return BlobTransactionRequest.from(obj);
    }
    case import_transactions13.TransactionType.Upgrade: {
      return UpgradeTransactionRequest.from(obj);
    }
    case import_transactions13.TransactionType.Upload: {
      return UploadTransactionRequest.from(obj);
    }
    default: {
      throw new import_errors12.FuelError(
        import_errors12.ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
        `Unsupported transaction type: ${type}.`
      );
    }
  }
};
var isTransactionTypeScript = (request) => request.type === import_transactions13.TransactionType.Script;
var isTransactionTypeCreate = (request) => request.type === import_transactions13.TransactionType.Create;
var isTransactionTypeBlob = (request) => request.type === import_transactions13.TransactionType.Blob;
var isTransactionTypeUpgrade = (request) => request.type === import_transactions13.TransactionType.Upgrade;
var isTransactionTypeUpload = (request) => request.type === import_transactions13.TransactionType.Upload;

// src/providers/transaction-response/transaction-response.ts
var import_errors16 = require("@fuel-ts/errors");
var import_math17 = require("@fuel-ts/math");
var import_transactions21 = require("@fuel-ts/transactions");
var import_utils25 = require("@fuel-ts/utils");

// src/providers/transaction-summary/assemble-transaction-summary.ts
var import_math16 = require("@fuel-ts/math");
var import_transactions19 = require("@fuel-ts/transactions");
var import_utils23 = require("@fuel-ts/utils");

// src/providers/transaction-summary/calculate-tx-fee-for-summary.ts
var import_math12 = require("@fuel-ts/math");
var import_transactions14 = require("@fuel-ts/transactions");
var import_utils21 = require("@fuel-ts/utils");
var calculateTXFeeForSummary = (params) => {
  const {
    gasPrice,
    rawPayload,
    tip,
    consensusParameters: { gasCosts, feeParams, maxGasPerTx }
  } = params;
  const gasPerByte = (0, import_math12.bn)(feeParams.gasPerByte);
  const gasPriceFactor = (0, import_math12.bn)(feeParams.gasPriceFactor);
  const transactionBytes = (0, import_utils21.arrayify)(rawPayload);
  const [transaction] = new import_transactions14.TransactionCoder().decode(transactionBytes, 0);
  const { type, witnesses, inputs, policies } = transaction;
  let metadataGas = (0, import_math12.bn)(0);
  let gasLimit = (0, import_math12.bn)(0);
  if (type !== import_transactions14.TransactionType.Create && type !== import_transactions14.TransactionType.Script) {
    return (0, import_math12.bn)(0);
  }
  if (type === import_transactions14.TransactionType.Create) {
    const { bytecodeWitnessIndex, storageSlots } = transaction;
    const contractBytesSize = (0, import_math12.bn)((0, import_utils21.arrayify)(witnesses[bytecodeWitnessIndex].data).length);
    metadataGas = calculateMetadataGasForTxCreate({
      contractBytesSize,
      gasCosts,
      stateRootSize: storageSlots.length || 0,
      txBytesSize: transactionBytes.length
    });
  } else {
    const { scriptGasLimit } = transaction;
    if (scriptGasLimit) {
      gasLimit = scriptGasLimit;
    }
    metadataGas = calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: transactionBytes.length
    });
  }
  const minGas = getMinGas({
    gasCosts,
    gasPerByte: (0, import_math12.bn)(gasPerByte),
    inputs,
    metadataGas,
    txBytesSize: transactionBytes.length
  });
  const witnessLimit = policies.find((policy) => policy.type === import_transactions14.PolicyType.WitnessLimit)?.data;
  const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
  const maxGas = getMaxGas({
    gasPerByte,
    minGas,
    witnessesLength,
    gasLimit,
    witnessLimit,
    maxGasPerTx
  });
  const maxFee = calculateGasFee({
    gasPrice,
    gas: maxGas,
    priceFactor: gasPriceFactor,
    tip
  });
  return maxFee;
};

// src/providers/transaction-summary/operations.ts
var import_configs11 = require("@fuel-ts/address/configs");
var import_errors14 = require("@fuel-ts/errors");
var import_math14 = require("@fuel-ts/math");
var import_transactions17 = require("@fuel-ts/transactions");

// src/providers/transaction-summary/call.ts
var import_abi_coder4 = require("@fuel-ts/abi-coder");
var getFunctionCall = ({ abi, receipt }) => {
  const abiInterface = new import_abi_coder4.Interface(abi);
  const callFunctionSelector = receipt.param1.toHex(8);
  const functionFragment = abiInterface.getFunction(callFunctionSelector);
  const inputs = functionFragment.jsonFn.inputs;
  const encodedArgs = receipt.param2.toHex();
  let argumentsProvided;
  const data = functionFragment.decodeArguments(encodedArgs);
  if (data) {
    argumentsProvided = inputs.reduce((prev, input, index) => {
      const value = data[index];
      const name = input.name;
      if (name) {
        return {
          ...prev,
          // reparse to remove bn
          [name]: JSON.parse(JSON.stringify(value))
        };
      }
      return prev;
    }, {});
  }
  const call = {
    functionSignature: functionFragment.signature,
    functionName: functionFragment.name,
    argumentsProvided,
    ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
  };
  return call;
};

// src/providers/transaction-summary/input.ts
var import_errors13 = require("@fuel-ts/errors");
var import_math13 = require("@fuel-ts/math");
var import_transactions15 = require("@fuel-ts/transactions");
function getInputsByTypes(inputs, types) {
  return inputs.filter((i) => types.includes(i.type));
}
function getInputsByType(inputs, type) {
  return inputs.filter((i) => i.type === type);
}
function getInputsCoin(inputs) {
  return getInputsByType(inputs, import_transactions15.InputType.Coin);
}
function getInputsMessage(inputs) {
  return getInputsByType(inputs, import_transactions15.InputType.Message);
}
function getInputsCoinAndMessage(inputs) {
  return getInputsByTypes(inputs, [import_transactions15.InputType.Coin, import_transactions15.InputType.Message]);
}
function isInputCoin(input) {
  return input.type === import_transactions15.InputType.Coin;
}
function getInputsContract(inputs) {
  return getInputsByType(inputs, import_transactions15.InputType.Contract);
}
function findCoinInput(inputs, assetId) {
  const coinInputs = getInputsCoin(inputs);
  return coinInputs.find((i) => i.assetId === assetId);
}
function aggregateInputsAmountsByAssetAndOwner(inputs, baseAssetId) {
  const aggregated = /* @__PURE__ */ new Map();
  getInputsCoinAndMessage(inputs).forEach((input) => {
    const assetId = isInputCoin(input) ? input.assetId : baseAssetId;
    const owner = isInputCoin(input) ? input.owner : input.recipient;
    let ownersMap = aggregated.get(assetId);
    if (!ownersMap) {
      ownersMap = /* @__PURE__ */ new Map();
      aggregated.set(assetId, ownersMap);
    }
    let ownerBalance = ownersMap.get(owner);
    if (!ownerBalance) {
      ownerBalance = new import_math13.BN(0);
      ownersMap.set(owner, ownerBalance);
    }
    ownersMap.set(owner, ownerBalance.add(input.amount));
  });
  return aggregated;
}
function findMessageInput(inputs) {
  return getInputsMessage(inputs)?.[0];
}
function getInputFromAssetId(inputs, assetId, isBaseAsset = false) {
  const coinInput = findCoinInput(inputs, assetId);
  if (coinInput) {
    return coinInput;
  }
  if (isBaseAsset) {
    return findMessageInput(inputs);
  }
  return void 0;
}
function getInputContractFromIndex(inputs, inputIndex) {
  if (inputIndex == null) {
    return void 0;
  }
  const contractInput = inputs?.[inputIndex];
  if (!contractInput) {
    return void 0;
  }
  if (contractInput.type !== import_transactions15.InputType.Contract) {
    throw new import_errors13.FuelError(
      import_errors13.ErrorCode.INVALID_TRANSACTION_INPUT,
      `Contract input should be of type 'contract'.`
    );
  }
  return contractInput;
}
function getInputAccountAddress(input) {
  if (input.type === import_transactions15.InputType.Coin) {
    return input.owner.toString();
  }
  if (input.type === import_transactions15.InputType.Message) {
    return input.recipient.toString();
  }
  return "";
}

// src/providers/transaction-summary/output.ts
var import_transactions16 = require("@fuel-ts/transactions");
function getOutputsByType(outputs, type) {
  return outputs.filter((o) => o.type === type);
}
function getOutputsContractCreated(outputs) {
  return getOutputsByType(outputs, import_transactions16.OutputType.ContractCreated);
}
function getOutputsCoin(outputs) {
  return getOutputsByType(outputs, import_transactions16.OutputType.Coin);
}
function getOutputsChange(outputs) {
  return getOutputsByType(outputs, import_transactions16.OutputType.Change);
}
function getOutputsContract(outputs) {
  return getOutputsByType(outputs, import_transactions16.OutputType.Contract);
}
function getOutputsVariable(outputs) {
  return getOutputsByType(outputs, import_transactions16.OutputType.Variable);
}

// src/providers/transaction-summary/types.ts
var TransactionTypeName = /* @__PURE__ */ ((TransactionTypeName2) => {
  TransactionTypeName2["Create"] = "Create";
  TransactionTypeName2["Mint"] = "Mint";
  TransactionTypeName2["Script"] = "Script";
  TransactionTypeName2["Upgrade"] = "Upgrade";
  TransactionTypeName2["Upload"] = "Upload";
  TransactionTypeName2["Blob"] = "Blob";
  return TransactionTypeName2;
})(TransactionTypeName || {});
var TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
  TransactionStatus2["submitted"] = "submitted";
  TransactionStatus2["success"] = "success";
  TransactionStatus2["squeezedout"] = "squeezedout";
  TransactionStatus2["failure"] = "failure";
  return TransactionStatus2;
})(TransactionStatus || {});
var OperationName = /* @__PURE__ */ ((OperationName2) => {
  OperationName2["payBlockProducer"] = "Pay network fee to block producer";
  OperationName2["contractCreated"] = "Contract created";
  OperationName2["transfer"] = "Transfer asset";
  OperationName2["contractCall"] = "Contract call";
  OperationName2["receive"] = "Receive asset";
  OperationName2["withdrawFromFuel"] = "Withdraw from Fuel";
  return OperationName2;
})(OperationName || {});
var AddressType = /* @__PURE__ */ ((AddressType2) => {
  AddressType2[AddressType2["contract"] = 0] = "contract";
  AddressType2[AddressType2["account"] = 1] = "account";
  return AddressType2;
})(AddressType || {});
var ChainName = /* @__PURE__ */ ((ChainName2) => {
  ChainName2["ethereum"] = "ethereum";
  ChainName2["fuel"] = "fuel";
  return ChainName2;
})(ChainName || {});

// src/providers/transaction-summary/operations.ts
function getReceiptsByType(receipts, type) {
  return (receipts ?? []).filter((r) => r.type === type);
}
function getTransactionTypeName(transactionType) {
  switch (transactionType) {
    case import_transactions17.TransactionType.Mint:
      return "Mint" /* Mint */;
    case import_transactions17.TransactionType.Create:
      return "Create" /* Create */;
    case import_transactions17.TransactionType.Script:
      return "Script" /* Script */;
    case import_transactions17.TransactionType.Blob:
      return "Blob" /* Blob */;
    case import_transactions17.TransactionType.Upgrade:
      return "Upgrade" /* Upgrade */;
    case import_transactions17.TransactionType.Upload:
      return "Upload" /* Upload */;
    default:
      throw new import_errors14.FuelError(
        import_errors14.ErrorCode.UNSUPPORTED_TRANSACTION_TYPE,
        `Unsupported transaction type: ${transactionType}.`
      );
  }
}
function isType(transactionType, type) {
  const txType = getTransactionTypeName(transactionType);
  return txType === type;
}
function isTypeMint(transactionType) {
  return isType(transactionType, "Mint" /* Mint */);
}
function isTypeCreate(transactionType) {
  return isType(transactionType, "Create" /* Create */);
}
function isTypeScript(transactionType) {
  return isType(transactionType, "Script" /* Script */);
}
function isTypeUpgrade(transactionType) {
  return isType(transactionType, "Upgrade" /* Upgrade */);
}
function isTypeUpload(transactionType) {
  return isType(transactionType, "Upload" /* Upload */);
}
function isTypeBlob(transactionType) {
  return isType(transactionType, "Blob" /* Blob */);
}
function hasSameAssetId(a) {
  return (b) => a.assetId === b.assetId;
}
function getReceiptsCall(receipts) {
  return getReceiptsByType(receipts, import_transactions17.ReceiptType.Call);
}
function getReceiptsMessageOut(receipts) {
  return getReceiptsByType(receipts, import_transactions17.ReceiptType.MessageOut);
}
function mergeAssets(op1, op2) {
  const assets1 = op1.assetsSent || [];
  const assets2 = op2.assetsSent || [];
  const assetMap = /* @__PURE__ */ new Map();
  assets1.forEach((asset) => {
    assetMap.set(asset.assetId, { ...asset });
  });
  assets2.forEach((asset) => {
    const existingAsset = assetMap.get(asset.assetId);
    if (existingAsset) {
      existingAsset.amount = (0, import_math14.bn)(existingAsset.amount).add(asset.amount);
    } else {
      assetMap.set(asset.assetId, { ...asset });
    }
  });
  return Array.from(assetMap.values());
}
function isSameOperation(a, b) {
  return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
}
function mergeAssetsSent(existing, toAdd) {
  if (!toAdd.assetsSent?.length) {
    return existing.assetsSent;
  }
  return existing.assetsSent?.length ? mergeAssets(existing, toAdd) : toAdd.assetsSent;
}
function mergeCalls(existing, toAdd) {
  if (!toAdd.calls?.length) {
    return existing.calls;
  }
  return [...existing.calls || [], ...toAdd.calls];
}
function mergeOperations(existing, toAdd) {
  return {
    ...existing,
    assetsSent: mergeAssetsSent(existing, toAdd),
    calls: mergeCalls(existing, toAdd)
  };
}
function addOperation(operations, toAdd) {
  const existingIndex = operations.findIndex((op) => isSameOperation(op, toAdd));
  if (existingIndex === -1) {
    return [...operations, toAdd];
  }
  return operations.map((op, index) => index === existingIndex ? mergeOperations(op, toAdd) : op);
}
function getReceiptsTransferOut(receipts) {
  return getReceiptsByType(receipts, import_transactions17.ReceiptType.TransferOut);
}
function getWithdrawFromFuelOperations({
  inputs,
  receipts,
  baseAssetId
}) {
  const messageOutReceipts = getReceiptsMessageOut(receipts);
  const withdrawFromFuelOperations = messageOutReceipts.reduce(
    (prevWithdrawFromFuelOps, receipt) => {
      const input = getInputFromAssetId(inputs, baseAssetId, true);
      if (input) {
        const inputAddress = getInputAccountAddress(input);
        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
          name: "Withdraw from Fuel" /* withdrawFromFuel */,
          from: {
            type: 1 /* account */,
            address: inputAddress
          },
          to: {
            type: 1 /* account */,
            address: receipt.recipient.toString(),
            chain: "ethereum" /* ethereum */
          },
          assetsSent: [
            {
              amount: receipt.amount,
              assetId: baseAssetId
            }
          ]
        });
        return newWithdrawFromFuelOps;
      }
      return prevWithdrawFromFuelOps;
    },
    []
  );
  return withdrawFromFuelOperations;
}
function getContractCalls(contractInput, abiMap, receipt, rawPayload, maxInputs) {
  const abi = abiMap?.[contractInput.contractID];
  if (!abi) {
    return [];
  }
  return [
    getFunctionCall({
      abi,
      receipt,
      rawPayload,
      maxInputs
    })
  ];
}
function getAssetsSent(receipt) {
  return receipt.amount?.isZero() ? void 0 : [
    {
      amount: receipt.amount,
      assetId: receipt.assetId
    }
  ];
}
function processCallReceipt(receipt, contractInput, inputs, abiMap, rawPayload, maxInputs, baseAssetId) {
  const assetId = receipt.assetId === import_configs11.ZeroBytes32 ? baseAssetId : receipt.assetId;
  const input = getInputFromAssetId(inputs, assetId, assetId === baseAssetId);
  if (!input) {
    return [];
  }
  const inputAddress = getInputAccountAddress(input);
  const calls = getContractCalls(contractInput, abiMap, receipt, rawPayload, maxInputs);
  return [
    {
      name: "Contract call" /* contractCall */,
      from: {
        type: 1 /* account */,
        address: inputAddress
      },
      to: {
        type: 0 /* contract */,
        address: receipt.to
      },
      assetsSent: getAssetsSent(receipt),
      calls
    }
  ];
}
function getContractCallOperations({
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs,
  baseAssetId
}) {
  const contractCallReceipts = getReceiptsCall(receipts);
  const contractOutputs = getOutputsContract(outputs);
  return contractOutputs.flatMap((output) => {
    const contractInput = getInputContractFromIndex(inputs, output.inputIndex);
    if (!contractInput) {
      return [];
    }
    return contractCallReceipts.filter((receipt) => receipt.to === contractInput.contractID).flatMap(
      (receipt) => processCallReceipt(
        receipt,
        contractInput,
        inputs,
        abiMap,
        rawPayload,
        maxInputs,
        baseAssetId
      )
    );
  });
}
function extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs) {
  const { to: toAddress, assetId, amount } = receipt;
  let { id: fromAddress } = receipt;
  const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 /* contract */ : 1 /* account */;
  if (import_configs11.ZeroBytes32 === fromAddress) {
    const change = changeOutputs.find((output) => output.assetId === assetId);
    fromAddress = change?.to || fromAddress;
  }
  const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 /* contract */ : 1 /* account */;
  return {
    name: "Transfer asset" /* transfer */,
    from: {
      type: fromType,
      address: fromAddress
    },
    to: {
      type: toType,
      address: toAddress
    },
    assetsSent: [
      {
        assetId: assetId.toString(),
        amount
      }
    ]
  };
}
function getTransferOperations({
  inputs,
  outputs,
  receipts,
  baseAssetId
}) {
  let operations = [];
  const coinOutputs = getOutputsCoin(outputs);
  const contractInputs = getInputsContract(inputs);
  const changeOutputs = getOutputsChange(outputs);
  const aggregated = aggregateInputsAmountsByAssetAndOwner(inputs, baseAssetId);
  coinOutputs.forEach(({ amount, assetId, to }) => {
    const txPayers = aggregated.get(assetId) || /* @__PURE__ */ new Map();
    let selectedPayer;
    let fallbackPayer;
    for (const [address, payedAmount] of txPayers) {
      if (!fallbackPayer) {
        fallbackPayer = address;
      }
      if (payedAmount.gte(amount)) {
        selectedPayer = address;
        break;
      }
    }
    selectedPayer = selectedPayer || fallbackPayer;
    if (selectedPayer) {
      operations = addOperation(operations, {
        name: "Transfer asset" /* transfer */,
        from: {
          type: 1 /* account */,
          address: selectedPayer
        },
        to: {
          type: 1 /* account */,
          address: to
        },
        assetsSent: [{ assetId, amount }]
      });
    }
  });
  const transferReceipts = getReceiptsByType(
    receipts,
    import_transactions17.ReceiptType.Transfer
  );
  const transferOutReceipts = getReceiptsByType(
    receipts,
    import_transactions17.ReceiptType.TransferOut
  );
  [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
    const operation = extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs);
    operations = addOperation(operations, operation);
  });
  return operations;
}
function getPayProducerOperations(outputs) {
  const coinOutputs = getOutputsCoin(outputs);
  const payProducerOperations = coinOutputs.reduce((prev, output) => {
    const operations = addOperation(prev, {
      name: "Pay network fee to block producer" /* payBlockProducer */,
      from: {
        type: 1 /* account */,
        address: "Network"
      },
      to: {
        type: 1 /* account */,
        address: output.to.toString()
      },
      assetsSent: [
        {
          assetId: output.assetId.toString(),
          amount: output.amount
        }
      ]
    });
    return operations;
  }, []);
  return payProducerOperations;
}
function getContractCreatedOperations({ inputs, outputs }) {
  const contractCreatedOutputs = getOutputsContractCreated(outputs);
  const input = getInputsCoinAndMessage(inputs)[0];
  const fromAddress = getInputAccountAddress(input);
  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
    const operations = addOperation(prev, {
      name: "Contract created" /* contractCreated */,
      from: {
        type: 1 /* account */,
        address: fromAddress
      },
      to: {
        type: 0 /* contract */,
        address: contractCreatedOutput?.contractId || ""
      }
    });
    return operations;
  }, []);
  return contractCreatedOperations;
}
function getOperations({
  transactionType,
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs,
  baseAssetId
}) {
  if (isTypeCreate(transactionType)) {
    return [...getContractCreatedOperations({ inputs, outputs })];
  }
  if (isTypeScript(transactionType)) {
    return [
      ...getTransferOperations({ inputs, outputs, receipts, baseAssetId }),
      ...getContractCallOperations({
        inputs,
        outputs,
        receipts,
        abiMap,
        rawPayload,
        maxInputs,
        baseAssetId
      }),
      ...getWithdrawFromFuelOperations({ inputs, receipts, baseAssetId })
    ];
  }
  return [...getPayProducerOperations(outputs)];
}

// src/providers/transaction-summary/receipt.ts
var import_transactions18 = require("@fuel-ts/transactions");
var processGqlReceipt = (gqlReceipt) => assembleReceiptByType(gqlReceipt);
var extractMintedAssetsFromReceipts = (receipts) => {
  const mintedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === import_transactions18.ReceiptType.Mint) {
      mintedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return mintedAssets;
};
var extractBurnedAssetsFromReceipts = (receipts) => {
  const burnedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === import_transactions18.ReceiptType.Burn) {
      burnedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return burnedAssets;
};

// src/providers/transaction-summary/status.ts
var import_errors15 = require("@fuel-ts/errors");
var import_math15 = require("@fuel-ts/math");
var getTransactionStatusName = (gqlStatus) => {
  switch (gqlStatus) {
    case "FailureStatus":
      return "failure" /* failure */;
    case "SuccessStatus":
      return "success" /* success */;
    case "SubmittedStatus":
      return "submitted" /* submitted */;
    case "SqueezedOutStatus":
      return "squeezedout" /* squeezedout */;
    default:
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.INVALID_TRANSACTION_STATUS,
        `Invalid transaction status: ${gqlStatus}.`
      );
  }
};
var processGraphqlStatus = (gqlTransactionStatus) => {
  let time;
  let blockId;
  let status;
  let totalFee;
  let totalGas;
  let isStatusFailure = false;
  let isStatusSuccess = false;
  let isStatusPending = false;
  if (gqlTransactionStatus?.type) {
    status = getTransactionStatusName(gqlTransactionStatus.type);
    switch (gqlTransactionStatus.type) {
      case "SuccessStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block?.id;
        isStatusSuccess = true;
        totalFee = (0, import_math15.bn)(gqlTransactionStatus.totalFee);
        totalGas = (0, import_math15.bn)(gqlTransactionStatus.totalGas);
        break;
      case "FailureStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block?.id;
        isStatusFailure = true;
        totalFee = (0, import_math15.bn)(gqlTransactionStatus.totalFee);
        totalGas = (0, import_math15.bn)(gqlTransactionStatus.totalGas);
        break;
      case "SubmittedStatus":
        time = gqlTransactionStatus.time;
        isStatusPending = true;
        break;
      default:
    }
  }
  const processedGraphqlStatus = {
    time,
    blockId,
    status,
    totalFee,
    totalGas,
    isStatusFailure,
    isStatusSuccess,
    isStatusPending
  };
  return processedGraphqlStatus;
};
var getTotalFeeFromStatus = (status) => status && "totalFee" in status ? (0, import_math15.bn)(status.totalFee) : void 0;

// src/providers/transaction-summary/assemble-transaction-summary.ts
function assembleTransactionSummary(params) {
  const {
    id,
    receipts,
    gasPerByte,
    gasPriceFactor,
    transaction,
    transactionBytes,
    gqlTransactionStatus,
    abiMap = {},
    maxInputs,
    gasCosts,
    maxGasPerTx,
    gasPrice,
    baseAssetId
  } = params;
  const gasUsed = getGasUsedFromReceipts(receipts);
  const rawPayload = (0, import_utils23.hexlify)(transactionBytes);
  const operations = getOperations({
    transactionType: transaction.type,
    inputs: transaction.inputs || [],
    outputs: transaction.outputs || [],
    receipts,
    rawPayload,
    abiMap,
    maxInputs,
    baseAssetId
  });
  const typeName = getTransactionTypeName(transaction.type);
  const tip = (0, import_math16.bn)(transaction.policies?.find((policy) => policy.type === import_transactions19.PolicyType.Tip)?.data);
  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time, totalFee } = processGraphqlStatus(gqlTransactionStatus);
  const fee = totalFee ?? calculateTXFeeForSummary({
    gasPrice,
    rawPayload,
    tip,
    consensusParameters: {
      gasCosts,
      maxGasPerTx,
      feeParams: {
        gasPerByte,
        gasPriceFactor
      }
    }
  });
  const mintedAssets = extractMintedAssetsFromReceipts(receipts);
  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
  let date;
  if (time) {
    date = import_utils23.DateTime.fromTai64(time);
  }
  const transactionSummary = {
    id,
    tip,
    fee,
    gasUsed,
    operations,
    type: typeName,
    blockId,
    time,
    status,
    receipts,
    mintedAssets,
    burnedAssets,
    isTypeMint: isTypeMint(transaction.type),
    isTypeCreate: isTypeCreate(transaction.type),
    isTypeScript: isTypeScript(transaction.type),
    isTypeUpgrade: isTypeUpgrade(transaction.type),
    isTypeUpload: isTypeUpload(transaction.type),
    isTypeBlob: isTypeBlob(transaction.type),
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    date,
    transaction
  };
  return transactionSummary;
}

// src/providers/transaction-response/getDecodedLogs.ts
var import_abi_coder5 = require("@fuel-ts/abi-coder");
var import_transactions20 = require("@fuel-ts/transactions");
function getDecodedLogs(receipts, mainAbi, externalAbis = {}) {
  return receipts.reduce((logs, receipt) => {
    if (receipt.type === import_transactions20.ReceiptType.LogData || receipt.type === import_transactions20.ReceiptType.Log) {
      const interfaceToUse = new import_abi_coder5.Interface(externalAbis[receipt.id] || mainAbi);
      const data = receipt.type === import_transactions20.ReceiptType.Log ? new import_abi_coder5.BigNumberCoder("u64").encode(receipt.ra) : receipt.data;
      const [decodedLog] = interfaceToUse.decodeLog(data, receipt.rb.toString());
      logs.push(decodedLog);
    }
    return logs;
  }, []);
}

// src/providers/transaction-response/transaction-response.ts
function mapGqlOutputsToTxOutputs(outputs) {
  return outputs.map((o) => {
    const obj = "amount" in o ? { ...o, amount: (0, import_math17.bn)(o.amount) } : o;
    switch (obj.type) {
      case "CoinOutput":
        return { ...obj, type: import_transactions21.OutputType.Coin };
      case "ContractOutput":
        return {
          ...obj,
          type: import_transactions21.OutputType.Contract,
          inputIndex: parseInt(obj.inputIndex, 10)
        };
      case "ChangeOutput":
        return {
          ...obj,
          type: import_transactions21.OutputType.Change
        };
      case "VariableOutput":
        return { ...obj, type: import_transactions21.OutputType.Variable };
      case "ContractCreated":
        return {
          ...obj,
          type: import_transactions21.OutputType.ContractCreated,
          contractId: obj.contract
        };
      default:
        return (0, import_utils25.assertUnreachable)(obj);
    }
  });
}
var TransactionResponse = class {
  /**
   * Constructor for `TransactionResponse`.
   *
   * @param tx - The transaction ID or TransactionRequest.
   * @param provider - The provider.
   */
  constructor(tx, provider, chainId, abis, submitTxSubscription) {
    this.submitTxSubscription = submitTxSubscription;
    this.id = typeof tx === "string" ? tx : tx.getTransactionId(chainId);
    this.provider = provider;
    this.abis = abis;
    this.request = typeof tx === "string" ? void 0 : tx;
  }
  /** Transaction ID */
  id;
  /** Current provider */
  provider;
  /** Gas used on the transaction */
  gasUsed = (0, import_math17.bn)(0);
  /** The graphql Transaction with receipts object. */
  gqlTransaction;
  request;
  status;
  abis;
  /**
   * Async constructor for `TransactionResponse`. This method can be used to create
   * an instance of `TransactionResponse` and wait for the transaction to be fetched
   * from the chain, ensuring that the `gqlTransaction` property is set.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  static async create(id, provider, abis) {
    const chainId = await provider.getChainId();
    const response = new TransactionResponse(id, provider, chainId, abis);
    await response.fetch();
    return response;
  }
  applyMalleableSubscriptionFields(transaction) {
    const status = this.status;
    if (!status) {
      return;
    }
    const tx = transaction;
    if (status.type === "SuccessStatus" || status.type === "FailureStatus") {
      tx.inputs = tx.inputs.map((input, idx) => {
        if ("txPointer" in input) {
          const correspondingInput = status.transaction.inputs?.[idx];
          return {
            ...input,
            txPointer: import_transactions21.TxPointerCoder.decodeFromGqlScalar(correspondingInput.txPointer)
          };
        }
        return input;
      });
      tx.outputs = mapGqlOutputsToTxOutputs(status.transaction.outputs);
      if ("receiptsRoot" in status.transaction) {
        tx.receiptsRoot = status.transaction.receiptsRoot;
      }
    }
  }
  async getTransaction() {
    if (this.request) {
      const tx = this.request.toTransaction();
      this.applyMalleableSubscriptionFields(tx);
      return {
        tx,
        bytes: this.request.toTransactionBytes()
      };
    }
    const gqlTransaction = this.gqlTransaction ?? await this.fetch();
    return {
      tx: this.decodeTransaction(gqlTransaction),
      bytes: (0, import_utils25.arrayify)(gqlTransaction.rawPayload)
    };
  }
  getReceipts() {
    const status = this.status ?? this.gqlTransaction?.status;
    switch (status?.type) {
      case "SuccessStatus":
      case "FailureStatus":
        return status.receipts.map(processGqlReceipt);
      default:
        return [];
    }
  }
  /**
   * Fetch the transaction with receipts from the provider.
   *
   * @returns Transaction with receipts query result.
   */
  async fetch() {
    const response = await this.provider.operations.getTransactionWithReceipts({
      transactionId: this.id
    });
    if (!response.transaction) {
      const subscription = await this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange } of subscription) {
        if (statusChange) {
          this.status = statusChange;
          break;
        }
      }
      return this.fetch();
    }
    this.gqlTransaction = response.transaction;
    return response.transaction;
  }
  /**
   * Decode the raw payload of the transaction.
   *
   * @param transactionWithReceipts - The transaction with receipts object.
   * @returns The decoded transaction.
   */
  decodeTransaction(transactionWithReceipts) {
    return new import_transactions21.TransactionCoder().decode(
      (0, import_utils25.arrayify)(transactionWithReceipts.rawPayload),
      0
    )?.[0];
  }
  /**
   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
   * fetch it from the provider
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns
   */
  async getTransactionSummary(contractsAbiMap) {
    const { tx: transaction, bytes: transactionBytes } = await this.getTransaction();
    const { gasPerByte, gasPriceFactor, gasCosts, maxGasPerTx } = await this.provider.getGasConfig();
    const totalFee = getTotalFeeFromStatus(this.status ?? this.gqlTransaction?.status);
    const gasPrice = totalFee ? (0, import_math17.bn)(0) : await this.provider.getLatestGasPrice();
    const maxInputs = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs;
    const baseAssetId = await this.provider.getBaseAssetId();
    const transactionSummary = assembleTransactionSummary({
      id: this.id,
      receipts: this.getReceipts(),
      transaction,
      transactionBytes,
      gqlTransactionStatus: this.status ?? this.gqlTransaction?.status,
      gasPerByte,
      gasPriceFactor,
      abiMap: contractsAbiMap,
      maxInputs,
      gasCosts,
      maxGasPerTx,
      gasPrice,
      baseAssetId
    });
    return transactionSummary;
  }
  async waitForStatusChange() {
    const status = this.gqlTransaction?.status?.type;
    if (status && status !== "SubmittedStatus") {
      return;
    }
    const subscription = this.submitTxSubscription ?? await this.provider.operations.statusChange({
      transactionId: this.id
    });
    for await (const sub2 of subscription) {
      const statusChange = "statusChange" in sub2 ? sub2.statusChange : sub2.submitAndAwaitStatus;
      this.status = statusChange;
      if (statusChange.type === "SqueezedOutStatus") {
        this.unsetResourceCache();
        throw new import_errors16.FuelError(
          import_errors16.ErrorCode.TRANSACTION_SQUEEZED_OUT,
          `Transaction Squeezed Out with reason: ${statusChange.reason}`
        );
      }
      if (statusChange.type !== "SubmittedStatus") {
        break;
      }
    }
  }
  /**
   * Assembles the result of a transaction by retrieving the transaction summary,
   * decoding logs (if available), and handling transaction failure.
   *
   * This method can be used to obtain the result of a transaction that has just
   * been submitted or one that has already been processed.
   *
   * @template TTransactionType - The type of the transaction.
   * @param contractsAbiMap - The map of contract ABIs.
   * @returns - The assembled transaction result.
   * @throws If the transaction status is a failure.
   */
  async assembleResult(contractsAbiMap) {
    const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
    const transactionResult = {
      ...transactionSummary
    };
    let logs = [];
    if (this.abis) {
      logs = getDecodedLogs(
        transactionSummary.receipts,
        this.abis.main,
        this.abis.otherContractsAbis
      );
      transactionResult.logs = logs;
    }
    const { receipts } = transactionResult;
    const status = this.status ?? this.gqlTransaction?.status;
    if (status?.type === "FailureStatus") {
      this.unsetResourceCache();
      const { reason } = status;
      throw extractTxError({
        receipts,
        statusReason: reason,
        logs
      });
    }
    return transactionResult;
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @returns The completed transaction result
   */
  async waitForResult(contractsAbiMap) {
    await this.waitForStatusChange();
    return this.assembleResult(contractsAbiMap);
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   */
  async wait(contractsAbiMap) {
    return this.waitForResult(contractsAbiMap);
  }
  unsetResourceCache() {
    this.provider.cache?.unset(this.id);
  }
};

// src/providers/utils/auto-retry-fetch.ts
var import_utils27 = require("@fuel-ts/utils");
function getWaitDelay(options, retryAttemptNum) {
  const duration = options.baseDelay ?? 150;
  switch (options.backoff) {
    case "linear":
      return duration * retryAttemptNum;
    case "fixed":
      return duration;
    case "exponential":
    default:
      return 2 ** (retryAttemptNum - 1) * duration;
  }
}
function autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {
  if (options === void 0) {
    return fetchFn;
  }
  return async (...args) => {
    try {
      return await fetchFn(...args);
    } catch (_error) {
      const error = _error;
      if (error.cause?.code !== "ECONNREFUSED") {
        throw error;
      }
      const retryNum = retryAttemptNum + 1;
      if (retryNum > options.maxRetries) {
        throw error;
      }
      const delay = getWaitDelay(options, retryNum);
      await (0, import_utils27.sleep)(delay);
      return autoRetryFetch(fetchFn, options, retryNum)(...args);
    }
  };
}

// src/providers/utils/handle-gql-error-message.ts
var import_errors17 = require("@fuel-ts/errors");
var handleGqlErrorMessage = (errorMessage, rawError) => {
  switch (errorMessage) {
    case "not enough coins to fit the target" /* NOT_ENOUGH_COINS */:
      throw new import_errors17.FuelError(
        import_errors17.ErrorCode.NOT_ENOUGH_FUNDS,
        `The account(s) sending the transaction don't have enough funds to cover the transaction.`,
        {},
        rawError
      );
    case "max number of coins is reached while trying to fit the target" /* MAX_COINS_REACHED */:
      throw new import_errors17.FuelError(
        import_errors17.ErrorCode.MAX_COINS_REACHED,
        "The account retrieving coins has exceeded the maximum number of coins per asset. Please consider combining your coins into a single UTXO.",
        {},
        rawError
      );
    default:
      throw new import_errors17.FuelError(import_errors17.ErrorCode.INVALID_REQUEST, errorMessage);
  }
};

// src/providers/utils/validate-pagination-args.ts
var import_errors18 = require("@fuel-ts/errors");
var validatePaginationArgs = (params) => {
  const { paginationLimit, inputArgs = {} } = params;
  const { first, last, after, before } = inputArgs;
  if (after && before) {
    throw new import_errors18.FuelError(
      import_errors18.ErrorCode.INVALID_INPUT_PARAMETERS,
      'Pagination arguments "after" and "before" cannot be used together'
    );
  }
  if ((first || 0) > paginationLimit || (last || 0) > paginationLimit) {
    throw new import_errors18.FuelError(
      import_errors18.ErrorCode.INVALID_INPUT_PARAMETERS,
      `Pagination limit for this query cannot exceed ${paginationLimit} items`
    );
  }
  if (first && before) {
    throw new import_errors18.FuelError(
      import_errors18.ErrorCode.INVALID_INPUT_PARAMETERS,
      'The use of pagination argument "first" with "before" is not supported'
    );
  }
  if (last && after) {
    throw new import_errors18.FuelError(
      import_errors18.ErrorCode.INVALID_INPUT_PARAMETERS,
      'The use of pagination argument "last" with "after" is not supported'
    );
  }
  if (!first && !last) {
    inputArgs.first = paginationLimit;
  }
  return inputArgs;
};

// src/providers/provider.ts
var MAX_RETRIES = 10;
var RESOURCES_PAGE_SIZE_LIMIT = 512;
var TRANSACTIONS_PAGE_SIZE_LIMIT = 60;
var BLOCKS_PAGE_SIZE_LIMIT = 5;
var DEFAULT_RESOURCE_CACHE_TTL = 2e4;
var GAS_USED_MODIFIER = 1.2;
var processGqlChain = (chain) => {
  const { name, daHeight, consensusParameters } = chain;
  const {
    contractParams,
    feeParams,
    predicateParams,
    scriptParams,
    txParams,
    gasCosts,
    baseAssetId,
    chainId,
    version
  } = consensusParameters;
  return {
    name,
    baseChainHeight: (0, import_math18.bn)(daHeight),
    consensusParameters: {
      version,
      chainId: (0, import_math18.bn)(chainId),
      baseAssetId,
      feeParameters: {
        version: feeParams.version,
        gasPerByte: (0, import_math18.bn)(feeParams.gasPerByte),
        gasPriceFactor: (0, import_math18.bn)(feeParams.gasPriceFactor)
      },
      contractParameters: {
        version: contractParams.version,
        contractMaxSize: (0, import_math18.bn)(contractParams.contractMaxSize),
        maxStorageSlots: (0, import_math18.bn)(contractParams.maxStorageSlots)
      },
      txParameters: {
        version: txParams.version,
        maxInputs: (0, import_math18.bn)(txParams.maxInputs),
        maxOutputs: (0, import_math18.bn)(txParams.maxOutputs),
        maxWitnesses: (0, import_math18.bn)(txParams.maxWitnesses),
        maxGasPerTx: (0, import_math18.bn)(txParams.maxGasPerTx),
        maxSize: (0, import_math18.bn)(txParams.maxSize),
        maxBytecodeSubsections: (0, import_math18.bn)(txParams.maxBytecodeSubsections)
      },
      predicateParameters: {
        version: predicateParams.version,
        maxPredicateLength: (0, import_math18.bn)(predicateParams.maxPredicateLength),
        maxPredicateDataLength: (0, import_math18.bn)(predicateParams.maxPredicateDataLength),
        maxGasPerPredicate: (0, import_math18.bn)(predicateParams.maxGasPerPredicate),
        maxMessageDataLength: (0, import_math18.bn)(predicateParams.maxMessageDataLength)
      },
      scriptParameters: {
        version: scriptParams.version,
        maxScriptLength: (0, import_math18.bn)(scriptParams.maxScriptLength),
        maxScriptDataLength: (0, import_math18.bn)(scriptParams.maxScriptDataLength)
      },
      gasCosts
    }
  };
};
var _cacheInputs, cacheInputs_fn;
var _Provider = class {
  /**
   * Constructor to initialize a Provider.
   *
   * @param url - GraphQL endpoint of the Fuel node
   * @param options - Additional options for the provider
   * @hidden
   */
  constructor(url, options = {}) {
    /**
     * @hidden
     */
    __privateAdd(this, _cacheInputs);
    __publicField(this, "operations");
    __publicField(this, "cache");
    /** @hidden */
    __publicField(this, "url");
    /** @hidden */
    __publicField(this, "urlWithoutAuth");
    /** @hidden */
    __publicField(this, "consensusParametersTimestamp");
    __publicField(this, "options", {
      timeout: void 0,
      resourceCacheTTL: void 0,
      fetch: void 0,
      retryOptions: void 0,
      headers: void 0
    });
    const { url: rawUrl, urlWithoutAuth, headers: authHeaders } = _Provider.extractBasicAuth(url);
    this.url = rawUrl;
    this.urlWithoutAuth = urlWithoutAuth;
    this.url = url;
    const { FUELS } = import_versions.versions;
    const headers = { ...authHeaders, ...options.headers, Source: `ts-sdk-${FUELS}` };
    this.options = {
      ...this.options,
      ...options,
      headers
    };
    this.operations = this.createOperations();
    const { resourceCacheTTL } = this.options;
    if ((0, import_utils28.isDefined)(resourceCacheTTL)) {
      if (resourceCacheTTL !== -1) {
        this.cache = new ResourceCache(resourceCacheTTL);
      } else {
        this.cache = void 0;
      }
    } else {
      this.cache = new ResourceCache(DEFAULT_RESOURCE_CACHE_TTL);
    }
  }
  /** @hidden */
  static clearChainAndNodeCaches() {
    _Provider.nodeInfoCache = {};
    _Provider.chainInfoCache = {};
  }
  /**
   * @hidden
   */
  static getFetchFn(options) {
    const { retryOptions, timeout, headers } = options;
    return autoRetryFetch(async (...args) => {
      const url = args[0];
      const request = args[1];
      const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
      let fullRequest = {
        ...request,
        signal,
        headers: { ...request?.headers, ...headers }
      };
      if (options.requestMiddleware) {
        fullRequest = await options.requestMiddleware(fullRequest);
      }
      return options.fetch ? options.fetch(url, fullRequest, options) : fetch(url, fullRequest);
    }, retryOptions);
  }
  static extractBasicAuth(url) {
    let parsedUrl;
    try {
      parsedUrl = new URL(url);
    } catch (error) {
      throw new import_errors19.FuelError(import_errors19.FuelError.CODES.INVALID_URL, "Invalid URL provided.", { url }, error);
    }
    const username = parsedUrl.username;
    const password = parsedUrl.password;
    const urlWithoutAuth = `${parsedUrl.origin}${parsedUrl.pathname}`;
    if (!(username && password)) {
      return { url, urlWithoutAuth: url, headers: void 0 };
    }
    return {
      url,
      urlWithoutAuth,
      headers: { Authorization: `Basic ${btoa(`${username}:${password}`)}` }
    };
  }
  /**
   * Initialize Provider async stuff
   */
  async init() {
    await this.fetchChainAndNodeInfo();
    return this;
  }
  /**
   * Returns the `chainInfo` for the current network.
   *
   * @returns the chain information configuration.
   */
  async getChain() {
    await this.init();
    return _Provider.chainInfoCache[this.urlWithoutAuth];
  }
  /**
   * Returns the `nodeInfo` for the current network.
   *
   * @returns the node information configuration.
   */
  async getNode() {
    await this.init();
    return _Provider.nodeInfoCache[this.urlWithoutAuth];
  }
  /**
   * Returns some helpful parameters related to gas fees.
   */
  async getGasConfig() {
    const {
      txParameters: { maxGasPerTx },
      predicateParameters: { maxGasPerPredicate },
      feeParameters: { gasPriceFactor, gasPerByte },
      gasCosts
    } = (await this.getChain()).consensusParameters;
    return {
      maxGasPerTx,
      maxGasPerPredicate,
      gasPriceFactor,
      gasPerByte,
      gasCosts
    };
  }
  /**
   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
   *
   * @param url - The URL to connect to.
   * @param options - Additional options for the provider.
   */
  async connect(url, options) {
    const { url: rawUrl, urlWithoutAuth, headers } = _Provider.extractBasicAuth(url);
    this.url = rawUrl;
    this.urlWithoutAuth = urlWithoutAuth;
    this.options = options ?? this.options;
    this.options = { ...this.options, headers: { ...this.options.headers, ...headers } };
    this.operations = this.createOperations();
    await this.init();
  }
  /**
   * Return the chain and node information.
   * @param ignoreCache - If true, ignores the cache and re-fetch configs.
   * @returns A promise that resolves to the Chain and NodeInfo.
   */
  async fetchChainAndNodeInfo(ignoreCache = false) {
    let nodeInfo;
    let chain;
    try {
      nodeInfo = _Provider.nodeInfoCache[this.urlWithoutAuth];
      chain = _Provider.chainInfoCache[this.urlWithoutAuth];
      const noCache = !nodeInfo || !chain;
      if (ignoreCache || noCache) {
        throw new Error(`Jumps to the catch block and re-fetch`);
      }
    } catch (_err) {
      const data = await this.operations.getChainAndNodeInfo();
      nodeInfo = {
        maxDepth: (0, import_math18.bn)(data.nodeInfo.maxDepth),
        maxTx: (0, import_math18.bn)(data.nodeInfo.maxTx),
        nodeVersion: data.nodeInfo.nodeVersion,
        utxoValidation: data.nodeInfo.utxoValidation,
        vmBacktrace: data.nodeInfo.vmBacktrace
      };
      _Provider.ensureClientVersionIsSupported(nodeInfo);
      chain = processGqlChain(data.chain);
      _Provider.chainInfoCache[this.urlWithoutAuth] = chain;
      _Provider.nodeInfoCache[this.urlWithoutAuth] = nodeInfo;
      this.consensusParametersTimestamp = Date.now();
    }
    return {
      chain,
      nodeInfo
    };
  }
  /**
   * @hidden
   */
  static ensureClientVersionIsSupported(nodeInfo) {
    const { isMajorSupported, isMinorSupported, supportedVersion } = (0, import_versions.checkFuelCoreVersionCompatibility)(nodeInfo.nodeVersion);
    if (!isMajorSupported || !isMinorSupported) {
      console.warn(
        `The Fuel Node that you are trying to connect to is using fuel-core version ${nodeInfo.nodeVersion},
which is not supported by the version of the TS SDK that you are using.
Things may not work as expected.
Supported fuel-core version: ${supportedVersion}.`
      );
    }
  }
  /**
   * Create GraphQL client and set operations.
   *
   * @returns The operation SDK object
   * @hidden
   */
  createOperations() {
    const fetchFn = _Provider.getFetchFn(this.options);
    const gqlClient = new import_graphql_request.GraphQLClient(this.urlWithoutAuth, {
      fetch: (input, requestInit) => fetchFn(input.toString(), requestInit || {}, this.options),
      responseMiddleware: (response) => {
        if ("response" in response) {
          const graphQlResponse = response.response;
          if (Array.isArray(graphQlResponse?.errors)) {
            for (const error of graphQlResponse.errors) {
              handleGqlErrorMessage(error.message, error);
            }
          }
        }
      }
    });
    const executeQuery = (query, vars) => {
      const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
      const isSubscription = opDefinition?.operation === "subscription";
      if (isSubscription) {
        return FuelGraphqlSubscriber.create({
          url: this.urlWithoutAuth,
          query,
          fetchFn: (url, requestInit) => fetchFn(url, requestInit, this.options),
          variables: vars
        });
      }
      return gqlClient.request(query, vars);
    };
    const customOperations = (requester) => ({
      getBlobs(variables) {
        const queryParams = variables.blobIds.map((_, i) => `$blobId${i}: BlobId!`).join(", ");
        const blobParams = variables.blobIds.map((_, i) => `blob${i}: blob(id: $blobId${i}) { id }`).join("\n");
        const updatedVariables = variables.blobIds.reduce(
          (acc, blobId, i) => {
            acc[`blobId${i}`] = blobId;
            return acc;
          },
          {}
        );
        const document2 = import_graphql_tag2.default`
          query getBlobs(${queryParams}) {
            ${blobParams}
          }
        `;
        return requester(document2, updatedVariables);
      }
    });
    return { ...getSdk(executeQuery), ...customOperations(executeQuery) };
  }
  /**
   * Returns the version of the connected node.
   *
   * @returns A promise that resolves to the version string.
   */
  async getVersion() {
    const {
      nodeInfo: { nodeVersion }
    } = await this.operations.getVersion();
    return nodeVersion;
  }
  /**
   * Returns the latest block number.
   *
   * @returns A promise that resolves to the latest block number.
   */
  async getBlockNumber() {
    const {
      chain: {
        latestBlock: { height }
      }
    } = await this.operations.getLatestBlockHeight();
    return (0, import_math18.bn)(height);
  }
  /**
   * Returns the node information for the current provider network.
   *
   * @returns a promise that resolves to the node information.
   */
  async fetchNode() {
    const { nodeInfo } = await this.operations.getNodeInfo();
    const processedNodeInfo = {
      maxDepth: (0, import_math18.bn)(nodeInfo.maxDepth),
      maxTx: (0, import_math18.bn)(nodeInfo.maxTx),
      nodeVersion: nodeInfo.nodeVersion,
      utxoValidation: nodeInfo.utxoValidation,
      vmBacktrace: nodeInfo.vmBacktrace
    };
    _Provider.nodeInfoCache[this.urlWithoutAuth] = processedNodeInfo;
    return processedNodeInfo;
  }
  /**
   * Returns the chain information for the current provider network.
   *
   * @returns a promise that resolves to the chain information.
   */
  async fetchChain() {
    const { chain } = await this.operations.getChain();
    const processedChain = processGqlChain(chain);
    _Provider.chainInfoCache[this.urlWithoutAuth] = processedChain;
    return processedChain;
  }
  /**
   * Returns the chain ID for the current provider network.
   *
   * @returns A promise that resolves to the chain ID number.
   */
  async getChainId() {
    const {
      consensusParameters: { chainId }
    } = await this.getChain();
    return chainId.toNumber();
  }
  /**
   * Returns the base asset ID for the current provider network.
   *
   * @returns the base asset ID.
   */
  async getBaseAssetId() {
    const all = await this.getChain();
    const {
      consensusParameters: { baseAssetId }
    } = all;
    return baseAssetId;
  }
  /**
   * @hidden
   */
  async validateTransaction(tx) {
    const {
      consensusParameters: {
        txParameters: { maxInputs, maxOutputs }
      }
    } = await this.getChain();
    if ((0, import_math18.bn)(tx.inputs.length).gt(maxInputs)) {
      throw new import_errors19.FuelError(
        import_errors19.ErrorCode.MAX_INPUTS_EXCEEDED,
        `The transaction exceeds the maximum allowed number of inputs. Tx inputs: ${tx.inputs.length}, max inputs: ${maxInputs}`
      );
    }
    if ((0, import_math18.bn)(tx.outputs.length).gt(maxOutputs)) {
      throw new import_errors19.FuelError(
        import_errors19.ErrorCode.MAX_OUTPUTS_EXCEEDED,
        `The transaction exceeds the maximum allowed number of outputs. Tx outputs: ${tx.outputs.length}, max outputs: ${maxOutputs}`
      );
    }
  }
  /**
   * Submits a transaction to the chain to be executed.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param sendTransactionParams - The provider send transaction parameters (optional).
   * @returns A promise that resolves to the transaction response object.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, enableAssetBurn } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    validateTransactionForAssetBurn(
      await this.getBaseAssetId(),
      transactionRequest,
      enableAssetBurn
    );
    if (estimateTxDependencies) {
      await this.estimateTxDependencies(transactionRequest);
    }
    await this.validateTransaction(transactionRequest);
    const encodedTransaction = (0, import_utils28.hexlify)(transactionRequest.toTransactionBytes());
    let abis;
    if (isTransactionTypeScript(transactionRequest)) {
      abis = transactionRequest.abis;
    }
    const subscription = await this.operations.submitAndAwaitStatus({ encodedTransaction });
    __privateMethod(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs, transactionRequest.getTransactionId(await this.getChainId()));
    const chainId = await this.getChainId();
    return new TransactionResponse(transactionRequest, this, chainId, abis, subscription);
  }
  /**
   * Executes a transaction without actually submitting it to the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param sendTransactionParams - The provider call parameters (optional).
   * @returns A promise that resolves to the call result object.
   */
  async dryRun(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = (0, import_utils28.hexlify)(transactionRequest.toTransactionBytes());
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions: encodedTransaction,
      utxoValidation: utxoValidation || false
    });
    const [{ receipts: rawReceipts, status: dryRunStatus }] = dryRunStatuses;
    const receipts = rawReceipts.map(processGqlReceipt);
    return { receipts, dryRunStatus };
  }
  /**
   * Verifies whether enough gas is available to complete transaction.
   *
   * @template T - The type of the transaction request object.
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise that resolves to the estimated transaction request object.
   */
  async estimatePredicates(transactionRequest) {
    const shouldEstimatePredicates = Boolean(
      transactionRequest.inputs.find(
        (input) => "predicate" in input && input.predicate && !(0, import_utils29.equalBytes)((0, import_utils28.arrayify)(input.predicate), (0, import_utils28.arrayify)("0x")) && new import_math18.BN(input.predicateGasUsed).isZero()
      )
    );
    if (!shouldEstimatePredicates) {
      return transactionRequest;
    }
    const encodedTransaction = (0, import_utils28.hexlify)(transactionRequest.toTransactionBytes());
    const response = await this.operations.estimatePredicates({
      encodedTransaction
    });
    const {
      estimatePredicates: { inputs }
    } = response;
    if (inputs) {
      inputs.forEach((input, index) => {
        if ("predicateGasUsed" in input && (0, import_math18.bn)(input.predicateGasUsed).gt(0)) {
          transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
        }
      });
    }
    return transactionRequest;
  }
  /**
   * Will dryRun a transaction and check for missing dependencies.
   *
   * If there are missing variable outputs,
   * `addVariableOutputs` is called on the transaction.
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise that resolves to the estimate transaction dependencies.
   */
  async estimateTxDependencies(transactionRequest) {
    if (isTransactionTypeCreate(transactionRequest)) {
      return {
        receipts: [],
        outputVariables: 0,
        missingContractIds: []
      };
    }
    let receipts = [];
    const missingContractIds = [];
    let outputVariables = 0;
    let dryRunStatus;
    await this.validateTransaction(transactionRequest);
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      const {
        dryRun: [{ receipts: rawReceipts, status }]
      } = await this.operations.dryRun({
        encodedTransactions: [(0, import_utils28.hexlify)(transactionRequest.toTransactionBytes())],
        utxoValidation: false,
        gasPrice: "0"
      });
      receipts = rawReceipts.map(processGqlReceipt);
      dryRunStatus = status;
      const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
      const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
      if (hasMissingOutputs && isTransactionTypeScript(transactionRequest)) {
        outputVariables += missingOutputVariables.length;
        transactionRequest.addVariableOutputs(missingOutputVariables.length);
        missingOutputContractIds.forEach(({ contractId }) => {
          transactionRequest.addContractInputAndOutput(import_address3.Address.fromString(contractId));
          missingContractIds.push(contractId);
        });
        const { maxFee } = await this.estimateTxGasAndFee({
          transactionRequest,
          gasPrice: (0, import_math18.bn)(0)
        });
        transactionRequest.maxFee = maxFee;
      } else {
        break;
      }
    }
    return {
      receipts,
      outputVariables,
      missingContractIds,
      dryRunStatus
    };
  }
  /**
   * Dry runs multiple transactions and checks for missing dependencies in batches.
   *
   * Transactions are dry run in batches. After each dry run, transactions requiring
   * further modifications are identified. The method iteratively updates these transactions
   * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
   *
   * @param transactionRequests - Array of transaction request objects.
   * @returns A promise that resolves to an array of results for each transaction.
   */
  async estimateMultipleTxDependencies(transactionRequests) {
    const results = transactionRequests.map(() => ({
      receipts: [],
      outputVariables: 0,
      missingContractIds: [],
      dryRunStatus: void 0
    }));
    const allRequests = (0, import_ramda8.clone)(transactionRequests);
    const serializedTransactionsMap = /* @__PURE__ */ new Map();
    allRequests.forEach((req, index) => {
      if (isTransactionTypeScript(req)) {
        serializedTransactionsMap.set(index, (0, import_utils28.hexlify)(req.toTransactionBytes()));
      }
    });
    let transactionsToProcess = Array.from(serializedTransactionsMap.keys());
    let attempt = 0;
    while (transactionsToProcess.length > 0 && attempt < MAX_RETRIES) {
      const encodedTransactions = transactionsToProcess.map(
        (index) => serializedTransactionsMap.get(index)
      );
      const dryRunResults = await this.operations.dryRun({
        encodedTransactions,
        utxoValidation: false
      });
      const nextRoundTransactions = [];
      for (let i = 0; i < dryRunResults.dryRun.length; i++) {
        const requestIdx = transactionsToProcess[i];
        const { receipts: rawReceipts, status } = dryRunResults.dryRun[i];
        const result = results[requestIdx];
        result.receipts = rawReceipts.map(processGqlReceipt);
        result.dryRunStatus = status;
        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(
          result.receipts
        );
        const hasMissingOutputs = missingOutputVariables.length > 0 || missingOutputContractIds.length > 0;
        const request = allRequests[requestIdx];
        if (hasMissingOutputs && isTransactionTypeScript(request)) {
          result.outputVariables += missingOutputVariables.length;
          request.addVariableOutputs(missingOutputVariables.length);
          missingOutputContractIds.forEach(({ contractId }) => {
            request.addContractInputAndOutput(import_address3.Address.fromString(contractId));
            result.missingContractIds.push(contractId);
          });
          const { maxFee } = await this.estimateTxGasAndFee({
            transactionRequest: request
          });
          request.maxFee = maxFee;
          serializedTransactionsMap.set(requestIdx, (0, import_utils28.hexlify)(request.toTransactionBytes()));
          nextRoundTransactions.push(requestIdx);
        }
      }
      transactionsToProcess = nextRoundTransactions;
      attempt += 1;
    }
    return results;
  }
  /**
   * Dry runs multiple transactions.
   *
   * @param transactionRequests - Array of transaction request objects.
   * @param sendTransactionParams - The provider call parameters (optional).
   *
   * @returns A promise that resolves to an array of results for each transaction call.
   */
  async dryRunMultipleTransactions(transactionRequests, { utxoValidation, estimateTxDependencies = true } = {}) {
    if (estimateTxDependencies) {
      return this.estimateMultipleTxDependencies(transactionRequests);
    }
    const encodedTransactions = transactionRequests.map((tx) => (0, import_utils28.hexlify)(tx.toTransactionBytes()));
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions,
      utxoValidation: utxoValidation || false
    });
    const results = dryRunStatuses.map(({ receipts: rawReceipts, status }) => {
      const receipts = rawReceipts.map(processGqlReceipt);
      return { receipts, dryRunStatus: status };
    });
    return results;
  }
  async autoRefetchConfigs() {
    const now = Date.now();
    const diff = now - (this.consensusParametersTimestamp ?? 0);
    if (diff < 6e4) {
      return;
    }
    if (!_Provider.chainInfoCache?.[this.urlWithoutAuth]) {
      await this.fetchChainAndNodeInfo(true);
      return;
    }
    const chainInfo = _Provider.chainInfoCache[this.urlWithoutAuth];
    const {
      consensusParameters: { version: previous }
    } = chainInfo;
    const {
      chain: {
        latestBlock: {
          header: { consensusParametersVersion: current }
        }
      }
    } = await this.operations.getConsensusParametersVersion();
    if (previous !== current) {
      await this.fetchChainAndNodeInfo(true);
    }
  }
  /**
   * Estimates the transaction gas and fee based on the provided transaction request.
   * @param transactionRequest - The transaction request object.
   * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
   */
  async estimateTxGasAndFee(params) {
    const { transactionRequest } = params;
    let { gasPrice } = params;
    await this.autoRefetchConfigs();
    const chainInfo = await this.getChain();
    const { gasPriceFactor, maxGasPerTx } = await this.getGasConfig();
    const minGas = transactionRequest.calculateMinGas(chainInfo);
    if (!(0, import_utils28.isDefined)(gasPrice)) {
      gasPrice = await this.estimateGasPrice(10);
    }
    const minFee = calculateGasFee({
      gasPrice: (0, import_math18.bn)(gasPrice),
      gas: minGas,
      priceFactor: gasPriceFactor,
      tip: transactionRequest.tip
    }).add(1);
    let gasLimit = (0, import_math18.bn)(0);
    if (isTransactionTypeScript(transactionRequest)) {
      gasLimit = transactionRequest.gasLimit;
      if (transactionRequest.gasLimit.eq(0)) {
        transactionRequest.gasLimit = minGas;
        transactionRequest.gasLimit = maxGasPerTx.sub(
          transactionRequest.calculateMaxGas(chainInfo, minGas)
        );
        gasLimit = transactionRequest.gasLimit;
      }
    }
    const maxGas = transactionRequest.calculateMaxGas(chainInfo, minGas);
    const maxFee = calculateGasFee({
      gasPrice: (0, import_math18.bn)(gasPrice),
      gas: maxGas,
      priceFactor: gasPriceFactor,
      tip: transactionRequest.tip
    }).add(1);
    return {
      minGas,
      minFee,
      maxGas,
      maxFee,
      gasPrice,
      gasLimit
    };
  }
  /**
   * Executes a signed transaction without applying the states changes
   * on the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added
   *
   * @param transactionRequestLike - The transaction request object.
   * @param estimateTxParams - The estimate transaction params (optional).
   * @returns A promise that resolves to the call result object.
   */
  async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransactions = [(0, import_utils28.hexlify)(transactionRequest.toTransactionBytes())];
    const { dryRun: dryRunStatuses } = await this.operations.dryRun({
      encodedTransactions,
      utxoValidation: true
    });
    const callResult = dryRunStatuses.map((dryRunStatus) => {
      const { id, receipts, status } = dryRunStatus;
      const processedReceipts = receipts.map(processGqlReceipt);
      return { id, receipts: processedReceipts, status };
    });
    return { receipts: callResult[0].receipts };
  }
  /**
   * @hidden
   *
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the transaction.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param transactionCostParams - The transaction cost parameters (optional).
   *
   * @returns A promise that resolves to the transaction cost object.
   */
  async getTransactionCost(transactionRequestLike, { signatureCallback } = {}) {
    const txRequestClone = (0, import_ramda8.clone)(transactionRequestify(transactionRequestLike));
    const updateMaxFee = txRequestClone.maxFee.eq(0);
    const isScriptTransaction = isTransactionTypeScript(txRequestClone);
    if (isScriptTransaction) {
      txRequestClone.gasLimit = (0, import_math18.bn)(0);
    }
    const signedRequest = (0, import_ramda8.clone)(txRequestClone);
    let addedSignatures = 0;
    if (signatureCallback && isTransactionTypeScript(signedRequest)) {
      const lengthBefore = signedRequest.witnesses.length;
      await signatureCallback(signedRequest);
      addedSignatures = signedRequest.witnesses.length - lengthBefore;
    }
    await this.estimatePredicates(signedRequest);
    txRequestClone.updatePredicateGasUsed(signedRequest.inputs);
    let { maxFee, maxGas, minFee, minGas, gasPrice, gasLimit } = await this.estimateTxGasAndFee({
      transactionRequest: signedRequest
    });
    let receipts = [];
    let dryRunStatus;
    let missingContractIds = [];
    let outputVariables = 0;
    let gasUsed = (0, import_math18.bn)(0);
    txRequestClone.maxFee = maxFee;
    if (isScriptTransaction) {
      txRequestClone.gasLimit = gasLimit;
      if (signatureCallback) {
        await signatureCallback(txRequestClone);
      }
      ({ receipts, missingContractIds, outputVariables, dryRunStatus } = await this.estimateTxDependencies(txRequestClone));
      if (dryRunStatus && "reason" in dryRunStatus) {
        throw this.extractDryRunError(txRequestClone, receipts, dryRunStatus);
      }
      const { maxGasPerTx } = await this.getGasConfig();
      const pristineGasUsed = getGasUsedFromReceipts(receipts);
      gasUsed = (0, import_math18.bn)(pristineGasUsed.muln(GAS_USED_MODIFIER)).max(maxGasPerTx.sub(minGas));
      txRequestClone.gasLimit = gasUsed;
      ({ maxFee, maxGas, minFee, minGas, gasPrice } = await this.estimateTxGasAndFee({
        transactionRequest: txRequestClone,
        gasPrice
      }));
    }
    return {
      receipts,
      gasUsed,
      gasPrice,
      minGas,
      maxGas,
      minFee,
      maxFee,
      outputVariables,
      missingContractIds,
      addedSignatures,
      estimatedPredicates: txRequestClone.inputs,
      dryRunStatus,
      updateMaxFee
    };
  }
  /**
   * Returns coins for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get (optional).
   * @param paginationArgs - Pagination arguments (optional).
   *
   * @returns A promise that resolves to the coins.
   */
  async getCoins(owner, assetId, paginationArgs) {
    const ownerAddress = import_address3.Address.fromAddressOrString(owner);
    const {
      coins: { edges, pageInfo }
    } = await this.operations.getCoins({
      ...validatePaginationArgs({
        paginationLimit: RESOURCES_PAGE_SIZE_LIMIT,
        inputArgs: paginationArgs
      }),
      filter: { owner: ownerAddress.toB256(), assetId: assetId && (0, import_utils28.hexlify)(assetId) }
    });
    const coins = edges.map(({ node }) => ({
      id: node.utxoId,
      assetId: node.assetId,
      amount: (0, import_math18.bn)(node.amount),
      owner: ownerAddress,
      blockCreated: (0, import_math18.bn)(node.blockCreated),
      txCreatedIdx: (0, import_math18.bn)(node.txCreatedIdx)
    }));
    return {
      coins,
      pageInfo
    };
  }
  /**
   * Returns resources for the given owner satisfying the spend query.
   *
   * @param owner - The address to get resources for.
   * @param quantities - The coin quantities to get.
   * @param excludedIds - IDs of excluded resources from the selection (optional).
   * @returns A promise that resolves to the resources.
   */
  async getResourcesToSpend(owner, quantities, excludedIds) {
    const ownerAddress = import_address3.Address.fromAddressOrString(owner);
    const excludeInput = {
      messages: excludedIds?.messages?.map((nonce) => (0, import_utils28.hexlify)(nonce)) || [],
      utxos: excludedIds?.utxos?.map((id) => (0, import_utils28.hexlify)(id)) || []
    };
    if (this.cache) {
      const cached = this.cache.getActiveData();
      excludeInput.messages.push(...cached.messages);
      excludeInput.utxos.push(...cached.utxos);
    }
    const coinsQuery = {
      owner: ownerAddress.toB256(),
      queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
        assetId: (0, import_utils28.hexlify)(assetId),
        amount: amount.toString(10),
        max: maxPerAsset ? maxPerAsset.toString(10) : void 0
      })),
      excludedIds: excludeInput
    };
    const result = await this.operations.getCoinsToSpend(coinsQuery);
    const coins = result.coinsToSpend.flat().map((coin) => {
      switch (coin.type) {
        case "MessageCoin":
          return {
            amount: (0, import_math18.bn)(coin.amount),
            assetId: coin.assetId,
            daHeight: (0, import_math18.bn)(coin.daHeight),
            sender: import_address3.Address.fromAddressOrString(coin.sender),
            recipient: import_address3.Address.fromAddressOrString(coin.recipient),
            nonce: coin.nonce
          };
        case "Coin":
          return {
            id: coin.utxoId,
            amount: (0, import_math18.bn)(coin.amount),
            assetId: coin.assetId,
            owner: ownerAddress,
            blockCreated: (0, import_math18.bn)(coin.blockCreated),
            txCreatedIdx: (0, import_math18.bn)(coin.txCreatedIdx)
          };
        default:
          return null;
      }
    }).filter((v) => !!v);
    return coins;
  }
  /**
   * Returns an array of blobIds that exist on chain, for a given array of blobIds.
   *
   * @param blobIds - blobIds to check.
   * @returns - A promise that resolves to an array of blobIds that exist on chain.
   */
  async getBlobs(blobIds) {
    const res = await this.operations.getBlobs({ blobIds });
    const blobs = [];
    Object.keys(res).forEach((key) => {
      const val = res[key];
      blobs.push(val?.id ?? null);
    });
    return blobs.filter((v) => v);
  }
  /**
   * Returns block matching the given ID or height.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block or null.
   */
  async getBlock(idOrHeight) {
    let block;
    if (idOrHeight === "latest") {
      const {
        chain: { latestBlock }
      } = await this.operations.getLatestBlock();
      block = latestBlock;
    } else {
      const isblockId = typeof idOrHeight === "string" && idOrHeight.length === 66;
      const variables = isblockId ? { blockId: idOrHeight } : { height: (0, import_math18.bn)(idOrHeight).toString(10) };
      const response = await this.operations.getBlock(variables);
      block = response.block;
    }
    if (!block) {
      return null;
    }
    const { header, height, id, transactions } = block;
    return {
      id,
      height: (0, import_math18.bn)(height),
      time: header.time,
      header: {
        applicationHash: header.applicationHash,
        daHeight: (0, import_math18.bn)(header.daHeight),
        eventInboxRoot: header.eventInboxRoot,
        messageOutboxRoot: header.messageOutboxRoot,
        prevRoot: header.prevRoot,
        stateTransitionBytecodeVersion: header.stateTransitionBytecodeVersion,
        transactionsCount: header.transactionsCount,
        transactionsRoot: header.transactionsRoot
      },
      transactionIds: transactions.map((tx) => tx.id)
    };
  }
  /**
   * Returns all the blocks matching the given parameters.
   *
   * @param params - The parameters to query blocks.
   * @returns A promise that resolves to the blocks.
   */
  async getBlocks(params) {
    const {
      blocks: { edges, pageInfo }
    } = await this.operations.getBlocks({
      ...validatePaginationArgs({
        paginationLimit: BLOCKS_PAGE_SIZE_LIMIT,
        inputArgs: params
      })
    });
    const blocks = edges.map(({ node: block }) => ({
      id: block.id,
      height: (0, import_math18.bn)(block.height),
      time: block.header.time,
      header: {
        applicationHash: block.header.applicationHash,
        daHeight: (0, import_math18.bn)(block.header.daHeight),
        eventInboxRoot: block.header.eventInboxRoot,
        messageOutboxRoot: block.header.messageOutboxRoot,
        prevRoot: block.header.prevRoot,
        stateTransitionBytecodeVersion: block.header.stateTransitionBytecodeVersion,
        transactionsCount: block.header.transactionsCount,
        transactionsRoot: block.header.transactionsRoot
      },
      transactionIds: block.transactions.map((tx) => tx.id)
    }));
    return { blocks, pageInfo };
  }
  /**
   * Returns block matching the given ID or type, including transaction data.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlockWithTransactions(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { blockHeight: (0, import_math18.bn)(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { blockHeight: (await this.getBlockNumber()).toString() };
    } else {
      variables = { blockId: idOrHeight };
    }
    const { block } = await this.operations.getBlockWithTransactions(variables);
    if (!block) {
      return null;
    }
    return {
      id: block.id,
      height: (0, import_math18.bn)(block.height, 10),
      time: block.header.time,
      header: {
        applicationHash: block.header.applicationHash,
        daHeight: (0, import_math18.bn)(block.header.daHeight),
        eventInboxRoot: block.header.eventInboxRoot,
        messageOutboxRoot: block.header.messageOutboxRoot,
        prevRoot: block.header.prevRoot,
        stateTransitionBytecodeVersion: block.header.stateTransitionBytecodeVersion,
        transactionsCount: block.header.transactionsCount,
        transactionsRoot: block.header.transactionsRoot
      },
      transactionIds: block.transactions.map((tx) => tx.id),
      transactions: block.transactions.map(
        (tx) => new import_transactions22.TransactionCoder().decode((0, import_utils28.arrayify)(tx.rawPayload), 0)?.[0]
      )
    };
  }
  /**
   * Get transaction with the given ID.
   *
   * @param transactionId - ID of the transaction.
   * @returns A promise that resolves to the transaction.
   */
  async getTransaction(transactionId) {
    const { transaction } = await this.operations.getTransaction({ transactionId });
    if (!transaction) {
      return null;
    }
    try {
      return new import_transactions22.TransactionCoder().decode(
        (0, import_utils28.arrayify)(transaction.rawPayload),
        0
      )?.[0];
    } catch (error) {
      if (error instanceof import_errors19.FuelError && error.code === import_errors19.ErrorCode.UNSUPPORTED_TRANSACTION_TYPE) {
        console.warn("Unsupported transaction type encountered");
        return null;
      }
      throw error;
    }
  }
  /**
   * Retrieves transactions based on the provided pagination arguments.
   * @param paginationArgs - The pagination arguments for retrieving transactions.
   * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.
   */
  async getTransactions(paginationArgs) {
    const {
      transactions: { edges, pageInfo }
    } = await this.operations.getTransactions({
      ...validatePaginationArgs({
        inputArgs: paginationArgs,
        paginationLimit: TRANSACTIONS_PAGE_SIZE_LIMIT
      })
    });
    const coder = new import_transactions22.TransactionCoder();
    const transactions = edges.map(({ node: { rawPayload } }) => {
      try {
        return coder.decode((0, import_utils28.arrayify)(rawPayload), 0)[0];
      } catch (error) {
        if (error instanceof import_errors19.FuelError && error.code === import_errors19.ErrorCode.UNSUPPORTED_TRANSACTION_TYPE) {
          console.warn("Unsupported transaction type encountered");
          return null;
        }
        throw error;
      }
    }).filter((tx) => tx !== null);
    return { transactions, pageInfo };
  }
  /**
   * Get deployed contract with the given ID.
   *
   * @param contractId - ID of the contract.
   * @returns A promise that resolves to the contract.
   */
  async getContract(contractId) {
    const { contract } = await this.operations.getContract({ contractId });
    if (!contract) {
      return null;
    }
    return contract;
  }
  /**
   * Returns the balance for the given contract for the given asset ID.
   *
   * @param contractId - The contract ID to get the balance for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getContractBalance(contractId, assetId) {
    const { contractBalance } = await this.operations.getContractBalance({
      contract: import_address3.Address.fromAddressOrString(contractId).toB256(),
      asset: (0, import_utils28.hexlify)(assetId)
    });
    return (0, import_math18.bn)(contractBalance.amount, 10);
  }
  /**
   * Returns the balance for the given owner for the given asset ID.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getBalance(owner, assetId) {
    const { balance } = await this.operations.getBalance({
      owner: import_address3.Address.fromAddressOrString(owner).toB256(),
      assetId: (0, import_utils28.hexlify)(assetId)
    });
    return (0, import_math18.bn)(balance.amount, 10);
  }
  /**
   * Returns balances for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param paginationArgs - Pagination arguments (optional).
   * @returns A promise that resolves to the balances.
   */
  async getBalances(owner) {
    const {
      balances: { edges }
    } = await this.operations.getBalances({
      /**
       * The query parameters for this method were designed to support pagination,
       * but the current Fuel-Core implementation does not support pagination yet.
       */
      first: 1e4,
      filter: { owner: import_address3.Address.fromAddressOrString(owner).toB256() }
    });
    const balances = edges.map(({ node }) => ({
      assetId: node.assetId,
      amount: (0, import_math18.bn)(node.amount)
    }));
    return { balances };
  }
  /**
   * Returns message for the given address.
   *
   * @param address - The address to get message from.
   * @param paginationArgs - Pagination arguments (optional).
   * @returns A promise that resolves to the messages.
   */
  async getMessages(address, paginationArgs) {
    const {
      messages: { edges, pageInfo }
    } = await this.operations.getMessages({
      ...validatePaginationArgs({
        inputArgs: paginationArgs,
        paginationLimit: RESOURCES_PAGE_SIZE_LIMIT
      }),
      owner: import_address3.Address.fromAddressOrString(address).toB256()
    });
    const messages = edges.map(({ node }) => ({
      messageId: import_transactions22.InputMessageCoder.getMessageId({
        sender: node.sender,
        recipient: node.recipient,
        nonce: node.nonce,
        amount: (0, import_math18.bn)(node.amount),
        data: node.data
      }),
      sender: import_address3.Address.fromAddressOrString(node.sender),
      recipient: import_address3.Address.fromAddressOrString(node.recipient),
      nonce: node.nonce,
      amount: (0, import_math18.bn)(node.amount),
      data: import_transactions22.InputMessageCoder.decodeData(node.data),
      daHeight: (0, import_math18.bn)(node.daHeight)
    }));
    return {
      messages,
      pageInfo
    };
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param transactionId - The transaction to get message from.
   * @param messageId - The message id from MessageOut receipt.
   * @param commitBlockId - The commit block id (optional).
   * @param commitBlockHeight - The commit block height (optional).
   * @returns A promise that resolves to the message proof.
   */
  async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
    let inputObject = {
      transactionId,
      nonce
    };
    if (commitBlockId && commitBlockHeight) {
      throw new import_errors19.FuelError(
        import_errors19.ErrorCode.INVALID_INPUT_PARAMETERS,
        "commitBlockId and commitBlockHeight cannot be used together"
      );
    }
    if (commitBlockId) {
      inputObject = {
        ...inputObject,
        commitBlockId
      };
    }
    if (commitBlockHeight) {
      inputObject = {
        ...inputObject,
        // Conver BN into a number string required on the query
        // This should problably be fixed on the fuel client side
        commitBlockHeight: commitBlockHeight.toNumber().toString()
      };
    }
    const result = await this.operations.getMessageProof(inputObject);
    if (!result.messageProof) {
      return null;
    }
    const {
      messageProof,
      messageBlockHeader,
      commitBlockHeader,
      blockProof,
      sender,
      recipient,
      amount,
      data
    } = result.messageProof;
    return {
      messageProof: {
        proofIndex: (0, import_math18.bn)(messageProof.proofIndex),
        proofSet: messageProof.proofSet
      },
      blockProof: {
        proofIndex: (0, import_math18.bn)(blockProof.proofIndex),
        proofSet: blockProof.proofSet
      },
      messageBlockHeader: {
        id: messageBlockHeader.id,
        daHeight: (0, import_math18.bn)(messageBlockHeader.daHeight),
        transactionsCount: Number(messageBlockHeader.transactionsCount),
        transactionsRoot: messageBlockHeader.transactionsRoot,
        height: (0, import_math18.bn)(messageBlockHeader.height),
        prevRoot: messageBlockHeader.prevRoot,
        time: messageBlockHeader.time,
        applicationHash: messageBlockHeader.applicationHash,
        messageReceiptCount: Number(messageBlockHeader.messageReceiptCount),
        messageOutboxRoot: messageBlockHeader.messageOutboxRoot,
        consensusParametersVersion: Number(messageBlockHeader.consensusParametersVersion),
        eventInboxRoot: messageBlockHeader.eventInboxRoot,
        stateTransitionBytecodeVersion: Number(messageBlockHeader.stateTransitionBytecodeVersion)
      },
      commitBlockHeader: {
        id: commitBlockHeader.id,
        daHeight: (0, import_math18.bn)(commitBlockHeader.daHeight),
        transactionsCount: Number(commitBlockHeader.transactionsCount),
        transactionsRoot: commitBlockHeader.transactionsRoot,
        height: (0, import_math18.bn)(commitBlockHeader.height),
        prevRoot: commitBlockHeader.prevRoot,
        time: commitBlockHeader.time,
        applicationHash: commitBlockHeader.applicationHash,
        messageReceiptCount: Number(commitBlockHeader.messageReceiptCount),
        messageOutboxRoot: commitBlockHeader.messageOutboxRoot,
        consensusParametersVersion: Number(commitBlockHeader.consensusParametersVersion),
        eventInboxRoot: commitBlockHeader.eventInboxRoot,
        stateTransitionBytecodeVersion: Number(commitBlockHeader.stateTransitionBytecodeVersion)
      },
      sender: import_address3.Address.fromAddressOrString(sender),
      recipient: import_address3.Address.fromAddressOrString(recipient),
      nonce,
      amount: (0, import_math18.bn)(amount),
      data
    };
  }
  /**
   * Get the latest gas price from the node.
   *
   * @returns A promise that resolves to the latest gas price.
   */
  async getLatestGasPrice() {
    const { latestGasPrice } = await this.operations.getLatestGasPrice();
    return (0, import_math18.bn)(latestGasPrice.gasPrice);
  }
  /**
   * Returns the estimate gas price for the given block horizon.
   *
   * @param blockHorizon - The block horizon to estimate gas price for.
   * @returns A promise that resolves to the estimated gas price.
   */
  async estimateGasPrice(blockHorizon) {
    const { estimateGasPrice } = await this.operations.estimateGasPrice({
      blockHorizon: String(blockHorizon)
    });
    return (0, import_math18.bn)(estimateGasPrice.gasPrice);
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param nonce - The nonce of the message to get status from.
   * @returns A promise that resolves to the message status
   */
  async getMessageStatus(nonce) {
    const result = await this.operations.getMessageStatus({ nonce });
    return result.messageStatus;
  }
  /**
   * Lets you produce blocks with custom timestamps and the block number of the last block produced.
   *
   * @param amount - The amount of blocks to produce.
   * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
   * @returns A promise that resolves to the block number of the last produced block.
   */
  async produceBlocks(amount, startTime) {
    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
      blocksToProduce: (0, import_math18.bn)(amount).toString(10),
      startTimestamp: startTime ? import_utils28.DateTime.fromUnixMilliseconds(startTime).toTai64() : void 0
    });
    return (0, import_math18.bn)(latestBlockHeight);
  }
  /**
   * Check if the given ID is an account.
   *
   * @param id - The ID to check.
   * @returns A promise that resolves to the result of the check.
   */
  async isUserAccount(id) {
    const { contract, blob, transaction } = await this.operations.isUserAccount({
      blobId: id,
      contractId: id,
      transactionId: id
    });
    if (contract || blob || transaction) {
      return false;
    }
    return true;
  }
  async getAddressType(id) {
    const { contract, blob, transaction } = await this.operations.isUserAccount({
      blobId: id,
      contractId: id,
      transactionId: id
    });
    if (contract) {
      return "Contract";
    }
    if (blob) {
      return "Blob";
    }
    if (transaction) {
      return "Transaction";
    }
    return "Account";
  }
  /**
   * Get the transaction response for the given transaction ID.
   *
   * @param transactionId - The transaction ID to get the response for.
   * @returns A promise that resolves to the transaction response.
   */
  async getTransactionResponse(transactionId) {
    const chainId = await this.getChainId();
    return new TransactionResponse(transactionId, this, chainId);
  }
  /**
   * Returns Message for given nonce.
   *
   * @param nonce - The nonce of the message to retrieve.
   * @returns A promise that resolves to the Message object or null.
   */
  async getMessageByNonce(nonce) {
    const { message: rawMessage } = await this.operations.getMessageByNonce({ nonce });
    if (!rawMessage) {
      return null;
    }
    const message = {
      messageId: import_transactions22.InputMessageCoder.getMessageId({
        sender: rawMessage.sender,
        recipient: rawMessage.recipient,
        nonce,
        amount: (0, import_math18.bn)(rawMessage.amount),
        data: rawMessage.data
      }),
      sender: import_address3.Address.fromAddressOrString(rawMessage.sender),
      recipient: import_address3.Address.fromAddressOrString(rawMessage.recipient),
      nonce,
      amount: (0, import_math18.bn)(rawMessage.amount),
      data: import_transactions22.InputMessageCoder.decodeData(rawMessage.data),
      daHeight: (0, import_math18.bn)(rawMessage.daHeight)
    };
    return message;
  }
  /**
   * Get the relayed transaction for the given transaction ID.
   *
   * @param relayedTransactionId - The relayed transaction ID to get the response for.
   * @returns A promise that resolves to the relayed transaction.
   */
  async getRelayedTransactionStatus(relayedTransactionId) {
    const { relayedTransactionStatus } = await this.operations.getRelayedTransactionStatus({
      relayedTransactionId
    });
    if (!relayedTransactionStatus) {
      return null;
    }
    return relayedTransactionStatus;
  }
  /**
   * @hidden
   */
  extractDryRunError(transactionRequest, receipts, dryRunStatus) {
    const status = dryRunStatus;
    let logs = [];
    if (transactionRequest.abis) {
      logs = getDecodedLogs(
        receipts,
        transactionRequest.abis.main,
        transactionRequest.abis.otherContractsAbis
      );
    }
    return extractTxError({
      logs,
      receipts,
      statusReason: status.reason
    });
  }
};
var Provider = _Provider;
_cacheInputs = new WeakSet();
cacheInputs_fn = function(inputs, transactionId) {
  if (!this.cache) {
    return;
  }
  const inputsToCache = inputs.reduce(
    (acc, input) => {
      if (input.type === import_transactions22.InputType.Coin) {
        acc.utxos.push(input.id);
      } else if (input.type === import_transactions22.InputType.Message) {
        acc.messages.push(input.nonce);
      }
      return acc;
    },
    { utxos: [], messages: [] }
  );
  this.cache.set(transactionId, inputsToCache);
};
/** @hidden */
__publicField(Provider, "chainInfoCache", {});
/** @hidden */
__publicField(Provider, "nodeInfoCache", {});

// src/providers/transaction-summary/get-transaction-summary.ts
var import_errors20 = require("@fuel-ts/errors");
var import_math19 = require("@fuel-ts/math");
var import_transactions23 = require("@fuel-ts/transactions");
var import_utils31 = require("@fuel-ts/utils");
async function getTransactionSummary(params) {
  const { id, provider, abiMap } = params;
  const { transaction: gqlTransaction } = await provider.operations.getTransactionWithReceipts({
    transactionId: id
  });
  if (!gqlTransaction) {
    throw new import_errors20.FuelError(
      import_errors20.ErrorCode.TRANSACTION_NOT_FOUND,
      `Transaction not found for given id: ${id}.`
    );
  }
  const [decodedTransaction] = new import_transactions23.TransactionCoder().decode(
    (0, import_utils31.arrayify)(gqlTransaction.rawPayload),
    0
  );
  let txReceipts = [];
  if (gqlTransaction?.status && "receipts" in gqlTransaction.status) {
    txReceipts = gqlTransaction.status.receipts;
  }
  const receipts = txReceipts.map(processGqlReceipt);
  const {
    consensusParameters: {
      feeParameters: { gasPerByte, gasPriceFactor },
      txParameters: { maxInputs, maxGasPerTx },
      gasCosts
    }
  } = await provider.getChain();
  const totalFee = getTotalFeeFromStatus(gqlTransaction.status);
  const gasPrice = totalFee ? (0, import_math19.bn)(0) : await provider.getLatestGasPrice();
  const baseAssetId = await provider.getBaseAssetId();
  const transactionInfo = assembleTransactionSummary({
    id: gqlTransaction.id,
    receipts,
    transaction: decodedTransaction,
    transactionBytes: (0, import_utils31.arrayify)(gqlTransaction.rawPayload),
    gqlTransactionStatus: gqlTransaction.status,
    gasPerByte: (0, import_math19.bn)(gasPerByte),
    gasPriceFactor: (0, import_math19.bn)(gasPriceFactor),
    abiMap,
    maxInputs,
    gasCosts,
    maxGasPerTx,
    gasPrice,
    baseAssetId
  });
  return {
    ...transactionInfo
  };
}
async function getTransactionSummaryFromRequest(params) {
  const { provider, transactionRequest, abiMap } = params;
  const { receipts } = await provider.dryRun(transactionRequest);
  const { gasPerByte, gasPriceFactor, gasCosts, maxGasPerTx } = await provider.getGasConfig();
  const maxInputs = (await provider.getChain()).consensusParameters.txParameters.maxInputs;
  const transaction = transactionRequest.toTransaction();
  const transactionBytes = transactionRequest.toTransactionBytes();
  const gasPrice = await provider.getLatestGasPrice();
  const baseAssetId = await provider.getBaseAssetId();
  const transactionSummary = assembleTransactionSummary({
    id: transactionRequest.getTransactionId(await provider.getChainId()),
    receipts,
    transaction,
    transactionBytes,
    abiMap,
    gasPerByte,
    gasPriceFactor,
    maxInputs,
    gasCosts,
    maxGasPerTx,
    gasPrice,
    baseAssetId
  });
  return transactionSummary;
}
async function getTransactionsSummaries(params) {
  const { filters, provider, abiMap } = params;
  const { owner, ...inputArgs } = filters;
  const validPaginationParams = validatePaginationArgs({
    inputArgs,
    paginationLimit: TRANSACTIONS_PAGE_SIZE_LIMIT
  });
  const { transactionsByOwner } = await provider.operations.getTransactionsByOwner({
    ...validPaginationParams,
    owner
  });
  const { edges, pageInfo } = transactionsByOwner;
  const {
    consensusParameters: {
      feeParameters: { gasPerByte, gasPriceFactor },
      txParameters: { maxInputs, maxGasPerTx },
      gasCosts
    }
  } = await provider.getChain();
  const gasPrice = await provider.getLatestGasPrice();
  const baseAssetId = await provider.getBaseAssetId();
  const transactions = edges.map((edge) => {
    const { node: gqlTransaction } = edge;
    const { id, rawPayload, status } = gqlTransaction;
    const [decodedTransaction] = new import_transactions23.TransactionCoder().decode((0, import_utils31.arrayify)(rawPayload), 0);
    let txReceipts = [];
    if (gqlTransaction?.status && "receipts" in gqlTransaction.status) {
      txReceipts = gqlTransaction.status.receipts;
    }
    const receipts = txReceipts.map(processGqlReceipt);
    const transactionSummary = assembleTransactionSummary({
      id,
      receipts,
      transaction: decodedTransaction,
      transactionBytes: (0, import_utils31.arrayify)(rawPayload),
      gqlTransactionStatus: status,
      abiMap,
      gasPerByte,
      gasPriceFactor,
      maxInputs,
      gasCosts,
      maxGasPerTx,
      gasPrice,
      baseAssetId
    });
    const output = {
      ...transactionSummary
    };
    return output;
  });
  return {
    transactions,
    pageInfo
  };
}

// src/providers/chains.ts
var CHAIN_IDS = {
  eth: {
    mainnet: 1,
    sepolia: 11155111,
    foundry: 31337
  },
  fuel: {
    devnet: 0,
    testnet: 0,
    mainnet: 9889
  }
};

// src/providers/assets/utils/network.ts
var getDefaultChainId = (networkType) => {
  if (networkType === "ethereum") {
    return CHAIN_IDS.eth.sepolia;
  }
  if (networkType === "fuel") {
    return CHAIN_IDS.fuel.testnet;
  }
  return void 0;
};
var getAssetNetwork = ({
  asset,
  chainId,
  networkType
}) => {
  const network = asset.networks.find(
    (item) => item.chainId === chainId && item.type === networkType
  );
  return network;
};
var getAssetWithNetwork = ({
  asset,
  chainId,
  networkType
}) => {
  const { networks: _, ...assetRest } = asset;
  const chainIdToUse = chainId ?? getDefaultChainId(networkType);
  if (chainIdToUse === void 0) {
    return void 0;
  }
  const assetNetwork = getAssetNetwork({
    asset,
    chainId: chainIdToUse,
    networkType
  });
  if (!assetNetwork) {
    return void 0;
  }
  return {
    ...assetRest,
    ...assetNetwork
  };
};
var getAssetEth = (asset, chainId) => getAssetWithNetwork({
  asset,
  networkType: "ethereum",
  chainId
});
var getAssetFuel = (asset, chainId) => getAssetWithNetwork({
  asset,
  networkType: "fuel",
  chainId
});

// src/providers/assets/utils/url.ts
var DELIMITER_PATH = "/";
var trimRegex = /^\/|\/$/g;
var trimPath = (path = "") => path.replace(trimRegex, "");
function urlJoin(baseUrl, ...paths) {
  const hasBaseUrl = baseUrl !== null && baseUrl !== void 0;
  const rootPath = baseUrl?.[0] === "/" && baseUrl.length > 1;
  const allPaths = [baseUrl, ...paths].filter(Boolean).map(trimPath);
  if (rootPath && hasBaseUrl) {
    allPaths.unshift("");
  }
  return allPaths.join(DELIMITER_PATH);
}

// src/providers/assets/utils/resolveIconPaths.ts
function resolveIconPaths(assets2, basePath = "./") {
  return assets2.map((asset) => ({
    ...asset,
    icon: urlJoin(basePath, asset.icon)
  }));
}

// src/providers/assets/utils/fuelAssetsBaseUrl.ts
var fuelAssetsBaseUrl = "https://cdn.fuel.network/assets/";

// src/providers/assets/assets.ts
var rawAssets = [
  {
    name: "Ethereum",
    symbol: "ETH",
    icon: "eth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.sepolia,
        decimals: 18
      },
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.foundry,
        decimals: 18
      },
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.devnet,
        decimals: 9,
        assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.testnet,
        decimals: 9,
        assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        decimals: 9,
        assetId: "0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"
      }
    ]
  },
  {
    name: "WETH",
    symbol: "WETH",
    icon: "weth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xa38a5a8beeb08d95744bc7f58528073f4052b254def59eba20c99c202b5acaa3",
        decimals: 9
      }
    ]
  },
  {
    name: "weETH",
    symbol: "weETH",
    icon: "weETH.webp",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x239ed6e12b7ce4089ee245244e3bf906999a6429c2a9a445a1e1faf56914a4ab",
        decimals: 9
      }
    ]
  },
  {
    name: "rsETH",
    symbol: "rsETH",
    icon: "rsETH.webp",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xbae80f7fb8aa6b90d9b01ef726ec847cc4f59419c4d5f2ea88fec785d1b0e849",
        decimals: 9
      }
    ]
  },
  {
    name: "rETH",
    symbol: "rETH",
    icon: "reth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xae78736cd615f374d3085123a210448e74fc6393",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xf3f9a0ed0ce8eac5f89d6b83e41b3848212d5b5f56108c54a205bb228ca30c16",
        decimals: 9
      }
    ]
  },
  {
    name: "wbETH",
    symbol: "wbETH",
    icon: "wbeth.png",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xa2E3356610840701BDf5611a53974510Ae27E2e1",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x7843c74bef935e837f2bcf67b5d64ecb46dd53ff86375530b0caf3699e8ffafe",
        decimals: 9
      }
    ]
  },
  {
    name: "rstETH",
    symbol: "rstETH",
    icon: "rstETH.webp",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x7a4EffD87C2f3C55CA251080b1343b605f327E3a",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x962792286fbc9b1d5860b4551362a12249362c21594c77abf4b3fe2bbe8d977a",
        decimals: 9
      }
    ]
  },
  {
    name: "amphrETH",
    symbol: "amphrETH",
    icon: "amphrETH.png",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x5fD13359Ba15A84B76f7F87568309040176167cd",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x05fc623e57bd7bc1258efa8e4f62b05af5471d73df6f2c2dc11ecc81134c4f36",
        decimals: 9
      }
    ]
  },
  {
    name: "Manta mBTC",
    symbol: "Manta mBTC",
    icon: "manta-mbtc.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x4041381e947CFD3D483d67a25C6aa9Dc924250c5",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xaf3111a248ff7a3238cdeea845bb2d43cf3835f1f6b8c9d28360728b55b9ce5b",
        decimals: 9
      }
    ]
  },
  {
    name: "Manta mETH",
    symbol: "Manta mETH",
    icon: "manta-meth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x8CdF550C04Bc9B9F10938368349C9c8051A772b6",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xafd219f513317b1750783c6581f55530d6cf189a5863fd18bd1b3ffcec1714b4",
        decimals: 9
      }
    ]
  },
  {
    name: "Manta mUSD",
    symbol: "Manta mUSD",
    icon: "manta-musd.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x3f24E1d7a973867fC2A03fE199E5502514E0e11E",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x89cb9401e55d49c3269654dd1cdfb0e80e57823a4a7db98ba8fc5953b120fef4",
        decimals: 9
      }
    ]
  },
  {
    name: "pumpBTC",
    symbol: "pumpBTC",
    icon: "pumpbtc.webp",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xf469fbd2abcd6b9de8e169d128226c0fc90a012e",
        decimals: 8
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x0aa5eb2bb97ca915288b653a2529355d4dc66de2b37533213f0e4aeee3d3421f",
        decimals: 8
      }
    ]
  },
  {
    name: "FBTC",
    symbol: "FBTC",
    icon: "fbtc.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xc96de26018a54d51c097160568752c4e3bd6c364",
        decimals: 8
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xb5ecb0a1e08e2abbabf624ffea089df933376855f468ade35c6375b00c33996a",
        decimals: 8
      }
    ]
  },
  {
    name: "SolvBTC",
    symbol: "SolvBTC",
    icon: "solvBTC.webp",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x7a56e1c57c7475ccf742a1832b028f0456652f97",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x1186afea9affb88809c210e13e2330b5258c2cef04bb8fff5eff372b7bd3f40f",
        decimals: 9
      }
    ]
  },
  {
    name: "SolvBTC.BBN",
    symbol: "SolvBTC.BBN",
    icon: "SolvBTC.BBN.png",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xd9d920aa40f578ab794426f5c90f6c731d159def",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x7a4f087c957d30218223c2baaaa365355c9ca81b6ea49004cfb1590a5399216f",
        decimals: 9
      }
    ]
  },
  {
    name: "Mantle mETH",
    symbol: "Mantle mETH",
    icon: "mantle-meth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xd5F7838F5C461fefF7FE49ea5ebaF7728bB0ADfa",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x642a5db59ec323c2f846d4d4cf3e58d78aff64accf4f8f6455ba0aa3ef000a3b",
        decimals: 9
      }
    ]
  },
  {
    name: "sDAI",
    symbol: "sDAI",
    icon: "sdai.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x83f20f44975d03b1b09e64809b757c47f942beea",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x9e46f919fbf978f3cad7cd34cca982d5613af63ff8aab6c379e4faa179552958",
        decimals: 9
      }
    ]
  },
  {
    name: "USDT",
    symbol: "USDT",
    icon: "usdt.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        decimals: 6
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xa0265fb5c32f6e8db3197af3c7eb05c48ae373605b8165b6f4a51c5b0ba4812e",
        decimals: 6
      }
    ]
  },
  {
    name: "USDC",
    symbol: "USDC",
    icon: "usdc.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        decimals: 6
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x286c479da40dc953bddc3bb4c453b608bba2e0ac483b077bd475174115395e6b",
        decimals: 6
      }
    ]
  },
  {
    name: "USDe",
    symbol: "USDe",
    icon: "USDe.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x4c9edd5852cd905f086c759e8383e09bff1e68b3",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xb6133b2ef9f6153eb869125d23dcf20d1e735331b5e41b15a6a7a6cec70e8651",
        decimals: 9
      }
    ]
  },
  {
    name: "sUSDe",
    symbol: "sUSDe",
    icon: "sUSDe.webp",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x9d39a5de30e57443bff2a8307a4256c8797a3497",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xd05563025104fc36496c15c7021ad6b31034b0e89a356f4f818045d1f48808bc",
        decimals: 9
      }
    ]
  },
  {
    name: "rsUSDe",
    symbol: "rsUSDe",
    icon: "rsUSDe.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x82f5104b23FF2FA54C2345F821dAc9369e9E0B26",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x78d4522ec607f6e8efb66ea49439d1ee48623cf763f9688a8eada025def033d9",
        decimals: 9
      }
    ]
  },
  {
    name: "wstETH",
    symbol: "wstETH",
    icon: "wsteth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x1a7815cc9f75db5c24a5b0814bfb706bb9fe485333e98254015de8f48f84c67b",
        decimals: 9
      }
    ]
  },
  {
    name: "ezETH",
    symbol: "ezETH",
    icon: "ezeth.webp",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xbf5495Efe5DB9ce00f80364C8B423567e58d2110",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x91b3559edb2619cde8ffb2aa7b3c3be97efd794ea46700db7092abeee62281b0",
        decimals: 9
      }
    ]
  },
  {
    name: "pzETH",
    symbol: "pzETH",
    icon: "pzETH.webp",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x8c9532a60e0e7c6bbd2b2c1303f63ace1c3e9811",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x1493d4ec82124de8f9b625682de69dcccda79e882b89a55a8c737b12de67bd68",
        decimals: 9
      }
    ]
  },
  {
    name: "Re7LRT",
    symbol: "Re7LRT",
    icon: "Re7LRT.png",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0x84631c0d0081FDe56DeB72F6DE77abBbF6A9f93a",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0xf2fc648c23a5db24610a1cf696acc4f0f6d9a7d6028dd9944964ab23f6e35995",
        decimals: 9
      }
    ]
  },
  {
    name: "steakLRT",
    symbol: "steakLRT",
    icon: "steakLRT.png",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.mainnet,
        address: "0xBEEF69Ac7870777598A04B2bd4771c71212E6aBc",
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.mainnet,
        contractId: "0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",
        assetId: "0x4fc8ac9f101df07e2c2dec4a53c8c42c439bdbe5e36ea2d863a61ff60afafc30",
        decimals: 9
      }
    ]
  }
];
var assets = resolveIconPaths(rawAssets, fuelAssetsBaseUrl);

// src/providers/utils/merge-quantities.ts
var mergeQuantities = (...coinQuantities) => {
  const resultMap = {};
  function addToMap({ amount, assetId }) {
    if (resultMap[assetId]) {
      resultMap[assetId] = resultMap[assetId].add(amount);
    } else {
      resultMap[assetId] = amount;
    }
  }
  coinQuantities.forEach((arr) => arr.forEach(addToMap));
  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
};

// src/types.ts
var AbstractAccount = class {
};

// src/utils/formatTransferToContractScriptData.ts
var import_abi_coder6 = require("@fuel-ts/abi-coder");
var import_address4 = require("@fuel-ts/address");
var import_utils33 = require("@fuel-ts/utils");
var asm = __toESM(require("@fuels/vm-asm"));
var formatTransferToContractScriptData = (transferParams) => {
  const numberCoder = new import_abi_coder6.BigNumberCoder("u64");
  return transferParams.reduce((acc, transferParam) => {
    const { assetId, amount, contractId } = transferParam;
    const encoded = numberCoder.encode(amount);
    const scriptData = (0, import_utils33.concat)([
      import_address4.Address.fromAddressOrString(contractId).toBytes(),
      encoded,
      (0, import_utils33.arrayify)(assetId)
    ]);
    return (0, import_utils33.concat)([acc, scriptData]);
  }, new Uint8Array());
};
var assembleTransferToContractScript = async (transferParams) => {
  const scriptData = formatTransferToContractScriptData(transferParams);
  await asm.initWasm();
  let script = new Uint8Array();
  transferParams.forEach((_, i) => {
    const offset = (import_abi_coder6.CONTRACT_ID_LEN + import_abi_coder6.WORD_SIZE + import_abi_coder6.ASSET_ID_LEN) * i;
    script = (0, import_utils33.concat)([
      script,
      // Load ScriptData into register 0x10.
      asm.gtf(16, 0, asm.GTFArgs.ScriptData).to_bytes(),
      // Add the offset to 0x10 so it will point to the current contract ID, store in 0x11.
      asm.addi(17, 16, offset).to_bytes(),
      // Add CONTRACT_ID_LEN to 0x11 to point to the amount in the ScriptData, store in 0x12.
      asm.addi(18, 17, import_abi_coder6.CONTRACT_ID_LEN).to_bytes(),
      // Load word to the amount at 0x12 into register 0x13.
      asm.lw(19, 18, 0).to_bytes(),
      // Add WORD_SIZE to 0x12 to point to the asset ID in the ScriptData, store in 0x14.
      asm.addi(20, 18, import_abi_coder6.WORD_SIZE).to_bytes(),
      // Perform the transfer using contract ID in 0x11, amount in 0x13, and asset ID in 0x14.
      asm.tr(17, 19, 20).to_bytes()
    ]);
  });
  script = (0, import_utils33.concat)([script, asm.ret(1).to_bytes()]);
  return { script, scriptData };
};

// src/account.ts
var MAX_FUNDING_ATTEMPTS = 5;
var Account = class extends AbstractAccount {
  /**
   * The address associated with the account.
   */
  address;
  /**
   * The provider used to interact with the network.
   */
  _provider;
  /**
   * The connector for use with external wallets
   */
  _connector;
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance  (optional).
   * @param connector - A FuelConnector instance (optional).
   */
  constructor(address, provider, connector) {
    super();
    this._provider = provider;
    this._connector = connector;
    this.address = import_address5.Address.fromDynamicInput(address);
  }
  /**
   * The provider used to interact with the network.
   *
   * @returns A Provider instance.
   *
   * @throws `FuelError` if the provider is not set.
   */
  get provider() {
    if (!this._provider) {
      throw new import_errors21.FuelError(import_errors21.ErrorCode.MISSING_PROVIDER, "Provider not set");
    }
    return this._provider;
  }
  /**
   * Sets the provider for the account.
   *
   * @param provider - A Provider instance.
   */
  set provider(provider) {
    this._provider = provider;
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this._provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - Quantities of resources to be obtained.
   * @param excludedIds - IDs of resources to be excluded from the query (optional).
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve (optional).
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId, paginationArgs) {
    return this.provider.getCoins(this.address, assetId, paginationArgs);
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages(paginationArgs) {
    return this.provider.getMessages(this.address, paginationArgs);
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for (optional).
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId) {
    const assetIdToFetch = assetId ?? await this.provider.getBaseAssetId();
    const amount = await this.provider.getBalance(this.address, assetIdToFetch);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    return this.provider.getBalances(this.address);
  }
  /**
   * Funds a transaction request by adding the necessary resources.
   *
   * @typeParam T - The type of the TransactionRequest.
   * @param request - The transaction request to fund.
   * @param params - The estimated transaction parameters.
   * @returns A promise that resolves to the funded transaction request.
   */
  async fund(request, params) {
    const { addedSignatures, estimatedPredicates, requiredQuantities, updateMaxFee, gasPrice } = params;
    const fee = request.maxFee;
    const baseAssetId = await this.provider.getBaseAssetId();
    const requiredInBaseAsset = requiredQuantities.find((quantity) => quantity.assetId === baseAssetId)?.amount || (0, import_math20.bn)(0);
    const requiredQuantitiesWithFee = addAmountToCoinQuantities({
      amount: (0, import_math20.bn)(fee),
      assetId: baseAssetId,
      coinQuantities: requiredQuantities
    });
    const quantitiesDict = {};
    requiredQuantitiesWithFee.forEach(({ amount, assetId }) => {
      quantitiesDict[assetId] = {
        required: amount,
        owned: (0, import_math20.bn)(0)
      };
    });
    request.inputs.filter(isRequestInputResource).forEach((input) => {
      const isCoin2 = isRequestInputCoin(input);
      const assetId = isCoin2 ? String(input.assetId) : baseAssetId;
      if (quantitiesDict[assetId]) {
        quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(input.amount);
      }
    });
    let missingQuantities = [];
    Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
      if (owned.lt(required)) {
        missingQuantities.push({
          assetId,
          amount: required.sub(owned)
        });
      }
    });
    let needsToBeFunded = missingQuantities.length > 0;
    let fundingAttempts = 0;
    while (needsToBeFunded && fundingAttempts < MAX_FUNDING_ATTEMPTS) {
      const resources = await this.getResourcesToSpend(
        missingQuantities,
        cacheRequestInputsResourcesFromOwner(request.inputs, this.address)
      );
      request.addResources(resources);
      request.updatePredicateGasUsed(estimatedPredicates);
      const requestToReestimate2 = (0, import_ramda9.clone)(request);
      if (addedSignatures) {
        Array.from({ length: addedSignatures }).forEach(
          () => requestToReestimate2.addEmptyWitness()
        );
      }
      if (!updateMaxFee) {
        needsToBeFunded = false;
        break;
      }
      const { maxFee: newFee } = await this.provider.estimateTxGasAndFee({
        transactionRequest: requestToReestimate2,
        gasPrice
      });
      const totalBaseAssetOnInputs = getAssetAmountInRequestInputs(
        request.inputs.filter(isRequestInputResource),
        baseAssetId,
        baseAssetId
      );
      const totalBaseAssetRequiredWithFee = requiredInBaseAsset.add(newFee);
      if (totalBaseAssetOnInputs.gt(totalBaseAssetRequiredWithFee)) {
        needsToBeFunded = false;
      } else {
        missingQuantities = [
          {
            amount: totalBaseAssetRequiredWithFee.sub(totalBaseAssetOnInputs),
            assetId: baseAssetId
          }
        ];
      }
      fundingAttempts += 1;
    }
    if (needsToBeFunded) {
      throw new import_errors21.FuelError(
        import_errors21.ErrorCode.NOT_ENOUGH_FUNDS,
        `The account ${this.address} does not have enough base asset funds to cover the transaction execution.`
      );
    }
    await this.provider.validateTransaction(request);
    request.updatePredicateGasUsed(estimatedPredicates);
    const requestToReestimate = (0, import_ramda9.clone)(request);
    if (addedSignatures) {
      Array.from({ length: addedSignatures }).forEach(() => requestToReestimate.addEmptyWitness());
    }
    if (!updateMaxFee) {
      return request;
    }
    const { maxFee } = await this.provider.estimateTxGasAndFee({
      transactionRequest: requestToReestimate,
      gasPrice
    });
    request.maxFee = maxFee;
    return request;
  }
  /**
   * A helper that creates a transfer transaction request and returns it.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the prepared transaction request.
   */
  async createTransfer(destination, amount, assetId, txParams = {}) {
    let request = new ScriptTransactionRequest(txParams);
    request = this.addTransfer(request, {
      destination,
      amount,
      assetId: assetId || await this.provider.getBaseAssetId()
    });
    request = await this.estimateAndFundTransaction(request, txParams);
    return request;
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId, txParams = {}) {
    const request = await this.createTransfer(destination, amount, assetId, txParams);
    return this.sendTransaction(request, { estimateTxDependencies: false });
  }
  /**
   * Transfers multiple amounts of a token to multiple recipients.
   *
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @param txParams - Optional transaction parameters.
   * @returns A promise that resolves to a `TransactionResponse` object representing the transaction result.
   */
  async batchTransfer(transferParams, txParams = {}) {
    let request = new ScriptTransactionRequest(txParams);
    request = this.addBatchTransfer(request, transferParams);
    request = await this.estimateAndFundTransaction(request, txParams);
    return this.sendTransaction(request, { estimateTxDependencies: false });
  }
  /**
   * Adds a transfer to the given transaction request.
   *
   * @param request - The script transaction request to add transfers to.
   * @param transferParams - The object representing the transfer to be made.
   * @returns The updated transaction request with the added transfer.
   */
  addTransfer(request, transferParams) {
    const { destination, amount, assetId } = transferParams;
    this.validateTransferAmount(amount);
    request.addCoinOutput(import_address5.Address.fromAddressOrString(destination), amount, assetId);
    return request;
  }
  /**
   * Adds multiple transfers to a script transaction request.
   *
   * @param request - The script transaction request to add transfers to.
   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.
   * @returns The updated script transaction request.
   */
  addBatchTransfer(request, transferParams) {
    transferParams.forEach(({ destination, amount, assetId }) => {
      this.addTransfer(request, {
        destination,
        amount,
        assetId
      });
    });
    return request;
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer (optional).
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId, amount, assetId, txParams = {}) {
    return this.batchTransferToContracts([{ amount, assetId, contractId }], txParams);
  }
  async batchTransferToContracts(contractTransferParams, txParams = {}) {
    let request = new ScriptTransactionRequest({
      ...txParams
    });
    const quantities = [];
    const defaultAssetId = await this.provider.getBaseAssetId();
    const transferParams = contractTransferParams.map((transferParam) => {
      const amount = (0, import_math20.bn)(transferParam.amount);
      const contractAddress = import_address5.Address.fromAddressOrString(transferParam.contractId);
      const assetId = transferParam.assetId ? (0, import_utils34.hexlify)(transferParam.assetId) : defaultAssetId;
      if (amount.lte(0)) {
        throw new import_errors21.FuelError(
          import_errors21.ErrorCode.INVALID_TRANSFER_AMOUNT,
          "Transfer amount must be a positive number."
        );
      }
      request.addContractInputAndOutput(contractAddress);
      quantities.push({ amount, assetId });
      return {
        amount,
        contractId: contractAddress.toB256(),
        assetId
      };
    });
    const { script, scriptData } = await assembleTransferToContractScript(transferParams);
    request.script = script;
    request.scriptData = scriptData;
    request = await this.estimateAndFundTransaction(request, txParams, { quantities });
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const recipientAddress = import_address5.Address.fromAddressOrString(recipient);
    const recipientDataArray = (0, import_utils34.arrayify)(
      "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = (0, import_utils34.arrayify)(
      "0x".concat((0, import_math20.bn)(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...(0, import_utils34.arrayify)(withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const params = { script, ...txParams };
    const baseAssetId = await this.provider.getBaseAssetId();
    let request = new ScriptTransactionRequest(params);
    const quantities = [{ amount: (0, import_math20.bn)(amount), assetId: baseAssetId }];
    const txCost = await this.getTransactionCost(request, { quantities });
    request = this.validateGasLimitAndMaxFee({
      transactionRequest: request,
      gasUsed: txCost.gasUsed,
      maxFee: txCost.maxFee,
      txParams
    });
    await this.fund(request, txCost);
    return this.sendTransaction(request);
  }
  /**
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the transaction.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param transactionCostParams - The transaction cost parameters (optional).
   *
   * @returns A promise that resolves to the transaction cost object.
   */
  async getTransactionCost(transactionRequestLike, { signatureCallback, quantities = [] } = {}) {
    const txRequestClone = (0, import_ramda9.clone)(transactionRequestify(transactionRequestLike));
    const baseAssetId = await this.provider.getBaseAssetId();
    const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
    const requiredQuantities = mergeQuantities(coinOutputsQuantities, quantities);
    const transactionFeeForDryRun = [{ assetId: baseAssetId, amount: (0, import_math20.bn)("100000000000000000") }];
    const findAssetInput = (assetId) => txRequestClone.inputs.find((input) => {
      if (input.type === import_transactions24.InputType.Coin) {
        return input.assetId === assetId;
      }
      if (isRequestInputMessageWithoutData(input)) {
        return baseAssetId === assetId;
      }
      return false;
    });
    const updateAssetInput = (assetId, quantity) => {
      const assetInput = findAssetInput(assetId);
      const usedQuantity = quantity;
      if (assetInput && "amount" in assetInput) {
        assetInput.amount = usedQuantity;
      } else {
        txRequestClone.addResources(
          this.generateFakeResources([
            {
              amount: quantity,
              assetId
            }
          ])
        );
      }
    };
    mergeQuantities(requiredQuantities, transactionFeeForDryRun).forEach(
      ({ amount, assetId }) => updateAssetInput(assetId, amount)
    );
    const txCost = await this.provider.getTransactionCost(txRequestClone, {
      signatureCallback
    });
    return {
      ...txCost,
      requiredQuantities
    };
  }
  /**
   * Sign a message from the account via the connector.
   *
   * @param message - the message to sign.
   * @returns a promise that resolves to the signature.
   *
   * @hidden
   */
  async signMessage(message) {
    if (!this._connector) {
      throw new import_errors21.FuelError(import_errors21.ErrorCode.MISSING_CONNECTOR, "A connector is required to sign messages.");
    }
    return this._connector.signMessage(this.address.toString(), message);
  }
  /**
   * Signs a transaction from the account via the connector..
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature of the transaction.
   */
  async signTransaction(transactionRequestLike) {
    if (!this._connector) {
      throw new import_errors21.FuelError(
        import_errors21.ErrorCode.MISSING_CONNECTOR,
        "A connector is required to sign transactions."
      );
    }
    return this._connector.signTransaction(this.address.toString(), transactionRequestLike);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @param sendTransactionParams - The provider send transaction parameters (optional).
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, onBeforeSend, skipCustomFee = false } = {}) {
    if (this._connector) {
      return this.provider.getTransactionResponse(
        await this._connector.sendTransaction(this.address.toString(), transactionRequestLike, {
          onBeforeSend,
          skipCustomFee
        })
      );
    }
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(transactionRequest, {
      estimateTxDependencies: false
    });
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @param estimateTxParams - The estimate transaction params (optional).
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
  }
  /**
   * Generates an array of fake resources based on the provided coins.
   *
   * @param coins - An array of `FakeResources` objects representing the coins.
   * @returns An array of `Resource` objects with generated properties.
   */
  generateFakeResources(coins) {
    return coins.map((coin) => ({
      id: (0, import_utils34.hexlify)((0, import_crypto2.randomBytes)(import_abi_coder7.UTXO_ID_LEN)),
      owner: this.address,
      blockCreated: (0, import_math20.bn)(1),
      txCreatedIdx: (0, import_math20.bn)(1),
      ...coin
    }));
  }
  /** @hidden * */
  validateTransferAmount(amount) {
    if ((0, import_math20.bn)(amount).lte(0)) {
      throw new import_errors21.FuelError(
        import_errors21.ErrorCode.INVALID_TRANSFER_AMOUNT,
        "Transfer amount must be a positive number."
      );
    }
  }
  /** @hidden * */
  async estimateAndFundTransaction(transactionRequest, txParams, costParams) {
    let request = transactionRequest;
    const txCost = await this.getTransactionCost(request, costParams);
    request = this.validateGasLimitAndMaxFee({
      transactionRequest: request,
      gasUsed: txCost.gasUsed,
      maxFee: txCost.maxFee,
      txParams
    });
    request = await this.fund(request, txCost);
    return request;
  }
  /** @hidden * */
  validateGasLimitAndMaxFee({
    gasUsed,
    maxFee,
    transactionRequest,
    txParams: { gasLimit: setGasLimit, maxFee: setMaxFee }
  }) {
    const request = transactionRequestify(transactionRequest);
    if (!(0, import_utils34.isDefined)(setGasLimit)) {
      request.gasLimit = gasUsed;
    } else if (gasUsed.gt(setGasLimit)) {
      throw new import_errors21.FuelError(
        import_errors21.ErrorCode.GAS_LIMIT_TOO_LOW,
        `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`
      );
    }
    if (!(0, import_utils34.isDefined)(setMaxFee)) {
      request.maxFee = maxFee;
    } else if (maxFee.gt(setMaxFee)) {
      throw new import_errors21.FuelError(
        import_errors21.ErrorCode.MAX_FEE_TOO_LOW,
        `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`
      );
    }
    return request;
  }
};

// src/wallet/base-wallet-unlocked.ts
var import_hasher4 = require("@fuel-ts/hasher");
var import_utils37 = require("@fuel-ts/utils");

// src/signer/signer.ts
var import_address6 = require("@fuel-ts/address");
var import_crypto3 = require("@fuel-ts/crypto");
var import_hasher3 = require("@fuel-ts/hasher");
var import_math21 = require("@fuel-ts/math");
var import_utils35 = require("@fuel-ts/utils");
var import_secp256k1 = require("@noble/curves/secp256k1");
var Signer = class {
  address;
  publicKey;
  compressedPublicKey;
  privateKey;
  /**
   * Create a Signer instance from a given private key
   *
   * @param privateKey - The private key to use for signing
   * @returns A new Signer instance
   */
  constructor(privateKey) {
    if (typeof privateKey === "string") {
      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
        privateKey = `0x${privateKey}`;
      }
    }
    const privateKeyBytes = (0, import_math21.toBytes)(privateKey, 32);
    this.privateKey = (0, import_utils35.hexlify)(privateKeyBytes);
    this.publicKey = (0, import_utils35.hexlify)(import_secp256k1.secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
    this.compressedPublicKey = (0, import_utils35.hexlify)(import_secp256k1.secp256k1.getPublicKey(privateKeyBytes, true));
    this.address = import_address6.Address.fromPublicKey(this.publicKey);
  }
  /**
   * Sign data using the Signer instance
   *
   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
   * @ignore
   * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
   *
   * @param data - The data to be sign
   * @returns hashed signature
   */
  sign(data) {
    const signature = import_secp256k1.secp256k1.sign((0, import_utils35.arrayify)(data), (0, import_utils35.arrayify)(this.privateKey));
    const r = (0, import_math21.toBytes)(`0x${signature.r.toString(16)}`, 32);
    const s = (0, import_math21.toBytes)(`0x${signature.s.toString(16)}`, 32);
    s[0] |= (signature.recovery || 0) << 7;
    return (0, import_utils35.hexlify)((0, import_utils35.concat)([r, s]));
  }
  /**
   * Add point on the current elliptic curve
   *
   * @param point - Point to add on the curve
   * @returns compressed point on the curve
   */
  addPoint(point) {
    const p0 = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_utils35.arrayify)(this.compressedPublicKey));
    const p1 = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_utils35.arrayify)(point));
    const result = p0.add(p1);
    return `0x${result.toHex(true)}`;
  }
  /**
   * Recover the public key from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - hashed signature
   * @returns public key from signature from the
   */
  static recoverPublicKey(data, signature) {
    const signedMessageBytes = (0, import_utils35.arrayify)(signature);
    const r = signedMessageBytes.slice(0, 32);
    const s = signedMessageBytes.slice(32, 64);
    const recoveryParam = (s[0] & 128) >> 7;
    s[0] &= 127;
    const sig = new import_secp256k1.secp256k1.Signature(BigInt((0, import_utils35.hexlify)(r)), BigInt((0, import_utils35.hexlify)(s))).addRecoveryBit(
      recoveryParam
    );
    const publicKey = sig.recoverPublicKey((0, import_utils35.arrayify)(data)).toRawBytes(false).slice(1);
    return (0, import_utils35.hexlify)(publicKey);
  }
  /**
   * Recover the address from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - Signature
   * @returns Address from signature
   */
  static recoverAddress(data, signature) {
    return import_address6.Address.fromPublicKey(Signer.recoverPublicKey(data, signature));
  }
  /**
   * Generate a random privateKey
   *
   * @param entropy - Adds extra entropy to generate the privateKey
   * @returns random 32-byte hashed
   */
  static generatePrivateKey(entropy) {
    return entropy ? (0, import_hasher3.hash)((0, import_utils35.concat)([(0, import_crypto3.randomBytes)(32), (0, import_utils35.arrayify)(entropy)])) : (0, import_crypto3.randomBytes)(32);
  }
  /**
   * Extended publicKey from a compact publicKey
   *
   * @param publicKey - Compact publicKey
   * @returns extended publicKey
   */
  static extendPublicKey(publicKey) {
    const point = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_utils35.arrayify)(publicKey));
    return (0, import_utils35.hexlify)(point.toRawBytes(false).slice(1));
  }
};

// src/wallet/keystore-wallet.ts
var import_address7 = require("@fuel-ts/address");
var import_crypto4 = require("@fuel-ts/crypto");
var import_errors22 = require("@fuel-ts/errors");
var import_utils36 = require("@fuel-ts/utils");
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = (0, import_crypto4.bufferFromString)(removeHexPrefix(privateKey), "hex");
  const ownerAddress = import_address7.Address.fromAddressOrString(address);
  const salt = (0, import_crypto4.randomBytes)(DEFAULT_KEY_SIZE);
  const key = (0, import_crypto4.scrypt)({
    password: (0, import_crypto4.bufferFromString)(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = (0, import_crypto4.randomBytes)(DEFAULT_IV_SIZE);
  const ciphertext = await (0, import_crypto4.encryptJsonWalletData)(privateKeyBuffer, key, iv);
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = (0, import_crypto4.keccak256)(data);
  const mac = (0, import_crypto4.stringFromBuffer)(macHashUint8Array, "hex");
  const keystore = {
    id: (0, import_crypto4.randomUUID)(),
    version: 3,
    address: removeHexPrefix(ownerAddress.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: (0, import_crypto4.stringFromBuffer)(iv, "hex") },
      ciphertext: (0, import_crypto4.stringFromBuffer)(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: (0, import_crypto4.stringFromBuffer)(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = (0, import_crypto4.bufferFromString)(ciphertext, "hex");
  const ivBuffer = (0, import_crypto4.bufferFromString)(iv, "hex");
  const saltBuffer = (0, import_crypto4.bufferFromString)(salt, "hex");
  const passwordBuffer = (0, import_crypto4.bufferFromString)(password);
  const key = (0, import_crypto4.scrypt)({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = (0, import_crypto4.keccak256)(data);
  const macHash = (0, import_crypto4.stringFromBuffer)(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new import_errors22.FuelError(
      import_errors22.ErrorCode.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer = await (0, import_crypto4.decryptJsonWalletData)(ciphertextBuffer, key, ivBuffer);
  const privateKey = (0, import_utils36.hexlify)(buffer);
  return privateKey;
}

// src/wallet/base-wallet-unlocked.ts
var BaseWalletUnlocked = class extends Account {
  /**
   * A function that returns the wallet's signer.
   */
  signer;
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   */
  constructor(privateKey, provider) {
    const signer = new Signer(privateKey);
    super(signer.address, provider);
    this.signer = () => signer;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign((0, import_hasher4.hashMessage)(message));
    return (0, import_utils37.hexlify)(signedMessage);
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const chainId = await this.provider.getChainId();
    const hashedTransaction = transactionRequest.getTransactionId(chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return (0, import_utils37.hexlify)(signature);
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @param estimateTxDependencies - Whether to estimate the transaction dependencies.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = false, enableAssetBurn } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    validateTransactionForAssetBurn(
      await this.provider.getBaseAssetId(),
      transactionRequest,
      enableAssetBurn
    );
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      { estimateTxDependencies: false, enableAssetBurn }
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.dryRun`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.dryRun(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true,
        estimateTxDependencies: false
      }
    );
  }
  /**
   * Encrypts an unlocked wallet with a password.
   *
   * @param password - the password to encrypt the wallet with.
   * @returns - the encrypted wallet.
   */
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
/**
 * Default HDWallet path.
 */
__publicField(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");

// src/hdwallet/hdwallet.ts
var import_crypto6 = require("@fuel-ts/crypto");
var import_errors25 = require("@fuel-ts/errors");
var import_hasher7 = require("@fuel-ts/hasher");
var import_math22 = require("@fuel-ts/math");
var import_utils41 = require("@fuel-ts/utils");

// src/mnemonic/mnemonic.ts
var import_crypto5 = require("@fuel-ts/crypto");
var import_errors24 = require("@fuel-ts/errors");
var import_hasher6 = require("@fuel-ts/hasher");
var import_utils39 = require("@fuel-ts/utils");

// src/wordlists/words/english.ts
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// src/wordlists/index.ts
var Language = /* @__PURE__ */ ((Language2) => {
  Language2["english"] = "english";
  return Language2;
})(Language || {});

// src/mnemonic/utils.ts
var import_errors23 = require("@fuel-ts/errors");
var import_hasher5 = require("@fuel-ts/hasher");
var import_utils38 = require("@fuel-ts/utils");
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getWords(mnemonic) {
  if (!Array.isArray(mnemonic)) {
    return mnemonic.split(/\s+/);
  }
  return mnemonic;
}
function getPhrase(mnemonic) {
  if (Array.isArray(mnemonic)) {
    return mnemonic.join(" ");
  }
  return mnemonic;
}
function entropyToMnemonicIndices(entropy) {
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i += 1) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = (0, import_utils38.arrayify)((0, import_hasher5.sha256)(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return indices;
}
function mnemonicWordsToEntropy(words, wordlist) {
  const size = Math.ceil(11 * words.length / 8);
  const entropy = (0, import_utils38.arrayify)(new Uint8Array(size));
  let offset = 0;
  for (let i = 0; i < words.length; i += 1) {
    const index = wordlist.indexOf(words[i].normalize("NFKD"));
    if (index === -1) {
      throw new import_errors23.FuelError(
        import_errors23.ErrorCode.INVALID_MNEMONIC,
        `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
      );
    }
    for (let bit = 0; bit < 11; bit += 1) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset += 1;
    }
  }
  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = (0, import_utils38.arrayify)((0, import_hasher5.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new import_errors23.FuelError(
      import_errors23.ErrorCode.INVALID_CHECKSUM,
      "Checksum validation failed for the provided mnemonic."
    );
  }
  return entropy.slice(0, entropyBits / 8);
}

// src/mnemonic/mnemonic.ts
var MasterSecret = (0, import_utils39.toUtf8Bytes)("Bitcoin seed");
var MainnetPRV = "0x0488ade4";
var TestnetPRV = "0x04358394";
var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
function assertWordList(wordlist) {
  if (wordlist.length !== 2048) {
    throw new import_errors24.FuelError(
      import_errors24.ErrorCode.INVALID_WORD_LIST,
      `Expected word list length of 2048, but got ${wordlist.length}.`
    );
  }
}
function assertEntropy(entropy) {
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new import_errors24.FuelError(
      import_errors24.ErrorCode.INVALID_ENTROPY,
      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
    );
  }
}
function assertMnemonic(words) {
  if (!MNEMONIC_SIZES.includes(words.length)) {
    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
      ", "
    )}] words, but got ${words.length}.`;
    throw new import_errors24.FuelError(import_errors24.ErrorCode.INVALID_MNEMONIC, errorMsg);
  }
}
var Mnemonic = class {
  wordlist;
  /**
   *
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic instance
   */
  constructor(wordlist = english) {
    this.wordlist = wordlist;
    assertWordList(this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns Entropy hash
   */
  mnemonicToEntropy(phrase) {
    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
  }
  /**
   *
   * @param entropy - Entropy source to the mnemonic phrase.
   * @returns Mnemonic phrase
   */
  entropyToMnemonic(entropy) {
    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic phrase
   */
  static mnemonicToEntropy(phrase, wordlist = english) {
    const words = getWords(phrase);
    assertMnemonic(words);
    return (0, import_utils39.hexlify)(mnemonicWordsToEntropy(words, wordlist));
  }
  /**
   * @param entropy - Entropy source to the mnemonic phrase.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static entropyToMnemonic(entropy, wordlist = english) {
    const entropyBytes = (0, import_utils39.arrayify)(entropy);
    assertWordList(wordlist);
    assertEntropy(entropyBytes);
    return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToSeed(phrase, passphrase = "") {
    assertMnemonic(getWords(phrase));
    const phraseBytes = (0, import_utils39.toUtf8Bytes)(getPhrase(phrase));
    const salt = (0, import_utils39.toUtf8Bytes)(`mnemonic${passphrase}`);
    return (0, import_crypto5.pbkdf2)(phraseBytes, salt, 2048, 64, "sha512");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToMasterKeys(phrase, passphrase = "") {
    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);
    return Mnemonic.masterKeysFromSeed(seed);
  }
  /**
   * Validates if given mnemonic is  valid
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns true if phrase is a valid mnemonic
   */
  static isMnemonicValid(phrase) {
    const words = getWords(phrase);
    let i = 0;
    try {
      assertMnemonic(words);
    } catch {
      return false;
    }
    while (i < words.length) {
      if (Mnemonic.binarySearch(words[i]) === false) {
        return false;
      }
      i += 1;
    }
    return true;
  }
  static binarySearch(target) {
    const words = english;
    let left = 0;
    let right = words.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (words[mid] === target) {
        return true;
      }
      if (target < words[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return false;
  }
  /**
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static masterKeysFromSeed(seed) {
    const seedArray = (0, import_utils39.arrayify)(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new import_errors24.FuelError(
        import_errors24.ErrorCode.INVALID_SEED,
        `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
      );
    }
    return (0, import_utils39.arrayify)((0, import_crypto5.computeHmac)("sha512", MasterSecret, seedArray));
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  static seedToExtendedKey(seed, testnet = false) {
    const masterKey = Mnemonic.masterKeysFromSeed(seed);
    const prefix = (0, import_utils39.arrayify)(testnet ? TestnetPRV : MainnetPRV);
    const depth = "0x00";
    const fingerprint = "0x00000000";
    const index = "0x00000000";
    const chainCode = masterKey.slice(32);
    const privateKey = masterKey.slice(0, 32);
    const extendedKey = (0, import_utils39.concat)([
      prefix,
      depth,
      fingerprint,
      index,
      chainCode,
      (0, import_utils39.concat)(["0x00", privateKey])
    ]);
    const checksum = (0, import_utils39.dataSlice)((0, import_hasher6.sha256)((0, import_hasher6.sha256)(extendedKey)), 0, 4);
    return (0, import_utils39.encodeBase58)((0, import_utils39.concat)([extendedKey, checksum]));
  }
  /**
   *  Create a new mnemonic using a randomly generated number as entropy.
   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
   *  If not provided, the default entropy length will be set to 256 bits.
   *  The return is a list of words that encodes the generated entropy.
   *
   *
   * @param size - Number of bytes used as an entropy
   * @param extraEntropy - Optional extra entropy to increase randomness
   * @returns A randomly generated mnemonic
   */
  static generate(size = 32, extraEntropy = "") {
    const entropy = extraEntropy ? (0, import_hasher6.sha256)((0, import_utils39.concat)([(0, import_crypto5.randomBytes)(size), (0, import_utils39.arrayify)(extraEntropy)])) : (0, import_crypto5.randomBytes)(size);
    return Mnemonic.entropyToMnemonic(entropy);
  }
};
var mnemonic_default = Mnemonic;

// src/hdwallet/hdwallet.ts
var HARDENED_INDEX = 2147483648;
var MainnetPRV2 = (0, import_utils41.hexlify)("0x0488ade4");
var MainnetPUB = (0, import_utils41.hexlify)("0x0488b21e");
var TestnetPRV2 = (0, import_utils41.hexlify)("0x04358394");
var TestnetPUB = (0, import_utils41.hexlify)("0x043587cf");
function base58check(data) {
  return (0, import_utils41.encodeBase58)((0, import_utils41.concat)([data, (0, import_utils41.dataSlice)((0, import_hasher7.sha256)((0, import_hasher7.sha256)(data)), 0, 4)]));
}
function getExtendedKeyPrefix(isPublic = false, testnet = false) {
  if (isPublic) {
    return testnet ? TestnetPUB : MainnetPUB;
  }
  return testnet ? TestnetPRV2 : MainnetPRV2;
}
function isPublicExtendedKey(extendedKey) {
  return [MainnetPUB, TestnetPUB].includes((0, import_utils41.hexlify)(extendedKey.slice(0, 4)));
}
function isValidExtendedKey(extendedKey) {
  return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
    (0, import_utils41.hexlify)(extendedKey.slice(0, 4))
  );
}
function parsePath(path, depth = 0) {
  const components = path.split("/");
  if (components.length === 0 || components[0] === "m" && depth !== 0) {
    throw new import_errors25.FuelError(import_errors25.ErrorCode.HD_WALLET_ERROR, `invalid path - ${path}`);
  }
  if (components[0] === "m") {
    components.shift();
  }
  return components.map(
    (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
  );
}
var HDWallet = class {
  depth = 0;
  index = 0;
  fingerprint = (0, import_utils41.hexlify)("0x00000000");
  parentFingerprint = (0, import_utils41.hexlify)("0x00000000");
  privateKey;
  publicKey;
  chainCode;
  /**
   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
   *
   * @param config - Wallet configurations
   */
  constructor(config) {
    if (config.privateKey) {
      const signer = new Signer(config.privateKey);
      this.publicKey = (0, import_utils41.hexlify)(signer.compressedPublicKey);
      this.privateKey = (0, import_utils41.hexlify)(config.privateKey);
    } else {
      if (!config.publicKey) {
        throw new import_errors25.FuelError(
          import_errors25.ErrorCode.HD_WALLET_ERROR,
          "Both public and private Key cannot be missing. At least one should be provided."
        );
      }
      this.publicKey = (0, import_utils41.hexlify)(config.publicKey);
    }
    this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
    this.fingerprint = (0, import_utils41.dataSlice)((0, import_crypto6.ripemd160)((0, import_hasher7.sha256)(this.publicKey)), 0, 4);
    this.depth = config.depth || this.depth;
    this.index = config.index || this.index;
    this.chainCode = config.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  /**
   * Derive the current HDWallet instance navigating only on the index.
   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param index - Index of the child HDWallet.
   * @returns A new instance of HDWallet on the derived index
   */
  deriveIndex(index) {
    const privateKey = this.privateKey && (0, import_utils41.arrayify)(this.privateKey);
    const publicKey = (0, import_utils41.arrayify)(this.publicKey);
    const chainCode = (0, import_utils41.arrayify)(this.chainCode);
    const data = new Uint8Array(37);
    if (index & HARDENED_INDEX) {
      if (!privateKey) {
        throw new import_errors25.FuelError(
          import_errors25.ErrorCode.HD_WALLET_ERROR,
          "Cannot derive a hardened index without a private Key."
        );
      }
      data.set(privateKey, 1);
    } else {
      data.set((0, import_utils41.arrayify)(this.publicKey));
    }
    data.set((0, import_math22.toBytes)(index, 4), 33);
    const bytes = (0, import_utils41.arrayify)((0, import_crypto6.computeHmac)("sha512", chainCode, data));
    const IL = bytes.slice(0, 32);
    const IR = bytes.slice(32);
    if (privateKey) {
      const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
      const ki = (0, import_math22.bn)(IL).add(privateKey).mod(N).toBytes(32);
      return new HDWallet({
        privateKey: ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const signer = new Signer((0, import_utils41.hexlify)(IL));
    const Ki = signer.addPoint(publicKey);
    return new HDWallet({
      publicKey: Ki,
      chainCode: IR,
      index,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  /**
   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
   * @returns A new instance of HDWallet on the derived path
   */
  derivePath(path) {
    const paths = parsePath(path, this.depth);
    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  toExtendedKey(isPublic = false, testnet = false) {
    if (this.depth >= 256) {
      throw new import_errors25.FuelError(
        import_errors25.ErrorCode.HD_WALLET_ERROR,
        `Exceeded max depth of 255. Current depth: ${this.depth}.`
      );
    }
    const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
    const depth = (0, import_utils41.hexlify)(Uint8Array.from([this.depth]));
    const parentFingerprint = this.parentFingerprint;
    const index = (0, import_math22.toHex)(this.index, 4);
    const chainCode = this.chainCode;
    const key = this.privateKey != null && !isPublic ? (0, import_utils41.concat)(["0x00", this.privateKey]) : this.publicKey;
    const extendedKey = (0, import_utils41.arrayify)((0, import_utils41.concat)([prefix, depth, parentFingerprint, index, chainCode, key]));
    return base58check(extendedKey);
  }
  /**
   * Create HDWallet instance from seed
   *
   * @param seed - Seed
   * @returns A new instance of HDWallet
   */
  static fromSeed(seed) {
    const masterKey = mnemonic_default.masterKeysFromSeed(seed);
    return new HDWallet({
      chainCode: (0, import_utils41.arrayify)(masterKey.slice(32)),
      privateKey: (0, import_utils41.arrayify)(masterKey.slice(0, 32))
    });
  }
  static fromExtendedKey(extendedKey) {
    const decoded = (0, import_utils41.hexlify)((0, import_math22.toBytes)((0, import_utils41.decodeBase58)(extendedKey)));
    const bytes = (0, import_utils41.arrayify)(decoded);
    const validChecksum = base58check(bytes.slice(0, 78)) === extendedKey;
    if (bytes.length !== 82 || !isValidExtendedKey(bytes)) {
      throw new import_errors25.FuelError(import_errors25.ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    }
    if (!validChecksum) {
      throw new import_errors25.FuelError(import_errors25.ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    }
    const depth = bytes[4];
    const parentFingerprint = (0, import_utils41.hexlify)(bytes.slice(5, 9));
    const index = parseInt((0, import_utils41.hexlify)(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = (0, import_utils41.hexlify)(bytes.slice(13, 45));
    const key = bytes.slice(45, 78);
    if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
      throw new import_errors25.FuelError(
        import_errors25.ErrorCode.HD_WALLET_ERROR,
        "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
      );
    }
    if (isPublicExtendedKey(bytes)) {
      if (key[0] !== 3) {
        throw new import_errors25.FuelError(import_errors25.ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
      }
      return new HDWallet({
        publicKey: key,
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
    if (key[0] !== 0) {
      throw new import_errors25.FuelError(import_errors25.ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
    }
    return new HDWallet({
      privateKey: key.slice(1),
      chainCode,
      index,
      depth,
      parentFingerprint
    });
  }
};
var hdwallet_default = HDWallet;

// src/wallet/wallets.ts
var WalletLocked = class extends Account {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this._provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new Signer("0x00");
    return new WalletLocked(this.address, this._provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);
    return new WalletUnlocked(privateKey, generateOptions?.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed, path, provider) {
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, path, passphrase, provider) {
    const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an encrypted JSON.
   *
   * @param jsonWallet - The encrypted JSON keystore.
   * @param password - The password to decrypt the JSON.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};

// src/wallet/wallet.ts
var Wallet = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
/**
 * Generate a new Wallet Unlocked with a random key pair.
 *
 * @param generateOptions - Options to customize the generation process (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "generate", WalletUnlocked.generate);
/**
 * Create a Wallet Unlocked from a seed.
 *
 * @param seed - The seed phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromSeed", WalletUnlocked.fromSeed);
/**
 * Create a Wallet Unlocked from a mnemonic phrase.
 *
 * @param mnemonic - The mnemonic phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @param passphrase - The passphrase for the mnemonic (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
/**
 * Create a Wallet Unlocked from an extended key.
 *
 * @param extendedKey - The extended key.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
/**
 * Create a Wallet Unlocked from an encrypted JSON.
 *
 * @param jsonWallet - The encrypted JSON keystore.
 * @param password - The password to decrypt the JSON.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);

// src/wallet-manager/wallet-manager.ts
var import_address10 = require("@fuel-ts/address");
var import_crypto7 = require("@fuel-ts/crypto");
var import_errors28 = require("@fuel-ts/errors");
var import_events = require("events");

// src/wallet-manager/storages/memory-storage.ts
var MemoryStorage = class {
  storage = /* @__PURE__ */ new Map();
  async getItem(key) {
    const item = await this.storage.get(key);
    return item;
  }
  async setItem(key, value) {
    await this.storage.set(key, value);
  }
  async removeItem(key) {
    await this.storage.delete(key);
  }
  async clear() {
    await this.storage.clear();
  }
};

// src/wallet-manager/vaults/mnemonic-vault.ts
var import_address8 = require("@fuel-ts/address");
var import_errors26 = require("@fuel-ts/errors");
var _secret;
var MnemonicVault = class {
  constructor(options) {
    __privateAdd(this, _secret, void 0);
    __publicField(this, "pathKey", "{}");
    __publicField(this, "rootPath", `m/44'/1179993420'/${this.pathKey}'/0/0`);
    __publicField(this, "numberOfAccounts", 0);
    __privateSet(this, _secret, options.secret || mnemonic_default.generate());
    this.rootPath = options.rootPath || this.rootPath;
    this.numberOfAccounts = options.numberOfAccounts || 1;
  }
  getDerivePath(index) {
    if (this.rootPath.includes(this.pathKey)) {
      return this.rootPath.replace(this.pathKey, String(index));
    }
    return `${this.rootPath}/${index}`;
  }
  serialize() {
    return {
      secret: __privateGet(this, _secret),
      rootPath: this.rootPath,
      numberOfAccounts: this.numberOfAccounts
    };
  }
  getAccounts() {
    const accounts = [];
    let numberOfAccounts = 0;
    do {
      const wallet = Wallet.fromMnemonic(__privateGet(this, _secret), this.getDerivePath(numberOfAccounts));
      accounts.push({
        publicKey: wallet.publicKey,
        address: wallet.address
      });
      numberOfAccounts += 1;
    } while (numberOfAccounts < this.numberOfAccounts);
    return accounts;
  }
  addAccount() {
    this.numberOfAccounts += 1;
    const wallet = Wallet.fromMnemonic(__privateGet(this, _secret), this.getDerivePath(this.numberOfAccounts - 1));
    return {
      publicKey: wallet.publicKey,
      address: wallet.address
    };
  }
  exportAccount(address) {
    let numberOfAccounts = 0;
    const ownerAddress = import_address8.Address.fromAddressOrString(address);
    do {
      const wallet = Wallet.fromMnemonic(__privateGet(this, _secret), this.getDerivePath(numberOfAccounts));
      if (wallet.address.equals(ownerAddress)) {
        return wallet.privateKey;
      }
      numberOfAccounts += 1;
    } while (numberOfAccounts < this.numberOfAccounts);
    throw new import_errors26.FuelError(
      import_errors26.ErrorCode.WALLET_MANAGER_ERROR,
      `Account with address '${address}' not found in derived wallets.`
    );
  }
  getWallet(address) {
    const privateKey = this.exportAccount(address);
    return Wallet.fromPrivateKey(privateKey);
  }
};
_secret = new WeakMap();
__publicField(MnemonicVault, "type", "mnemonic");

// src/wallet-manager/vaults/privatekey-vault.ts
var import_address9 = require("@fuel-ts/address");
var import_errors27 = require("@fuel-ts/errors");
var _privateKeys;
var PrivateKeyVault = class {
  /**
   * If privateKey vault is initialized with a secretKey, it creates
   * one account with the fallowing secret
   */
  constructor(options = {}) {
    __privateAdd(this, _privateKeys, []);
    if (options.secret) {
      __privateSet(this, _privateKeys, [options.secret]);
    } else {
      __privateSet(this, _privateKeys, options.accounts || [Wallet.generate().privateKey]);
    }
  }
  serialize() {
    return {
      accounts: __privateGet(this, _privateKeys)
    };
  }
  getPublicAccount(privateKey) {
    const wallet = Wallet.fromPrivateKey(privateKey);
    return {
      address: wallet.address,
      publicKey: wallet.publicKey
    };
  }
  getAccounts() {
    return __privateGet(this, _privateKeys).map((pk) => this.getPublicAccount(pk));
  }
  addAccount() {
    const wallet = Wallet.generate();
    __privateGet(this, _privateKeys).push(wallet.privateKey);
    return this.getPublicAccount(wallet.privateKey);
  }
  exportAccount(address) {
    const ownerAddress = import_address9.Address.fromAddressOrString(address);
    const privateKey = __privateGet(this, _privateKeys).find(
      (pk) => Wallet.fromPrivateKey(pk).address.equals(ownerAddress)
    );
    if (!privateKey) {
      throw new import_errors27.FuelError(
        import_errors27.ErrorCode.WALLET_MANAGER_ERROR,
        `No private key found for address '${address}'.`
      );
    }
    return privateKey;
  }
  getWallet(address) {
    const privateKey = this.exportAccount(address);
    return Wallet.fromPrivateKey(privateKey);
  }
};
_privateKeys = new WeakMap();
__publicField(PrivateKeyVault, "type", "privateKey");

// src/wallet-manager/wallet-manager.ts
var ERROR_MESSAGES = {
  invalid_vault_type: "The provided Vault type is invalid.",
  address_not_found: "No private key found for address the specified wallet address.",
  vault_not_found: "The specified vault was not found.",
  wallet_not_unlocked: "The wallet is currently locked.",
  passphrase_not_match: "The provided passphrase did not match the expected value."
};
function assert(condition, message) {
  if (!condition) {
    throw new import_errors28.FuelError(import_errors28.ErrorCode.WALLET_MANAGER_ERROR, message);
  }
}
var _vaults, _passphrase, _isLocked, _serializeVaults, serializeVaults_fn, _deserializeVaults, deserializeVaults_fn;
var _WalletManager = class extends import_events.EventEmitter {
  constructor(options) {
    super();
    /**
     * Serialize all vaults to store
     *
     * `This is only accessible from inside the class`
     */
    __privateAdd(this, _serializeVaults);
    /**
     * Deserialize all vaults to state
     *
     * `This is only accessible from inside the class`
     */
    __privateAdd(this, _deserializeVaults);
    /**
     * Storage
     *
     * Persistent encrypted data. `The default storage works only on memory`.
     */
    __publicField(this, "storage", new MemoryStorage());
    /* Key name passed to the storage */
    __publicField(this, "STORAGE_KEY", "WalletManager");
    // `This variables are only accessible from inside the class`
    __privateAdd(this, _vaults, []);
    __privateAdd(this, _passphrase, "");
    __privateAdd(this, _isLocked, true);
    this.storage = options?.storage || this.storage;
  }
  get isLocked() {
    return __privateGet(this, _isLocked);
  }
  /**
   * Return the vault serialized object containing all the privateKeys,
   * the format of the return depends on the Vault type.
   */
  exportVault(vaultId) {
    assert(!__privateGet(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const vaultState = __privateGet(this, _vaults).find((_, idx) => idx === vaultId);
    assert(vaultState, ERROR_MESSAGES.vault_not_found);
    return vaultState.vault.serialize();
  }
  /**
   * List all vaults on the Wallet Manager, this function not return secret's
   */
  getVaults() {
    return __privateGet(this, _vaults).map((v, idx) => ({
      title: v.title,
      type: v.type,
      vaultId: idx
    }));
  }
  /**
   * List all accounts on the Wallet Manager not vault information is revealed
   */
  getAccounts() {
    return __privateGet(this, _vaults).flatMap(
      (vaultState, vaultId) => vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))
    );
  }
  /**
   * Create a Wallet instance for the specific account
   */
  getWallet(address) {
    const ownerAddress = import_address10.Address.fromAddressOrString(address);
    const vaultState = __privateGet(this, _vaults).find(
      (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))
    );
    assert(vaultState, ERROR_MESSAGES.address_not_found);
    return vaultState.vault.getWallet(ownerAddress);
  }
  /**
   * Export specific account privateKey
   */
  exportPrivateKey(address) {
    const ownerAddress = import_address10.Address.fromAddressOrString(address);
    assert(!__privateGet(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const vaultState = __privateGet(this, _vaults).find(
      (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))
    );
    assert(vaultState, ERROR_MESSAGES.address_not_found);
    return vaultState.vault.exportAccount(ownerAddress);
  }
  /**
   * Add account to a selected vault or on the first vault as default.
   * If not vaults are adds it will return error
   */
  async addAccount(options) {
    await this.loadState();
    const vaultState = __privateGet(this, _vaults)[options?.vaultId || 0];
    await assert(vaultState, ERROR_MESSAGES.vault_not_found);
    const account = vaultState.vault.addAccount();
    await this.saveState();
    return account;
  }
  /**
   * Remove vault by index, by remove the vault you also remove all accounts
   * created by the vault.
   */
  async removeVault(index) {
    __privateGet(this, _vaults).splice(index, 1);
    await this.saveState();
  }
  /**
   * Add Vault, the `vaultConfig.type` will look for the Vaults supported if
   * didn't found it will throw.
   */
  async addVault(vaultConfig) {
    await this.loadState();
    const Vault2 = this.getVaultClass(vaultConfig.type);
    const vault = new Vault2(vaultConfig);
    __privateSet(this, _vaults, __privateGet(this, _vaults).concat({
      title: vaultConfig.title,
      type: vaultConfig.type,
      vault
    }));
    await this.saveState();
  }
  /**
   * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and
   * secrets.
   */
  lock() {
    __privateSet(this, _isLocked, true);
    __privateSet(this, _vaults, []);
    __privateSet(this, _passphrase, "");
    this.emit("lock");
  }
  /**
   * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.
   * Vaults with secrets are not unlocked or instantiated on this moment.
   */
  async unlock(passphrase) {
    __privateSet(this, _passphrase, passphrase);
    __privateSet(this, _isLocked, false);
    try {
      await this.loadState();
      this.emit("unlock");
    } catch (err) {
      await this.lock();
      throw err;
    }
  }
  /**
   * Update WalletManager encryption passphrase
   */
  async updatePassphrase(oldpass, newpass) {
    const isLocked = __privateGet(this, _isLocked);
    await this.unlock(oldpass);
    __privateSet(this, _passphrase, newpass);
    await this.saveState();
    await this.loadState();
    if (isLocked) {
      await this.lock();
    }
  }
  /**
   * Retrieve and decrypt WalletManager state from storage
   */
  async loadState() {
    await assert(!__privateGet(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const data = await this.storage.getItem(this.STORAGE_KEY);
    if (data) {
      const state = await (0, import_crypto7.decrypt)(__privateGet(this, _passphrase), JSON.parse(data));
      __privateSet(this, _vaults, __privateMethod(this, _deserializeVaults, deserializeVaults_fn).call(this, state.vaults));
    }
  }
  /**
   * Store encrypted WalletManager state on storage
   */
  async saveState() {
    await assert(!__privateGet(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const encryptedData = await (0, import_crypto7.encrypt)(__privateGet(this, _passphrase), {
      vaults: __privateMethod(this, _serializeVaults, serializeVaults_fn).call(this, __privateGet(this, _vaults))
    });
    await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));
    this.emit("update");
  }
  /**
   * Return a instantiable Class reference from `WalletManager.Vaults` supported list.
   */
  getVaultClass(type) {
    const VaultClass = _WalletManager.Vaults.find((v) => v.type === type);
    assert(VaultClass, ERROR_MESSAGES.invalid_vault_type);
    return VaultClass;
  }
};
var WalletManager = _WalletManager;
_vaults = new WeakMap();
_passphrase = new WeakMap();
_isLocked = new WeakMap();
_serializeVaults = new WeakSet();
serializeVaults_fn = function(vaults) {
  return vaults.map(({ title, type, vault }) => ({
    title,
    type,
    data: vault.serialize()
  }));
};
_deserializeVaults = new WeakSet();
deserializeVaults_fn = function(vaults) {
  return vaults.map(({ title, type, data: vaultConfig }) => {
    const VaultClass = this.getVaultClass(type);
    return {
      title,
      type,
      vault: new VaultClass(vaultConfig)
    };
  });
};
/**
 * Vaults
 *
 * Vaults are responsible to store secret keys and return an `Wallet` instance,
 * to interact with the network.
 *
 * Each vault has access to its own state
 *
 */
__publicField(WalletManager, "Vaults", [MnemonicVault, PrivateKeyVault]);

// src/wallet-manager/types.ts
var import_errors29 = require("@fuel-ts/errors");
var Vault = class {
  constructor(_options) {
    throw new import_errors29.FuelError(import_errors29.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  serialize() {
    throw new import_errors29.FuelError(import_errors29.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  getAccounts() {
    throw new import_errors29.FuelError(import_errors29.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  addAccount() {
    throw new import_errors29.FuelError(import_errors29.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  exportAccount(_address) {
    throw new import_errors29.FuelError(import_errors29.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  getWallet(_address) {
    throw new import_errors29.FuelError(import_errors29.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
};
__publicField(Vault, "type");
var StorageAbstract = class {
};

// src/predicate/predicate.ts
var import_abi_coder8 = require("@fuel-ts/abi-coder");
var import_address11 = require("@fuel-ts/address");
var import_errors31 = require("@fuel-ts/errors");
var import_utils45 = require("@fuel-ts/utils");

// src/utils/deployScriptOrPredicate.ts
var import_errors30 = require("@fuel-ts/errors");
var import_hasher8 = require("@fuel-ts/hasher");
var import_math23 = require("@fuel-ts/math");
var import_utils43 = require("@fuel-ts/utils");

// src/utils/predicate-script-loader-instructions.ts
var import_utils42 = require("@fuel-ts/utils");
var asm2 = __toESM(require("@fuels/vm-asm"));
var BLOB_ID_SIZE = 32;
var REG_ADDRESS_OF_DATA_AFTER_CODE = 16;
var REG_START_OF_LOADED_CODE = 17;
var REG_GENERAL_USE = 18;
var WORD_SIZE2 = 8;
function getDataOffset(binary) {
  const OFFSET_INDEX = 8;
  const dataView = new DataView(binary.buffer, OFFSET_INDEX, 8);
  const dataOffset = dataView.getBigUint64(0, false);
  return Number(dataOffset);
}
function getPredicateScriptLoaderInstructions(originalBinary, blobId) {
  const { RegId, Instruction } = asm2;
  const REG_PC = RegId.pc().to_u8();
  const REG_SP = RegId.sp().to_u8();
  const REG_IS = RegId.is().to_u8();
  const getInstructions = (numOfInstructions2) => [
    // 1. Load the blob content into memory
    // Find the start of the hardcoded blob ID, which is located after the loader code ends.
    asm2.move_(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_PC),
    // hold the address of the blob ID.
    asm2.addi(
      REG_ADDRESS_OF_DATA_AFTER_CODE,
      REG_ADDRESS_OF_DATA_AFTER_CODE,
      numOfInstructions2 * Instruction.size()
    ),
    // The code is going to be loaded from the current value of SP onwards, save
    // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.
    asm2.move_(REG_START_OF_LOADED_CODE, REG_SP),
    // REG_GENERAL_USE to hold the size of the blob.
    asm2.bsiz(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE),
    // Push the blob contents onto the stack.
    asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 1),
    // Move on to the data section length
    asm2.addi(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_ADDRESS_OF_DATA_AFTER_CODE, BLOB_ID_SIZE),
    // load the size of the data section into REG_GENERAL_USE
    asm2.lw(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE, 0),
    // after we have read the length of the data section, we move the pointer to the actual
    // data by skipping WORD_SIZE bytes.
    asm2.addi(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_ADDRESS_OF_DATA_AFTER_CODE, WORD_SIZE2),
    // load the data section of the executable
    asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 2),
    // Jump into the memory where the contract is loaded.
    // What follows is called _jmp_mem by the sway compiler.
    // Subtract the address contained in IS because jmp will add it back.
    asm2.sub(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, REG_IS),
    // jmp will multiply by 4, so we need to divide to cancel that out.
    asm2.divi(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, 4),
    // Jump to the start of the contract we loaded.
    asm2.jmp(REG_START_OF_LOADED_CODE)
  ];
  const getInstructionsNoDataSection = (numOfInstructions2) => [
    // 1. Load the blob content into memory
    // Find the start of the hardcoded blob ID, which is located after the loader code ends.
    // 1. Load the blob content into memory
    // Find the start of the hardcoded blob ID, which is located after the loader code ends.
    asm2.move_(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_PC),
    // hold the address of the blob ID.
    asm2.addi(
      REG_ADDRESS_OF_DATA_AFTER_CODE,
      REG_ADDRESS_OF_DATA_AFTER_CODE,
      numOfInstructions2 * Instruction.size()
    ),
    // The code is going to be loaded from the current value of SP onwards, save
    // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.
    asm2.move_(REG_START_OF_LOADED_CODE, REG_SP),
    // REG_GENERAL_USE to hold the size of the blob.
    asm2.bsiz(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE),
    // Push the blob contents onto the stack.
    asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 1),
    // Jump into the memory where the contract is loaded.
    // What follows is called _jmp_mem by the sway compiler.
    // Subtract the address contained in IS because jmp will add it back.
    asm2.sub(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, REG_IS),
    // jmp will multiply by 4, so we need to divide to cancel that out.
    asm2.divi(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, 4),
    // Jump to the start of the contract we loaded.
    asm2.jmp(REG_START_OF_LOADED_CODE)
  ];
  const offset = getDataOffset(originalBinary);
  if (originalBinary.length < offset) {
    throw new Error(
      `Data section offset is out of bounds, offset: ${offset}, binary length: ${originalBinary.length}`
    );
  }
  const dataSection = originalBinary.slice(offset);
  if (dataSection.length > 0) {
    const numOfInstructions2 = getInstructions(0).length;
    if (numOfInstructions2 > 65535) {
      throw new Error("Too many instructions, exceeding u16::MAX.");
    }
    const instructionBytes2 = new Uint8Array(
      getInstructions(numOfInstructions2).flatMap(
        (instruction) => Array.from(instruction.to_bytes())
      )
    );
    const blobBytes2 = new Uint8Array(blobId);
    const dataSectionLenBytes = new Uint8Array(8);
    const dataView = new DataView(dataSectionLenBytes.buffer);
    dataView.setBigUint64(0, BigInt(dataSection.length), false);
    const loaderBytecode2 = new Uint8Array([
      ...instructionBytes2,
      ...blobBytes2,
      ...dataSectionLenBytes
    ]);
    return {
      loaderBytecode: (0, import_utils42.concat)([loaderBytecode2, dataSection]),
      blobOffset: loaderBytecode2.length
    };
  }
  const numOfInstructions = getInstructionsNoDataSection(0).length;
  if (numOfInstructions > 65535) {
    throw new Error("Too many instructions, exceeding u16::MAX.");
  }
  const instructionBytes = new Uint8Array(
    getInstructionsNoDataSection(numOfInstructions).flatMap(
      (instruction) => Array.from(instruction.to_bytes())
    )
  );
  const blobBytes = new Uint8Array(blobId);
  const loaderBytecode = new Uint8Array([...instructionBytes, ...blobBytes]);
  return { loaderBytecode };
}

// src/utils/deployScriptOrPredicate.ts
async function fundBlobTx(deployer, blobTxRequest) {
  let totalCost = (0, import_math23.bn)(0);
  const chainInfo = await deployer.provider.getChain();
  const gasPrice = await deployer.provider.estimateGasPrice(10);
  const priceFactor = chainInfo.consensusParameters.feeParameters.gasPriceFactor;
  const minGas = blobTxRequest.calculateMinGas(chainInfo);
  const minFee = calculateGasFee({
    gasPrice,
    gas: minGas,
    priceFactor,
    tip: blobTxRequest.tip
  }).add(1);
  totalCost = totalCost.add(minFee);
  if (totalCost.gt(await deployer.getBalance())) {
    throw new import_errors30.FuelError(import_errors30.ErrorCode.FUNDS_TOO_LOW, "Insufficient balance to deploy predicate.");
  }
  const txCost = await deployer.getTransactionCost(blobTxRequest);
  blobTxRequest.maxFee = txCost.maxFee;
  return deployer.fund(blobTxRequest, txCost);
}
function adjustConfigurableOffsets(jsonAbi, configurableOffsetDiff) {
  const { configurables: readOnlyConfigurables } = jsonAbi;
  const configurables = [];
  readOnlyConfigurables.forEach((config) => {
    configurables.push({ ...config, offset: config.offset - configurableOffsetDiff });
  });
  return { ...jsonAbi, configurables };
}
async function deployScriptOrPredicate({
  deployer,
  bytecode,
  abi,
  loaderInstanceCallback
}) {
  const dataSectionOffset = getDataOffset((0, import_utils43.arrayify)(bytecode));
  const byteCodeWithoutDataSection = bytecode.slice(0, dataSectionOffset);
  const blobId = (0, import_hasher8.hash)(byteCodeWithoutDataSection);
  const blobTxRequest = new BlobTransactionRequest({
    blobId,
    witnessIndex: 0,
    witnesses: [byteCodeWithoutDataSection]
  });
  const { loaderBytecode, blobOffset } = getPredicateScriptLoaderInstructions(
    (0, import_utils43.arrayify)(bytecode),
    (0, import_utils43.arrayify)(blobId)
  );
  const configurableOffsetDiff = byteCodeWithoutDataSection.length - (blobOffset || 0);
  const newAbi = adjustConfigurableOffsets(abi, configurableOffsetDiff);
  const blobExists = (await deployer.provider.getBlobs([blobId])).length > 0;
  const loaderInstance = loaderInstanceCallback(loaderBytecode, newAbi);
  if (blobExists) {
    return {
      waitForResult: () => Promise.resolve(loaderInstance),
      blobId
    };
  }
  const fundedBlobRequest = await fundBlobTx(deployer, blobTxRequest);
  const waitForResult = async () => {
    try {
      const blobTx = await deployer.sendTransaction(fundedBlobRequest);
      const result = await blobTx.waitForResult();
      if (result.status !== "success" /* success */) {
        throw new Error();
      }
    } catch (err) {
      throw new import_errors30.FuelError(import_errors30.ErrorCode.TRANSACTION_FAILED, "Failed to deploy predicate chunk");
    }
    return loaderInstance;
  };
  return {
    waitForResult,
    blobId
  };
}

// src/predicate/utils/getPredicateRoot.ts
var import_hasher9 = require("@fuel-ts/hasher");
var import_merkle = require("@fuel-ts/merkle");
var import_utils44 = require("@fuel-ts/utils");
var getPredicateRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes = (0, import_utils44.arrayify)(bytecode);
  const chunks = (0, import_utils44.chunkAndPadBytes)(bytes, chunkSize);
  const codeRoot = (0, import_merkle.calcRoot)(chunks.map((c) => (0, import_utils44.hexlify)(c)));
  const predicateRoot = (0, import_hasher9.hash)((0, import_utils44.concat)(["0x4655454C", codeRoot]));
  return predicateRoot;
};

// src/predicate/predicate.ts
var Predicate = class extends Account {
  bytes;
  predicateData = [];
  interface;
  initialBytecode;
  configurableConstants;
  /**
   * Creates an instance of the Predicate class.
   *
   * @param bytecode - The bytecode of the predicate.
   * @param abi - The JSON ABI of the predicate.
   * @param provider - The provider used to interact with the blockchain.
   * @param data - The predicate input data (optional).
   * @param configurableConstants - Optional configurable constants for the predicate.
   */
  constructor({
    bytecode,
    abi,
    provider,
    data,
    configurableConstants
  }) {
    const { predicateBytes, predicateInterface } = Predicate.processPredicateData(
      bytecode,
      abi,
      configurableConstants
    );
    const address = import_address11.Address.fromB256(getPredicateRoot(predicateBytes));
    super(address, provider);
    this.initialBytecode = (0, import_utils45.arrayify)(bytecode);
    this.bytes = predicateBytes;
    this.interface = predicateInterface;
    this.configurableConstants = configurableConstants;
    if (data !== void 0 && data.length > 0) {
      this.predicateData = data;
    }
  }
  /**
   * Populates the transaction data with predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns The transaction request with predicate data.
   */
  populateTransactionPredicateData(transactionRequestLike) {
    const request = transactionRequestify(transactionRequestLike);
    const placeholderIndex = this.getIndexFromPlaceholderWitness(request);
    if (placeholderIndex !== -1) {
      request.removeWitness(placeholderIndex);
    }
    request.inputs.filter(isRequestInputCoinOrMessage).forEach((input) => {
      if (isRequestInputResourceFromOwner(input, this.address)) {
        input.predicate = (0, import_utils45.hexlify)(this.bytes);
        input.predicateData = (0, import_utils45.hexlify)(this.getPredicateData());
        input.witnessIndex = 0;
      }
    });
    return request;
  }
  /**
   * Sends a transaction with the populated predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns A promise that resolves to the transaction response.
   */
  sendTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    return super.sendTransaction(transactionRequest, { estimateTxDependencies: false });
  }
  /**
   * Simulates a transaction with the populated predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns A promise that resolves to the call result.
   */
  simulateTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    return super.simulateTransaction(transactionRequest, { estimateTxDependencies: false });
  }
  getPredicateData() {
    if (!this.predicateData.length) {
      return new Uint8Array();
    }
    const mainFn = this.interface?.functions.main;
    return mainFn?.encodeArguments(this.predicateData) || new Uint8Array();
  }
  /**
   * Creates a new Predicate instance from an existing Predicate instance.
   * @param overrides - The data and configurable constants to override.
   * @returns A new Predicate instance with the same bytecode, ABI and provider but with the ability to set the data and configurable constants.
   */
  toNewInstance(overrides = {}) {
    return new Predicate({
      bytecode: this.initialBytecode,
      abi: this.interface.jsonAbi,
      provider: this.provider,
      data: overrides.data ?? this.predicateData,
      configurableConstants: overrides.configurableConstants ?? this.configurableConstants
    });
  }
  /**
   * Processes the predicate data and returns the altered bytecode and interface.
   *
   * @param bytes - The bytes of the predicate.
   * @param jsonAbi - The JSON ABI of the predicate.
   * @param configurableConstants - Optional configurable constants for the predicate.
   * @returns An object containing the new predicate bytes and interface.
   */
  static processPredicateData(bytes, jsonAbi, configurableConstants) {
    let predicateBytes = (0, import_utils45.arrayify)(bytes);
    const abiInterface = new import_abi_coder8.Interface(jsonAbi);
    if (abiInterface.functions.main === void 0) {
      throw new import_errors31.FuelError(
        import_errors31.ErrorCode.ABI_MAIN_METHOD_MISSING,
        'Cannot use ABI without "main" function.'
      );
    }
    if (configurableConstants && Object.keys(configurableConstants).length) {
      predicateBytes = Predicate.setConfigurableConstants(
        predicateBytes,
        configurableConstants,
        abiInterface
      );
    }
    return {
      predicateBytes,
      predicateInterface: abiInterface
    };
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param excludedIds - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    const resources = await this.provider.getResourcesToSpend(
      this.address,
      quantities,
      excludedIds
    );
    return resources.map((resource) => ({
      ...resource,
      predicate: (0, import_utils45.hexlify)(this.bytes),
      predicateData: (0, import_utils45.hexlify)(this.getPredicateData())
    }));
  }
  /**
   * Generates an array of fake resources based on the provided coins.
   *
   * @param coins - An array of `FakeResources` objects representing the coins.
   * @returns An array of `Resource` objects with generated properties.
   */
  generateFakeResources(coins) {
    return super.generateFakeResources(coins).map((coin) => ({
      ...coin,
      predicate: (0, import_utils45.hexlify)(this.bytes),
      predicateData: (0, import_utils45.hexlify)(this.getPredicateData())
    }));
  }
  /**
   * Sets the configurable constants for the predicate.
   *
   * @param bytes - The bytes of the predicate.
   * @param configurableConstants - Configurable constants to be set.
   * @param abiInterface - The ABI interface of the predicate.
   * @returns The mutated bytes with the configurable constants set.
   */
  static setConfigurableConstants(bytes, configurableConstants, abiInterface) {
    const mutatedBytes = bytes;
    try {
      if (Object.keys(abiInterface.configurables).length === 0) {
        throw new import_errors31.FuelError(
          import_errors31.ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
          "Predicate has no configurable constants to be set"
        );
      }
      Object.entries(configurableConstants).forEach(([key, value]) => {
        if (!abiInterface?.configurables[key]) {
          throw new import_errors31.FuelError(
            import_errors31.ErrorCode.CONFIGURABLE_NOT_FOUND,
            `No configurable constant named '${key}' found in the Predicate`
          );
        }
        const { offset } = abiInterface.configurables[key];
        const encoded = abiInterface.encodeConfigurable(key, value);
        mutatedBytes.set(encoded, offset);
      });
    } catch (err) {
      throw new import_errors31.FuelError(
        import_errors31.ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants: ${err.message}.`
      );
    }
    return mutatedBytes;
  }
  /**
   * Returns the index of the witness placeholder that was added to this predicate.
   * If no witness placeholder was added, it returns -1.
   * @param request - The transaction request.
   * @returns The index of the witness placeholder, or -1 if there is no witness placeholder.
   */
  getIndexFromPlaceholderWitness(request) {
    const predicateInputs = request.inputs.filter(isRequestInputResource).filter((input) => isRequestInputResourceFromOwner(input, this.address));
    let index = -1;
    const hasEmptyPredicateInputs = predicateInputs.find((input) => !input.predicate);
    if (hasEmptyPredicateInputs) {
      index = hasEmptyPredicateInputs.witnessIndex;
      const allInputsAreEmpty = predicateInputs.every((input) => !input.predicate);
      if (!allInputsAreEmpty) {
        const wasFilledInputAddedFirst = !!predicateInputs[0]?.predicate;
        if (wasFilledInputAddedFirst) {
          index = -1;
        }
      }
    }
    return index;
  }
  /**
   *
   * @param account - The account used to pay the deployment costs.
   * @returns The _blobId_ and a _waitForResult_ callback that returns the deployed predicate
   * once the blob deployment transaction finishes.
   *
   * The returned loader predicate will have the same configurable constants
   * as the original predicate which was used to generate the loader predicate.
   */
  async deploy(account) {
    return deployScriptOrPredicate({
      deployer: account,
      abi: this.interface.jsonAbi,
      bytecode: this.bytes,
      loaderInstanceCallback: (loaderBytecode, newAbi) => new Predicate({
        bytecode: loaderBytecode,
        abi: newAbi,
        provider: this.provider,
        data: this.predicateData
      })
    });
  }
};

// src/connectors/fuel.ts
var import_errors34 = require("@fuel-ts/errors");

// src/connectors/fuel-connector.ts
var import_errors32 = require("@fuel-ts/errors");
var import_events2 = require("events");

// src/connectors/types/connector-types.ts
var FuelConnectorMethods = /* @__PURE__ */ ((FuelConnectorMethods2) => {
  FuelConnectorMethods2["ping"] = "ping";
  FuelConnectorMethods2["version"] = "version";
  FuelConnectorMethods2["connect"] = "connect";
  FuelConnectorMethods2["disconnect"] = "disconnect";
  FuelConnectorMethods2["isConnected"] = "isConnected";
  FuelConnectorMethods2["accounts"] = "accounts";
  FuelConnectorMethods2["currentAccount"] = "currentAccount";
  FuelConnectorMethods2["signMessage"] = "signMessage";
  FuelConnectorMethods2["sendTransaction"] = "sendTransaction";
  FuelConnectorMethods2["assets"] = "assets";
  FuelConnectorMethods2["addAsset"] = "addAsset";
  FuelConnectorMethods2["addAssets"] = "addAssets";
  FuelConnectorMethods2["networks"] = "networks";
  FuelConnectorMethods2["currentNetwork"] = "currentNetwork";
  FuelConnectorMethods2["addNetwork"] = "addNetwork";
  FuelConnectorMethods2["selectNetwork"] = "selectNetwork";
  FuelConnectorMethods2["addABI"] = "addABI";
  FuelConnectorMethods2["getABI"] = "getABI";
  FuelConnectorMethods2["hasABI"] = "hasABI";
  return FuelConnectorMethods2;
})(FuelConnectorMethods || {});
var FuelConnectorEventTypes = /* @__PURE__ */ ((FuelConnectorEventTypes2) => {
  FuelConnectorEventTypes2["connectors"] = "connectors";
  FuelConnectorEventTypes2["currentConnector"] = "currentConnector";
  FuelConnectorEventTypes2["connection"] = "connection";
  FuelConnectorEventTypes2["accounts"] = "accounts";
  FuelConnectorEventTypes2["currentAccount"] = "currentAccount";
  FuelConnectorEventTypes2["networks"] = "networks";
  FuelConnectorEventTypes2["currentNetwork"] = "currentNetwork";
  FuelConnectorEventTypes2["assets"] = "assets";
  FuelConnectorEventTypes2["abis"] = "abis";
  return FuelConnectorEventTypes2;
})(FuelConnectorEventTypes || {});
var FuelConnectorEventType = "FuelConnector";

// src/connectors/types/local-storage.ts
var LocalStorage = class {
  storage;
  constructor(localStorage) {
    this.storage = localStorage;
  }
  async setItem(key, value) {
    this.storage.setItem(key, value);
  }
  async getItem(key) {
    return this.storage.getItem(key);
  }
  async removeItem(key) {
    this.storage.removeItem(key);
  }
  async clear() {
    this.storage.clear();
  }
};

// src/connectors/fuel-connector.ts
var FuelConnector = class extends import_events2.EventEmitter {
  name = "";
  metadata = {};
  connected = false;
  installed = false;
  external = true;
  events = FuelConnectorEventTypes;
  /**
   * Should return true if the connector is loaded
   * in less then one second.
   *
   * @returns Always true.
   */
  async ping() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return the current version of the connector
   * and the network version that is compatible.
   *
   * @returns boolean - connection status.
   */
  async version() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return true if the connector is connected
   * to any of the accounts available.
   *
   * @returns The connection status.
   */
  async isConnected() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return all the accounts authorized for the
   * current connection.
   *
   * @returns The accounts addresses strings
   */
  async accounts() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the connection process and return
   * true if the account authorize the connection.
   *
   * and return false if the user reject the connection.
   *
   * @emits accounts
   * @returns boolean - connection status.
   */
  async connect() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should disconnect the current connection and
   * return false if the disconnection was successful.
   *
   * @emits assets connection
   * @returns The connection status.
   */
  async disconnect() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the sign message process and return
   * the signed message.
   *
   * @param address - The address to sign the message
   * @param message - The message to sign all text will be treated as text utf-8
   *
   * @returns Message signature
   */
  async signMessage(_address, _message) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the sign transaction process and return
   * the signed transaction.
   *
   * @param address - The address to sign the transaction
   * @param transaction - The transaction to sign
   *
   * @returns Transaction signature
   */
  async signTransaction(_address, _transaction) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the send transaction process and return
   * the transaction id submitted to the network.
   *
   * If the network is not available for the connection
   * it should throw an error to avoid the transaction
   * to be sent to the wrong network and lost.
   *
   * @param address - The address to sign the transaction
   * @param transaction - The transaction to send
   * @param params - Optional parameters to send the transaction
   * @returns The transaction id
   */
  async sendTransaction(_address, _transaction, _params) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return the current account selected inside the connector, if the account
   * is authorized for the connection.
   *
   * If the account is not authorized it should return null.
   *
   * @returns The current account selected otherwise null.
   */
  async currentAccount() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should add the assets metadata to the connector and return true if the asset
   * was added successfully.
   *
   * If the asset already exists it should throw an error.
   *
   * @emits assets
   * @param assets - The assets to add the metadata to the connection.
   * @throws Error if the asset already exists
   * @returns True if the asset was added successfully
   */
  async addAssets(_assets) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should add the asset metadata to the connector and return true if the asset
   * was added successfully.
   *
   * If the asset already exists it should throw an error.
   *
   * @emits assets
   * @param asset - The asset to add the metadata to the connection.
   * @throws Error if the asset already exists
   * @returns True if the asset was added successfully
   */
  async addAsset(_asset) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return all the assets added to the connector. If a connection is already established.
   *
   * @returns Array of assets metadata from the connector vinculated to the all accounts from a specific Wallet.
   */
  async assets() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the add network process and return true if the network was added successfully.
   *
   * @emits networks
   * @throws Error if the network already exists
   * @param networkUrl - The URL of the network to be added.
   * @returns Return true if the network was added successfully
   */
  async addNetwork(_networkUrl) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should start the select network process and return true if the network has change successfully.
   *
   * @emits networks
   * @throws Error if the network already exists
   * @param network - The network to be selected.
   * @returns Return true if the network was added successfully
   */
  async selectNetwork(_network) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return all the networks available from the connector. If the connection is already established.
   *
   * @returns Return all the networks added to the connector.
   */
  async networks() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return the current network selected inside the connector. Even if the connection is not established.
   *
   * @returns Return the current network selected inside the connector.
   */
  async currentNetwork() {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should add the ABI to the connector and return true if the ABI was added successfully.
   *
   * @param contractId - The contract id to add the ABI.
   * @param abi - The JSON ABI that represents a contract.
   * @returns Return true if the ABI was added successfully.
   */
  async addABI(_contractId, _abi) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.
   *
   * @param id - The contract id to get the ABI.
   * @returns The ABI if it exists, otherwise return null.
   */
  async getABI(_id) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.
   *
   * @param id - The contract id to get the abi
   * @returns Returns true if the abi exists or false if not.
   */
  async hasABI(_id) {
    throw new import_errors32.FuelError(import_errors32.FuelError.CODES.NOT_IMPLEMENTED, "Method not implemented.");
  }
  /**
   * Event listener for the connector.
   *
   * @param eventName - The event name to listen
   * @param listener - The listener function
   */
  on(eventName, listener) {
    super.on(eventName, listener);
    return this;
  }
};

// src/connectors/utils/cache.ts
function cacheFor(fn, { cache: cache2, cacheTime, key }) {
  return async (...args) => {
    if (cache2[key] && cache2[key]?.value) {
      return cache2[key]?.value;
    }
    clearTimeout(cache2[key]?.timeout);
    const result = await fn(...args);
    cache2[key] = {
      timeout: Number(
        setTimeout(() => {
          cache2[key] = null;
        }, cacheTime)
      ),
      value: result
    };
    return result;
  };
}

// src/connectors/utils/dispatch-fuel-connector-event.ts
function dispatchFuelConnectorEvent(connector) {
  window.dispatchEvent(
    new CustomEvent(FuelConnectorEventType, {
      detail: connector
    })
  );
}

// src/connectors/utils/promises.ts
var import_errors33 = require("@fuel-ts/errors");
function deferPromise() {
  const defer = {};
  defer.promise = new Promise((resolve, reject) => {
    defer.reject = reject;
    defer.resolve = resolve;
  });
  return defer;
}
async function withTimeout(promise, timeout = 1050) {
  const timeoutPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new import_errors33.FuelError(import_errors33.FuelError.CODES.TIMEOUT_EXCEEDED, "Promise timed out"));
    }, timeout);
  });
  return Promise.race([timeoutPromise, promise]);
}

// src/connectors/fuel.ts
var HAS_CONNECTOR_TIMEOUT = 2e3;
var PING_CACHE_TIME = 5e3;
var { warn } = console;
var _Fuel = class extends FuelConnector {
  _storage = null;
  _connectors = [];
  _targetObject = null;
  _unsubscribes = [];
  _targetUnsubscribe = () => {
  };
  _pingCache = {};
  _currentConnector;
  _initializationPromise = null;
  constructor(config = _Fuel.defaultConfig) {
    super();
    this.setMaxListeners(1e3);
    this._connectors = config.connectors ?? [];
    this._targetObject = this.getTargetObject(config.targetObject);
    this._storage = config.storage === void 0 ? this.getStorage() : config.storage;
    this.setupMethods();
    this._initializationPromise = this.initialize();
  }
  async initialize() {
    try {
      const connectResponse = this.setDefaultConnector();
      this._targetUnsubscribe = this.setupConnectorListener();
      await connectResponse;
    } catch (error) {
      throw new import_errors34.FuelError(import_errors34.ErrorCode.INVALID_PROVIDER, "Error initializing Fuel Connector");
    }
  }
  async init() {
    await this._initializationPromise;
    return this;
  }
  /**
   * Return the target object to listen for global events.
   */
  getTargetObject(targetObject) {
    if (targetObject) {
      return targetObject;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof document !== "undefined") {
      return document;
    }
    return null;
  }
  /**
   * Return the storage used.
   */
  getStorage() {
    if (typeof window !== "undefined") {
      return new LocalStorage(window.localStorage);
    }
    return void 0;
  }
  /**
   * Setup the default connector from the storage.
   */
  async setDefaultConnector() {
    const connectorName = await this._storage?.getItem(_Fuel.STORAGE_KEY) || this._connectors[0]?.name;
    if (connectorName) {
      return this.selectConnector(connectorName, {
        emitEvents: false
      });
    }
    return void 0;
  }
  /**
   * Start listener for all the events of the current
   * connector and emit them to the Fuel instance
   */
  setupConnectorEvents(events) {
    if (!this._currentConnector) {
      return;
    }
    const currentConnector = this._currentConnector;
    this._unsubscribes.map((unSub) => unSub());
    this._unsubscribes = events.map((event) => {
      const handler = (...args) => this.emit(event, ...args);
      currentConnector.on(event, handler);
      return () => currentConnector.off(event, handler);
    });
  }
  /**
   * Call method from the current connector.
   */
  async callMethod(method, ...args) {
    const hasConnector = await this.hasConnector();
    await this.pingConnector();
    if (!this._currentConnector || !hasConnector) {
      throw new import_errors34.FuelError(
        import_errors34.ErrorCode.MISSING_CONNECTOR,
        `No connector selected for calling ${method}. Use hasConnector before executing other methods.`
      );
    }
    if (typeof this._currentConnector[method] === "function") {
      return this._currentConnector[method](...args);
    }
    return void 0;
  }
  /**
   * Create a method for each method proxy that is available on the Common interface
   * and call the method from the current connector.
   */
  setupMethods() {
    Object.values(FuelConnectorMethods).forEach((method) => {
      this[method] = async (...args) => this.callMethod(method, ...args);
    });
  }
  /**
   * Fetch the status of a connector and set the installed and connected
   * status.
   */
  async fetchConnectorStatus(connector) {
    const requestTimestamp = Date.now();
    const [isConnected, ping] = await Promise.allSettled([
      withTimeout(connector.isConnected()),
      withTimeout(this.pingConnector(connector))
    ]);
    const isStale = requestTimestamp < (connector._latestUpdate || 0);
    if (!isStale) {
      connector._latestUpdate = Date.now();
      connector.installed = ping.status === "fulfilled" && ping.value;
      connector.connected = isConnected.status === "fulfilled" && isConnected.value;
    }
    return {
      installed: connector.installed,
      connected: connector.connected
    };
  }
  /**
   * Fetch the status of all connectors and set the installed and connected
   * status.
   */
  async fetchConnectorsStatus() {
    return Promise.all(
      this._connectors.map(async (connector) => this.fetchConnectorStatus(connector))
    );
  }
  /**
   * Fetch the status of a connector and set the installed and connected
   * status. If no connector is provided it will ping the current connector.
   */
  async pingConnector(connector) {
    const curConnector = connector || this._currentConnector;
    if (!curConnector) {
      return false;
    }
    try {
      return await cacheFor(async () => withTimeout(curConnector.ping()), {
        key: curConnector.name,
        cache: this._pingCache,
        cacheTime: PING_CACHE_TIME
      })();
    } catch {
      throw new import_errors34.FuelError(import_errors34.ErrorCode.INVALID_PROVIDER, "Current connector is not available.");
    }
  }
  /**
   * Setup a listener for the FuelConnector event and add the connector
   * to the list of new connectors.
   */
  setupConnectorListener = () => {
    const { _targetObject: targetObject } = this;
    const eventName = FuelConnectorEventType;
    if (targetObject?.on) {
      targetObject.on(eventName, this.addConnector);
      return () => {
        targetObject.off?.(eventName, this.addConnector);
      };
    }
    if (targetObject?.addEventListener) {
      const handler = (e) => {
        this.addConnector(e.detail);
      };
      targetObject.addEventListener(eventName, handler);
      return () => {
        targetObject.removeEventListener?.(eventName, handler);
      };
    }
    return () => {
    };
  };
  /**
   * Add a new connector to the list of connectors.
   */
  addConnector = async (connector) => {
    if (!this.getConnector(connector)) {
      this._connectors.push(connector);
    }
    await this.fetchConnectorStatus(connector);
    this.emit(this.events.connectors, this._connectors);
    if (!this._currentConnector) {
      await this.selectConnector(connector.name, {
        emitEvents: false
      });
    }
  };
  triggerConnectorEvents = async () => {
    const [isConnected, networks, currentNetwork] = await Promise.all([
      this.isConnected(),
      this.networks(),
      this.currentNetwork()
    ]);
    this.emit(this.events.connection, isConnected);
    this.emit(this.events.networks, networks);
    this.emit(this.events.currentNetwork, currentNetwork);
    if (isConnected) {
      const [accounts, currentAccount] = await Promise.all([
        this.accounts(),
        this.currentAccount()
      ]);
      this.emit(this.events.accounts, accounts);
      this.emit(this.events.currentAccount, currentAccount);
    }
  };
  /**
   * Get a connector from the list of connectors.
   */
  getConnector = (connector) => this._connectors.find((c) => {
    const connectorName = typeof connector === "string" ? connector : connector.name;
    return c.name === connectorName || c === connector;
  }) || null;
  /**
   * Return the list of connectors with the status of installed and connected.
   */
  async connectors() {
    await this.fetchConnectorsStatus();
    return this._connectors;
  }
  /**
   * Set the current connector to be used.
   */
  async selectConnector(connectorName, options = {
    emitEvents: true
  }) {
    const connector = this.getConnector(connectorName);
    if (!connector) {
      return false;
    }
    if (this._currentConnector?.name === connectorName) {
      return true;
    }
    const { installed } = await this.fetchConnectorStatus(connector);
    if (installed) {
      this._currentConnector = connector;
      this.emit(this.events.currentConnector, connector);
      this.setupConnectorEvents(Object.values(FuelConnectorEventTypes));
      await this._storage?.setItem(_Fuel.STORAGE_KEY, connector.name);
      if (options.emitEvents) {
        this.triggerConnectorEvents();
      }
      return true;
    }
    return false;
  }
  /**
   * Return the current selected connector.
   */
  currentConnector() {
    return this._currentConnector;
  }
  /**
   * Return true if any connector is available.
   */
  async hasConnector() {
    if (this._currentConnector) {
      return true;
    }
    const defer = deferPromise();
    this.once(this.events.currentConnector, () => {
      defer.resolve(true);
    });
    return withTimeout(defer.promise, HAS_CONNECTOR_TIMEOUT).then(() => true).catch(() => false);
  }
  async hasWallet() {
    return this.hasConnector();
  }
  /**
   * Return a Fuel Provider instance with extends features to work with
   * connectors.
   *
   * @deprecated getProvider is deprecated and is going to be removed in the future, use getWallet instead.
   */
  async getProvider(providerOrNetwork) {
    warn(
      "getProvider is deprecated and is going to be removed in the future, use getWallet instead."
    );
    return this._getProvider(providerOrNetwork);
  }
  /**
   * Return a Fuel Provider instance with extends features to work with
   * connectors.
   */
  async _getProvider(providerOrNetwork) {
    let provider;
    if (providerOrNetwork && "getTransactionResponse" in providerOrNetwork) {
      provider = providerOrNetwork;
    } else if (providerOrNetwork && "chainId" in providerOrNetwork && "url" in providerOrNetwork) {
      provider = new Provider(providerOrNetwork.url);
    } else if (!providerOrNetwork) {
      const currentNetwork = await this.currentNetwork();
      provider = new Provider(currentNetwork.url);
    } else {
      throw new import_errors34.FuelError(import_errors34.ErrorCode.INVALID_PROVIDER, "Provider is not valid.");
    }
    return provider;
  }
  /**
   * Return a Fuel Wallet Locked instance with extends features to work with
   * connectors.
   */
  async getWallet(address, providerOrNetwork) {
    const provider = await this._getProvider(providerOrNetwork);
    return new Account(address, provider, this);
  }
  /**
   * Remove all open listeners this is useful when you want to
   * remove the Fuel instance and avoid memory leaks.
   */
  unsubscribe() {
    this._unsubscribes.map((unSub) => unSub());
    this._targetUnsubscribe();
    this.removeAllListeners();
  }
  /**
   * Clean all the data from the storage.
   */
  async clean() {
    await this._storage?.removeItem(_Fuel.STORAGE_KEY);
  }
  /**
   * Removes all listeners and cleans the storage.
   */
  async destroy() {
    this.unsubscribe();
    await this.clean();
  }
};
var Fuel = _Fuel;
__publicField(Fuel, "STORAGE_KEY", "fuel-current-connector");
__publicField(Fuel, "defaultConfig", {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AbstractAccount,
  AbstractScriptRequest,
  Account,
  AddressType,
  BLOCKS_PAGE_SIZE_LIMIT,
  BaseTransactionRequest,
  BaseWalletUnlocked,
  BlobTransactionRequest,
  CHAIN_IDS,
  ChainName,
  ChangeOutputCollisionError,
  CreateTransactionRequest,
  DEFAULT_RESOURCE_CACHE_TTL,
  Fuel,
  FuelConnector,
  FuelConnectorEventType,
  FuelConnectorEventTypes,
  FuelConnectorMethods,
  GAS_USED_MODIFIER,
  HDWallet,
  Language,
  LocalStorage,
  MNEMONIC_SIZES,
  MemoryStorage,
  Mnemonic,
  MnemonicVault,
  NoWitnessAtIndexError,
  NoWitnessByOwnerError,
  OperationName,
  Predicate,
  PrivateKeyVault,
  Provider,
  RESOURCES_PAGE_SIZE_LIMIT,
  ScriptTransactionRequest,
  Signer,
  StorageAbstract,
  TRANSACTIONS_PAGE_SIZE_LIMIT,
  TransactionResponse,
  TransactionStatus,
  TransactionType,
  TransactionTypeName,
  UpgradeTransactionRequest,
  UploadTransactionRequest,
  Vault,
  Wallet,
  WalletLocked,
  WalletManager,
  WalletUnlocked,
  addAmountToCoinQuantities,
  addOperation,
  aggregateInputsAmountsByAssetAndOwner,
  assemblePanicError,
  assembleReceiptByType,
  assembleRevertError,
  assembleTransactionSummary,
  assets,
  buildBlockExplorerUrl,
  cacheFor,
  cacheRequestInputsResources,
  cacheRequestInputsResourcesFromOwner,
  calculateGasFee,
  calculateMetadataGasForTxBlob,
  calculateMetadataGasForTxCreate,
  calculateMetadataGasForTxScript,
  calculateMetadataGasForTxUpgrade,
  calculateMetadataGasForTxUpload,
  calculateMinGasForTxUpload,
  calculateTXFeeForSummary,
  coinQuantityfy,
  deferPromise,
  deployScriptOrPredicate,
  dispatchFuelConnectorEvent,
  english,
  extractBurnedAssetsFromReceipts,
  extractMintedAssetsFromReceipts,
  extractTxError,
  fuelAssetsBaseUrl,
  gasUsedByInputs,
  getAssetAmountInRequestInputs,
  getAssetEth,
  getAssetFuel,
  getAssetNetwork,
  getAssetWithNetwork,
  getBurnableAssetCount,
  getContractCallOperations,
  getContractCreatedOperations,
  getDecodedLogs,
  getDefaultChainId,
  getGasUsedFromReceipts,
  getInputAccountAddress,
  getInputContractFromIndex,
  getInputFromAssetId,
  getInputsByType,
  getInputsByTypes,
  getInputsCoin,
  getInputsCoinAndMessage,
  getInputsContract,
  getInputsMessage,
  getMaxGas,
  getMinGas,
  getOperations,
  getOutputsByType,
  getOutputsChange,
  getOutputsCoin,
  getOutputsContract,
  getOutputsContractCreated,
  getOutputsVariable,
  getPayProducerOperations,
  getPredicateRoot,
  getReceiptsByType,
  getReceiptsCall,
  getReceiptsMessageOut,
  getReceiptsTransferOut,
  getReceiptsWithMissingData,
  getRequestInputResourceOwner,
  getTotalFeeFromStatus,
  getTransactionStatusName,
  getTransactionSummary,
  getTransactionSummaryFromRequest,
  getTransactionTypeName,
  getTransactionsSummaries,
  getTransferOperations,
  getWithdrawFromFuelOperations,
  hasSameAssetId,
  inputify,
  isCoin,
  isInputCoin,
  isMessage,
  isMessageCoin,
  isRawCoin,
  isRawMessage,
  isRequestInputCoin,
  isRequestInputCoinOrMessage,
  isRequestInputMessage,
  isRequestInputMessageWithoutData,
  isRequestInputResource,
  isRequestInputResourceFromOwner,
  isTransactionTypeBlob,
  isTransactionTypeCreate,
  isTransactionTypeScript,
  isTransactionTypeUpgrade,
  isTransactionTypeUpload,
  isType,
  isTypeBlob,
  isTypeCreate,
  isTypeMint,
  isTypeScript,
  isTypeUpgrade,
  isTypeUpload,
  normalizeJSON,
  outputify,
  processGqlReceipt,
  processGraphqlStatus,
  rawAssets,
  resolveGasDependentCosts,
  resolveIconPaths,
  returnZeroScript,
  transactionRequestify,
  urlJoin,
  validateTransactionForAssetBurn,
  withTimeout,
  withdrawScript
});
//# sourceMappingURL=index.js.map