import { Address } from '@fuel-ts/address';
import { BN } from '@fuel-ts/math';
import type { Transaction } from '@fuel-ts/transactions';
import type { BytesLike } from '@fuel-ts/utils';
import { getSdk as getOperationsSdk } from './__generated__/operations';
import type { GqlConsensusParametersVersion, GqlContractParameters as ContractParameters, GqlDryRunFailureStatusFragment, GqlDryRunSuccessStatusFragment, GqlFeeParameters as FeeParameters, GqlGasCostsFragment as GasCosts, GqlPredicateParameters as PredicateParameters, GqlScriptParameters as ScriptParameters, GqlTxParameters as TxParameters, GqlPageInfo, GqlRelayedTransactionFailed } from './__generated__/operations';
import type { Coin } from './coin';
import type { CoinQuantity, CoinQuantityLike } from './coin-quantity';
import type { Message, MessageProof, MessageStatus } from './message';
import type { ExcludeResourcesOption, Resource } from './resource';
import { ResourceCache } from './resource-cache';
import type { TransactionRequestLike, TransactionRequest, TransactionRequestInput, ScriptTransactionRequest } from './transaction-request';
import type { TransactionResultReceipt } from './transaction-response';
import { TransactionResponse } from './transaction-response';
import type { RetryOptions } from './utils/auto-retry-fetch';
export declare const RESOURCES_PAGE_SIZE_LIMIT = 512;
export declare const TRANSACTIONS_PAGE_SIZE_LIMIT = 60;
export declare const BLOCKS_PAGE_SIZE_LIMIT = 5;
export declare const DEFAULT_RESOURCE_CACHE_TTL = 20000;
export declare const GAS_USED_MODIFIER = 1.2;
export type DryRunFailureStatusFragment = GqlDryRunFailureStatusFragment;
export type DryRunSuccessStatusFragment = GqlDryRunSuccessStatusFragment;
export type DryRunStatus = DryRunFailureStatusFragment | DryRunSuccessStatusFragment;
export type CallResult = {
    receipts: TransactionResultReceipt[];
    dryRunStatus?: DryRunStatus;
};
export type EstimateTxDependenciesReturns = CallResult & {
    outputVariables: number;
    missingContractIds: string[];
};
/**
 * A Fuel block
 */
export type Block = {
    id: string;
    height: BN;
    time: string;
    transactionIds: string[];
    header: {
        daHeight: BN;
        stateTransitionBytecodeVersion: string;
        transactionsCount: string;
        transactionsRoot: string;
        messageOutboxRoot: string;
        eventInboxRoot: string;
        prevRoot: string;
        applicationHash: string;
    };
};
export type PageInfo = GqlPageInfo;
export type GetCoinsResponse = {
    coins: Coin[];
    pageInfo: PageInfo;
};
export type GetMessagesResponse = {
    messages: Message[];
    pageInfo: PageInfo;
};
export type GetBalancesResponse = {
    balances: CoinQuantity[];
};
export type GetTransactionsResponse = {
    transactions: Transaction[];
    pageInfo: PageInfo;
};
export type GetBlocksResponse = {
    blocks: Block[];
    pageInfo: PageInfo;
};
/**
 * Deployed Contract bytecode and contract id
 */
export type ContractResult = {
    id: string;
    bytecode: string;
};
type ModifyStringToBN<T> = {
    [P in keyof T]: P extends 'version' ? T[P] : T[P] extends string ? BN : T[P];
};
export { GasCosts, FeeParameters, ContractParameters, PredicateParameters, ScriptParameters, TxParameters, };
export type ConsensusParameters = {
    version: GqlConsensusParametersVersion;
    chainId: BN;
    baseAssetId: string;
    feeParameters: ModifyStringToBN<FeeParameters>;
    contractParameters: ModifyStringToBN<ContractParameters>;
    predicateParameters: ModifyStringToBN<PredicateParameters>;
    scriptParameters: ModifyStringToBN<ScriptParameters>;
    txParameters: ModifyStringToBN<TxParameters>;
    gasCosts: GasCosts;
};
/**
 * Chain information
 */
export type ChainInfo = {
    name: string;
    baseChainHeight: BN;
    consensusParameters: ConsensusParameters;
};
/**
 * Node information
 */
export type NodeInfo = {
    utxoValidation: boolean;
    vmBacktrace: boolean;
    maxTx: BN;
    maxDepth: BN;
    nodeVersion: string;
};
export type NodeInfoAndConsensusParameters = {
    nodeVersion: string;
    gasPerByte: BN;
    gasPriceFactor: BN;
    maxGasPerTx: BN;
};
export type TransactionCost = {
    gasPrice: BN;
    gasUsed: BN;
    minGas: BN;
    minFee: BN;
    maxFee: BN;
    maxGas: BN;
    receipts: TransactionResultReceipt[];
    outputVariables: number;
    missingContractIds: string[];
    estimatedPredicates: TransactionRequestInput[];
    requiredQuantities: CoinQuantity[];
    addedSignatures: number;
    dryRunStatus?: DryRunStatus;
    updateMaxFee?: boolean;
};
/**
 * @hidden
 *
 * Cursor pagination arguments
 *
 * https://relay.dev/graphql/connections.htm#sec-Arguments
 */
export type CursorPaginationArgs = {
    /** Forward pagination limit */
    first?: number | null;
    /** Forward pagination cursor */
    after?: string | null;
    /** Backward pagination limit  */
    last?: number | null;
    /** Backward pagination cursor */
    before?: string | null;
};
export type ProviderOptions = {
    /**
     * Custom fetch function to use for making requests.
     */
    fetch?: (url: string, requestInit?: RequestInit, providerOptions?: Omit<ProviderOptions, 'fetch'>) => Promise<Response>;
    /**
     * Timeout [ms] after which every request will be aborted.
     */
    timeout?: number;
    /**
     * Resources cache for the given time [ms]. If set to -1, the cache will be disabled.
     */
    resourceCacheTTL?: number;
    /**
     * Retry options to use when fetching data from the node.
     */
    retryOptions?: RetryOptions;
    /**
     * Custom headers to include in the request.
     */
    headers?: RequestInit['headers'];
    /**
     * Middleware to modify the request before it is sent.
     * This can be used to add headers, modify the body, etc.
     */
    requestMiddleware?: (request: RequestInit) => RequestInit | Promise<RequestInit>;
};
/**
 * UTXO validation params
 */
export type UTXOValidationParams = {
    utxoValidation?: boolean;
};
/**
 * Transaction estimation params
 */
export type EstimateTransactionParams = {
    /**
     * Estimate the transaction dependencies.
     */
    estimateTxDependencies?: boolean;
};
export type TransactionCostParams = EstimateTransactionParams & {
    /**
     * The quantities to forward to the contract.
     */
    quantities?: CoinQuantity[];
    /**
     * A callback to sign the transaction.
     *
     * @param request - The transaction request to sign.
     * @returns A promise that resolves to the signed transaction request.
     */
    signatureCallback?: (request: ScriptTransactionRequest) => Promise<ScriptTransactionRequest>;
};
/**
 * Provider Call transaction params
 */
export type ProviderCallParams = UTXOValidationParams & EstimateTransactionParams;
/**
 * Provider Send transaction params
 */
export type ProviderSendTxParams = EstimateTransactionParams & {
    /**
     * Whether to enable asset burn for the transaction.
     */
    enableAssetBurn?: boolean;
};
type Operations = ReturnType<typeof getOperationsSdk>;
type SdkOperations = Omit<Operations, 'statusChange' | 'submitAndAwaitStatus'> & {
    statusChange: (...args: Parameters<Operations['statusChange']>) => Promise<ReturnType<Operations['statusChange']>>;
    submitAndAwaitStatus: (...args: Parameters<Operations['submitAndAwaitStatus']>) => Promise<ReturnType<Operations['submitAndAwaitStatus']>>;
    getBlobs: (variables: {
        blobIds: string[];
    }) => Promise<{
        blob: {
            id: string;
        } | null;
    }[]>;
};
/**
 * A provider for connecting to a node
 */
export default class Provider {
    #private;
    operations: SdkOperations;
    cache?: ResourceCache;
    /** @hidden */
    static clearChainAndNodeCaches(): void;
    /** @hidden */
    url: string;
    /** @hidden */
    private urlWithoutAuth;
    /** @hidden */
    private static chainInfoCache;
    /** @hidden */
    private static nodeInfoCache;
    /** @hidden */
    consensusParametersTimestamp?: number;
    options: ProviderOptions;
    /**
     * @hidden
     */
    private static getFetchFn;
    /**
     * Constructor to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     * @hidden
     */
    constructor(url: string, options?: ProviderOptions);
    private static extractBasicAuth;
    /**
     * Initialize Provider async stuff
     */
    init(): Promise<Provider>;
    /**
     * Returns the `chainInfo` for the current network.
     *
     * @returns the chain information configuration.
     */
    getChain(): Promise<ChainInfo>;
    /**
     * Returns the `nodeInfo` for the current network.
     *
     * @returns the node information configuration.
     */
    getNode(): Promise<NodeInfo>;
    /**
     * Returns some helpful parameters related to gas fees.
     */
    getGasConfig(): Promise<{
        maxGasPerTx: BN;
        maxGasPerPredicate: BN;
        gasPriceFactor: BN;
        gasPerByte: BN;
        gasCosts: GasCosts;
    }>;
    /**
     * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
     *
     * @param url - The URL to connect to.
     * @param options - Additional options for the provider.
     */
    connect(url: string, options?: ProviderOptions): Promise<void>;
    /**
     * Return the chain and node information.
     * @param ignoreCache - If true, ignores the cache and re-fetch configs.
     * @returns A promise that resolves to the Chain and NodeInfo.
     */
    fetchChainAndNodeInfo(ignoreCache?: boolean): Promise<{
        chain: ChainInfo;
        nodeInfo: NodeInfo;
    }>;
    /**
     * @hidden
     */
    private static ensureClientVersionIsSupported;
    /**
     * Create GraphQL client and set operations.
     *
     * @returns The operation SDK object
     * @hidden
     */
    private createOperations;
    /**
     * Returns the version of the connected node.
     *
     * @returns A promise that resolves to the version string.
     */
    getVersion(): Promise<string>;
    /**
     * Returns the latest block number.
     *
     * @returns A promise that resolves to the latest block number.
     */
    getBlockNumber(): Promise<BN>;
    /**
     * Returns the node information for the current provider network.
     *
     * @returns a promise that resolves to the node information.
     */
    fetchNode(): Promise<NodeInfo>;
    /**
     * Returns the chain information for the current provider network.
     *
     * @returns a promise that resolves to the chain information.
     */
    fetchChain(): Promise<ChainInfo>;
    /**
     * Returns the chain ID for the current provider network.
     *
     * @returns A promise that resolves to the chain ID number.
     */
    getChainId(): Promise<number>;
    /**
     * Returns the base asset ID for the current provider network.
     *
     * @returns the base asset ID.
     */
    getBaseAssetId(): Promise<string>;
    /**
     * @hidden
     */
    validateTransaction(tx: TransactionRequest): Promise<void>;
    /**
     * Submits a transaction to the chain to be executed.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider send transaction parameters (optional).
     * @returns A promise that resolves to the transaction response object.
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike, { estimateTxDependencies, enableAssetBurn }?: ProviderSendTxParams): Promise<TransactionResponse>;
    /**
     * Executes a transaction without actually submitting it to the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider call parameters (optional).
     * @returns A promise that resolves to the call result object.
     */
    dryRun(transactionRequestLike: TransactionRequestLike, { utxoValidation, estimateTxDependencies }?: ProviderCallParams): Promise<CallResult>;
    /**
     * Verifies whether enough gas is available to complete transaction.
     *
     * @template T - The type of the transaction request object.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimated transaction request object.
     */
    estimatePredicates<T extends TransactionRequest>(transactionRequest: T): Promise<T>;
    /**
     * Will dryRun a transaction and check for missing dependencies.
     *
     * If there are missing variable outputs,
     * `addVariableOutputs` is called on the transaction.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimate transaction dependencies.
     */
    estimateTxDependencies(transactionRequest: TransactionRequest): Promise<EstimateTxDependenciesReturns>;
    /**
     * Dry runs multiple transactions and checks for missing dependencies in batches.
     *
     * Transactions are dry run in batches. After each dry run, transactions requiring
     * further modifications are identified. The method iteratively updates these transactions
     * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @returns A promise that resolves to an array of results for each transaction.
     */
    estimateMultipleTxDependencies(transactionRequests: TransactionRequest[]): Promise<EstimateTxDependenciesReturns[]>;
    /**
     * Dry runs multiple transactions.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @param sendTransactionParams - The provider call parameters (optional).
     *
     * @returns A promise that resolves to an array of results for each transaction call.
     */
    dryRunMultipleTransactions(transactionRequests: TransactionRequest[], { utxoValidation, estimateTxDependencies }?: ProviderCallParams): Promise<CallResult[]>;
    autoRefetchConfigs(): Promise<void>;
    /**
     * Estimates the transaction gas and fee based on the provided transaction request.
     * @param transactionRequest - The transaction request object.
     * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
     */
    estimateTxGasAndFee(params: {
        transactionRequest: TransactionRequest;
        gasPrice?: BN;
    }): Promise<{
        minGas: BN;
        minFee: BN;
        maxGas: BN;
        maxFee: BN;
        gasPrice: BN;
        gasLimit: BN;
    }>;
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added
     *
     * @param transactionRequestLike - The transaction request object.
     * @param estimateTxParams - The estimate transaction params (optional).
     * @returns A promise that resolves to the call result object.
     */
    simulate(transactionRequestLike: TransactionRequestLike, { estimateTxDependencies }?: EstimateTransactionParams): Promise<CallResult>;
    /**
     * @hidden
     *
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the transaction.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param transactionCostParams - The transaction cost parameters (optional).
     *
     * @returns A promise that resolves to the transaction cost object.
     */
    getTransactionCost(transactionRequestLike: TransactionRequestLike, { signatureCallback }?: TransactionCostParams): Promise<Omit<TransactionCost, 'requiredQuantities'>>;
    /**
     * Returns coins for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get (optional).
     * @param paginationArgs - Pagination arguments (optional).
     *
     * @returns A promise that resolves to the coins.
     */
    getCoins(owner: string | Address, assetId?: BytesLike, paginationArgs?: CursorPaginationArgs): Promise<GetCoinsResponse>;
    /**
     * Returns resources for the given owner satisfying the spend query.
     *
     * @param owner - The address to get resources for.
     * @param quantities - The coin quantities to get.
     * @param excludedIds - IDs of excluded resources from the selection (optional).
     * @returns A promise that resolves to the resources.
     */
    getResourcesToSpend(owner: string | Address, quantities: CoinQuantityLike[], excludedIds?: ExcludeResourcesOption): Promise<Resource[]>;
    /**
     * Returns an array of blobIds that exist on chain, for a given array of blobIds.
     *
     * @param blobIds - blobIds to check.
     * @returns - A promise that resolves to an array of blobIds that exist on chain.
     */
    getBlobs(blobIds: string[]): Promise<string[]>;
    /**
     * Returns block matching the given ID or height.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block or null.
     */
    getBlock(idOrHeight: string | number | 'latest'): Promise<Block | null>;
    /**
     * Returns all the blocks matching the given parameters.
     *
     * @param params - The parameters to query blocks.
     * @returns A promise that resolves to the blocks.
     */
    getBlocks(params?: CursorPaginationArgs): Promise<GetBlocksResponse>;
    /**
     * Returns block matching the given ID or type, including transaction data.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    getBlockWithTransactions(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<(Block & {
        transactions: Transaction[];
    }) | null>;
    /**
     * Get transaction with the given ID.
     *
     * @param transactionId - ID of the transaction.
     * @returns A promise that resolves to the transaction.
     */
    getTransaction<TTransactionType = void>(transactionId: string): Promise<Transaction<TTransactionType> | null>;
    /**
     * Retrieves transactions based on the provided pagination arguments.
     * @param paginationArgs - The pagination arguments for retrieving transactions.
     * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.
     */
    getTransactions(paginationArgs?: CursorPaginationArgs): Promise<GetTransactionsResponse>;
    /**
     * Get deployed contract with the given ID.
     *
     * @param contractId - ID of the contract.
     * @returns A promise that resolves to the contract.
     */
    getContract(contractId: string): Promise<ContractResult | null>;
    /**
     * Returns the balance for the given contract for the given asset ID.
     *
     * @param contractId - The contract ID to get the balance for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    getContractBalance(
    /** The contract ID to get the balance for */
    contractId: string | Address, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns the balance for the given owner for the given asset ID.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    getBalance(
    /** The address to get coins for */
    owner: string | Address, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns balances for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the balances.
     */
    getBalances(owner: string | Address): Promise<GetBalancesResponse>;
    /**
     * Returns message for the given address.
     *
     * @param address - The address to get message from.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the messages.
     */
    getMessages(address: string | Address, paginationArgs?: CursorPaginationArgs): Promise<GetMessagesResponse>;
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param transactionId - The transaction to get message from.
     * @param messageId - The message id from MessageOut receipt.
     * @param commitBlockId - The commit block id (optional).
     * @param commitBlockHeight - The commit block height (optional).
     * @returns A promise that resolves to the message proof.
     */
    getMessageProof(transactionId: string, nonce: string, commitBlockId?: string, commitBlockHeight?: BN): Promise<MessageProof | null>;
    /**
     * Get the latest gas price from the node.
     *
     * @returns A promise that resolves to the latest gas price.
     */
    getLatestGasPrice(): Promise<BN>;
    /**
     * Returns the estimate gas price for the given block horizon.
     *
     * @param blockHorizon - The block horizon to estimate gas price for.
     * @returns A promise that resolves to the estimated gas price.
     */
    estimateGasPrice(blockHorizon: number): Promise<BN>;
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param nonce - The nonce of the message to get status from.
     * @returns A promise that resolves to the message status
     */
    getMessageStatus(
    /** The nonce of the message to get status from */
    nonce: string): Promise<MessageStatus>;
    /**
     * Lets you produce blocks with custom timestamps and the block number of the last block produced.
     *
     * @param amount - The amount of blocks to produce.
     * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
     * @returns A promise that resolves to the block number of the last produced block.
     */
    produceBlocks(amount: number, startTime?: number): Promise<BN>;
    /**
     * Check if the given ID is an account.
     *
     * @param id - The ID to check.
     * @returns A promise that resolves to the result of the check.
     */
    isUserAccount(id: string): Promise<boolean>;
    getAddressType(id: string): Promise<'Account' | 'Contract' | 'Transaction' | 'Blob'>;
    /**
     * Get the transaction response for the given transaction ID.
     *
     * @param transactionId - The transaction ID to get the response for.
     * @returns A promise that resolves to the transaction response.
     */
    getTransactionResponse(transactionId: string): Promise<TransactionResponse>;
    /**
     * Returns Message for given nonce.
     *
     * @param nonce - The nonce of the message to retrieve.
     * @returns A promise that resolves to the Message object or null.
     */
    getMessageByNonce(nonce: string): Promise<Message | null>;
    /**
     * Get the relayed transaction for the given transaction ID.
     *
     * @param relayedTransactionId - The relayed transaction ID to get the response for.
     * @returns A promise that resolves to the relayed transaction.
     */
    getRelayedTransactionStatus(relayedTransactionId: string): Promise<GqlRelayedTransactionFailed | null>;
    /**
     * @hidden
     */
    private extractDryRunError;
}
//# sourceMappingURL=provider.d.ts.map