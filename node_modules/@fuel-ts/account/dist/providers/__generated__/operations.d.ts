import type { DocumentNode } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
export type Incremental<T> = T | {
    [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    Address: {
        input: string;
        output: string;
    };
    AssetId: {
        input: string;
        output: string;
    };
    BlobId: {
        input: any;
        output: any;
    };
    BlockId: {
        input: string;
        output: string;
    };
    Bytes32: {
        input: string;
        output: string;
    };
    ContractId: {
        input: string;
        output: string;
    };
    HexString: {
        input: string;
        output: string;
    };
    Nonce: {
        input: string;
        output: string;
    };
    RelayedTransactionId: {
        input: string;
        output: string;
    };
    Salt: {
        input: string;
        output: string;
    };
    Signature: {
        input: string;
        output: string;
    };
    Tai64Timestamp: {
        input: string;
        output: string;
    };
    TransactionId: {
        input: string;
        output: string;
    };
    TxPointer: {
        input: string;
        output: string;
    };
    U16: {
        input: string;
        output: string;
    };
    U32: {
        input: string;
        output: string;
    };
    U64: {
        input: string;
        output: string;
    };
    UtxoId: {
        input: string;
        output: string;
    };
};
export type GqlBalance = {
    amount: Scalars['U64']['output'];
    assetId: Scalars['AssetId']['output'];
    owner: Scalars['Address']['output'];
};
export type GqlBalanceConnection = {
    /** A list of edges. */
    edges: Array<GqlBalanceEdge>;
    /** A list of nodes. */
    nodes: Array<GqlBalance>;
    /** Information to aid in pagination. */
    pageInfo: GqlPageInfo;
};
/** An edge in a connection. */
export type GqlBalanceEdge = {
    /** A cursor for use in pagination */
    cursor: Scalars['String']['output'];
    /** The item at the end of the edge */
    node: GqlBalance;
};
export type GqlBalanceFilterInput = {
    /** Filter coins based on the `owner` field */
    owner: Scalars['Address']['input'];
};
export type GqlBlob = {
    bytecode: Scalars['HexString']['output'];
    id: Scalars['BlobId']['output'];
};
export type GqlBlock = {
    consensus: GqlConsensus;
    header: GqlHeader;
    height: Scalars['U32']['output'];
    id: Scalars['BlockId']['output'];
    transactionIds: Array<Scalars['TransactionId']['output']>;
    transactions: Array<GqlTransaction>;
    version: GqlBlockVersion;
};
export type GqlBlockConnection = {
    /** A list of edges. */
    edges: Array<GqlBlockEdge>;
    /** A list of nodes. */
    nodes: Array<GqlBlock>;
    /** Information to aid in pagination. */
    pageInfo: GqlPageInfo;
};
/** An edge in a connection. */
export type GqlBlockEdge = {
    /** A cursor for use in pagination */
    cursor: Scalars['String']['output'];
    /** The item at the end of the edge */
    node: GqlBlock;
};
export declare enum GqlBlockVersion {
    V1 = "V1"
}
/** Breakpoint, defined as a tuple of contract ID and relative PC offset inside it */
export type GqlBreakpoint = {
    contract: Scalars['ContractId']['input'];
    pc: Scalars['U64']['input'];
};
export type GqlChainInfo = {
    consensusParameters: GqlConsensusParameters;
    daHeight: Scalars['U64']['output'];
    gasCosts: GqlGasCosts;
    latestBlock: GqlBlock;
    name: Scalars['String']['output'];
};
export type GqlChangeOutput = {
    amount: Scalars['U64']['output'];
    assetId: Scalars['AssetId']['output'];
    to: Scalars['Address']['output'];
};
export type GqlCoin = {
    amount: Scalars['U64']['output'];
    assetId: Scalars['AssetId']['output'];
    /** TxPointer - the height of the block this coin was created in */
    blockCreated: Scalars['U32']['output'];
    owner: Scalars['Address']['output'];
    /** TxPointer - the index of the transaction that created this coin */
    txCreatedIdx: Scalars['U16']['output'];
    utxoId: Scalars['UtxoId']['output'];
};
export type GqlCoinConnection = {
    /** A list of edges. */
    edges: Array<GqlCoinEdge>;
    /** A list of nodes. */
    nodes: Array<GqlCoin>;
    /** Information to aid in pagination. */
    pageInfo: GqlPageInfo;
};
/** An edge in a connection. */
export type GqlCoinEdge = {
    /** A cursor for use in pagination */
    cursor: Scalars['String']['output'];
    /** The item at the end of the edge */
    node: GqlCoin;
};
export type GqlCoinFilterInput = {
    /** Returns coins only with `asset_id`. */
    assetId?: InputMaybe<Scalars['AssetId']['input']>;
    /** Returns coins owned by the `owner`. */
    owner: Scalars['Address']['input'];
};
export type GqlCoinOutput = {
    amount: Scalars['U64']['output'];
    assetId: Scalars['AssetId']['output'];
    to: Scalars['Address']['output'];
};
/** The schema analog of the [`coins::CoinType`]. */
export type GqlCoinType = GqlCoin | GqlMessageCoin;
export type GqlConsensus = GqlGenesis | GqlPoAConsensus;
export type GqlConsensusParameters = {
    baseAssetId: Scalars['AssetId']['output'];
    blockGasLimit: Scalars['U64']['output'];
    blockTransactionSizeLimit: Scalars['U64']['output'];
    chainId: Scalars['U64']['output'];
    contractParams: GqlContractParameters;
    feeParams: GqlFeeParameters;
    gasCosts: GqlGasCosts;
    predicateParams: GqlPredicateParameters;
    privilegedAddress: Scalars['Address']['output'];
    scriptParams: GqlScriptParameters;
    txParams: GqlTxParameters;
    version: GqlConsensusParametersVersion;
};
export type GqlConsensusParametersPurpose = {
    checksum: Scalars['Bytes32']['output'];
    witnessIndex: Scalars['U16']['output'];
};
export declare enum GqlConsensusParametersVersion {
    V1 = "V1"
}
export type GqlContract = {
    bytecode: Scalars['HexString']['output'];
    id: Scalars['ContractId']['output'];
    salt: Scalars['Salt']['output'];
};
export type GqlContractBalance = {
    amount: Scalars['U64']['output'];
    assetId: Scalars['AssetId']['output'];
    contract: Scalars['ContractId']['output'];
};
export type GqlContractBalanceConnection = {
    /** A list of edges. */
    edges: Array<GqlContractBalanceEdge>;
    /** A list of nodes. */
    nodes: Array<GqlContractBalance>;
    /** Information to aid in pagination. */
    pageInfo: GqlPageInfo;
};
/** An edge in a connection. */
export type GqlContractBalanceEdge = {
    /** A cursor for use in pagination */
    cursor: Scalars['String']['output'];
    /** The item at the end of the edge */
    node: GqlContractBalance;
};
export type GqlContractBalanceFilterInput = {
    /** Filter assets based on the `contractId` field */
    contract: Scalars['ContractId']['input'];
};
export type GqlContractCreated = {
    contract: Scalars['ContractId']['output'];
    stateRoot: Scalars['Bytes32']['output'];
};
export type GqlContractOutput = {
    balanceRoot: Scalars['Bytes32']['output'];
    inputIndex: Scalars['U16']['output'];
    stateRoot: Scalars['Bytes32']['output'];
};
export type GqlContractParameters = {
    contractMaxSize: Scalars['U64']['output'];
    maxStorageSlots: Scalars['U64']['output'];
    version: GqlContractParametersVersion;
};
export declare enum GqlContractParametersVersion {
    V1 = "V1"
}
export type GqlDependentCost = GqlHeavyOperation | GqlLightOperation;
export type GqlDryRunFailureStatus = {
    programState?: Maybe<GqlProgramState>;
    reason: Scalars['String']['output'];
    receipts: Array<GqlReceipt>;
    totalFee: Scalars['U64']['output'];
    totalGas: Scalars['U64']['output'];
};
export type GqlDryRunSuccessStatus = {
    programState?: Maybe<GqlProgramState>;
    receipts: Array<GqlReceipt>;
    totalFee: Scalars['U64']['output'];
    totalGas: Scalars['U64']['output'];
};
export type GqlDryRunTransactionExecutionStatus = {
    id: Scalars['TransactionId']['output'];
    receipts: Array<GqlReceipt>;
    status: GqlDryRunTransactionStatus;
};
export type GqlDryRunTransactionStatus = GqlDryRunFailureStatus | GqlDryRunSuccessStatus;
export type GqlEstimateGasPrice = {
    gasPrice: Scalars['U64']['output'];
};
export type GqlExcludeInput = {
    /** Messages to exclude from the selection. */
    messages: Array<Scalars['Nonce']['input']>;
    /** Utxos to exclude from the selection. */
    utxos: Array<Scalars['UtxoId']['input']>;
};
export type GqlFailureStatus = {
    block: GqlBlock;
    blockHeight: Scalars['U32']['output'];
    programState?: Maybe<GqlProgramState>;
    reason: Scalars['String']['output'];
    receipts: Array<GqlReceipt>;
    time: Scalars['Tai64Timestamp']['output'];
    totalFee: Scalars['U64']['output'];
    totalGas: Scalars['U64']['output'];
    transaction: GqlTransaction;
    transactionId: Scalars['TransactionId']['output'];
};
export type GqlFeeParameters = {
    gasPerByte: Scalars['U64']['output'];
    gasPriceFactor: Scalars['U64']['output'];
    version: GqlFeeParametersVersion;
};
export declare enum GqlFeeParametersVersion {
    V1 = "V1"
}
export type GqlGasCosts = {
    add: Scalars['U64']['output'];
    addi: Scalars['U64']['output'];
    aloc: Scalars['U64']['output'];
    alocDependentCost: GqlDependentCost;
    and: Scalars['U64']['output'];
    andi: Scalars['U64']['output'];
    bal: Scalars['U64']['output'];
    bhei: Scalars['U64']['output'];
    bhsh: Scalars['U64']['output'];
    bldd?: Maybe<GqlDependentCost>;
    bsiz?: Maybe<GqlDependentCost>;
    burn: Scalars['U64']['output'];
    call: GqlDependentCost;
    cb: Scalars['U64']['output'];
    ccp: GqlDependentCost;
    cfe: GqlDependentCost;
    cfei: Scalars['U64']['output'];
    cfeiDependentCost: GqlDependentCost;
    cfsi: Scalars['U64']['output'];
    contractRoot: GqlDependentCost;
    croo: GqlDependentCost;
    csiz: GqlDependentCost;
    div: Scalars['U64']['output'];
    divi: Scalars['U64']['output'];
    eck1: Scalars['U64']['output'];
    ecr1: Scalars['U64']['output'];
    ed19: Scalars['U64']['output'];
    ed19DependentCost: GqlDependentCost;
    eq: Scalars['U64']['output'];
    exp: Scalars['U64']['output'];
    expi: Scalars['U64']['output'];
    flag: Scalars['U64']['output'];
    gm: Scalars['U64']['output'];
    gt: Scalars['U64']['output'];
    gtf: Scalars['U64']['output'];
    ji: Scalars['U64']['output'];
    jmp: Scalars['U64']['output'];
    jmpb: Scalars['U64']['output'];
    jmpf: Scalars['U64']['output'];
    jne: Scalars['U64']['output'];
    jneb: Scalars['U64']['output'];
    jnef: Scalars['U64']['output'];
    jnei: Scalars['U64']['output'];
    jnzb: Scalars['U64']['output'];
    jnzf: Scalars['U64']['output'];
    jnzi: Scalars['U64']['output'];
    k256: GqlDependentCost;
    lb: Scalars['U64']['output'];
    ldc: GqlDependentCost;
    log: Scalars['U64']['output'];
    logd: GqlDependentCost;
    lt: Scalars['U64']['output'];
    lw: Scalars['U64']['output'];
    mcl: GqlDependentCost;
    mcli: GqlDependentCost;
    mcp: GqlDependentCost;
    mcpi: GqlDependentCost;
    meq: GqlDependentCost;
    mint: Scalars['U64']['output'];
    mldv: Scalars['U64']['output'];
    mlog: Scalars['U64']['output'];
    modOp: Scalars['U64']['output'];
    modi: Scalars['U64']['output'];
    moveOp: Scalars['U64']['output'];
    movi: Scalars['U64']['output'];
    mroo: Scalars['U64']['output'];
    mul: Scalars['U64']['output'];
    muli: Scalars['U64']['output'];
    newStoragePerByte: Scalars['U64']['output'];
    noop: Scalars['U64']['output'];
    not: Scalars['U64']['output'];
    or: Scalars['U64']['output'];
    ori: Scalars['U64']['output'];
    poph: Scalars['U64']['output'];
    popl: Scalars['U64']['output'];
    pshh: Scalars['U64']['output'];
    pshl: Scalars['U64']['output'];
    ret: Scalars['U64']['output'];
    retd: GqlDependentCost;
    rvrt: Scalars['U64']['output'];
    s256: GqlDependentCost;
    sb: Scalars['U64']['output'];
    scwq: GqlDependentCost;
    sll: Scalars['U64']['output'];
    slli: Scalars['U64']['output'];
    smo: GqlDependentCost;
    srl: Scalars['U64']['output'];
    srli: Scalars['U64']['output'];
    srw: Scalars['U64']['output'];
    srwq: GqlDependentCost;
    stateRoot: GqlDependentCost;
    sub: Scalars['U64']['output'];
    subi: Scalars['U64']['output'];
    sw: Scalars['U64']['output'];
    sww: Scalars['U64']['output'];
    swwq: GqlDependentCost;
    time: Scalars['U64']['output'];
    tr: Scalars['U64']['output'];
    tro: Scalars['U64']['output'];
    version: GqlGasCostsVersion;
    vmInitialization: GqlDependentCost;
    wdam: Scalars['U64']['output'];
    wdcm: Scalars['U64']['output'];
    wddv: Scalars['U64']['output'];
    wdmd: Scalars['U64']['output'];
    wdml: Scalars['U64']['output'];
    wdmm: Scalars['U64']['output'];
    wdop: Scalars['U64']['output'];
    wqam: Scalars['U64']['output'];
    wqcm: Scalars['U64']['output'];
    wqdv: Scalars['U64']['output'];
    wqmd: Scalars['U64']['output'];
    wqml: Scalars['U64']['output'];
    wqmm: Scalars['U64']['output'];
    wqop: Scalars['U64']['output'];
    xor: Scalars['U64']['output'];
    xori: Scalars['U64']['output'];
};
export declare enum GqlGasCostsVersion {
    V1 = "V1"
}
export type GqlGenesis = {
    /**
     * The chain configs define what consensus type to use, what settlement layer to use,
     * rules of block validity, etc.
     */
    chainConfigHash: Scalars['Bytes32']['output'];
    /** The Binary Merkle Tree root of all genesis coins. */
    coinsRoot: Scalars['Bytes32']['output'];
    /** The Binary Merkle Tree root of state, balances, contracts code hash of each contract. */
    contractsRoot: Scalars['Bytes32']['output'];
    /** The Binary Merkle Tree root of all genesis messages. */
    messagesRoot: Scalars['Bytes32']['output'];
    /** The Binary Merkle Tree root of all processed transaction ids. */
    transactionsRoot: Scalars['Bytes32']['output'];
};
export type GqlHeader = {
    /** Hash of the application header. */
    applicationHash: Scalars['Bytes32']['output'];
    /** The version of the consensus parameters used to create this block. */
    consensusParametersVersion: Scalars['U32']['output'];
    /** The layer 1 height of messages and events to include since the last layer 1 block number. */
    daHeight: Scalars['U64']['output'];
    /** Merkle root of inbox events in this block. */
    eventInboxRoot: Scalars['Bytes32']['output'];
    /** Fuel block height. */
    height: Scalars['U32']['output'];
    /** Hash of the header */
    id: Scalars['BlockId']['output'];
    /** Merkle root of message receipts in this block. */
    messageOutboxRoot: Scalars['Bytes32']['output'];
    /** Number of message receipts in this block. */
    messageReceiptCount: Scalars['U32']['output'];
    /** Merkle root of all previous block header hashes. */
    prevRoot: Scalars['Bytes32']['output'];
    /** The version of the state transition bytecode used to create this block. */
    stateTransitionBytecodeVersion: Scalars['U32']['output'];
    /** The block producer time. */
    time: Scalars['Tai64Timestamp']['output'];
    /** Number of transactions in this block. */
    transactionsCount: Scalars['U16']['output'];
    /** Merkle root of transactions. */
    transactionsRoot: Scalars['Bytes32']['output'];
    /** Version of the header */
    version: GqlHeaderVersion;
};
export declare enum GqlHeaderVersion {
    V1 = "V1"
}
export type GqlHeavyOperation = {
    base: Scalars['U64']['output'];
    gasPerUnit: Scalars['U64']['output'];
};
export type GqlInput = GqlInputCoin | GqlInputContract | GqlInputMessage;
export type GqlInputCoin = {
    amount: Scalars['U64']['output'];
    assetId: Scalars['AssetId']['output'];
    owner: Scalars['Address']['output'];
    predicate: Scalars['HexString']['output'];
    predicateData: Scalars['HexString']['output'];
    predicateGasUsed: Scalars['U64']['output'];
    txPointer: Scalars['TxPointer']['output'];
    utxoId: Scalars['UtxoId']['output'];
    witnessIndex: Scalars['Int']['output'];
};
export type GqlInputContract = {
    balanceRoot: Scalars['Bytes32']['output'];
    contractId: Scalars['ContractId']['output'];
    stateRoot: Scalars['Bytes32']['output'];
    txPointer: Scalars['TxPointer']['output'];
    utxoId: Scalars['UtxoId']['output'];
};
export type GqlInputMessage = {
    amount: Scalars['U64']['output'];
    data: Scalars['HexString']['output'];
    nonce: Scalars['Nonce']['output'];
    predicate: Scalars['HexString']['output'];
    predicateData: Scalars['HexString']['output'];
    predicateGasUsed: Scalars['U64']['output'];
    recipient: Scalars['Address']['output'];
    sender: Scalars['Address']['output'];
    witnessIndex: Scalars['U16']['output'];
};
export type GqlLatestGasPrice = {
    blockHeight: Scalars['U32']['output'];
    gasPrice: Scalars['U64']['output'];
};
export type GqlLightOperation = {
    base: Scalars['U64']['output'];
    unitsPerGas: Scalars['U64']['output'];
};
export type GqlMerkleProof = {
    proofIndex: Scalars['U64']['output'];
    proofSet: Array<Scalars['Bytes32']['output']>;
};
export type GqlMessage = {
    amount: Scalars['U64']['output'];
    daHeight: Scalars['U64']['output'];
    data: Scalars['HexString']['output'];
    nonce: Scalars['Nonce']['output'];
    recipient: Scalars['Address']['output'];
    sender: Scalars['Address']['output'];
};
export type GqlMessageCoin = {
    amount: Scalars['U64']['output'];
    assetId: Scalars['AssetId']['output'];
    daHeight: Scalars['U64']['output'];
    nonce: Scalars['Nonce']['output'];
    recipient: Scalars['Address']['output'];
    sender: Scalars['Address']['output'];
};
export type GqlMessageConnection = {
    /** A list of edges. */
    edges: Array<GqlMessageEdge>;
    /** A list of nodes. */
    nodes: Array<GqlMessage>;
    /** Information to aid in pagination. */
    pageInfo: GqlPageInfo;
};
/** An edge in a connection. */
export type GqlMessageEdge = {
    /** A cursor for use in pagination */
    cursor: Scalars['String']['output'];
    /** The item at the end of the edge */
    node: GqlMessage;
};
export type GqlMessageProof = {
    amount: Scalars['U64']['output'];
    blockProof: GqlMerkleProof;
    commitBlockHeader: GqlHeader;
    data: Scalars['HexString']['output'];
    messageBlockHeader: GqlHeader;
    messageProof: GqlMerkleProof;
    nonce: Scalars['Nonce']['output'];
    recipient: Scalars['Address']['output'];
    sender: Scalars['Address']['output'];
};
export declare enum GqlMessageState {
    NotFound = "NOT_FOUND",
    Spent = "SPENT",
    Unspent = "UNSPENT"
}
export type GqlMessageStatus = {
    state: GqlMessageState;
};
export type GqlMutation = {
    /**
     * Resume execution of the VM instance after a breakpoint.
     * Runs until the next breakpoint or until the transaction completes.
     */
    continueTx: GqlRunResult;
    /** Execute a dry-run of multiple transactions using a fork of current state, no changes are committed. */
    dryRun: Array<GqlDryRunTransactionExecutionStatus>;
    /** End debugger session. */
    endSession: Scalars['Boolean']['output'];
    /** Execute a single fuel-asm instruction. */
    execute: Scalars['Boolean']['output'];
    /**
     * Sequentially produces `blocks_to_produce` blocks. The first block starts with
     * `start_timestamp`. If the block production in the [`crate::service::Config`] is
     * `Trigger::Interval { block_time }`, produces blocks with `block_time ` intervals between
     * them. The `start_timestamp` is the timestamp in seconds.
     */
    produceBlocks: Scalars['U32']['output'];
    /** Reset the VM instance to the initial state. */
    reset: Scalars['Boolean']['output'];
    /** Set a breakpoint for a VM instance. */
    setBreakpoint: Scalars['Boolean']['output'];
    /** Set single-stepping mode for the VM instance. */
    setSingleStepping: Scalars['Boolean']['output'];
    /**
     * Initialize a new debugger session, returning its ID.
     * A new VM instance is spawned for each session.
     * The session is run in a separate database transaction,
     * on top of the most recent node state.
     */
    startSession: Scalars['ID']['output'];
    /**
     * Run a single transaction in given session until it
     * hits a breakpoint or completes.
     */
    startTx: GqlRunResult;
    /**
     * Submits transaction to the `TxPool`.
     *
     * Returns submitted transaction if the transaction is included in the `TxPool` without problems.
     */
    submit: GqlTransaction;
};
export type GqlMutationContinueTxArgs = {
    id: Scalars['ID']['input'];
};
export type GqlMutationDryRunArgs = {
    gasPrice?: InputMaybe<Scalars['U64']['input']>;
    txs: Array<Scalars['HexString']['input']>;
    utxoValidation?: InputMaybe<Scalars['Boolean']['input']>;
};
export type GqlMutationEndSessionArgs = {
    id: Scalars['ID']['input'];
};
export type GqlMutationExecuteArgs = {
    id: Scalars['ID']['input'];
    op: Scalars['String']['input'];
};
export type GqlMutationProduceBlocksArgs = {
    blocksToProduce: Scalars['U32']['input'];
    startTimestamp?: InputMaybe<Scalars['Tai64Timestamp']['input']>;
};
export type GqlMutationResetArgs = {
    id: Scalars['ID']['input'];
};
export type GqlMutationSetBreakpointArgs = {
    breakpoint: GqlBreakpoint;
    id: Scalars['ID']['input'];
};
export type GqlMutationSetSingleSteppingArgs = {
    enable: Scalars['Boolean']['input'];
    id: Scalars['ID']['input'];
};
export type GqlMutationStartTxArgs = {
    id: Scalars['ID']['input'];
    txJson: Scalars['String']['input'];
};
export type GqlMutationSubmitArgs = {
    tx: Scalars['HexString']['input'];
};
export type GqlNodeInfo = {
    maxDepth: Scalars['U64']['output'];
    maxTx: Scalars['U64']['output'];
    nodeVersion: Scalars['String']['output'];
    peers: Array<GqlPeerInfo>;
    utxoValidation: Scalars['Boolean']['output'];
    vmBacktrace: Scalars['Boolean']['output'];
};
export type GqlOutput = GqlChangeOutput | GqlCoinOutput | GqlContractCreated | GqlContractOutput | GqlVariableOutput;
/**
 * A separate `Breakpoint` type to be used as an output, as a single
 * type cannot act as both input and output type in async-graphql
 */
export type GqlOutputBreakpoint = {
    contract: Scalars['ContractId']['output'];
    pc: Scalars['U64']['output'];
};
/** Information about pagination in a connection */
export type GqlPageInfo = {
    /** When paginating forwards, the cursor to continue. */
    endCursor?: Maybe<Scalars['String']['output']>;
    /** When paginating forwards, are there more items? */
    hasNextPage: Scalars['Boolean']['output'];
    /** When paginating backwards, are there more items? */
    hasPreviousPage: Scalars['Boolean']['output'];
    /** When paginating backwards, the cursor to continue. */
    startCursor?: Maybe<Scalars['String']['output']>;
};
export type GqlPeerInfo = {
    /** The advertised multi-addrs that can be used to connect to this peer */
    addresses: Array<Scalars['String']['output']>;
    /** The internal fuel p2p reputation of this peer */
    appScore: Scalars['Float']['output'];
    /** The last reported height of the peer */
    blockHeight?: Maybe<Scalars['U32']['output']>;
    /** The self-reported version of the client the peer is using */
    clientVersion?: Maybe<Scalars['String']['output']>;
    /** The libp2p peer id */
    id: Scalars['String']['output'];
    /** The last heartbeat from this peer in unix epoch time ms */
    lastHeartbeatMs: Scalars['U64']['output'];
};
export type GqlPoAConsensus = {
    /** Gets the signature of the block produced by `PoA` consensus. */
    signature: Scalars['Signature']['output'];
};
export type GqlPolicies = {
    maturity?: Maybe<Scalars['U32']['output']>;
    maxFee?: Maybe<Scalars['U64']['output']>;
    tip?: Maybe<Scalars['U64']['output']>;
    witnessLimit?: Maybe<Scalars['U64']['output']>;
};
export type GqlPredicateParameters = {
    maxGasPerPredicate: Scalars['U64']['output'];
    maxMessageDataLength: Scalars['U64']['output'];
    maxPredicateDataLength: Scalars['U64']['output'];
    maxPredicateLength: Scalars['U64']['output'];
    version: GqlPredicateParametersVersion;
};
export declare enum GqlPredicateParametersVersion {
    V1 = "V1"
}
export type GqlProgramState = {
    data: Scalars['HexString']['output'];
    returnType: GqlReturnType;
};
export type GqlQuery = {
    balance: GqlBalance;
    balances: GqlBalanceConnection;
    blob?: Maybe<GqlBlob>;
    block?: Maybe<GqlBlock>;
    blocks: GqlBlockConnection;
    chain: GqlChainInfo;
    /** Gets the coin by `utxo_id`. */
    coin?: Maybe<GqlCoin>;
    /** Gets all unspent coins of some `owner` maybe filtered with by `asset_id` per page. */
    coins: GqlCoinConnection;
    /**
     * For each `query_per_asset`, get some spendable coins(of asset specified by the query) owned by
     * `owner` that add up at least the query amount. The returned coins can be spent.
     * The number of coins is optimized to prevent dust accumulation.
     *
     * The query supports excluding and maximum the number of coins.
     *
     * Returns:
     * The list of spendable coins per asset from the query. The length of the result is
     * the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`
     * is the same.
     */
    coinsToSpend: Array<Array<GqlCoinType>>;
    consensusParameters: GqlConsensusParameters;
    contract?: Maybe<GqlContract>;
    contractBalance: GqlContractBalance;
    contractBalances: GqlContractBalanceConnection;
    estimateGasPrice: GqlEstimateGasPrice;
    /** Estimate the predicate gas for the provided transaction */
    estimatePredicates: GqlTransaction;
    /** Returns true when the GraphQL API is serving requests. */
    health: Scalars['Boolean']['output'];
    latestGasPrice: GqlLatestGasPrice;
    /** Read read a range of memory bytes. */
    memory: Scalars['String']['output'];
    message?: Maybe<GqlMessage>;
    messageProof?: Maybe<GqlMessageProof>;
    messageStatus: GqlMessageStatus;
    messages: GqlMessageConnection;
    nodeInfo: GqlNodeInfo;
    /** Read register value by index. */
    register: Scalars['U64']['output'];
    relayedTransactionStatus?: Maybe<GqlRelayedTransactionStatus>;
    stateTransitionBytecodeByRoot: GqlStateTransitionBytecode;
    stateTransitionBytecodeByVersion?: Maybe<GqlStateTransitionBytecode>;
    transaction?: Maybe<GqlTransaction>;
    transactions: GqlTransactionConnection;
    transactionsByOwner: GqlTransactionConnection;
};
export type GqlQueryBalanceArgs = {
    assetId: Scalars['AssetId']['input'];
    owner: Scalars['Address']['input'];
};
export type GqlQueryBalancesArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    filter: GqlBalanceFilterInput;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
};
export type GqlQueryBlobArgs = {
    id: Scalars['BlobId']['input'];
};
export type GqlQueryBlockArgs = {
    height?: InputMaybe<Scalars['U32']['input']>;
    id?: InputMaybe<Scalars['BlockId']['input']>;
};
export type GqlQueryBlocksArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
};
export type GqlQueryCoinArgs = {
    utxoId: Scalars['UtxoId']['input'];
};
export type GqlQueryCoinsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    filter: GqlCoinFilterInput;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
};
export type GqlQueryCoinsToSpendArgs = {
    excludedIds?: InputMaybe<GqlExcludeInput>;
    owner: Scalars['Address']['input'];
    queryPerAsset: Array<GqlSpendQueryElementInput>;
};
export type GqlQueryConsensusParametersArgs = {
    version: Scalars['Int']['input'];
};
export type GqlQueryContractArgs = {
    id: Scalars['ContractId']['input'];
};
export type GqlQueryContractBalanceArgs = {
    asset: Scalars['AssetId']['input'];
    contract: Scalars['ContractId']['input'];
};
export type GqlQueryContractBalancesArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    filter: GqlContractBalanceFilterInput;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
};
export type GqlQueryEstimateGasPriceArgs = {
    blockHorizon?: InputMaybe<Scalars['U32']['input']>;
};
export type GqlQueryEstimatePredicatesArgs = {
    tx: Scalars['HexString']['input'];
};
export type GqlQueryMemoryArgs = {
    id: Scalars['ID']['input'];
    size: Scalars['U32']['input'];
    start: Scalars['U32']['input'];
};
export type GqlQueryMessageArgs = {
    nonce: Scalars['Nonce']['input'];
};
export type GqlQueryMessageProofArgs = {
    commitBlockHeight?: InputMaybe<Scalars['U32']['input']>;
    commitBlockId?: InputMaybe<Scalars['BlockId']['input']>;
    nonce: Scalars['Nonce']['input'];
    transactionId: Scalars['TransactionId']['input'];
};
export type GqlQueryMessageStatusArgs = {
    nonce: Scalars['Nonce']['input'];
};
export type GqlQueryMessagesArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    owner?: InputMaybe<Scalars['Address']['input']>;
};
export type GqlQueryRegisterArgs = {
    id: Scalars['ID']['input'];
    register: Scalars['U32']['input'];
};
export type GqlQueryRelayedTransactionStatusArgs = {
    id: Scalars['RelayedTransactionId']['input'];
};
export type GqlQueryStateTransitionBytecodeByRootArgs = {
    root: Scalars['HexString']['input'];
};
export type GqlQueryStateTransitionBytecodeByVersionArgs = {
    version: Scalars['Int']['input'];
};
export type GqlQueryTransactionArgs = {
    id: Scalars['TransactionId']['input'];
};
export type GqlQueryTransactionsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
};
export type GqlQueryTransactionsByOwnerArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
    owner: Scalars['Address']['input'];
};
export type GqlReceipt = {
    amount?: Maybe<Scalars['U64']['output']>;
    assetId?: Maybe<Scalars['AssetId']['output']>;
    /** Set in the case of a Panic receipt to indicate a missing contract input id */
    contractId?: Maybe<Scalars['ContractId']['output']>;
    data?: Maybe<Scalars['HexString']['output']>;
    digest?: Maybe<Scalars['Bytes32']['output']>;
    gas?: Maybe<Scalars['U64']['output']>;
    gasUsed?: Maybe<Scalars['U64']['output']>;
    id?: Maybe<Scalars['ContractId']['output']>;
    is?: Maybe<Scalars['U64']['output']>;
    len?: Maybe<Scalars['U64']['output']>;
    nonce?: Maybe<Scalars['Nonce']['output']>;
    param1?: Maybe<Scalars['U64']['output']>;
    param2?: Maybe<Scalars['U64']['output']>;
    pc?: Maybe<Scalars['U64']['output']>;
    ptr?: Maybe<Scalars['U64']['output']>;
    ra?: Maybe<Scalars['U64']['output']>;
    rb?: Maybe<Scalars['U64']['output']>;
    rc?: Maybe<Scalars['U64']['output']>;
    rd?: Maybe<Scalars['U64']['output']>;
    reason?: Maybe<Scalars['U64']['output']>;
    receiptType: GqlReceiptType;
    recipient?: Maybe<Scalars['Address']['output']>;
    result?: Maybe<Scalars['U64']['output']>;
    sender?: Maybe<Scalars['Address']['output']>;
    subId?: Maybe<Scalars['Bytes32']['output']>;
    to?: Maybe<Scalars['ContractId']['output']>;
    toAddress?: Maybe<Scalars['Address']['output']>;
    val?: Maybe<Scalars['U64']['output']>;
};
export declare enum GqlReceiptType {
    Burn = "BURN",
    Call = "CALL",
    Log = "LOG",
    LogData = "LOG_DATA",
    MessageOut = "MESSAGE_OUT",
    Mint = "MINT",
    Panic = "PANIC",
    Return = "RETURN",
    ReturnData = "RETURN_DATA",
    Revert = "REVERT",
    ScriptResult = "SCRIPT_RESULT",
    Transfer = "TRANSFER",
    TransferOut = "TRANSFER_OUT"
}
export type GqlRelayedTransactionFailed = {
    blockHeight: Scalars['U32']['output'];
    failure: Scalars['String']['output'];
};
export type GqlRelayedTransactionStatus = GqlRelayedTransactionFailed;
export declare enum GqlReturnType {
    Return = "RETURN",
    ReturnData = "RETURN_DATA",
    Revert = "REVERT"
}
export type GqlRunResult = {
    breakpoint?: Maybe<GqlOutputBreakpoint>;
    jsonReceipts: Array<Scalars['String']['output']>;
    state: GqlRunState;
};
export declare enum GqlRunState {
    /** Stopped on a breakpoint */
    Breakpoint = "BREAKPOINT",
    /** All breakpoints have been processed, and the program has terminated */
    Completed = "COMPLETED"
}
export type GqlScriptParameters = {
    maxScriptDataLength: Scalars['U64']['output'];
    maxScriptLength: Scalars['U64']['output'];
    version: GqlScriptParametersVersion;
};
export declare enum GqlScriptParametersVersion {
    V1 = "V1"
}
export type GqlSpendQueryElementInput = {
    /** Target amount for the query. */
    amount: Scalars['U64']['input'];
    /** Identifier of the asset to spend. */
    assetId: Scalars['AssetId']['input'];
    /** The maximum number of currencies for selection. */
    max?: InputMaybe<Scalars['U32']['input']>;
};
export type GqlSqueezedOutStatus = {
    reason: Scalars['String']['output'];
};
export type GqlStateTransitionBytecode = {
    bytecode: GqlUploadedBytecode;
    root: Scalars['HexString']['output'];
};
export type GqlStateTransitionPurpose = {
    root: Scalars['Bytes32']['output'];
};
export type GqlSubmittedStatus = {
    time: Scalars['Tai64Timestamp']['output'];
};
export type GqlSubscription = {
    /**
     * Returns a stream of status updates for the given transaction id.
     * If the current status is [`TransactionStatus::Success`], [`TransactionStatus::SqueezedOut`]
     * or [`TransactionStatus::Failed`] the stream will return that and end immediately.
     * If the current status is [`TransactionStatus::Submitted`] this will be returned
     * and the stream will wait for a future update.
     *
     * This stream will wait forever so it's advised to use within a timeout.
     *
     * It is possible for the stream to miss an update if it is polled slower
     * then the updates arrive. In such a case the stream will close without
     * a status. If this occurs the stream can simply be restarted to return
     * the latest status.
     */
    statusChange: GqlTransactionStatus;
    /** Submits transaction to the `TxPool` and await either confirmation or failure. */
    submitAndAwait: GqlTransactionStatus;
    /**
     * Submits the transaction to the `TxPool` and returns a stream of events.
     * Compared to the `submitAndAwait`, the stream also contains `
     * SubmittedStatus` as an intermediate state.
     */
    submitAndAwaitStatus: GqlTransactionStatus;
};
export type GqlSubscriptionStatusChangeArgs = {
    id: Scalars['TransactionId']['input'];
};
export type GqlSubscriptionSubmitAndAwaitArgs = {
    tx: Scalars['HexString']['input'];
};
export type GqlSubscriptionSubmitAndAwaitStatusArgs = {
    tx: Scalars['HexString']['input'];
};
export type GqlSuccessStatus = {
    block: GqlBlock;
    blockHeight: Scalars['U32']['output'];
    programState?: Maybe<GqlProgramState>;
    receipts: Array<GqlReceipt>;
    time: Scalars['Tai64Timestamp']['output'];
    totalFee: Scalars['U64']['output'];
    totalGas: Scalars['U64']['output'];
    transaction: GqlTransaction;
    transactionId: Scalars['TransactionId']['output'];
};
export type GqlTransaction = {
    blobId?: Maybe<Scalars['BlobId']['output']>;
    bytecodeRoot?: Maybe<Scalars['Bytes32']['output']>;
    bytecodeWitnessIndex?: Maybe<Scalars['U16']['output']>;
    id: Scalars['TransactionId']['output'];
    inputAssetIds?: Maybe<Array<Scalars['AssetId']['output']>>;
    inputContract?: Maybe<GqlInputContract>;
    inputContracts?: Maybe<Array<Scalars['ContractId']['output']>>;
    inputs?: Maybe<Array<GqlInput>>;
    isBlob: Scalars['Boolean']['output'];
    isCreate: Scalars['Boolean']['output'];
    isMint: Scalars['Boolean']['output'];
    isScript: Scalars['Boolean']['output'];
    isUpgrade: Scalars['Boolean']['output'];
    isUpload: Scalars['Boolean']['output'];
    maturity?: Maybe<Scalars['U32']['output']>;
    mintAmount?: Maybe<Scalars['U64']['output']>;
    mintAssetId?: Maybe<Scalars['AssetId']['output']>;
    mintGasPrice?: Maybe<Scalars['U64']['output']>;
    outputContract?: Maybe<GqlContractOutput>;
    outputs: Array<GqlOutput>;
    policies?: Maybe<GqlPolicies>;
    proofSet?: Maybe<Array<Scalars['Bytes32']['output']>>;
    /** Return the transaction bytes using canonical encoding */
    rawPayload: Scalars['HexString']['output'];
    receiptsRoot?: Maybe<Scalars['Bytes32']['output']>;
    salt?: Maybe<Scalars['Salt']['output']>;
    script?: Maybe<Scalars['HexString']['output']>;
    scriptData?: Maybe<Scalars['HexString']['output']>;
    scriptGasLimit?: Maybe<Scalars['U64']['output']>;
    status?: Maybe<GqlTransactionStatus>;
    storageSlots?: Maybe<Array<Scalars['HexString']['output']>>;
    subsectionIndex?: Maybe<Scalars['U16']['output']>;
    subsectionsNumber?: Maybe<Scalars['U16']['output']>;
    txPointer?: Maybe<Scalars['TxPointer']['output']>;
    upgradePurpose?: Maybe<GqlUpgradePurpose>;
    witnesses?: Maybe<Array<Scalars['HexString']['output']>>;
};
export type GqlTransactionConnection = {
    /** A list of edges. */
    edges: Array<GqlTransactionEdge>;
    /** A list of nodes. */
    nodes: Array<GqlTransaction>;
    /** Information to aid in pagination. */
    pageInfo: GqlPageInfo;
};
/** An edge in a connection. */
export type GqlTransactionEdge = {
    /** A cursor for use in pagination */
    cursor: Scalars['String']['output'];
    /** The item at the end of the edge */
    node: GqlTransaction;
};
export type GqlTransactionStatus = GqlFailureStatus | GqlSqueezedOutStatus | GqlSubmittedStatus | GqlSuccessStatus;
export type GqlTxParameters = {
    maxBytecodeSubsections: Scalars['U16']['output'];
    maxGasPerTx: Scalars['U64']['output'];
    maxInputs: Scalars['U16']['output'];
    maxOutputs: Scalars['U16']['output'];
    maxSize: Scalars['U64']['output'];
    maxWitnesses: Scalars['U32']['output'];
    version: GqlTxParametersVersion;
};
export declare enum GqlTxParametersVersion {
    V1 = "V1"
}
export type GqlUpgradePurpose = GqlConsensusParametersPurpose | GqlStateTransitionPurpose;
export type GqlUploadedBytecode = {
    /** Combined bytecode of all uploaded subsections. */
    bytecode: Scalars['HexString']['output'];
    /** Indicates if the bytecode upload is complete. */
    completed: Scalars['Boolean']['output'];
    /** Number of uploaded subsections (if incomplete). */
    uploadedSubsectionsNumber?: Maybe<Scalars['Int']['output']>;
};
export type GqlVariableOutput = {
    amount: Scalars['U64']['output'];
    assetId: Scalars['AssetId']['output'];
    to: Scalars['Address']['output'];
};
export type GqlSubmittedStatusFragment = {
    time: string;
    type: 'SubmittedStatus';
};
export type GqlSuccessStatusFragment = {
    time: string;
    totalGas: string;
    totalFee: string;
    type: 'SuccessStatus';
    programState?: {
        returnType: GqlReturnType;
        data: string;
    } | null;
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
export type GqlSuccessStatusWithBlockIdFragment = {
    time: string;
    totalGas: string;
    totalFee: string;
    type: 'SuccessStatus';
    block: {
        id: string;
    };
    programState?: {
        returnType: GqlReturnType;
        data: string;
    } | null;
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
export type GqlFailureStatusFragment = {
    totalGas: string;
    totalFee: string;
    time: string;
    reason: string;
    type: 'FailureStatus';
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
export type GqlFailureStatusWithBlockIdFragment = {
    totalGas: string;
    totalFee: string;
    time: string;
    reason: string;
    type: 'FailureStatus';
    block: {
        id: string;
    };
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
export type GqlSqueezedOutStatusFragment = {
    reason: string;
    type: 'SqueezedOutStatus';
};
type GqlTransactionStatusFragment_FailureStatus = {
    totalGas: string;
    totalFee: string;
    time: string;
    reason: string;
    type: 'FailureStatus';
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
type GqlTransactionStatusFragment_SqueezedOutStatus = {
    reason: string;
    type: 'SqueezedOutStatus';
};
type GqlTransactionStatusFragment_SubmittedStatus = {
    time: string;
    type: 'SubmittedStatus';
};
type GqlTransactionStatusFragment_SuccessStatus = {
    time: string;
    totalGas: string;
    totalFee: string;
    type: 'SuccessStatus';
    programState?: {
        returnType: GqlReturnType;
        data: string;
    } | null;
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
export type GqlTransactionStatusFragment = GqlTransactionStatusFragment_FailureStatus | GqlTransactionStatusFragment_SqueezedOutStatus | GqlTransactionStatusFragment_SubmittedStatus | GqlTransactionStatusFragment_SuccessStatus;
export type GqlMalleableTransactionFieldsFragment = {
    receiptsRoot?: string | null;
    inputs?: Array<{
        txPointer: string;
        type: 'InputCoin';
    } | {
        txPointer: string;
        type: 'InputContract';
    } | {
        type: 'InputMessage';
    }> | null;
    outputs: Array<{
        to: string;
        amount: string;
        assetId: string;
        type: 'ChangeOutput';
    } | {
        to: string;
        amount: string;
        assetId: string;
        type: 'CoinOutput';
    } | {
        contract: string;
        stateRoot: string;
        type: 'ContractCreated';
    } | {
        inputIndex: string;
        balanceRoot: string;
        stateRoot: string;
        type: 'ContractOutput';
    } | {
        to: string;
        amount: string;
        assetId: string;
        type: 'VariableOutput';
    }>;
};
type GqlTransactionStatusSubscriptionFragment_FailureStatus = {
    totalGas: string;
    totalFee: string;
    time: string;
    reason: string;
    type: 'FailureStatus';
    transaction: {
        receiptsRoot?: string | null;
        inputs?: Array<{
            txPointer: string;
            type: 'InputCoin';
        } | {
            txPointer: string;
            type: 'InputContract';
        } | {
            type: 'InputMessage';
        }> | null;
        outputs: Array<{
            to: string;
            amount: string;
            assetId: string;
            type: 'ChangeOutput';
        } | {
            to: string;
            amount: string;
            assetId: string;
            type: 'CoinOutput';
        } | {
            contract: string;
            stateRoot: string;
            type: 'ContractCreated';
        } | {
            inputIndex: string;
            balanceRoot: string;
            stateRoot: string;
            type: 'ContractOutput';
        } | {
            to: string;
            amount: string;
            assetId: string;
            type: 'VariableOutput';
        }>;
    };
    block: {
        id: string;
    };
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
type GqlTransactionStatusSubscriptionFragment_SqueezedOutStatus = {
    reason: string;
    type: 'SqueezedOutStatus';
};
type GqlTransactionStatusSubscriptionFragment_SubmittedStatus = {
    time: string;
    type: 'SubmittedStatus';
};
type GqlTransactionStatusSubscriptionFragment_SuccessStatus = {
    time: string;
    totalGas: string;
    totalFee: string;
    type: 'SuccessStatus';
    transaction: {
        receiptsRoot?: string | null;
        inputs?: Array<{
            txPointer: string;
            type: 'InputCoin';
        } | {
            txPointer: string;
            type: 'InputContract';
        } | {
            type: 'InputMessage';
        }> | null;
        outputs: Array<{
            to: string;
            amount: string;
            assetId: string;
            type: 'ChangeOutput';
        } | {
            to: string;
            amount: string;
            assetId: string;
            type: 'CoinOutput';
        } | {
            contract: string;
            stateRoot: string;
            type: 'ContractCreated';
        } | {
            inputIndex: string;
            balanceRoot: string;
            stateRoot: string;
            type: 'ContractOutput';
        } | {
            to: string;
            amount: string;
            assetId: string;
            type: 'VariableOutput';
        }>;
    };
    block: {
        id: string;
    };
    programState?: {
        returnType: GqlReturnType;
        data: string;
    } | null;
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
export type GqlTransactionStatusSubscriptionFragment = GqlTransactionStatusSubscriptionFragment_FailureStatus | GqlTransactionStatusSubscriptionFragment_SqueezedOutStatus | GqlTransactionStatusSubscriptionFragment_SubmittedStatus | GqlTransactionStatusSubscriptionFragment_SuccessStatus;
export type GqlTransactionFragment = {
    id: string;
    rawPayload: string;
    status?: {
        totalGas: string;
        totalFee: string;
        time: string;
        reason: string;
        type: 'FailureStatus';
        receipts: Array<{
            id?: string | null;
            pc?: string | null;
            is?: string | null;
            to?: string | null;
            toAddress?: string | null;
            amount?: string | null;
            assetId?: string | null;
            gas?: string | null;
            param1?: string | null;
            param2?: string | null;
            val?: string | null;
            ptr?: string | null;
            digest?: string | null;
            reason?: string | null;
            ra?: string | null;
            rb?: string | null;
            rc?: string | null;
            rd?: string | null;
            len?: string | null;
            receiptType: GqlReceiptType;
            result?: string | null;
            gasUsed?: string | null;
            data?: string | null;
            sender?: string | null;
            recipient?: string | null;
            nonce?: string | null;
            contractId?: string | null;
            subId?: string | null;
        }>;
    } | {
        reason: string;
        type: 'SqueezedOutStatus';
    } | {
        time: string;
        type: 'SubmittedStatus';
    } | {
        time: string;
        totalGas: string;
        totalFee: string;
        type: 'SuccessStatus';
        programState?: {
            returnType: GqlReturnType;
            data: string;
        } | null;
        receipts: Array<{
            id?: string | null;
            pc?: string | null;
            is?: string | null;
            to?: string | null;
            toAddress?: string | null;
            amount?: string | null;
            assetId?: string | null;
            gas?: string | null;
            param1?: string | null;
            param2?: string | null;
            val?: string | null;
            ptr?: string | null;
            digest?: string | null;
            reason?: string | null;
            ra?: string | null;
            rb?: string | null;
            rc?: string | null;
            rd?: string | null;
            len?: string | null;
            receiptType: GqlReceiptType;
            result?: string | null;
            gasUsed?: string | null;
            data?: string | null;
            sender?: string | null;
            recipient?: string | null;
            nonce?: string | null;
            contractId?: string | null;
            subId?: string | null;
        }>;
    } | null;
};
export type GqlTransactionRawPayloadFragment = {
    id: string;
    rawPayload: string;
};
type GqlInputEstimatePredicatesFragment_InputCoin = {
    predicateGasUsed: string;
};
type GqlInputEstimatePredicatesFragment_InputContract = {};
type GqlInputEstimatePredicatesFragment_InputMessage = {
    predicateGasUsed: string;
};
export type GqlInputEstimatePredicatesFragment = GqlInputEstimatePredicatesFragment_InputCoin | GqlInputEstimatePredicatesFragment_InputContract | GqlInputEstimatePredicatesFragment_InputMessage;
export type GqlTransactionEstimatePredicatesFragment = {
    inputs?: Array<{
        predicateGasUsed: string;
    } | {
        predicateGasUsed: string;
    } | {}> | null;
};
export type GqlDryRunFailureStatusFragment = {
    totalGas: string;
    totalFee: string;
    reason: string;
    type: 'DryRunFailureStatus';
    programState?: {
        returnType: GqlReturnType;
        data: string;
    } | null;
};
export type GqlDryRunSuccessStatusFragment = {
    totalGas: string;
    totalFee: string;
    type: 'DryRunSuccessStatus';
    programState?: {
        returnType: GqlReturnType;
        data: string;
    } | null;
};
export type GqlReceiptFragment = {
    id?: string | null;
    pc?: string | null;
    is?: string | null;
    to?: string | null;
    toAddress?: string | null;
    amount?: string | null;
    assetId?: string | null;
    gas?: string | null;
    param1?: string | null;
    param2?: string | null;
    val?: string | null;
    ptr?: string | null;
    digest?: string | null;
    reason?: string | null;
    ra?: string | null;
    rb?: string | null;
    rc?: string | null;
    rd?: string | null;
    len?: string | null;
    receiptType: GqlReceiptType;
    result?: string | null;
    gasUsed?: string | null;
    data?: string | null;
    sender?: string | null;
    recipient?: string | null;
    nonce?: string | null;
    contractId?: string | null;
    subId?: string | null;
};
type GqlDryRunTransactionStatusFragment_DryRunFailureStatus = {
    totalGas: string;
    totalFee: string;
    reason: string;
    type: 'DryRunFailureStatus';
    programState?: {
        returnType: GqlReturnType;
        data: string;
    } | null;
};
type GqlDryRunTransactionStatusFragment_DryRunSuccessStatus = {
    totalGas: string;
    totalFee: string;
    type: 'DryRunSuccessStatus';
    programState?: {
        returnType: GqlReturnType;
        data: string;
    } | null;
};
export type GqlDryRunTransactionStatusFragment = GqlDryRunTransactionStatusFragment_DryRunFailureStatus | GqlDryRunTransactionStatusFragment_DryRunSuccessStatus;
export type GqlDryRunTransactionExecutionStatusFragment = {
    id: string;
    status: {
        totalGas: string;
        totalFee: string;
        reason: string;
        type: 'DryRunFailureStatus';
        programState?: {
            returnType: GqlReturnType;
            data: string;
        } | null;
    } | {
        totalGas: string;
        totalFee: string;
        type: 'DryRunSuccessStatus';
        programState?: {
            returnType: GqlReturnType;
            data: string;
        } | null;
    };
    receipts: Array<{
        id?: string | null;
        pc?: string | null;
        is?: string | null;
        to?: string | null;
        toAddress?: string | null;
        amount?: string | null;
        assetId?: string | null;
        gas?: string | null;
        param1?: string | null;
        param2?: string | null;
        val?: string | null;
        ptr?: string | null;
        digest?: string | null;
        reason?: string | null;
        ra?: string | null;
        rb?: string | null;
        rc?: string | null;
        rd?: string | null;
        len?: string | null;
        receiptType: GqlReceiptType;
        result?: string | null;
        gasUsed?: string | null;
        data?: string | null;
        sender?: string | null;
        recipient?: string | null;
        nonce?: string | null;
        contractId?: string | null;
        subId?: string | null;
    }>;
};
export type GqlBlockFragment = {
    id: string;
    height: string;
    header: {
        time: string;
        daHeight: string;
        stateTransitionBytecodeVersion: string;
        transactionsCount: string;
        transactionsRoot: string;
        messageOutboxRoot: string;
        eventInboxRoot: string;
        prevRoot: string;
        applicationHash: string;
    };
    transactions: Array<{
        id: string;
    }>;
};
export type GqlCoinFragment = {
    utxoId: string;
    amount: string;
    assetId: string;
    blockCreated: string;
    txCreatedIdx: string;
    type: 'Coin';
};
export type GqlMessageCoinFragment = {
    sender: string;
    recipient: string;
    nonce: string;
    amount: string;
    assetId: string;
    daHeight: string;
    type: 'MessageCoin';
};
export type GqlMessageFragment = {
    amount: string;
    sender: string;
    recipient: string;
    data: string;
    daHeight: string;
};
export type GqlGetMessageFragment = {
    nonce: string;
    amount: string;
    sender: string;
    recipient: string;
    data: string;
    daHeight: string;
};
export type GqlMessageProofFragment = {
    sender: string;
    recipient: string;
    amount: string;
    data: string;
    messageProof: {
        proofSet: Array<string>;
        proofIndex: string;
    };
    blockProof: {
        proofSet: Array<string>;
        proofIndex: string;
    };
    messageBlockHeader: {
        version: GqlHeaderVersion;
        id: string;
        daHeight: string;
        consensusParametersVersion: string;
        stateTransitionBytecodeVersion: string;
        transactionsCount: string;
        messageReceiptCount: string;
        transactionsRoot: string;
        messageOutboxRoot: string;
        eventInboxRoot: string;
        height: string;
        prevRoot: string;
        time: string;
        applicationHash: string;
    };
    commitBlockHeader: {
        version: GqlHeaderVersion;
        id: string;
        daHeight: string;
        consensusParametersVersion: string;
        stateTransitionBytecodeVersion: string;
        transactionsCount: string;
        messageReceiptCount: string;
        transactionsRoot: string;
        messageOutboxRoot: string;
        eventInboxRoot: string;
        height: string;
        prevRoot: string;
        time: string;
        applicationHash: string;
    };
};
export type GqlTxParametersFragment = {
    version: GqlTxParametersVersion;
    maxInputs: string;
    maxOutputs: string;
    maxWitnesses: string;
    maxGasPerTx: string;
    maxSize: string;
    maxBytecodeSubsections: string;
};
export type GqlPredicateParametersFragment = {
    version: GqlPredicateParametersVersion;
    maxPredicateLength: string;
    maxPredicateDataLength: string;
    maxGasPerPredicate: string;
    maxMessageDataLength: string;
};
export type GqlScriptParametersFragment = {
    version: GqlScriptParametersVersion;
    maxScriptLength: string;
    maxScriptDataLength: string;
};
export type GqlContractParametersFragment = {
    version: GqlContractParametersVersion;
    contractMaxSize: string;
    maxStorageSlots: string;
};
export type GqlFeeParametersFragment = {
    version: GqlFeeParametersVersion;
    gasPriceFactor: string;
    gasPerByte: string;
};
type GqlDependentCostFragment_HeavyOperation = {
    base: string;
    gasPerUnit: string;
    type: 'HeavyOperation';
};
type GqlDependentCostFragment_LightOperation = {
    base: string;
    unitsPerGas: string;
    type: 'LightOperation';
};
export type GqlDependentCostFragment = GqlDependentCostFragment_HeavyOperation | GqlDependentCostFragment_LightOperation;
export type GqlGasCostsFragment = {
    ecr1: string;
    newStoragePerByte: string;
    contractRoot: {
        base: string;
        gasPerUnit: string;
        type: 'HeavyOperation';
    } | {
        base: string;
        unitsPerGas: string;
        type: 'LightOperation';
    };
    stateRoot: {
        base: string;
        gasPerUnit: string;
        type: 'HeavyOperation';
    } | {
        base: string;
        unitsPerGas: string;
        type: 'LightOperation';
    };
    vmInitialization: {
        base: string;
        gasPerUnit: string;
        type: 'HeavyOperation';
    } | {
        base: string;
        unitsPerGas: string;
        type: 'LightOperation';
    };
    s256: {
        base: string;
        gasPerUnit: string;
        type: 'HeavyOperation';
    } | {
        base: string;
        unitsPerGas: string;
        type: 'LightOperation';
    };
};
export type GqlConsensusParametersFragment = {
    version: GqlConsensusParametersVersion;
    baseAssetId: string;
    chainId: string;
    txParams: {
        version: GqlTxParametersVersion;
        maxInputs: string;
        maxOutputs: string;
        maxWitnesses: string;
        maxGasPerTx: string;
        maxSize: string;
        maxBytecodeSubsections: string;
    };
    predicateParams: {
        version: GqlPredicateParametersVersion;
        maxPredicateLength: string;
        maxPredicateDataLength: string;
        maxGasPerPredicate: string;
        maxMessageDataLength: string;
    };
    scriptParams: {
        version: GqlScriptParametersVersion;
        maxScriptLength: string;
        maxScriptDataLength: string;
    };
    contractParams: {
        version: GqlContractParametersVersion;
        contractMaxSize: string;
        maxStorageSlots: string;
    };
    feeParams: {
        version: GqlFeeParametersVersion;
        gasPriceFactor: string;
        gasPerByte: string;
    };
    gasCosts: {
        ecr1: string;
        newStoragePerByte: string;
        contractRoot: {
            base: string;
            gasPerUnit: string;
            type: 'HeavyOperation';
        } | {
            base: string;
            unitsPerGas: string;
            type: 'LightOperation';
        };
        stateRoot: {
            base: string;
            gasPerUnit: string;
            type: 'HeavyOperation';
        } | {
            base: string;
            unitsPerGas: string;
            type: 'LightOperation';
        };
        vmInitialization: {
            base: string;
            gasPerUnit: string;
            type: 'HeavyOperation';
        } | {
            base: string;
            unitsPerGas: string;
            type: 'LightOperation';
        };
        s256: {
            base: string;
            gasPerUnit: string;
            type: 'HeavyOperation';
        } | {
            base: string;
            unitsPerGas: string;
            type: 'LightOperation';
        };
    };
};
export type GqlChainInfoFragment = {
    name: string;
    daHeight: string;
    consensusParameters: {
        version: GqlConsensusParametersVersion;
        baseAssetId: string;
        chainId: string;
        txParams: {
            version: GqlTxParametersVersion;
            maxInputs: string;
            maxOutputs: string;
            maxWitnesses: string;
            maxGasPerTx: string;
            maxSize: string;
            maxBytecodeSubsections: string;
        };
        predicateParams: {
            version: GqlPredicateParametersVersion;
            maxPredicateLength: string;
            maxPredicateDataLength: string;
            maxGasPerPredicate: string;
            maxMessageDataLength: string;
        };
        scriptParams: {
            version: GqlScriptParametersVersion;
            maxScriptLength: string;
            maxScriptDataLength: string;
        };
        contractParams: {
            version: GqlContractParametersVersion;
            contractMaxSize: string;
            maxStorageSlots: string;
        };
        feeParams: {
            version: GqlFeeParametersVersion;
            gasPriceFactor: string;
            gasPerByte: string;
        };
        gasCosts: {
            ecr1: string;
            newStoragePerByte: string;
            contractRoot: {
                base: string;
                gasPerUnit: string;
                type: 'HeavyOperation';
            } | {
                base: string;
                unitsPerGas: string;
                type: 'LightOperation';
            };
            stateRoot: {
                base: string;
                gasPerUnit: string;
                type: 'HeavyOperation';
            } | {
                base: string;
                unitsPerGas: string;
                type: 'LightOperation';
            };
            vmInitialization: {
                base: string;
                gasPerUnit: string;
                type: 'HeavyOperation';
            } | {
                base: string;
                unitsPerGas: string;
                type: 'LightOperation';
            };
            s256: {
                base: string;
                gasPerUnit: string;
                type: 'HeavyOperation';
            } | {
                base: string;
                unitsPerGas: string;
                type: 'LightOperation';
            };
        };
    };
};
export type GqlContractBalanceFragment = {
    contract: string;
    amount: string;
    assetId: string;
};
export type GqlPageInfoFragment = {
    hasPreviousPage: boolean;
    hasNextPage: boolean;
    startCursor?: string | null;
    endCursor?: string | null;
};
export type GqlGetVersionQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GqlGetVersionQuery = {
    nodeInfo: {
        nodeVersion: string;
    };
};
export type GqlNodeInfoFragment = {
    utxoValidation: boolean;
    vmBacktrace: boolean;
    maxTx: string;
    maxDepth: string;
    nodeVersion: string;
};
export type GqlRelayedTransactionStatusFragment = {
    blockHeight: string;
    failure: string;
};
export type GqlGetNodeInfoQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GqlGetNodeInfoQuery = {
    nodeInfo: {
        utxoValidation: boolean;
        vmBacktrace: boolean;
        maxTx: string;
        maxDepth: string;
        nodeVersion: string;
    };
};
export type GqlGetChainQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GqlGetChainQuery = {
    chain: {
        name: string;
        daHeight: string;
        consensusParameters: {
            version: GqlConsensusParametersVersion;
            baseAssetId: string;
            chainId: string;
            txParams: {
                version: GqlTxParametersVersion;
                maxInputs: string;
                maxOutputs: string;
                maxWitnesses: string;
                maxGasPerTx: string;
                maxSize: string;
                maxBytecodeSubsections: string;
            };
            predicateParams: {
                version: GqlPredicateParametersVersion;
                maxPredicateLength: string;
                maxPredicateDataLength: string;
                maxGasPerPredicate: string;
                maxMessageDataLength: string;
            };
            scriptParams: {
                version: GqlScriptParametersVersion;
                maxScriptLength: string;
                maxScriptDataLength: string;
            };
            contractParams: {
                version: GqlContractParametersVersion;
                contractMaxSize: string;
                maxStorageSlots: string;
            };
            feeParams: {
                version: GqlFeeParametersVersion;
                gasPriceFactor: string;
                gasPerByte: string;
            };
            gasCosts: {
                ecr1: string;
                newStoragePerByte: string;
                contractRoot: {
                    base: string;
                    gasPerUnit: string;
                    type: 'HeavyOperation';
                } | {
                    base: string;
                    unitsPerGas: string;
                    type: 'LightOperation';
                };
                stateRoot: {
                    base: string;
                    gasPerUnit: string;
                    type: 'HeavyOperation';
                } | {
                    base: string;
                    unitsPerGas: string;
                    type: 'LightOperation';
                };
                vmInitialization: {
                    base: string;
                    gasPerUnit: string;
                    type: 'HeavyOperation';
                } | {
                    base: string;
                    unitsPerGas: string;
                    type: 'LightOperation';
                };
                s256: {
                    base: string;
                    gasPerUnit: string;
                    type: 'HeavyOperation';
                } | {
                    base: string;
                    unitsPerGas: string;
                    type: 'LightOperation';
                };
            };
        };
    };
};
export type GqlGetChainAndNodeInfoQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GqlGetChainAndNodeInfoQuery = {
    chain: {
        name: string;
        daHeight: string;
        consensusParameters: {
            version: GqlConsensusParametersVersion;
            baseAssetId: string;
            chainId: string;
            txParams: {
                version: GqlTxParametersVersion;
                maxInputs: string;
                maxOutputs: string;
                maxWitnesses: string;
                maxGasPerTx: string;
                maxSize: string;
                maxBytecodeSubsections: string;
            };
            predicateParams: {
                version: GqlPredicateParametersVersion;
                maxPredicateLength: string;
                maxPredicateDataLength: string;
                maxGasPerPredicate: string;
                maxMessageDataLength: string;
            };
            scriptParams: {
                version: GqlScriptParametersVersion;
                maxScriptLength: string;
                maxScriptDataLength: string;
            };
            contractParams: {
                version: GqlContractParametersVersion;
                contractMaxSize: string;
                maxStorageSlots: string;
            };
            feeParams: {
                version: GqlFeeParametersVersion;
                gasPriceFactor: string;
                gasPerByte: string;
            };
            gasCosts: {
                ecr1: string;
                newStoragePerByte: string;
                contractRoot: {
                    base: string;
                    gasPerUnit: string;
                    type: 'HeavyOperation';
                } | {
                    base: string;
                    unitsPerGas: string;
                    type: 'LightOperation';
                };
                stateRoot: {
                    base: string;
                    gasPerUnit: string;
                    type: 'HeavyOperation';
                } | {
                    base: string;
                    unitsPerGas: string;
                    type: 'LightOperation';
                };
                vmInitialization: {
                    base: string;
                    gasPerUnit: string;
                    type: 'HeavyOperation';
                } | {
                    base: string;
                    unitsPerGas: string;
                    type: 'LightOperation';
                };
                s256: {
                    base: string;
                    gasPerUnit: string;
                    type: 'HeavyOperation';
                } | {
                    base: string;
                    unitsPerGas: string;
                    type: 'LightOperation';
                };
            };
        };
    };
    nodeInfo: {
        utxoValidation: boolean;
        vmBacktrace: boolean;
        maxTx: string;
        maxDepth: string;
        nodeVersion: string;
    };
};
export type GqlGetTransactionQueryVariables = Exact<{
    transactionId: Scalars['TransactionId']['input'];
}>;
export type GqlGetTransactionQuery = {
    transaction?: {
        id: string;
        rawPayload: string;
        status?: {
            totalGas: string;
            totalFee: string;
            time: string;
            reason: string;
            type: 'FailureStatus';
            receipts: Array<{
                id?: string | null;
                pc?: string | null;
                is?: string | null;
                to?: string | null;
                toAddress?: string | null;
                amount?: string | null;
                assetId?: string | null;
                gas?: string | null;
                param1?: string | null;
                param2?: string | null;
                val?: string | null;
                ptr?: string | null;
                digest?: string | null;
                reason?: string | null;
                ra?: string | null;
                rb?: string | null;
                rc?: string | null;
                rd?: string | null;
                len?: string | null;
                receiptType: GqlReceiptType;
                result?: string | null;
                gasUsed?: string | null;
                data?: string | null;
                sender?: string | null;
                recipient?: string | null;
                nonce?: string | null;
                contractId?: string | null;
                subId?: string | null;
            }>;
        } | {
            reason: string;
            type: 'SqueezedOutStatus';
        } | {
            time: string;
            type: 'SubmittedStatus';
        } | {
            time: string;
            totalGas: string;
            totalFee: string;
            type: 'SuccessStatus';
            programState?: {
                returnType: GqlReturnType;
                data: string;
            } | null;
            receipts: Array<{
                id?: string | null;
                pc?: string | null;
                is?: string | null;
                to?: string | null;
                toAddress?: string | null;
                amount?: string | null;
                assetId?: string | null;
                gas?: string | null;
                param1?: string | null;
                param2?: string | null;
                val?: string | null;
                ptr?: string | null;
                digest?: string | null;
                reason?: string | null;
                ra?: string | null;
                rb?: string | null;
                rc?: string | null;
                rd?: string | null;
                len?: string | null;
                receiptType: GqlReceiptType;
                result?: string | null;
                gasUsed?: string | null;
                data?: string | null;
                sender?: string | null;
                recipient?: string | null;
                nonce?: string | null;
                contractId?: string | null;
                subId?: string | null;
            }>;
        } | null;
    } | null;
};
export type GqlGetTransactionWithReceiptsQueryVariables = Exact<{
    transactionId: Scalars['TransactionId']['input'];
}>;
export type GqlGetTransactionWithReceiptsQuery = {
    transaction?: {
        id: string;
        rawPayload: string;
        status?: {
            totalGas: string;
            totalFee: string;
            time: string;
            reason: string;
            type: 'FailureStatus';
            block: {
                id: string;
            };
            receipts: Array<{
                id?: string | null;
                pc?: string | null;
                is?: string | null;
                to?: string | null;
                toAddress?: string | null;
                amount?: string | null;
                assetId?: string | null;
                gas?: string | null;
                param1?: string | null;
                param2?: string | null;
                val?: string | null;
                ptr?: string | null;
                digest?: string | null;
                reason?: string | null;
                ra?: string | null;
                rb?: string | null;
                rc?: string | null;
                rd?: string | null;
                len?: string | null;
                receiptType: GqlReceiptType;
                result?: string | null;
                gasUsed?: string | null;
                data?: string | null;
                sender?: string | null;
                recipient?: string | null;
                nonce?: string | null;
                contractId?: string | null;
                subId?: string | null;
            }>;
        } | {
            reason: string;
            type: 'SqueezedOutStatus';
        } | {
            time: string;
            type: 'SubmittedStatus';
        } | {
            time: string;
            totalGas: string;
            totalFee: string;
            type: 'SuccessStatus';
            block: {
                id: string;
            };
            programState?: {
                returnType: GqlReturnType;
                data: string;
            } | null;
            receipts: Array<{
                id?: string | null;
                pc?: string | null;
                is?: string | null;
                to?: string | null;
                toAddress?: string | null;
                amount?: string | null;
                assetId?: string | null;
                gas?: string | null;
                param1?: string | null;
                param2?: string | null;
                val?: string | null;
                ptr?: string | null;
                digest?: string | null;
                reason?: string | null;
                ra?: string | null;
                rb?: string | null;
                rc?: string | null;
                rd?: string | null;
                len?: string | null;
                receiptType: GqlReceiptType;
                result?: string | null;
                gasUsed?: string | null;
                data?: string | null;
                sender?: string | null;
                recipient?: string | null;
                nonce?: string | null;
                contractId?: string | null;
                subId?: string | null;
            }>;
        } | null;
    } | null;
};
export type GqlGetTransactionsQueryVariables = Exact<{
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
}>;
export type GqlGetTransactionsQuery = {
    transactions: {
        edges: Array<{
            node: {
                rawPayload: string;
            };
        }>;
        pageInfo: {
            hasPreviousPage: boolean;
            hasNextPage: boolean;
            startCursor?: string | null;
            endCursor?: string | null;
        };
    };
};
export type GqlGetTransactionsByOwnerQueryVariables = Exact<{
    owner: Scalars['Address']['input'];
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
}>;
export type GqlGetTransactionsByOwnerQuery = {
    transactionsByOwner: {
        pageInfo: {
            hasPreviousPage: boolean;
            hasNextPage: boolean;
            startCursor?: string | null;
            endCursor?: string | null;
        };
        edges: Array<{
            node: {
                id: string;
                rawPayload: string;
                status?: {
                    totalGas: string;
                    totalFee: string;
                    time: string;
                    reason: string;
                    type: 'FailureStatus';
                    receipts: Array<{
                        id?: string | null;
                        pc?: string | null;
                        is?: string | null;
                        to?: string | null;
                        toAddress?: string | null;
                        amount?: string | null;
                        assetId?: string | null;
                        gas?: string | null;
                        param1?: string | null;
                        param2?: string | null;
                        val?: string | null;
                        ptr?: string | null;
                        digest?: string | null;
                        reason?: string | null;
                        ra?: string | null;
                        rb?: string | null;
                        rc?: string | null;
                        rd?: string | null;
                        len?: string | null;
                        receiptType: GqlReceiptType;
                        result?: string | null;
                        gasUsed?: string | null;
                        data?: string | null;
                        sender?: string | null;
                        recipient?: string | null;
                        nonce?: string | null;
                        contractId?: string | null;
                        subId?: string | null;
                    }>;
                } | {
                    reason: string;
                    type: 'SqueezedOutStatus';
                } | {
                    time: string;
                    type: 'SubmittedStatus';
                } | {
                    time: string;
                    totalGas: string;
                    totalFee: string;
                    type: 'SuccessStatus';
                    programState?: {
                        returnType: GqlReturnType;
                        data: string;
                    } | null;
                    receipts: Array<{
                        id?: string | null;
                        pc?: string | null;
                        is?: string | null;
                        to?: string | null;
                        toAddress?: string | null;
                        amount?: string | null;
                        assetId?: string | null;
                        gas?: string | null;
                        param1?: string | null;
                        param2?: string | null;
                        val?: string | null;
                        ptr?: string | null;
                        digest?: string | null;
                        reason?: string | null;
                        ra?: string | null;
                        rb?: string | null;
                        rc?: string | null;
                        rd?: string | null;
                        len?: string | null;
                        receiptType: GqlReceiptType;
                        result?: string | null;
                        gasUsed?: string | null;
                        data?: string | null;
                        sender?: string | null;
                        recipient?: string | null;
                        nonce?: string | null;
                        contractId?: string | null;
                        subId?: string | null;
                    }>;
                } | null;
            };
        }>;
    };
};
export type GqlEstimatePredicatesQueryVariables = Exact<{
    encodedTransaction: Scalars['HexString']['input'];
}>;
export type GqlEstimatePredicatesQuery = {
    estimatePredicates: {
        inputs?: Array<{
            predicateGasUsed: string;
        } | {
            predicateGasUsed: string;
        } | {}> | null;
    };
};
export type GqlGetLatestBlockQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GqlGetLatestBlockQuery = {
    chain: {
        latestBlock: {
            id: string;
            height: string;
            header: {
                time: string;
                daHeight: string;
                stateTransitionBytecodeVersion: string;
                transactionsCount: string;
                transactionsRoot: string;
                messageOutboxRoot: string;
                eventInboxRoot: string;
                prevRoot: string;
                applicationHash: string;
            };
            transactions: Array<{
                id: string;
            }>;
        };
    };
};
export type GqlGetLatestBlockHeightQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GqlGetLatestBlockHeightQuery = {
    chain: {
        latestBlock: {
            height: string;
        };
    };
};
export type GqlGetBlockQueryVariables = Exact<{
    blockId?: InputMaybe<Scalars['BlockId']['input']>;
    height?: InputMaybe<Scalars['U32']['input']>;
}>;
export type GqlGetBlockQuery = {
    block?: {
        id: string;
        height: string;
        header: {
            time: string;
            daHeight: string;
            stateTransitionBytecodeVersion: string;
            transactionsCount: string;
            transactionsRoot: string;
            messageOutboxRoot: string;
            eventInboxRoot: string;
            prevRoot: string;
            applicationHash: string;
        };
        transactions: Array<{
            id: string;
        }>;
    } | null;
};
export type GqlGetBlockWithTransactionsQueryVariables = Exact<{
    blockId?: InputMaybe<Scalars['BlockId']['input']>;
    blockHeight?: InputMaybe<Scalars['U32']['input']>;
}>;
export type GqlGetBlockWithTransactionsQuery = {
    block?: {
        id: string;
        height: string;
        transactions: Array<{
            id: string;
            rawPayload: string;
        }>;
        header: {
            time: string;
            daHeight: string;
            stateTransitionBytecodeVersion: string;
            transactionsCount: string;
            transactionsRoot: string;
            messageOutboxRoot: string;
            eventInboxRoot: string;
            prevRoot: string;
            applicationHash: string;
        };
    } | null;
};
export type GqlGetBlocksQueryVariables = Exact<{
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
}>;
export type GqlGetBlocksQuery = {
    blocks: {
        pageInfo: {
            hasPreviousPage: boolean;
            hasNextPage: boolean;
            startCursor?: string | null;
            endCursor?: string | null;
        };
        edges: Array<{
            node: {
                id: string;
                height: string;
                header: {
                    time: string;
                    daHeight: string;
                    stateTransitionBytecodeVersion: string;
                    transactionsCount: string;
                    transactionsRoot: string;
                    messageOutboxRoot: string;
                    eventInboxRoot: string;
                    prevRoot: string;
                    applicationHash: string;
                };
                transactions: Array<{
                    id: string;
                }>;
            };
        }>;
    };
};
export type GqlGetCoinQueryVariables = Exact<{
    coinId: Scalars['UtxoId']['input'];
}>;
export type GqlGetCoinQuery = {
    coin?: {
        owner: string;
        utxoId: string;
        amount: string;
        assetId: string;
        blockCreated: string;
        txCreatedIdx: string;
        type: 'Coin';
    } | null;
};
export type GqlGetCoinsQueryVariables = Exact<{
    filter: GqlCoinFilterInput;
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
}>;
export type GqlGetCoinsQuery = {
    coins: {
        pageInfo: {
            hasPreviousPage: boolean;
            hasNextPage: boolean;
            startCursor?: string | null;
            endCursor?: string | null;
        };
        edges: Array<{
            node: {
                utxoId: string;
                amount: string;
                assetId: string;
                blockCreated: string;
                txCreatedIdx: string;
                type: 'Coin';
            };
        }>;
    };
};
export type GqlGetCoinsToSpendQueryVariables = Exact<{
    owner: Scalars['Address']['input'];
    queryPerAsset: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;
    excludedIds?: InputMaybe<GqlExcludeInput>;
}>;
export type GqlGetCoinsToSpendQuery = {
    coinsToSpend: Array<Array<{
        utxoId: string;
        amount: string;
        assetId: string;
        blockCreated: string;
        txCreatedIdx: string;
        type: 'Coin';
    } | {
        sender: string;
        recipient: string;
        nonce: string;
        amount: string;
        assetId: string;
        daHeight: string;
        type: 'MessageCoin';
    }>>;
};
export type GqlGetContractQueryVariables = Exact<{
    contractId: Scalars['ContractId']['input'];
}>;
export type GqlGetContractQuery = {
    contract?: {
        bytecode: string;
        id: string;
    } | null;
};
export type GqlGetContractBalanceQueryVariables = Exact<{
    contract: Scalars['ContractId']['input'];
    asset: Scalars['AssetId']['input'];
}>;
export type GqlGetContractBalanceQuery = {
    contractBalance: {
        contract: string;
        amount: string;
        assetId: string;
    };
};
export type GqlGetBalanceQueryVariables = Exact<{
    owner: Scalars['Address']['input'];
    assetId: Scalars['AssetId']['input'];
}>;
export type GqlGetBalanceQuery = {
    balance: {
        amount: string;
    };
};
export type GqlGetLatestGasPriceQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GqlGetLatestGasPriceQuery = {
    latestGasPrice: {
        gasPrice: string;
    };
};
export type GqlEstimateGasPriceQueryVariables = Exact<{
    blockHorizon: Scalars['U32']['input'];
}>;
export type GqlEstimateGasPriceQuery = {
    estimateGasPrice: {
        gasPrice: string;
    };
};
export type GqlGetBalancesQueryVariables = Exact<{
    filter: GqlBalanceFilterInput;
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
}>;
export type GqlGetBalancesQuery = {
    balances: {
        pageInfo: {
            hasPreviousPage: boolean;
            hasNextPage: boolean;
            startCursor?: string | null;
            endCursor?: string | null;
        };
        edges: Array<{
            node: {
                assetId: string;
                amount: string;
            };
        }>;
    };
};
export type GqlGetMessagesQueryVariables = Exact<{
    owner: Scalars['Address']['input'];
    after?: InputMaybe<Scalars['String']['input']>;
    before?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
    last?: InputMaybe<Scalars['Int']['input']>;
}>;
export type GqlGetMessagesQuery = {
    messages: {
        pageInfo: {
            hasPreviousPage: boolean;
            hasNextPage: boolean;
            startCursor?: string | null;
            endCursor?: string | null;
        };
        edges: Array<{
            node: {
                nonce: string;
                amount: string;
                sender: string;
                recipient: string;
                data: string;
                daHeight: string;
            };
        }>;
    };
};
export type GqlGetMessageProofQueryVariables = Exact<{
    transactionId: Scalars['TransactionId']['input'];
    nonce: Scalars['Nonce']['input'];
    commitBlockId?: InputMaybe<Scalars['BlockId']['input']>;
    commitBlockHeight?: InputMaybe<Scalars['U32']['input']>;
}>;
export type GqlGetMessageProofQuery = {
    messageProof?: {
        sender: string;
        recipient: string;
        amount: string;
        data: string;
        messageProof: {
            proofSet: Array<string>;
            proofIndex: string;
        };
        blockProof: {
            proofSet: Array<string>;
            proofIndex: string;
        };
        messageBlockHeader: {
            version: GqlHeaderVersion;
            id: string;
            daHeight: string;
            consensusParametersVersion: string;
            stateTransitionBytecodeVersion: string;
            transactionsCount: string;
            messageReceiptCount: string;
            transactionsRoot: string;
            messageOutboxRoot: string;
            eventInboxRoot: string;
            height: string;
            prevRoot: string;
            time: string;
            applicationHash: string;
        };
        commitBlockHeader: {
            version: GqlHeaderVersion;
            id: string;
            daHeight: string;
            consensusParametersVersion: string;
            stateTransitionBytecodeVersion: string;
            transactionsCount: string;
            messageReceiptCount: string;
            transactionsRoot: string;
            messageOutboxRoot: string;
            eventInboxRoot: string;
            height: string;
            prevRoot: string;
            time: string;
            applicationHash: string;
        };
    } | null;
};
export type GqlGetMessageStatusQueryVariables = Exact<{
    nonce: Scalars['Nonce']['input'];
}>;
export type GqlGetMessageStatusQuery = {
    messageStatus: {
        state: GqlMessageState;
    };
};
export type GqlGetRelayedTransactionStatusQueryVariables = Exact<{
    relayedTransactionId: Scalars['RelayedTransactionId']['input'];
}>;
export type GqlGetRelayedTransactionStatusQuery = {
    relayedTransactionStatus?: {
        blockHeight: string;
        failure: string;
    } | null;
};
export type GqlDryRunMutationVariables = Exact<{
    encodedTransactions: Array<Scalars['HexString']['input']> | Scalars['HexString']['input'];
    utxoValidation?: InputMaybe<Scalars['Boolean']['input']>;
    gasPrice?: InputMaybe<Scalars['U64']['input']>;
}>;
export type GqlDryRunMutation = {
    dryRun: Array<{
        id: string;
        status: {
            totalGas: string;
            totalFee: string;
            reason: string;
            type: 'DryRunFailureStatus';
            programState?: {
                returnType: GqlReturnType;
                data: string;
            } | null;
        } | {
            totalGas: string;
            totalFee: string;
            type: 'DryRunSuccessStatus';
            programState?: {
                returnType: GqlReturnType;
                data: string;
            } | null;
        };
        receipts: Array<{
            id?: string | null;
            pc?: string | null;
            is?: string | null;
            to?: string | null;
            toAddress?: string | null;
            amount?: string | null;
            assetId?: string | null;
            gas?: string | null;
            param1?: string | null;
            param2?: string | null;
            val?: string | null;
            ptr?: string | null;
            digest?: string | null;
            reason?: string | null;
            ra?: string | null;
            rb?: string | null;
            rc?: string | null;
            rd?: string | null;
            len?: string | null;
            receiptType: GqlReceiptType;
            result?: string | null;
            gasUsed?: string | null;
            data?: string | null;
            sender?: string | null;
            recipient?: string | null;
            nonce?: string | null;
            contractId?: string | null;
            subId?: string | null;
        }>;
    }>;
};
export type GqlSubmitMutationVariables = Exact<{
    encodedTransaction: Scalars['HexString']['input'];
}>;
export type GqlSubmitMutation = {
    submit: {
        id: string;
    };
};
export type GqlProduceBlocksMutationVariables = Exact<{
    startTimestamp?: InputMaybe<Scalars['Tai64Timestamp']['input']>;
    blocksToProduce: Scalars['U32']['input'];
}>;
export type GqlProduceBlocksMutation = {
    produceBlocks: string;
};
export type GqlGetMessageByNonceQueryVariables = Exact<{
    nonce: Scalars['Nonce']['input'];
}>;
export type GqlGetMessageByNonceQuery = {
    message?: {
        amount: string;
        sender: string;
        recipient: string;
        data: string;
        daHeight: string;
    } | null;
};
export type GqlIsUserAccountQueryVariables = Exact<{
    blobId: Scalars['BlobId']['input'];
    contractId: Scalars['ContractId']['input'];
    transactionId: Scalars['TransactionId']['input'];
}>;
export type GqlIsUserAccountQuery = {
    blob?: {
        id: any;
    } | null;
    contract?: {
        id: string;
    } | null;
    transaction?: {
        id: string;
    } | null;
};
export type GqlGetConsensusParametersVersionQueryVariables = Exact<{
    [key: string]: never;
}>;
export type GqlGetConsensusParametersVersionQuery = {
    chain: {
        latestBlock: {
            header: {
                consensusParametersVersion: string;
            };
        };
    };
};
export type GqlSubmitAndAwaitStatusSubscriptionVariables = Exact<{
    encodedTransaction: Scalars['HexString']['input'];
}>;
export type GqlSubmitAndAwaitStatusSubscription = {
    submitAndAwaitStatus: {
        totalGas: string;
        totalFee: string;
        time: string;
        reason: string;
        type: 'FailureStatus';
        transaction: {
            receiptsRoot?: string | null;
            inputs?: Array<{
                txPointer: string;
                type: 'InputCoin';
            } | {
                txPointer: string;
                type: 'InputContract';
            } | {
                type: 'InputMessage';
            }> | null;
            outputs: Array<{
                to: string;
                amount: string;
                assetId: string;
                type: 'ChangeOutput';
            } | {
                to: string;
                amount: string;
                assetId: string;
                type: 'CoinOutput';
            } | {
                contract: string;
                stateRoot: string;
                type: 'ContractCreated';
            } | {
                inputIndex: string;
                balanceRoot: string;
                stateRoot: string;
                type: 'ContractOutput';
            } | {
                to: string;
                amount: string;
                assetId: string;
                type: 'VariableOutput';
            }>;
        };
        block: {
            id: string;
        };
        receipts: Array<{
            id?: string | null;
            pc?: string | null;
            is?: string | null;
            to?: string | null;
            toAddress?: string | null;
            amount?: string | null;
            assetId?: string | null;
            gas?: string | null;
            param1?: string | null;
            param2?: string | null;
            val?: string | null;
            ptr?: string | null;
            digest?: string | null;
            reason?: string | null;
            ra?: string | null;
            rb?: string | null;
            rc?: string | null;
            rd?: string | null;
            len?: string | null;
            receiptType: GqlReceiptType;
            result?: string | null;
            gasUsed?: string | null;
            data?: string | null;
            sender?: string | null;
            recipient?: string | null;
            nonce?: string | null;
            contractId?: string | null;
            subId?: string | null;
        }>;
    } | {
        reason: string;
        type: 'SqueezedOutStatus';
    } | {
        time: string;
        type: 'SubmittedStatus';
    } | {
        time: string;
        totalGas: string;
        totalFee: string;
        type: 'SuccessStatus';
        transaction: {
            receiptsRoot?: string | null;
            inputs?: Array<{
                txPointer: string;
                type: 'InputCoin';
            } | {
                txPointer: string;
                type: 'InputContract';
            } | {
                type: 'InputMessage';
            }> | null;
            outputs: Array<{
                to: string;
                amount: string;
                assetId: string;
                type: 'ChangeOutput';
            } | {
                to: string;
                amount: string;
                assetId: string;
                type: 'CoinOutput';
            } | {
                contract: string;
                stateRoot: string;
                type: 'ContractCreated';
            } | {
                inputIndex: string;
                balanceRoot: string;
                stateRoot: string;
                type: 'ContractOutput';
            } | {
                to: string;
                amount: string;
                assetId: string;
                type: 'VariableOutput';
            }>;
        };
        block: {
            id: string;
        };
        programState?: {
            returnType: GqlReturnType;
            data: string;
        } | null;
        receipts: Array<{
            id?: string | null;
            pc?: string | null;
            is?: string | null;
            to?: string | null;
            toAddress?: string | null;
            amount?: string | null;
            assetId?: string | null;
            gas?: string | null;
            param1?: string | null;
            param2?: string | null;
            val?: string | null;
            ptr?: string | null;
            digest?: string | null;
            reason?: string | null;
            ra?: string | null;
            rb?: string | null;
            rc?: string | null;
            rd?: string | null;
            len?: string | null;
            receiptType: GqlReceiptType;
            result?: string | null;
            gasUsed?: string | null;
            data?: string | null;
            sender?: string | null;
            recipient?: string | null;
            nonce?: string | null;
            contractId?: string | null;
            subId?: string | null;
        }>;
    };
};
export type GqlStatusChangeSubscriptionVariables = Exact<{
    transactionId: Scalars['TransactionId']['input'];
}>;
export type GqlStatusChangeSubscription = {
    statusChange: {
        totalGas: string;
        totalFee: string;
        time: string;
        reason: string;
        type: 'FailureStatus';
        transaction: {
            receiptsRoot?: string | null;
            inputs?: Array<{
                txPointer: string;
                type: 'InputCoin';
            } | {
                txPointer: string;
                type: 'InputContract';
            } | {
                type: 'InputMessage';
            }> | null;
            outputs: Array<{
                to: string;
                amount: string;
                assetId: string;
                type: 'ChangeOutput';
            } | {
                to: string;
                amount: string;
                assetId: string;
                type: 'CoinOutput';
            } | {
                contract: string;
                stateRoot: string;
                type: 'ContractCreated';
            } | {
                inputIndex: string;
                balanceRoot: string;
                stateRoot: string;
                type: 'ContractOutput';
            } | {
                to: string;
                amount: string;
                assetId: string;
                type: 'VariableOutput';
            }>;
        };
        block: {
            id: string;
        };
        receipts: Array<{
            id?: string | null;
            pc?: string | null;
            is?: string | null;
            to?: string | null;
            toAddress?: string | null;
            amount?: string | null;
            assetId?: string | null;
            gas?: string | null;
            param1?: string | null;
            param2?: string | null;
            val?: string | null;
            ptr?: string | null;
            digest?: string | null;
            reason?: string | null;
            ra?: string | null;
            rb?: string | null;
            rc?: string | null;
            rd?: string | null;
            len?: string | null;
            receiptType: GqlReceiptType;
            result?: string | null;
            gasUsed?: string | null;
            data?: string | null;
            sender?: string | null;
            recipient?: string | null;
            nonce?: string | null;
            contractId?: string | null;
            subId?: string | null;
        }>;
    } | {
        reason: string;
        type: 'SqueezedOutStatus';
    } | {
        time: string;
        type: 'SubmittedStatus';
    } | {
        time: string;
        totalGas: string;
        totalFee: string;
        type: 'SuccessStatus';
        transaction: {
            receiptsRoot?: string | null;
            inputs?: Array<{
                txPointer: string;
                type: 'InputCoin';
            } | {
                txPointer: string;
                type: 'InputContract';
            } | {
                type: 'InputMessage';
            }> | null;
            outputs: Array<{
                to: string;
                amount: string;
                assetId: string;
                type: 'ChangeOutput';
            } | {
                to: string;
                amount: string;
                assetId: string;
                type: 'CoinOutput';
            } | {
                contract: string;
                stateRoot: string;
                type: 'ContractCreated';
            } | {
                inputIndex: string;
                balanceRoot: string;
                stateRoot: string;
                type: 'ContractOutput';
            } | {
                to: string;
                amount: string;
                assetId: string;
                type: 'VariableOutput';
            }>;
        };
        block: {
            id: string;
        };
        programState?: {
            returnType: GqlReturnType;
            data: string;
        } | null;
        receipts: Array<{
            id?: string | null;
            pc?: string | null;
            is?: string | null;
            to?: string | null;
            toAddress?: string | null;
            amount?: string | null;
            assetId?: string | null;
            gas?: string | null;
            param1?: string | null;
            param2?: string | null;
            val?: string | null;
            ptr?: string | null;
            digest?: string | null;
            reason?: string | null;
            ra?: string | null;
            rb?: string | null;
            rc?: string | null;
            rd?: string | null;
            len?: string | null;
            receiptType: GqlReceiptType;
            result?: string | null;
            gasUsed?: string | null;
            data?: string | null;
            sender?: string | null;
            recipient?: string | null;
            nonce?: string | null;
            contractId?: string | null;
            subId?: string | null;
        }>;
    };
};
export declare const SubmittedStatusFragmentDoc: DocumentNode;
export declare const ReceiptFragmentDoc: DocumentNode;
export declare const SuccessStatusFragmentDoc: DocumentNode;
export declare const SuccessStatusWithBlockIdFragmentDoc: DocumentNode;
export declare const MalleableTransactionFieldsFragmentDoc: DocumentNode;
export declare const FailureStatusFragmentDoc: DocumentNode;
export declare const FailureStatusWithBlockIdFragmentDoc: DocumentNode;
export declare const SqueezedOutStatusFragmentDoc: DocumentNode;
export declare const TransactionStatusSubscriptionFragmentDoc: DocumentNode;
export declare const TransactionStatusFragmentDoc: DocumentNode;
export declare const TransactionFragmentDoc: DocumentNode;
export declare const TransactionRawPayloadFragmentDoc: DocumentNode;
export declare const InputEstimatePredicatesFragmentDoc: DocumentNode;
export declare const TransactionEstimatePredicatesFragmentDoc: DocumentNode;
export declare const DryRunFailureStatusFragmentDoc: DocumentNode;
export declare const DryRunSuccessStatusFragmentDoc: DocumentNode;
export declare const DryRunTransactionStatusFragmentDoc: DocumentNode;
export declare const DryRunTransactionExecutionStatusFragmentDoc: DocumentNode;
export declare const BlockFragmentDoc: DocumentNode;
export declare const CoinFragmentDoc: DocumentNode;
export declare const MessageCoinFragmentDoc: DocumentNode;
export declare const MessageFragmentDoc: DocumentNode;
export declare const GetMessageFragmentDoc: DocumentNode;
export declare const MessageProofFragmentDoc: DocumentNode;
export declare const TxParametersFragmentDoc: DocumentNode;
export declare const PredicateParametersFragmentDoc: DocumentNode;
export declare const ScriptParametersFragmentDoc: DocumentNode;
export declare const ContractParametersFragmentDoc: DocumentNode;
export declare const FeeParametersFragmentDoc: DocumentNode;
export declare const DependentCostFragmentDoc: DocumentNode;
export declare const GasCostsFragmentDoc: DocumentNode;
export declare const ConsensusParametersFragmentDoc: DocumentNode;
export declare const ChainInfoFragmentDoc: DocumentNode;
export declare const ContractBalanceFragmentDoc: DocumentNode;
export declare const PageInfoFragmentDoc: DocumentNode;
export declare const NodeInfoFragmentDoc: DocumentNode;
export declare const RelayedTransactionStatusFragmentDoc: DocumentNode;
export declare const GetVersionDocument: DocumentNode;
export declare const GetNodeInfoDocument: DocumentNode;
export declare const GetChainDocument: DocumentNode;
export declare const GetChainAndNodeInfoDocument: DocumentNode;
export declare const GetTransactionDocument: DocumentNode;
export declare const GetTransactionWithReceiptsDocument: DocumentNode;
export declare const GetTransactionsDocument: DocumentNode;
export declare const GetTransactionsByOwnerDocument: DocumentNode;
export declare const EstimatePredicatesDocument: DocumentNode;
export declare const GetLatestBlockDocument: DocumentNode;
export declare const GetLatestBlockHeightDocument: DocumentNode;
export declare const GetBlockDocument: DocumentNode;
export declare const GetBlockWithTransactionsDocument: DocumentNode;
export declare const GetBlocksDocument: DocumentNode;
export declare const GetCoinDocument: DocumentNode;
export declare const GetCoinsDocument: DocumentNode;
export declare const GetCoinsToSpendDocument: DocumentNode;
export declare const GetContractDocument: DocumentNode;
export declare const GetContractBalanceDocument: DocumentNode;
export declare const GetBalanceDocument: DocumentNode;
export declare const GetLatestGasPriceDocument: DocumentNode;
export declare const EstimateGasPriceDocument: DocumentNode;
export declare const GetBalancesDocument: DocumentNode;
export declare const GetMessagesDocument: DocumentNode;
export declare const GetMessageProofDocument: DocumentNode;
export declare const GetMessageStatusDocument: DocumentNode;
export declare const GetRelayedTransactionStatusDocument: DocumentNode;
export declare const DryRunDocument: DocumentNode;
export declare const SubmitDocument: DocumentNode;
export declare const ProduceBlocksDocument: DocumentNode;
export declare const GetMessageByNonceDocument: DocumentNode;
export declare const IsUserAccountDocument: DocumentNode;
export declare const GetConsensusParametersVersionDocument: DocumentNode;
export declare const SubmitAndAwaitStatusDocument: DocumentNode;
export declare const StatusChangeDocument: DocumentNode;
export type Requester<C = {}> = <R, V>(doc: DocumentNode, vars?: V, options?: C) => Promise<R> | AsyncIterable<R>;
export declare function getSdk<C>(requester: Requester<C>): {
    getVersion(variables?: GqlGetVersionQueryVariables, options?: C): Promise<GqlGetVersionQuery>;
    getNodeInfo(variables?: GqlGetNodeInfoQueryVariables, options?: C): Promise<GqlGetNodeInfoQuery>;
    getChain(variables?: GqlGetChainQueryVariables, options?: C): Promise<GqlGetChainQuery>;
    getChainAndNodeInfo(variables?: GqlGetChainAndNodeInfoQueryVariables, options?: C): Promise<GqlGetChainAndNodeInfoQuery>;
    getTransaction(variables: GqlGetTransactionQueryVariables, options?: C): Promise<GqlGetTransactionQuery>;
    getTransactionWithReceipts(variables: GqlGetTransactionWithReceiptsQueryVariables, options?: C): Promise<GqlGetTransactionWithReceiptsQuery>;
    getTransactions(variables?: GqlGetTransactionsQueryVariables, options?: C): Promise<GqlGetTransactionsQuery>;
    getTransactionsByOwner(variables: GqlGetTransactionsByOwnerQueryVariables, options?: C): Promise<GqlGetTransactionsByOwnerQuery>;
    estimatePredicates(variables: GqlEstimatePredicatesQueryVariables, options?: C): Promise<GqlEstimatePredicatesQuery>;
    getLatestBlock(variables?: GqlGetLatestBlockQueryVariables, options?: C): Promise<GqlGetLatestBlockQuery>;
    getLatestBlockHeight(variables?: GqlGetLatestBlockHeightQueryVariables, options?: C): Promise<GqlGetLatestBlockHeightQuery>;
    getBlock(variables?: GqlGetBlockQueryVariables, options?: C): Promise<GqlGetBlockQuery>;
    getBlockWithTransactions(variables?: GqlGetBlockWithTransactionsQueryVariables, options?: C): Promise<GqlGetBlockWithTransactionsQuery>;
    getBlocks(variables?: GqlGetBlocksQueryVariables, options?: C): Promise<GqlGetBlocksQuery>;
    getCoin(variables: GqlGetCoinQueryVariables, options?: C): Promise<GqlGetCoinQuery>;
    getCoins(variables: GqlGetCoinsQueryVariables, options?: C): Promise<GqlGetCoinsQuery>;
    getCoinsToSpend(variables: GqlGetCoinsToSpendQueryVariables, options?: C): Promise<GqlGetCoinsToSpendQuery>;
    getContract(variables: GqlGetContractQueryVariables, options?: C): Promise<GqlGetContractQuery>;
    getContractBalance(variables: GqlGetContractBalanceQueryVariables, options?: C): Promise<GqlGetContractBalanceQuery>;
    getBalance(variables: GqlGetBalanceQueryVariables, options?: C): Promise<GqlGetBalanceQuery>;
    getLatestGasPrice(variables?: GqlGetLatestGasPriceQueryVariables, options?: C): Promise<GqlGetLatestGasPriceQuery>;
    estimateGasPrice(variables: GqlEstimateGasPriceQueryVariables, options?: C): Promise<GqlEstimateGasPriceQuery>;
    getBalances(variables: GqlGetBalancesQueryVariables, options?: C): Promise<GqlGetBalancesQuery>;
    getMessages(variables: GqlGetMessagesQueryVariables, options?: C): Promise<GqlGetMessagesQuery>;
    getMessageProof(variables: GqlGetMessageProofQueryVariables, options?: C): Promise<GqlGetMessageProofQuery>;
    getMessageStatus(variables: GqlGetMessageStatusQueryVariables, options?: C): Promise<GqlGetMessageStatusQuery>;
    getRelayedTransactionStatus(variables: GqlGetRelayedTransactionStatusQueryVariables, options?: C): Promise<GqlGetRelayedTransactionStatusQuery>;
    dryRun(variables: GqlDryRunMutationVariables, options?: C): Promise<GqlDryRunMutation>;
    submit(variables: GqlSubmitMutationVariables, options?: C): Promise<GqlSubmitMutation>;
    produceBlocks(variables: GqlProduceBlocksMutationVariables, options?: C): Promise<GqlProduceBlocksMutation>;
    getMessageByNonce(variables: GqlGetMessageByNonceQueryVariables, options?: C): Promise<GqlGetMessageByNonceQuery>;
    isUserAccount(variables: GqlIsUserAccountQueryVariables, options?: C): Promise<GqlIsUserAccountQuery>;
    getConsensusParametersVersion(variables?: GqlGetConsensusParametersVersionQueryVariables, options?: C): Promise<GqlGetConsensusParametersVersionQuery>;
    submitAndAwaitStatus(variables: GqlSubmitAndAwaitStatusSubscriptionVariables, options?: C): AsyncIterable<GqlSubmitAndAwaitStatusSubscription>;
    statusChange(variables: GqlStatusChangeSubscriptionVariables, options?: C): AsyncIterable<GqlStatusChangeSubscription>;
};
export type Sdk = ReturnType<typeof getSdk>;
export {};
//# sourceMappingURL=operations.d.ts.map